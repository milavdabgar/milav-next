\documentclass{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{../../../../../../latex-templates/gtu-solutions/commands.tex}

\title{Advanced Java Programming (4351603) - Winter 2024 Solution}
\date{November 27, 2024}

\begin{document}
\maketitle

\questionmarks{1(અ)}{3}{તેના ઉપયોગ સાથે JFC નું વર્ણન કરો.}

\begin{solutionbox}
JFC (Java Foundation Classes) એ જાવામાં ડેસ્કટોપ એપ્લિકેશન બનાવવા માટેનું વ્યાપક GUI ફ્રેમવર્ક છે.

\begin{center}
\captionof{table}{JFC કમ્પોનન્ટ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કમ્પોનન્ટ} & \textbf{વર્ણન} \\ \hline
\keyword{Swing} & હળવા વજનના GUI કમ્પોનન્ટ \\ \hline
\keyword{AWT} & મૂળભૂત વિન્ડોઇંગ ટૂલકિટ \\ \hline
\keyword{Java 2D} & એડવાન્સ ગ્રાફિક્સ અને ઇમેજિંગ \\ \hline
\keyword{Accessibility} & સહાયક ટેકનોલોજી માટે સપોર્ટ \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{મુખ્ય ઉપયોગ}: સમૃદ્ધ ડેસ્કટોપ એપ્લિકેશન બનાવવું.
    \item \textbf{મુખ્ય ફાયદો}: પ્લેટફોર્મ સ્વતંત્રતા અને સુસંગત દેખાવ.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{JFC = Java's Fantastic Components}
\end{mnemonicbox}

\questionmarks{1(બ)}{4}{AWT અને સ્વિંગ વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{AWT vs Swing}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{AWT} & \textbf{Swing} \\ \hline
\textbf{કમ્પોનન્ટ} & હેવીવેઇટ (native) & લાઇટવેઇટ (શુદ્ધ જાવા) \\ \hline
\textbf{પ્લેટફોર્મ} & પ્લેટફોર્મ આધારિત & પ્લેટફોર્મ સ્વતંત્ર \\ \hline
\textbf{દેખાવ} & Native OS લુક & બદલી શકાય તેવું લુક \& ફીલ \\ \hline
\textbf{પ્રદર્શન} & વધુ ઝડપી & થોડું ધીમું \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{AWT મર્યાદા}: મર્યાદિત કમ્પોનન્ટ, પ્લેટફોર્મ-વિશિષ્ટ દેખાવ.
    \item \textbf{Swing ફાયદો}: સમૃદ્ધ કમ્પોનન્ટ સેટ, કસ્ટમાઇઝેબલ UI.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{AWT = Always Weighs Too-much, Swing = Simply Works In New Generation}
\end{mnemonicbox}

\questionmarks{1(ક)}{7}{વિવિધ ઇવેન્ટ લિસ્નર ની યાદી બનાવો. કોઈપણ એક સમજાવો.}

\begin{solutionbox}
\textbf{ઇવેન્ટ લિસ્નર યાદી:}
\begin{center}
\captionof{table}{ઇવેન્ટ લિસ્નર}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{લિસ્નર} & \textbf{હેતુ} \\ \hline
\keyword{ActionListener} & બટન ક્લિક, મેનુ પસંદગી \\ \hline
\keyword{MouseListener} & માઉસ ઇવેન્ટ (ક્લિક, પ્રેસ, રિલીઝ) \\ \hline
\keyword{KeyListener} & કીબોર્ડ ઇનપુટ ઇવેન્ટ \\ \hline
\keyword{WindowListener} & વિન્ડો સ્ટેટ ફેરફાર \\ \hline
\keyword{FocusListener} & કમ્પોનન્ટ ફોકસ ઇવેન્ટ \\ \hline
\keyword{ItemListener} & ચેકબોક્સ/રેડિયો બટન ફેરફાર \\ \hline
\end{tabulary}
\end{center}

\textbf{ActionListener સમજાવટ:}
\begin{itemize}
    \item \textbf{ઇન્ટરફેસ મેથડ}: \code{actionPerformed(ActionEvent e)}
    \item \textbf{ઉપયોગ}: બટન ક્લિક અને મેનુ ક્રિયાઓ હેન્ડલ કરે
    \item \textbf{અમલીકરણ}: અનામિક ક્લાસ અથવા lambda expression
\end{itemize}

\begin{lstlisting}[language=Java]
button.addActionListener(e -> {
    System.out.println("Button clicked!");
});
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{AMKWFI Listeners = Action Mouse Key Window Focus Item}
\end{mnemonicbox}

\questionmarks{1(ક OR)}{7}{વિવિધ લેઆઉટ મેનેજરોની યાદી બનાવો. કોઈપણ એક સમજાવો.}

\begin{solutionbox}
\textbf{લેઆઉટ મેનેજર યાદી:}
\begin{center}
\captionof{table}{લેઆઉટ મેનેજર}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{લેઆઉટ મેનેજર} & \textbf{હેતુ} \\ \hline
\keyword{FlowLayout} & ક્રમિક કમ્પોનન્ટ પ્લેસમેન્ટ \\ \hline
\keyword{BorderLayout} & પાંચ પ્રદેશો (ઉત્તર, દક્ષિણ, પૂર્વ, પશ્ચિમ, કેન્દ્ર) \\ \hline
\keyword{GridLayout} & ગ્રિડ-આધારિત ગોઠવણી \\ \hline
\keyword{CardLayout} & કમ્પોનન્ટનો સ્ટેક \\ \hline
\keyword{BoxLayout} & એક પંક્તિ અથવા સ્તંભ \\ \hline
\keyword{GridBagLayout} & કન્સ્ટ્રેઇન્ટ સાથે જટિલ ગ્રિડ \\ \hline
\end{tabulary}
\end{center}

\textbf{BorderLayout સમજાવટ:}
\begin{itemize}
    \item \textbf{ડિફોલ્ટ લેઆઉટ}: JFrame અને JDialog માટે.
    \item \textbf{પાંચ પ્રદેશો}: ઉત્તર, દક્ષિણ, પૂર્વ, પશ્ચિમ, કેન્દ્ર.
    \item \textbf{રીસાઈઝિંગ}: કેન્દ્ર વિસ્તરે છે, અન્ય પ્રાથમિક કદ રાખે છે.
\end{itemize}

\begin{center}
\begin{tikzpicture}[node distance=0cm, outer sep=0pt]
    \node (center) [rectangle, draw, minimum width=4cm, minimum height=2cm] {કેન્દ્ર};
    \node (north) [rectangle, draw, minimum width=6cm, minimum height=1cm, above=of center, anchor=south] {ઉત્તર};
    \node (south) [rectangle, draw, minimum width=6cm, minimum height=1cm, below=of center, anchor=north] {દક્ષિણ};
    \node (west) [rectangle, draw, minimum width=1cm, minimum height=2cm, left=of center, anchor=east] {પશ્ચિમ};
    \node (east) [rectangle, draw, minimum width=1cm, minimum height=2cm, right=of center, anchor=west] {પૂર્વ};
\end{tikzpicture}
\captionof{figure}{BorderLayout પ્રદેશો}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FBGCBG Layouts = Flow Border Grid Card Box GridBag}
\end{mnemonicbox}

\questionmarks{2(અ)}{3}{ડેટાબેઝને કનેક્ટ કરવાના પગલાંની યાદી બનાવો અને સમજાવો.}

\begin{solutionbox}
\textbf{ડેટાબેઝ કનેક્શન પગલાં:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પગલું} & \textbf{ક્રિયા} \\ \hline
1. ડ્રાઇવર લોડ & \code{Class.forName("driver.class")} \\ \hline
2. કનેક્શન બનાવો & \code{DriverManager.getConnection()} \\ \hline
3. સ્ટેટમેન્ટ બનાવો & \code{connection.createStatement()} \\ \hline
4. ક્વેરી એક્ઝિક્યુટ કરો & \code{statement.executeQuery()} \\ \hline
5. પરિણામ પર પ્રોસેસ કરો & \code{resultSet.next()} \\ \hline
6. રિસોર્સ બંધ કરો & બધા કનેક્શન બંધ કરો \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LCD EPR = Load Create Driver, Execute Process Results}
\end{mnemonicbox}

\questionmarks{2(બ)}{4}{3-tier આર્કિટેક્ચર ડાયાગ્રામ સાથે સમજાવો.}

\begin{solutionbox}
3-tier આર્કિટેક્ચર એપ્લિકેશનને બહેતર જાળવણી માટે ત્રણ લોજિકલ લેયરમાં વિભાજિત કરે છે.

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node [gtu block] (UI) {પ્રેઝન્ટેશન ટાયર\\(વેબ બ્રાઉઝર/UI)};
    \node [gtu block, right=of UI] (App) {એપ્લિકેશન ટાયર\\(બિઝનેસ લોજિક/સર્વલેટ)};
    \node [gtu block, right=of App] (Data) {ડેટા ટાયર\\(ડેટાબેઝ સર્વર)};
    
    \path [gtu arrow] (UI) -- (App);
    \path [gtu arrow] (App) -- (UI);
    \path [gtu arrow] (App) -- (Data);
    \path [gtu arrow] (Data) -- (App);
\end{tikzpicture}
\captionof{figure}{3-Tier આર્કિટેક્ચર}
\end{center}

\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ટાયર} & \textbf{જવાબદારી} \\ \hline
\textbf{પ્રેઝન્ટેશન} & યુઝર ઇન્ટરફેસ અને યુઝર ઇન્ટરેક્શન \\ \hline
\textbf{એપ્લિકેશન} & બિઝનેસ લોજિક અને પ્રોસેસિંગ \\ \hline
\textbf{ડેટા} & ડેટા સ્ટોરેજ અને મેનેજમેન્ટ \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{ફાયદો}: બહેતર સ્કેલેબિલિટી અને જાળવણી.
    \item \textbf{ઉદાહરણ}: વેબ બ્રાઉઝર $\rightarrow$ વેબ સર્વર $\rightarrow$ ડેટાબેઝ.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PAD = Presentation Application Data}
\end{mnemonicbox}

\questionmarks{2(ક)}{7}{ઇન્ટરફેસ અને વર્ગો સાથે JDBC API નું વર્ણન કરો.}

\begin{solutionbox}
\textbf{JDBC API કમ્પોનન્ટ્સ:}

\begin{center}
\captionof{table}{JDBC કમ્પોનન્ટ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{કમ્પોનન્ટ} & \textbf{હેતુ} \\ \hline
Interface & Connection & ડેટાબેઝ કનેક્શન \\ \hline
Interface & Statement & SQL એક્ઝિક્યુશન \\ \hline
Interface & ResultSet & ક્વેરી પરિણામો \\ \hline
Interface & PreparedStatement & પ્રીકમ્પાઇલ્ડ SQL \\ \hline
Class & DriverManager & ડ્રાઇવર મેનેજમેન્ટ \\ \hline
Class & SQLException & એરર હેન્ડલિંગ \\ \hline
\end{tabulary}
\end{center}

\textbf{JDBC આર્કિટેક્ચર:}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu block] (App) {Java Application};
    \node [gtu block, right=of App] (Api) {JDBC API};
    \node [gtu block, right=of Api] (Mgr) {JDBC Driver Manager};
    \node [gtu block, below=of Mgr] (Drv) {JDBC Driver};
    \node [gtu block, below=of Drv] (Db) {Database};
    
    \path [gtu arrow] (App) -- (Api);
    \path [gtu arrow] (Api) -- (Mgr);
    \path [gtu arrow] (Mgr) -- (Drv);
    \path [gtu arrow] (Drv) -- (Db);
\end{tikzpicture}
\captionof{figure}{JDBC આર્કિટેક્ચર}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CSRP Classes = Connection Statement ResultSet PreparedStatement}
\end{mnemonicbox}

\questionmarks{2(અ OR)}{3}{JDBC ના ફાયદા અને ગેરફાયદાની યાદી બનાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{ફાયદા vs ગેરફાયદા}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ફાયદા} & \textbf{ગેરફાયદા} \\ \hline
પ્લેટફોર્મ સ્વતંત્ર & પર્ફોર્મન્સ ઓવરહેડ \\ \hline
સ્ટાન્ડર્ડ API & જટિલ કન્ફિગરેશન \\ \hline
બહુવિધ ડેટાબેઝ સપોર્ટ & મર્યાદિત ORM ફીચર્સ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PSM vs PCL = Platform Standard Multiple vs Performance Complex Limited}
\end{mnemonicbox}

\questionmarks{2(બ OR)}{4}{2-tier આર્કિટેક્ચર ડાયાગ્રામ સાથે સમજાવો.}

\begin{solutionbox}
2-tier આર્કિટેક્ચર ક્લાયન્ટને ડેટાબેઝ સર્વર સાથે સીધું જોડે છે.

\begin{center}
\begin{tikzpicture}[node distance=3cm, auto]
    \node [gtu block] (Client) {ક્લાયન્ટ ટાયર\\(એપ્લિકેશન/UI)};
    \node [gtu block, right=of Client] (Data) {ડેટા ટાયર\\(ડેટાબેઝ સર્વર)};
    
    \path [gtu arrow] (Client) -- (Data);
    \path [gtu arrow] (Data) -- (Client);
\end{tikzpicture}
\captionof{figure}{2-Tier આર્કિટેક્ચર}
\end{center}

\begin{itemize}
    \item \textbf{ફાયદો}: સરળ આર્કિટેક્ચર, સીધો કમ્યુનિકેશન.
    \item \textbf{ગેરફાયદો}: મર્યાદિત સ્કેલેબિલિટી, ટાઈટ કપલિંગ.
    \item \textbf{ઉદાહરણ}: ડેસ્કટોપ એપ્લિકેશન સીધું ડેટાબેઝ સાથે જોડાય.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CD = Client Data (direct connection)}
\end{mnemonicbox}

\questionmarks{2(ક OR)}{7}{JDBC ડ્રાઇવર પ્રકારોની યાદી બનાવો અને TYPE-4 સમજાવો.}

\begin{solutionbox}
\textbf{JDBC ડ્રાઇવર પ્રકારો:}
\begin{center}
\captionof{table}{JDBC ડ્રાઇવર પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{નામ} & \textbf{વર્ણન} \\ \hline
Type-1 & JDBC-ODBC Bridge & ODBC ડ્રાઇવર વાપરે \\ \hline
Type-2 & Native-API Driver & આંશિક જાવા, આંશિક native \\ \hline
Type-3 & Network Protocol Driver & શુદ્ધ જાવા, middleware \\ \hline
Type-4 & Native Protocol Driver & શુદ્ધ જાવા, સીધું \\ \hline
\end{tabulary}
\end{center}

\textbf{TYPE-4 ડ્રાઇવર સમજાવટ:}
\begin{itemize}
    \item \textbf{શુદ્ધ જાવા}: સંપૂર્ણપણે જાવામાં લખાયેલું.
    \item \textbf{સીધો કમ્યુનિકેશન}: ડેટાબેઝ સાથે સીધો વાતચીત.
    \item \textbf{પ્લેટફોર્મ સ્વતંત્ર}: native લાઇબ્રેરીની જરૂર નથી.
    \item \textbf{શ્રેષ્ઠ પ્રદર્શન}: બધા પ્રકારોમાં સૌથી ઝડપી.
    \item \textbf{ઉદાહરણો}: MySQL Connector/J, PostgreSQL JDBC.
\end{itemize}

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node [gtu block] (App) {Java Application};
    \node [gtu block, right=of App] (Driver) {Type-4 JDBC Driver\\(Pure Java)};
    \node [gtu block, right=of Driver] (Db) {Database Server};
    
    \path [gtu arrow] (App) -- (Driver);
    \path [gtu arrow] (Driver) -- (Db);
\end{tikzpicture}
\captionof{figure}{Type-4 ડ્રાઇવર}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ONNN Drivers = ODBC Native Network Native-pure}
\end{mnemonicbox}

\questionmarks{3(અ)}{3}{સર્વલેટની એપ્લિકેશન સમજાવો.}

\begin{solutionbox}
\textbf{સર્વલેટ એપ્લિકેશન:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{ઉપયોગ} \\ \hline
વેબ ફોર્મ & HTML ફોર્મ ડેટા પ્રોસેસ કરવું \\ \hline
ડેટાબેઝ ઓપરેશન & ડેટાબેઝ કનેક્ટ અને મેનિપ્યુલેટ કરવું \\ \hline
સેશન મેનેજમેન્ટ & યુઝર સેશન ટ્રેક કરવું \\ \hline
ફાઈલ અપલોડ & ફાઈલ અપલોડ હેન્ડલ કરવું \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{WDSF = Web Database Session File}
\end{mnemonicbox}

\questionmarks{3(બ)}{4}{એપ્લેટ અને સર્વલેટ વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{એપ્લેટ vs સર્વલેટ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{એપ્લેટ} & \textbf{સર્વલેટ} \\ \hline
\textbf{એક્ઝિક્યુશન} & ક્લાયન્ટ-સાઇડ (બ્રાઉઝર) & સર્વર-સાઇડ (વેબ સર્વર) \\ \hline
\textbf{હેતુ} & યુઝર ઇન્ટરફેસ & રિક્વેસ્ટ પ્રોસેસિંગ \\ \hline
\textbf{સિક્યોરિટી} & પ્રતિબંધિત (sandbox) & સર્વરની સંપૂર્ણ પહોંચ \\ \hline
\textbf{પ્રદર્શન} & ક્લાયન્ટ દ્વારા મર્યાદિત & સર્વર રિસોર્સ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Client vs Server = Applet vs Servlet}
\end{mnemonicbox}

\questionmarks{3(ક)}{7}{સર્વલેટ ની લાઈફ સાઇકલ વિગતવાર સમજાવો.}

\begin{solutionbox}
\textbf{સર્વલેટ લાઇફ સાઇકલ:}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (Load) {Load Class};
    \node [gtu state, right=of Load] (Init) {init()};
    \node [gtu state, below=of Init] (Serv) {service()};
    \node [gtu state, left=of Serv] (Dest) {destroy()};
    \node [gtu state, left=of Dest] (Unload) {Unload};
    
    \path [gtu arrow] (Load) -- (Init);
    \path [gtu arrow] (Init) -- (Serv);
    \path [gtu arrow] (Serv) edge [loop below] node {Requests} (Serv);
    \path [gtu arrow] (Serv) -- (Dest);
    \path [gtu arrow] (Dest) -- (Unload);
\end{tikzpicture}
\captionof{figure}{સર્વલેટ લાઇફ સાઇકલ}
\end{center}

\begin{center}
\captionof{table}{લાઇફ સાઇકલ તબક્કા}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{તબક્કો} & \textbf{મેથડ} & \textbf{વર્ણન} \\ \hline
લોડિંગ & - & વેબ કન્ટેનર સર્વલેટ ક્લાસ લોડ કરે \\ \hline
ઇનિશિયલાઇઝેશન & \code{init()} & એકવાર કોલ થાય, રિસોર્સ સેટઅપ \\ \hline
સર્વિસ & \code{service()} & દરેક રિક્વેસ્ટ હેન્ડલ કરે (doGet/doPost) \\ \hline
ડિસ્ટ્રક્શન & \code{destroy()} & અનલોડ કરતા પહેલા સફાઈ \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{થ્રેડ સેફ્ટી}: બહુવિધ રિક્વેસ્ટ એકસાથે હેન્ડલ થાય.
    \item \textbf{સિંગલ ઇન્સ્ટન્સ}: એક સર્વલેટ ઇન્સ્ટન્સ બધી રિક્વેસ્ટ હેન્ડલ કરે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LISD = Load Init Service Destroy}
\end{mnemonicbox}

\questionmarks{3(અ OR)}{3}{સર્વલેટ માં web.xml ફાઇલ સમજાવો.}

\begin{solutionbox}
\textbf{web.xml હેતુ:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{એલિમેન્ટ} & \textbf{વર્ણન} \\ \hline
ડિપ્લોયમેન્ટ ડિસ્ક્રિપ્ટર & વેબ એપ્લિકેશન માટે કન્ફિગરેશન ફાઇલ \\ \hline
સર્વલેટ મેપિંગ & URL પેટર્ન સર્વલેટ સાથે મેપ કરે \\ \hline
ઇનિશિયલાઇઝેશન & સર્વલેટ પેરામીટર અને લોડ ઓર્ડર \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{સ્થાન}: WEB-INF ડિરેક્ટરી
    \item \textbf{ફોર્મેટ}: XML કન્ફિગરેશન ફાઇલ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DMI = Deployment Mapping Initialization}
\end{mnemonicbox}

\questionmarks{3(બ OR)}{4}{સર્વલેટની વિશેષતાની યાદી બનાવો અને સમજાવો.}

\begin{solutionbox}
\textbf{સર્વલેટ વિશેષતાઓ:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{વિશેષતા} & \textbf{વર્ણન} \\ \hline
પ્લેટફોર્મ સ્વતંત્ર & એકવાર લખો, ગમે ત્યાં ચલાવો \\ \hline
સર્વર-સાઇડ & વેબ સર્વર પર એક્ઝિક્યુટ થાય \\ \hline
પ્રોટોકોલ સ્વતંત્ર & HTTP, FTP વગેરે સપોર્ટ કરે \\ \hline
પર્સિસ્ટન્ટ & રિક્વેસ્ટ વચ્ચે મેમરીમાં રહે \\ \hline
સિક્યોર & બિલ્ટ-ઇન સિક્યોરિટી ફીચર્સ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PSPPS = Platform Server Protocol Persistent Secure}
\end{mnemonicbox}

\questionmarks{3(ક OR)}{7}{સર્વલેટમાં સેશન ટ્રેકિંગ સમજાવો.}

\begin{solutionbox}
\textbf{સેશન ટ્રેકિંગ મેથડ:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{મેથડ} & \textbf{વર્ણન} \\ \hline
કુકીઝ & બ્રાઉઝરમાં સ્ટોર થતો નાનો ડેટા \\ \hline
URL રીરાઇટિંગ & URL માં સેશન ID \\ \hline
હિડન ફોર્મ ફીલ્ડ & ફોર્મમાં સેશન ડેટા \\ \hline
HttpSession & સર્વર-સાઇડ સેશન ઓબ્જેક્ટ \\ \hline
\end{tabulary}
\end{center}

\textbf{HttpSession Logic Flow:}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (Start) {રિક્વેસ્ટ};
    \node [gtu state, right=of Start] (Check) {સેશન ID ચેક};
    \node [gtu decision, right=of Check] (Exists) {અસ્તિત્વ?};
    \node [gtu state, below=of Exists] (New) {નવું બનાવો};
    \node [gtu state, right=of Exists, node distance=3cm] (Use) {વર્તમાન વાપરો};
    \node [gtu state, below=of Use] (Process) {પ્રોસેસ};
    
    \path [gtu arrow] (Start) -- (Check);
    \path [gtu arrow] (Check) -- (Exists);
    \path [gtu arrow] (Exists) -- node {ના} (New);
    \path [gtu arrow] (Exists) -- node {હા} (Use);
    \path [gtu arrow] (New) -- (Process);
    \path [gtu arrow] (Use) -- (Process);
\end{tikzpicture}
\captionof{figure}{સેશન ટ્રેકિંગ Logic}
\end{center}

\textbf{HttpSession અમલીકરણ:}
\begin{lstlisting}[language=Java]
HttpSession session = request.getSession();
session.setAttribute("user", username);
String user = (String) session.getAttribute("user");
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CUHH = Cookies URL Hidden HttpSession}
\end{mnemonicbox}

\questionmarks{4(અ)}{3}{JSP નું આર્કિટેક્ચર ડાયાગ્રામ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{JSP આર્કિટેક્ચર:}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu block] (JSP) {JSP પેજ};
    \node [gtu block, right=of JSP] (Engine) {JSP એન્જિન};
    \node [gtu block, below=of Engine] (Servlet) {સર્વલેટ Gen};
    \node [gtu block, left=of Servlet] (Byte) {કમ્પાઇલ};
    \node [gtu block, below=of Byte] (Exec) {એક્ઝિક્યુટ};
    \node [gtu block, right=of Exec] (Resp) {HTML રિસ્પોન્સ};
    
    \path [gtu arrow] (JSP) -- (Engine);
    \path [gtu arrow] (Engine) -- (Servlet);
    \path [gtu arrow] (Servlet) -- (Byte);
    \path [gtu arrow] (Byte) -- (Exec);
    \path [gtu arrow] (Exec) -- (Resp);
\end{tikzpicture}
\captionof{figure}{JSP પ્રોસેસિંગ}
\end{center}

\begin{enumerate}
    \item \textbf{JSP એન્જિન}: JSP ને સર્વલેટમાં રૂપાંતરિત કરે.
    \item \textbf{વેબ કન્ટેનર}: JSP લાઇફસાઇકલ મેનેજ કરે.
    \item \textbf{જનરેટેડ સર્વલેટ}: વાસ્તવિક એક્ઝિક્યુશન યુનિટ.
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{JSP = Java Server Pages (Page to Servlet)}
\end{mnemonicbox}

\questionmarks{4(બ)}{4}{ઉદાહરણ સાથે JSP scripting elements સમજાવો.}

\begin{solutionbox}
\textbf{JSP સ્ક્રિપ્ટિંગ એલિમેન્ટ્સ:}
\begin{center}
\captionof{table}{સ્ક્રિપ્ટિંગ એલિમેન્ટ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{એલિમેન્ટ} & \textbf{સિન્ટેક્સ} & \textbf{હેતુ} \\ \hline
Scriptlet & \code{<\% code \%>} & જાવા કોડ બ્લોક \\ \hline
Expression & \code{<\%= expression \%>} & આઉટપુટ વેલ્યુ \\ \hline
Declaration & \code{<\%! declaration \%>} & વેરિયેબલ/મેથડ \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણો:}
\begin{lstlisting}[language=Java]
<%! int count = 0; %>               <!-- ડિક્લેરેશન -->
<% count++; %>                      <!-- સ્ક્રિપ્ટલેટ -->
<%= "Count: " + count %>            <!-- એક્સ્પ્રેશન -->
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SED = Scriptlet Expression Declaration}
\end{mnemonicbox}

\questionmarks{4(ક)}{7}{JSP જીવન ચક્ર સમજાવો.}

\begin{solutionbox}
\textbf{JSP લાઇફ સાઇકલ તબક્કા:}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (Trans) {Translate};
    \node [gtu state, right=of Trans] (Comp) {Compile};
    \node [gtu state, right=of Comp] (Load) {Load};
    \node [gtu state, below=of Load] (Inst) {Instance};
    \node [gtu state, left=of Inst] (Init) {Init};
    \node [gtu state, left=of Init] (Serv) {Service};
    \node [gtu state, below=of Serv] (Dest) {Destroy};
    
    \path [gtu arrow] (Trans) -- (Comp);
    \path [gtu arrow] (Comp) -- (Load);
    \path [gtu arrow] (Load) -- (Inst);
    \path [gtu arrow] (Inst) -- (Init);
    \path [gtu arrow] (Init) -- (Serv);
    \path [gtu arrow] (Serv) edge [loop above] node {} (Serv);
    \path [gtu arrow] (Serv) -- (Dest);
\end{tikzpicture}
\captionof{figure}{JSP લાઇફ સાઇકલ}
\end{center}

\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{તબક્કો} & \textbf{વર્ણન} \\ \hline
ટ્રાન્સલેશન & JSP સર્વલેટ સોર્સમાં કન્વર્ટ \\ \hline
કમ્પાઇલેશન & સર્વલેટ સોર્સ બાઇટકોડમાં કમ્પાઇલ \\ \hline
લોડિંગ & સર્વલેટ ક્લાસ JVM દ્વારા લોડ \\ \hline
ઇન્સ્ટેન્શિએશન & સર્વલેટ ઓબ્જેક્ટ બનાવ્યું \\ \hline
ઇનિશિયલાઇઝેશન & \code{jspInit()} મેથડ કોલ \\ \hline
રિક્વેસ્ટ પ્રોસેસિંગ & \code{\_jspService()} રિક્વેસ્ટ હેન્ડલ કરે \\ \hline
ડિસ્ટ્રક્શન & \code{jspDestroy()} સફાઈ મેથડ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TCLIIRD = Translation Compilation Loading Instantiation Init Request Destroy}
\end{mnemonicbox}

\questionmarks{4(અ OR)}{3}{JSP અને સર્વલેટ વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{JSP vs સર્વલેટ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{JSP} & \textbf{સર્વલેટ} \\ \hline
\textbf{કોડ સ્ટાઇલ} & HTML સાથે જાવા & શુદ્ધ જાવા કોડ \\ \hline
\textbf{ડેવલપમેન્ટ} & UI માટે સરળ & લોજિક માટે વધુ સારું \\ \hline
\textbf{કમ્પાઇલેશન} & ઓટોમેટિક & મેન્યુઅલ \\ \hline
\textbf{મોડિફિકેશન} & પુનઃકમ્પાઇલેશનની જરૂર નથી & પુનઃકમ્પાઇલેશન જરૂરી \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{HTML vs Java = JSP vs Servlet}
\end{mnemonicbox}

\questionmarks{4(બ OR)}{4}{JSP ના ફાયદાની યાદી બનાવો અને સમજાવો.}

\begin{solutionbox}
\textbf{JSP ફાયદા:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ફાયદો} & \textbf{વર્ણન} \\ \hline
સરળ ડેવલપમેન્ટ & HTML જેવું સિન્ટેક્સ જાવા સાથે \\ \hline
ઓટોમેટિક કમ્પાઇલેશન & મેન્યુઅલ કમ્પાઇલેશનની જરૂર નથી \\ \hline
પ્લેટફોર્મ સ્વતંત્ર & કોઈપણ જાવા-સક્ષમ સર્વર પર ચાલે \\ \hline
ચિંતાઓનું વિભાજન & ડિઝાઇન લોજિકથી અલગ \\ \hline
પુનઃઉપયોગી કમ્પોનન્ટ & ટેગ લાઇબ્રેરી અને બીન્સ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EAPSR = Easy Automatic Platform Separation Reusable}
\end{mnemonicbox}

\questionmarks{4(ક OR)}{7}{કુકી શું છે? JSP પૃષ્ઠનો ઉપયોગ કરીને કુકી કેવી રીતે વાંચવી અને કાઢી નાખવી તે સમજાવો.}

\begin{solutionbox}
\textbf{કુકી ઓવરવ્યૂ:}
કુકી એ ક્લાયન્ટના બ્રાઉઝર પર સ્ટોર થતો નાનો ડેટા છે જે સ્ટેટ જાળવવા માટે વપરાય છે.

\textbf{કુકી ઓપરેશન:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{JSP કોડ} \\ \hline
બનાવવું & \code{Cookie cookie = new Cookie("name", "value");} \\ \hline
ઉમેરવું & \code{response.addCookie(cookie);} \\ \hline
વાંચવું & \code{Cookie[] cookies = request.getCookies();} \\ \hline
કાઢવું & \code{cookie.setMaxAge(0);} \\ \hline
\end{tabulary}
\end{center}

\textbf{કુકી વાંચવાનું ઉદાહરણ:}
\begin{lstlisting}[language=Java]
<%
Cookie[] cookies = request.getCookies();
if (cookies != null) {
    for (Cookie cookie : cookies) {
        if ("username".equals(cookie.getName())) {
            out.println("User: " + cookie.getValue());
        }
    }
}
%>
\end{lstlisting}

\textbf{કુકી કાઢવાનું ઉદાહરણ:}
\begin{lstlisting}[language=Java]
<%
Cookie cookie = new Cookie("username", "");
cookie.setMaxAge(0);
response.addCookie(cookie);
%>
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CARD = Create Add Read Delete}
\end{mnemonicbox}

\questionmarks{5(અ)}{3}{MVC આર્કિટેક્ચરનું મહત્વ સમજાવો.}

\begin{solutionbox}
\textbf{MVC મહત્વ:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{લાભ} & \textbf{વર્ણન} \\ \hline
ચિંતાઓનું વિભાજન & લોજિક, પ્રેઝન્ટેશન, ડેટા અલગ \\ \hline
જાળવણીયોગ્યતા & વ્યક્તિગત કમ્પોનન્ટ સરળતાથી મોડિફાઇ કરી શકાય \\ \hline
ટેસ્ટેબિલિટી & કમ્પોનન્ટ સ્વતંત્ર રીતે ટેસ્ટ કરી શકાય \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{કોડ ઓર્ગેનાઇઝેશન}: વધુ સારી સ્ટ્રક્ચર અને ઓર્ગેનાઇઝેશન.
    \item \textbf{ટીમ ડેવલપમેન્ટ}: બહુવિધ ડેવલપર એકસાથે કામ કરી શકે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SMT = Separation Maintainability Testability}
\end{mnemonicbox}

\questionmarks{5(બ)}{4}{સંક્ષિપ્તમાં આસ્પેક્ટ ઓરિએન્ટેડ પ્રોગ્રામિંગ અને ડિપેન્ડન્સી ઇન્જેક્શન સમજાવો.}

\begin{solutionbox}
\textbf{આસ્પેક્ટ ઓરિએન્ટેડ પ્રોગ્રામિંગ (AOP):}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કન્સેપ્ટ} & \textbf{વર્ણન} \\ \hline
ક્રોસ-કટિંગ કન્સર્ન & લોગિંગ, સિક્યોરિટી, ટ્રાન્ઝેક્શન \\ \hline
આસ્પેક્ટ & ક્રોસ-કટિંગ ફંક્શનાલિટીના મોડ્યુલર યુનિટ \\ \hline
જોઇન પોઇન્ટ & જ્યાં આસ્પેક્ટ લાગુ કરવાય \\ \hline
\end{tabulary}
\end{center}

\textbf{ડિપેન્ડન્સી ઇન્જેક્શન (DI):}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કન્સેપ્ટ} & \textbf{વર્ણન} \\ \hline
ઇન્વર્સન ઓફ કન્ટ્રોલ & ડિપેન્ડન્સી બાહ્યથી આપવામાં આવે \\ \hline
લૂઝ કપલિંગ & ઓબ્જેક્ટ ડિપેન્ડન્સી બનાવતા નથી \\ \hline
કન્ફિગરેશન & ડિપેન્ડન્સી બાહ્યથી કન્ફિગર કરાય \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{AOP = Aspects Over Points, DI = Dependencies Injected}
\end{mnemonicbox}

\questionmarks{5(ક)}{7}{MVC આર્કિટેક્ચર સમજાવો.}

\begin{solutionbox}
\textbf{MVC કમ્પોનન્ટ્સ:}

\begin{center}
\begin{tikzpicture}[node distance=2.5cm, auto]
    \node [gtu block] (View) {View\\(પ્રેઝન્ટેશન)};
    \node [gtu block, right=of View] (Ctrl) {Controller\\(LogicFlow)};
    \node [gtu block, right=of Ctrl] (Model) {Model\\(Data/Logic)};
    
    \path [gtu arrow] (View) edge[bend left] node {} (Ctrl);
    \path [gtu arrow] (Ctrl) edge[bend left] node {} (View);
    
    \path [gtu arrow] (Ctrl) edge[bend left] node {} (Model);
    \path [gtu arrow] (Model) edge[bend left] node {} (Ctrl);
\end{tikzpicture}
\captionof{figure}{MVC Interaction}
\end{center}

\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કમ્પોનન્ટ} & \textbf{જવાબદારી} \\ \hline
મોડેલ & બિઝનેસ લોજિક અને ડેટા મેનેજમેન્ટ \\ \hline
વ્યૂ & યુઝર ઇન્ટરફેસ અને પ્રેઝન્ટેશન \\ \hline
કન્ટ્રોલર & રિક્વેસ્ટ હેન્ડલિંગ અને ફ્લો કન્ટ્રોલ \\ \hline
\end{tabulary}
\end{center}

\textbf{MVC ફ્લો:}
\begin{enumerate}
    \item \textbf{યુઝર રિક્વેસ્ટ} $\rightarrow$ કન્ટ્રોલર રિક્વેસ્ટ પ્રાપ્ત કરે.
    \item \textbf{કન્ટ્રોલર} $\rightarrow$ રિક્વેસ્ટ પ્રોસેસ કરે, મોડેલ કોલ કરે.
    \item \textbf{મોડેલ} $\rightarrow$ બિઝનેસ લોજિક પર્ફોર્મ કરે, ડેટા રિટર્ન કરે.
    \item \textbf{કન્ટ્રોલર} $\rightarrow$ યોગ્ય વ્યૂ સિલેક્ટ કરે.
    \item \textbf{વ્યૂ} $\rightarrow$ યુઝરને રિસ્પોન્સ રેન્ડર કરે.
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MVC = Model View Controller (Business UI Control)}
\end{mnemonicbox}

\questionmarks{5(અ OR)}{3}{MVC આર્કિટેક્ચરના ફાયદા સમજાવો.}

\begin{solutionbox}
\textbf{MVC ફાયદા:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ફાયદો} & \textbf{વર્ણન} \\ \hline
કોડ પુનઃઉપયોગિતા & કમ્પોનન્ટ વિવિધ એપ્લિકેશનમાં પુનઃવાપરી શકાય \\ \hline
સમાંતર ડેવલપમેન્ટ & બહુવિધ ડેવલપર વિવિધ લેયર પર કામ કરી શકે \\ \hline
સરળ ટેસ્ટિંગ & દરેક કમ્પોનન્ટ સ્વતંત્ર રીતે ટેસ્ટ કરાય \\ \hline
જાળવણી & એક લેયરમાં ફેરફાર અન્યને અસર કરતા નથી \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CPEM = Code Parallel Easy Maintenance}
\end{mnemonicbox}

\questionmarks{5(બ OR)}{4}{સ્પ્રિંગ અને સ્પ્રિંગ બૂટ વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{સ્પ્રિંગ vs સ્પ્રિંગ બૂટ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{સ્પ્રિંગ} & \textbf{સ્પ્રિંગ બૂટ} \\ \hline
કન્ફિગરેશન & મેન્યુઅલ XML/Java કન્ફિગ & ઓટો-કન્ફિગરેશન \\ \hline
સેટઅપ ટાઇમ & વધુ સેટઅપ જરૂરી & ન્યૂનતમ સેટઅપ \\ \hline
એમ્બેડેડ સર્વર & બાહ્ય સર્વરની જરૂર & બિલ્ટ-ઇન સર્વર \\ \hline
ડિપેન્ડન્સી & મેન્યુઅલ ડિપેન્ડન્સી મેનેજમેન્ટ & સ્ટાર્ટર ડિપેન્ડન્સી \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Manual vs Auto = Spring vs SpringBoot}
\end{mnemonicbox}

\questionmarks{5(ક OR)}{7}{સ્પ્રિંગ ફ્રેમવર્કનું આર્કિટેક્ચર સમજાવો.}

\begin{solutionbox}
\textbf{સ્પ્રિંગ ફ્રેમવર્ક આર્કિટેક્ચર:}

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node [gtu block] (Core) {Core Container\\(IoC \& DI)};
    \node [gtu block, right=of Core] (Web) {Web Layer\\(MVC, WebFlux)};
    \node [gtu block, below=of Core] (Data) {Data Access\\(JDBC, ORM)};
    \node [gtu block, right=of Data] (Test) {Test\\(JUnit, Mock)};
    \node [gtu block, below=of Data] (AOP) {AOP\\(આસ્પેક્ટ)};
    
    \path [gtu arrow] (Core) -- (Web);
    \path [gtu arrow] (Core) -- (Data);
    \path [gtu arrow] (Core) -- (AOP);
    \path [gtu arrow] (Core) -- (Test);
\end{tikzpicture}
\captionof{figure}{સ્પ્રિંગ આર્કિટેક્ચર}
\end{center}

\textbf{સ્પ્રિંગ મોડ્યુલ:}
\begin{center}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{મોડ્યુલ} & \textbf{હેતુ} \\ \hline
Core Container & IoC કન્ટેનર, ડિપેન્ડન્સી ઇન્જેક્શન \\ \hline
Data Access & JDBC, ORM, ટ્રાન્ઝેક્શન મેનેજમેન્ટ \\ \hline
Web & વેબ MVC, REST સર્વિસ \\ \hline
AOP & આસ્પેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગ \\ \hline
Test & ટેસ્ટિંગ સપોર્ટ અને મોક ઓબ્જેક્ટ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CDWAST = Core Data Web AOP Security Test}
\end{mnemonicbox}

\end{document}
