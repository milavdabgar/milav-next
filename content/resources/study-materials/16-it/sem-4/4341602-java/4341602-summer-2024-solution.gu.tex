\documentclass{article}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}
\usetikzlibrary{fit,positioning,shapes,calc,arrows.meta}

\title{Object Oriented Programming With Java (4341602) - Summer 2024 Solution (Gujarati)}
\date{June 13, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{Explain the basic structure of Java program.}

\begin{solutionbox}
\textbf{Basic Structure}: Java પ્રોગ્રામમાં classes, methods અને statements ચોક્કસ શ્રેણીમાં ગોઠવાયેલા હોય છે.

\begin{center}
\captionof{table}{મૂળભૂત માળખું ઘટકો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઘટક} & \textbf{વર્ણન} \\ \hline
Package Declaration & વૈકલ્પિક, package સભ્યપદ દર્શાવે છે \\ \hline
Import Statements & જરૂરી classes/packages આયાત કરે છે \\ \hline
Class Declaration & મુખ્ય class વ્યાખ્યા, objects માટે blueprint \\ \hline
Main Method & પ્રવેશ બિંદુ \code{public static void main(String[] args)} \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[node distance=0cm, outer sep=0pt]
    \node [draw, rectangle, minimum width=6cm, minimum height=1cm, fill=blue!5] (pkg) {Package Declaration};
    \node [draw, rectangle, minimum width=6cm, minimum height=1cm, below=0cm of pkg, fill=blue!10] (imp) {Import Statements};
    
    \node [draw, rectangle, minimum width=6cm, minimum height=5cm, below=0cm of imp, fill=blue!15, label={[anchor=north]north:Class Declaration}] (cls) {};
    
    \node [draw, rectangle, minimum width=5cm, minimum height=1cm, below=-1.5cm of cls.north, fill=white] (var) {Variables};
    \node [draw, rectangle, minimum width=5cm, minimum height=2.5cm, below=0.5cm of var, fill=white, label={[anchor=north]north:Methods}] (mtd) {};
    
    \node [draw, rectangle, minimum width=4cm, minimum height=1cm, below=-1.5cm of mtd.north, fill=green!10] (main) {main method};

\end{tikzpicture}
\captionof{figure}{Java પ્રોગ્રામનું માળખું}
\end{center}

\begin{itemize}
    \item \textbf{Package}: સંબંધિત classes ને જૂથબદ્ધ કરે છે (જેમ કે \code{package com.example;})
    \item \textbf{Import}: બાહ્ય classes ને access કરે છે (જેમ કે \code{import java.util.*;})
    \item \textbf{Class}: બધો કોડ અહીં હોય છે
    \item \textbf{Main method}: પ્રોગ્રામ execution અહીંથી શરૂ થાય છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PICM - Package, Import, Class, Main}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{List out different features of java. Explain any two.}

\begin{solutionbox}
\textbf{Java ના લક્ષણો}:
\begin{enumerate}
    \item \textbf{Platform Independent}: એક વાર લખો, બધે ચલાવો (WORA)
    \item \textbf{Object Oriented}: બધું object છે
    \item \textbf{Simple}: સરળ syntax, pointers નથી
    \item \textbf{Secure}: built-in સુરક્ષા લક્ષણો, bytecode verification
    \item \textbf{Robust}: મજબૂત memory management, exceotopm handling
    \item \textbf{Multithreaded}: concurrent execution આધાર
\end{enumerate}

\textbf{1. Platform Independence:}
Java કોડ bytecode માં compile થાય છે, જે platform-neutral છે. આ bytecode ને JVM (Java Virtual Machine) interpret કરે છે, જે દરેક OS (Windows, Linux, Mac) માટે અલગ હોય છે.

\textbf{2. Object Oriented:}
Java વાસ્તવિક દુનિયાની વસ્તુઓને objects અને classes દ્વારા model કરે છે. તે મુખ્ય OOP સિદ્ધાંતોને આધાર આપે છે:
\begin{itemize}
    \item \textbf{Encapsulation}: ડેટા અને methods ને બાંધવું
    \item \textbf{Inheritance}: કોડ પુનઃઉપયોગ
    \item \textbf{Polymorphism}: એક જ interface, અલગ સ્વરૂપ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{POSRMM - Platform, Object, Simple, Robust, Multithreaded, Memory}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Write a program in java to find out sum of the digits of entered number.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={અંકોનો સરવાળો}]
public class DigitSum {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Please provide a number.");
            return;
        }
        
        int number = Integer.parseInt(args[0]);
        int sum = 0;
        int temp = Math.abs(number);
        
        while (temp > 0) {
            sum += temp % 10;
            temp /= 10;
        }
        
        System.out.println("Sum of digits: " + sum);
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{Algorithm Trace (ઇનપુટ: 123)}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પગલું} & \textbf{ક્રિયા} & \textbf{પરિણામ} \\ \hline
1 & છેલ્લો અંક કાઢો & $123 \% 10 = 3$ \\ \hline
2 & સરવાળામાં ઉમેરો & $sum = 0 + 3 = 3$ \\ \hline
3 & છેલ્લો અંક હટાવો & $123 / 10 = 12$ \\ \hline
4 & અંક કાઢો & $12 \% 10 = 2$ \\ \hline
5 & સરવાળામાં ઉમેરો & $sum = 3 + 2 = 5$ \\ \hline
6 & અંક હટાવો & $12 / 10 = 1$ \\ \hline
7 & અંક કાઢો & $1 \% 10 = 1$ \\ \hline
8 & સરવાળામાં ઉમેરો & $sum = 5 + 1 = 6$ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EARD - Extract, Add, Remove, Done}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Write a program in java to find out maximum from any ten numbers using command line argument.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={મહત્તમ શોધો}]
public class FindMaximum {
    public static void main(String[] args) {
        if (args.length < 10) {
            System.out.println("Please enter 10 numbers");
            return;
        }
        
        int max = Integer.parseInt(args[0]);
        
        for (int i = 1; i < 10; i++) {
            int current = Integer.parseInt(args[i]);
            if (current > max) {
                max = current;
            }
        }
        
        System.out.println("Maximum number: " + max);
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{Logic Steps}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પગલું} & \textbf{ક્રિયા} \\ \hline
Validation & 10 arguments છે કે કેમ તે તપાસો \\ \hline
Initialization & પ્રથમ સંખ્યાને \code{max} ધારો \\ \hline
Comparison & બાકીની સંખ્યાઓ સાથે સરખાવો \\ \hline
Update & જો \code{current > max}, તો \code{max = current} \\ \hline
Output & \code{max} છાપો \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{VCIU - Validate, Compare, Initialize, Update}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{List out different concept of oop. Explain anyone in detail.}

\begin{solutionbox}
\textbf{OOP ની વિભાવનાઓ}:
\begin{itemize}
    \item Encapsulation
    \item Inheritance
    \item Polymorphism
    \item Abstraction
\end{itemize}

\textbf{Encapsulation}:
Encapsulation એ ડેટા અને methods ને એક unit (class) માં જોડવાની પદ્ધતિ છે. તે ડેટાને બહારની દખલગીરીથી સુરક્ષિત કરે છે.

\begin{itemize}
    \item \textbf{Data Hiding}: ડેટાને \code{private} જાહેર કરીને સીધો access રોકવામાં આવે છે.
    \item \textbf{Accessors/Mutators}: ડેટા access કરવા માટે public \code{getter} અને \code{setter} methods આપવામાં આવે છે.
    \item \textbf{ફાયદા}: સુરક્ષા, જાળવણી અને લવચીકતા વધારે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EIPA - Encapsulation, Inheritance, Polymorphism, Abstraction}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Explain JVM in detail.}

\begin{solutionbox}
\textbf{JVM (Java Virtual Machine)} એ engine છે જે Java bytecode execute કરે છે.

\begin{center}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block] (source) {Java Source};
    \node [gtu block, right=of source] (compiler) {Compiler};
    \node [gtu block, right=of compiler] (bytecode) {Bytecode};
    \node [gtu block, below=1cm of compiler, fill=yellow!10, minimum width=4cm] (jvm) {JVM};
    
    \node [gtu block, below=0.5cm of jvm] (os) {Native OS};
    
    \draw [gtu arrow] (source) -- (compiler);
    \draw [gtu arrow] (compiler) -- (bytecode);
    \draw [gtu arrow] (bytecode) -- (jvm);
    \draw [gtu arrow] (jvm) -- (os);
    
    % Internal JVM components
    \node [draw, dashed, inner sep=5pt, fit=(jvm)] {}; 
    \node [right=0.2cm of jvm, text width=3cm, font=\footnotesize] {
    Includes:\\
    - Class Loader\\
    - Memory Areas\\
    - Execution Engine};
\end{tikzpicture}
\captionof{figure}{JVM આર્કિટેક્ચર}
\end{center}

\begin{center}
\captionof{table}{JVM ઘટકો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઘટક} & \textbf{કાર્ય} \\ \hline
Class Loader & \code{.class} files ને memory માં લોડ કરે છે \\ \hline
Memory Areas & મેમરી ફાળવે છે (Heap, Stack, Method Area) \\ \hline
Execution Engine & Bytecode interpret કરે છે અથવા JIT compiler વાપરે છે \\ \hline
JIT Compiler & ઝડપ માટે કોડને native machine code માં બદલે છે \\ \hline
\end{tabulary}
\end{center}

\textbf{મુખ્ય લક્ષણો}:
\begin{itemize}
    \item \textbf{Platform Independence}: JVM Java ને portable બનાવે છે.
    \item \textbf{Memory Management}: મેમરી ફાળવણી અને garbage collection સંભાળે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEMJ - Class loader, Execution, Memory, JIT}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Explain constructor overloading with example.}

\begin{solutionbox}
\textbf{Constructor Overloading}: એક જ class માં અલગ parameters યાદી સાથે એકથી વધુ constructors હોવાની પદ્ધતિ.

\begin{lstlisting}[language=Java,caption={Constructor Overloading}]
public class Student {
    private String name;
    private int age;
    private String course;
    
    // 1. Default constructor
    public Student() {
        this.name = "Unknown";
        this.age = 0;
        this.course = "Not Assigned";
    }
    
    // 2. Constructor with one parameter
    public Student(String name) {
        this.name = name;
        this.age = 0;
        this.course = "Not Assigned";
    }
    
    // 3. Constructor with two parameters
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        this.course = "Not Assigned";
    }
    
    // 4. Constructor with all parameters
    public Student(String name, int age, String course) {
        this.name = name;
        this.age = age;
        this.course = course;
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{Constructor ના પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Constructor} & \textbf{Parameters} & \textbf{શૈલી} \\ \hline
Default & કોઈ નહિ & મૂળભૂત કિંમતો સાથે initialization \\ \hline
Single Param & નામ & માત્ર નામ સાથે નોંધણી \\ \hline
Two Param & નામ, ઉંમર & મૂળભૂત વિગતો સાથે \\ \hline
Full Param & બધા fields & સંપૂર્ણ initialization \\ \hline
\end{tabulary}
\end{center}

\textbf{નિયમો}:
\begin{itemize}
    \item Class નામ જેવું જ નામ હોવું જોઈએ.
    \item Parameters યાદી અલગ હોવી જોઈએ (સંખ્યા અથવા પ્રકાર).
    \item Compile-time પર નક્કી થાય છે (Compile-time Polymorphism).
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SNDF - Same Name, Different Parameters, Flexible}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{What is wrapper class? Explain with example.}

\begin{solutionbox}
\textbf{Wrapper Class}: એક class જે primitive data type ને object માં લપેટે છે.

\begin{center}
\captionof{table}{Primitive vs Wrapper}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Primitive} & \textbf{Wrapper Class} \\ \hline
byte & Byte \\ \hline
int & Integer \\ \hline
char & Character \\ \hline
double & Double \\ \hline
boolean & Boolean \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Boxing and Unboxing}]
// Boxing: Primitive to Object
int num = 10;
Integer obj = Integer.valueOf(num); // Manual
Integer autoBox = 10;               // Autoboxing

// Unboxing: Object to Primitive
Integer wrapper = new Integer(20);
int value = wrapper.intValue();     // Manual
int autoUnbox = wrapper;            // Auto-unboxing
\end{lstlisting}

\textbf{ઉપયોગ}: Collection Frameworks (ArrayList, Vector) માં જરૂરી છે જ્યાં માત્ર objects જ સંગ્રહિત થાય છે.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BUC - Boxing, Unboxing, Collections}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{Explain static keyword with example.}

\begin{solutionbox}
\textbf{Static Keyword}: દર્શાવે છે કે સભ્ય class નો છે, instance નો નહિ.

\begin{center}
\captionof{table}{Static ઉપયોગો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{સભ્ય} & \textbf{વર્તન} \\ \hline
Variable & બધા instances વચ્ચે shared memory (class variable) \\ \hline
Method & Object બનાવ્યા વિના કૉલ કરી શકાય \\ \hline
Block & Class લોડ થાય ત્યારે એક વાર execute થાય \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Static Example}]
public class Counter {
    static int count = 0;  // Shared variable
    int id;                // Instance variable
    
    public Counter() {
        count++;           // દરેક નવા object માટે વધારો
        this.id = count;
    }
    
    public static void showCount() {
        // માત્ર static ડેટા access કરી શકે
        System.out.println("Total objects: " + count);
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{Memory Efficiency}: Variable માત્ર એક જ વાર બને છે.
    \item \textbf{Utility}: Utility methods માટે વપરાય છે (જેમ કે \code{Math.sqrt()}).
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SCMA - Shared, Class-level, Memory, Access}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{What is constructor? Explain copy constructor with example.}

\begin{solutionbox}
\textbf{Constructor}: Object ને initialize કરવા માટે વપરાતો ખાસ કોડ બ્લોક.

\textbf{Copy Constructor}: જે object ને એ જ class ના બીજા object નો ઉપયોગ કરીને initialize કરે છે. તે object ની નકલ (clone) બનાવે છે.

\begin{lstlisting}[language=Java,caption={Copy Constructor}]
public class Book {
    private String title;
    private String author;
    
    // Parameterized constructor
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }
    
    // Copy constructor
    public Book(Book other) {
        this.title = other.title;
        this.author = other.author;
    }
}

// Usage
class Main {
    public static void main(String[] args) {
        Book b1 = new Book("Java Guide", "James");
        Book b2 = new Book(b1); // b1 ની નકલ બનાવે છે
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{Constructor ગુણધર્મો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ગુણધર્મ} & \textbf{વર્ણન} \\ \hline
નામ & Class નામ જેવું જ હોવું જોઈએ \\ \hline
Return Type & કોઈ નહિ (void પણ નહિ) \\ \hline
Invocation & \code{new} સમયે આપોઆપ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SNAC - Same Name, Automatic Call}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Explain any four-string function in java with example.}

\begin{solutionbox}
\textbf{String Functions}:
\begin{center}
\captionof{table}{સામાન્ય String Functions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Function} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\ \hline
\code{length()} & અક્ષરોની સંખ્યા આપે છે & \code{"Hi".length()} $\to$ 2 \\ \hline
\code{charAt(i)} & i index પરનો અક્ષર આપે છે & \code{"Hi".charAt(0)} $\to$ 'H' \\ \hline
\code{substring(i)} & i થી સ્ટ્રિંગનો ભાગ આપે છે & \code{"Code".substring(2)} $\to$ "de" \\ \hline
\code{toUpperCase()} & અક્ષરોને કેપિટલમાં ફેરવે છે & \code{"java".toUpperCase()} $\to$ "JAVA" \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={String Example}]
String str = "Java Programming";
int len = str.length();           // 16
char ch = str.charAt(0);          // 'J'
String sub = str.substring(5);    // "Programming"
String upper = str.toUpperCase(); // "JAVA PROGRAMMING"
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LCST - Length, Character, Substring, Transform}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{List out different types of inheritance. Explain multilevel inheritance.}

\begin{solutionbox}
\textbf{Inheritance ના પ્રકારો}:
\begin{enumerate}
    \item Single Inheritance
    \item Multilevel Inheritance
    \item Hierarchical Inheritance
    \item Multiple Inheritance (Interfaces દ્વારા)
    \item Hybrid Inheritance
\end{enumerate}

\textbf{Multilevel Inheritance}:
એક પદ્ધતિ જ્યાં class ડેરિવેડ class માંથી inherit થાય છે, વારસાની સાંકળ રચે છે.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node [gtu block] (veh) {Vehicle};
    \node [gtu block, right=of veh] (car) {Car};
    \node [gtu block, right=of car] (sports) {SportsCar};
    
    \draw [gtu arrow] (veh) -- (car);
    \draw [gtu arrow] (car) -- (sports);
\end{tikzpicture}
\captionof{figure}{Multilevel Inheritance}
\end{center}

\begin{lstlisting}[language=Java,caption={Multilevel Inheritance}]
class Vehicle { void start() {} }
class Car extends Vehicle { void drive() {} }
class SportsCar extends Car { void race() {} }
\end{lstlisting}

આ ઉદાહરણમાં, \code{SportsCar} \code{Car} અને \code{Vehicle} બંનેના લક્ષણો વારસામાં મેળવે છે.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SMHM - Single, Multilevel, Hierarchical, Multiple}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{What is interface? Explain multiple inheritance with example.}

\begin{solutionbox}
\textbf{Interface}: Java માં એક અમૂર્ત સંદર્ભ પ્રકાર છે જે class જેવો જ છે પરંતુ તેમાં માત્ર constants, method signatures (ખાલી methods), default methods અને static methods હોય છે. તે સંપૂર્ણ અમૂર્તતા અને multiple inheritance પ્રાપ્ત કરવા માટે વપરાય છે.

\textbf{Multiple Inheritance}: Ambiguity (Diamond Problem) ને ટાળવા માટે Java classes સાથે multiple inheritance ડાયરેક્ટ સપોર્ટ કરતું નથી, પરંતુ તે interfaces દ્વારા સપોર્ટ કરે છે. એક class એકથી વધુ interfaces implement કરી શકે છે.

\begin{center}
\begin{tikzpicture}[node distance=2cm]
    \node [gtu block] (fly) {interface Flyable};
    \node [gtu block, right=of fly] (swim) {interface Swimmable};
    \node [gtu block, below right=1cm and -1cm of fly] (duck) {class Duck};
    
    \draw [gtu arrow] (fly) -- (duck);
    \draw [gtu arrow] (swim) -- (duck);
\end{tikzpicture}
\captionof{figure}{Multiple Inheritance (Interfaces)}
\end{center}

\begin{lstlisting}[language=Java,caption={Multiple Inheritance Example}]
interface Flyable {
    void fly();
}
interface Swimmable {
    void swim();
}

// એક class અનેક interfaces implement કરે છે
class Duck implements Flyable, Swimmable {
    public void fly() {
        System.out.println("Duck is flying");
    }
    public void swim() {
        System.out.println("Duck is swimming");
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{Interface vs Class}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Interface} & \textbf{Class} \\ \hline
માત્ર અમૂર્ત (abstract) methods હોઈ શકે & કોંક્રિટ (concrete) methods હોય છે \\ \hline
Variables \code{public static final} હોય છે & કોઈ પણ પ્રકારના variable હોઈ શકે \\ \hline
Multiple inheritance સપોર્ટ કરે છે & Single inheritance સપોર્ટ કરે છે \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CMDS - Contract, Multiple, Diamond-solution}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{Explain this keyword with example.}

\begin{solutionbox}
\textbf{'this' Keyword}: Java માં એક સંદર્ભ ચલ જે વર્તમાન object નો સંદર્ભ આપે છે.

\begin{center}
\captionof{table}{'this' ના ઉપયોગો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કેસ} & \textbf{હેતુ} \\ \hline
Instance Variable & Parameter થી field ને અલગ પાડવા (\code{this.x = x}) \\ \hline
Method Call & વર્તમાન class method ને બોલાવવા (\code{this.method()}) \\ \hline
Constructor Call & Constructors ને સાંકળવા (\code{this()}) \\ \hline
Return Object & વર્તમાન instance પાછું આપવા (\code{return this}) \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Using 'this'}]
public class Person {
    String name;
    
    public Person(String name) {
        this.name = name; // Ambiguity ઉકેલે છે
    }
    
    public Person getInstance() {
        return this; // વર્તમાન object રિટર્ન કરે છે
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CRPM - Current, Resolve, Parameter, Method}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Explain method overriding with example.}

\begin{solutionbox}
\textbf{Method Overriding}: જ્યારે પેટા-વર્ગ (subclass) પિતૃ-વર્ગ (parent class) માં પહેલેથી જ વ્યાખ્યાયિત પદ્ધતિ માટે ચોક્કસ અમલીકરણ પ્રદાન કરે છે ત્યારે તે થાય છે. તે Runtime Polymorphism માટે વપરાય છે.

\begin{lstlisting}[language=Java,caption={Method Overriding}]
class Animal {
    void makeSound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}

class Main {
    public static void main(String[] args) {
        Animal a = new Dog(); // Upcasting
        a.makeSound(); // Output: Dog barks
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{Overriding ના નિયમો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{નિયમ} & \textbf{વર્ણન} \\ \hline
Signature & Method નામ અને args સમાન હોવા જોઈએ \\ \hline
Inheritance & IS-A સંબંધ હોવો જોઈએ \\ \hline
Access & Access level વધુ પ્રતિબંધિત હોઈ શકતું નથી \\ \hline
Binding & Runtime પર નક્કી થાય છે (Dynamic Binding) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SSRD - Same Signature, Runtime Decision}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{What is package? Write steps to create a package and give example of it.}

\begin{solutionbox}
\textbf{Package}: એક namespace જે સંબંધિત classes અને interfaces ને સંગઠિત કરે છે. તે મદદ કરે છે:
\begin{itemize}
    \item નામકરણ તકરાર (naming conflicts) અટકાવવા.
    \item ઍક્સેસ નિયંત્રિત કરવા (protected/default access).
    \item Classes શોધવા/ઉપયોગ કરવાનું સરળ બનાવવા.
\end{itemize}

\textbf{Package બનાવવા અને વાપરવાના પગલાં}:
\begin{enumerate}
    \item \textbf{Directory}: પેકેજ નામ સાથે મેળ ખાતું ફોલ્ડર માળખું બનાવો (દા.ત., \code{com/utils}).
    \item \textbf{Declaration}: ફાઇલની ટોચ પર \code{package com.utils;} ઉમેરો.
    \item \textbf{Compile}: ફોલ્ડર્સ આપમેળે જનરેટ કરવા માટે \code{-d .} સાથે કમ્પાઇલ કરો.
    \item \textbf{Import}: બીજી ફાઇલમાં \code{import com.utils.*;} વાપરો.
\end{enumerate}

\begin{lstlisting}[language=Java,caption={Package બનાવવું}]
// File: src/com/company/utils/MathUtils.java
package com.company.utils;

public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,caption={Package વાપરવું}]
// File: src/Calculator.java
import com.company.utils.MathUtils;

public class Calculator {
    public static void main(String[] args) {
        int result = MathUtils.add(5, 10);
        System.out.println("Result: " + result);
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{Compiling અને Running}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ક્રિયા} & \textbf{આદેશ} \\ \hline
Compile Package & \code{javac -d . MathUtils.java} \\ \hline
Compile Main & \code{javac Calculator.java} \\ \hline
Run & \code{java Calculator} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ONAM - Organization, Namespace, Access, Maintenance}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Explain thread priorities with suitable example.}

\begin{solutionbox}
\textbf{Thread Priority}: Java threads માં 1 થી 10 સુધીની પ્રાધાન્યતા (priority) કિંમતો હોય છે જે Thread Scheduler ને કયું થ્રેડ એક્ઝિક્યુટ કરવું તે નક્કી કરવામાં મદદ કરે છે.

\begin{center}
\captionof{table}{Priority Constants}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{સ્તર} & \textbf{Constant} & \textbf{કિંમત} \\ \hline
Min & \code{Thread.MIN\_PRIORITY} & 1 \\ \hline
Norm & \code{Thread.NORM\_PRIORITY} & 5 (Default) \\ \hline
Max & \code{Thread.MAX\_PRIORITY} & 10 \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Thread Priority}]
class MyThread extends Thread {
    public void run() {
        System.out.println("Running: " + getName());
    }
}

public class PriorityDemo {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        t1.setPriority(Thread.MAX_PRIORITY); // 10
        t2.setPriority(Thread.MIN_PRIORITY); // 1
        
        t1.start(); 
        t2.start();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{HNG - Higher priority, Not Guaranteed}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{What is Thread? Explain Thread life cycle.}

\begin{solutionbox}
\textbf{Thread}: એક હળવા વજનની subprocess જે અન્ય threads સાથે સમાંતર (concurrently) ચાલે છે.

\textbf{Thread Life Cycle}: થ્રેડ તેના જીવનકાળ દરમિયાન વિવિધ અવસ્થાઓમાંથી પસાર થાય છે.

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto, >=stealth]
    \node [gtu state] (new) {NEW};
    \node [gtu state, right=of new] (runnable) {RUNNABLE};
    \node [gtu state, right=of runnable] (running) {RUNNING};
    \node [gtu state, right=of running] (term) {TERMINATED};
    \node [gtu state, below=of running] (blocked) {BLOCKED/WAITING};
    
    \draw [->, thick] (new) -- node[above] {\small start()} (runnable);
    \draw [->, thick] (runnable) -- node[above] {\small Scheduler} (running);
    \draw [->, thick] (running) -- node[above] {\small End} (term);
    \draw [->, thick] (running) -- node[right] {\small sleep/wait} (blocked);
    \draw [->, thick] (blocked) -| node[below, near start] {\small notify/time} (runnable);
\end{tikzpicture}
\captionof{figure}{Thread Life Cycle}
\end{center}

\begin{center}
\captionof{table}{Thread અવસ્થાઓ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{અવસ્થા} & \textbf{વર્ણન} \\ \hline
NEW & Instance બન્યું છે, \code{start()} કૉલ નથી થયું \\ \hline
RUNNABLE & ચાલવા માટે તૈયાર, CPU ની રાહ જુએ છે \\ \hline
RUNNING & હાલમાં એક્ઝિક્યુટ થઈ રહ્યું છે \\ \hline
BLOCKED & સંસાધન માટે રાહ જુએ છે \\ \hline
TERMINATED & એક્ઝિક્યુશન પૂર્ણ થયું \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NRBT - New, Runnable, Blocked, Terminated}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Write a program in java that create the multiple threads by implementing the Thread class.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Multiple Threads}]
class NumberPrinter extends Thread {
    String name;
    
    NumberPrinter(String name) {
        this.name = name;
    }
    
    public void run() {
        for(int i=1; i<=3; i++) {
            System.out.println(name + ": " + i);
            try { 
                Thread.sleep(500); // Pause
            } catch(Exception e) {}
        }
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        NumberPrinter t1 = new NumberPrinter("Thread-1");
        NumberPrinter t2 = new NumberPrinter("Thread-2");
        NumberPrinter t3 = new NumberPrinter("Thread-3");
        
        t1.start();
        t2.start();
        t3.start();
        
        System.out.println("Main finished");
    }
}
\end{lstlisting}

\textbf{પગલાં}:
\begin{enumerate}
    \item \code{Thread} class ને extend કરો.
    \item Logic સાથે \code{run()} method override કરો.
    \item Class ના instances બનાવો.
    \item એક્ઝિક્યુશન શરૂ કરવા માટે \code{start()} કૉલ કરો.
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EOCS - Extend, Override, Create, Start}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{Explain basic concept of Exception Handling.}

\begin{solutionbox}
\textbf{Exception Handling}: Runtime errors સંભાળવા માટેની પદ્ધતિ જેથી એપ્લિકેશનનો સામાન્ય પ્રવાહ જળવાઈ રહે.

\begin{center}
\captionof{table}{મુખ્ય શબ્દો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Keyword} & \textbf{કાર્ય} \\ \hline
try & શંકાસ્પદ કોડનો બ્લોક \\ \hline
catch & Exception સંભાળતો બ્લોક \\ \hline
finally & પરિણામ ગમે તે હોય, એક્ઝિક્યુટ થાય \\ \hline
throw & સ્પષ્ટ રીતે exception ફેંકવા માટે \\ \hline
throws & મેથડ કયા exceptions ફેંકી શકે છે તે જાહેર કરે છે \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Exception Syntax}]
try {
    // Risky code
} catch (Exception e) {
    // Handling code
} finally {
    // Cleanup
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TRCF - Try, Runtime error, Catch, Finally}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Explain multiple catch with suitable example.}

\begin{solutionbox}
\textbf{Multiple Catch Blocks}: એક \code{try} બ્લોક પછી અનેક \code{catch} બ્લોક હોઈ શકે છે જેથી વિવિધ પ્રકારના exceptions અલગ રીતે સંભાળી શકાય.

\begin{lstlisting}[language=Java,caption={Multiple Catch}]
public class MultiCatch {
    public static void main(String[] args) {
        try {
            int a[] = new int[5];
            a[10] = 30 / 0; // Risky code
        } catch (ArithmeticException e) {
            System.out.println("Math Error: " + e);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array Error: " + e);
        } catch (Exception e) {
            // Generic catch છેલ્લે હોવો જોઈએ
            System.out.println("General Error: " + e);
        }
    }
}
\end{lstlisting}

\textbf{નિયમો}:
\begin{itemize}
    \item એક સમયે માત્ર એક જ exception થાય છે અને માત્ર એક જ catch બ્લોક એક્ઝિક્યુટ થાય છે.
    \item ચોક્કસ exceptions સામાન્ય exceptions (\code{Exception} parent class) પહેલાં પકડવા જોઈએ.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SOOF - Specific first, One executes, Order matters, Finally}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{What is Exception? Write a program that show the use of Arithmetic Exception.}

\begin{solutionbox}
\textbf{Exception}: પ્રોગ્રામના એક્ઝિક્યુશન દરમિયાન (runtime) થતી અનિચ્છનીય અથવા અણધારી ઘટના જે સૂચનાઓના સામાન્ય પ્રવાહને વિક્ષેપિત કરે છે.

\textbf{ArithmeticException}: જ્યારે અસાધારણ અંકગણિત સ્થિતિ થાય છે, જેમ કે શૂન્ય વડે ભાગાકાર (division by zero), ત્યારે ફેંકવામાં આવતું runtime exception.

\begin{lstlisting}[language=Java,caption={Arithmetic Exception Demo}]
public class DivisionDemo {
    public static void main(String[] args) {
        try {
            int numerator = 100;
            int denominator = 0; // Division by zero
            
            // This line throws ArithmeticException
            int result = numerator / denominator;
            
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.out.println("Error detected: Division by zero is not allowed.");
            System.out.println("Exception: " + e.getMessage());
        } finally {
            System.out.println("Cleanup actions...");
        }
    }
}
\end{lstlisting}
Try-catch બ્લોક વગર, પ્રોગ્રામ ભાગાકારના સમયે જ ક્રેશ થઈ જશે.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DZMI - Division by Zero, Mathematical Invalid}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{Explain ArrayIndexOutOfBound Exception in Java with example.}

\begin{solutionbox}
\textbf{ArrayIndexOutOfBoundsException}: જ્યારે એરે (array) ને ગેરકાયદેસર index સાથે access કરવામાં આવે ત્યારે ફેંકવામાં આવતું runtime exception. Index નેગેટિવ હોઈ શકે અથવા એરેના કદ કરતાં મોટો કે બરાબર હોઈ શકે.

\begin{center}
\captionof{table}{કારણો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{કારણ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
Negative Index & Index $< 0$ & a[-1] \\ \hline
Size Exceeded & Index $\ge$ Length & a[length] \\ \hline
Empty Array & ખાલી એરેનો index 0 & a[0] \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Array Index Exception}]
int[] numbers = {10, 20, 30}; // Size 3, indices 0-2
try {
    System.out.println(numbers[5]); // Index 5 અમાન્ય છે
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Invalid Index: " + e.getMessage());
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NIE - Negative, Index-exceed, Empty}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Explain basics of stream classes.}

\begin{solutionbox}
\textbf{Stream Classes}: Stream એ ડેટાનો ક્રમ છે. Java I/O streams પર આધારિત છે.

\begin{center}
\begin{tikzpicture}[node distance=1cm, level 1/.style={sibling distance=5cm}, level 2/.style={sibling distance=2.5cm}]
    \node [gtu block] {Java I/O}
        child {node [gtu block] {Byte Stream}
            child {node [gtu block] {InputStream}}
            child {node [gtu block] {OutputStream}}
        }
        child {node [gtu block] {Character Stream}
            child {node [gtu block] {Reader}}
            child {node [gtu block] {Writer}}
        };
\end{tikzpicture}
\captionof{figure}{Stream Hierarchy}
\end{center}

\begin{center}
\captionof{table}{Stream શ્રેણીઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Stream Type} & \textbf{Data Type} & \textbf{Classes} \\ \hline
Byte Stream & Binary Data (Images, etc) & InputStream, OutputStream \\ \hline
Char Stream & Text Data (Strings) & Reader, Writer \\ \hline
\end{tabulary}
\end{center}

\textbf{Subclasses}:
\begin{itemize}
    \item \textbf{File}: FileInputStream, FileWriter, વગેરે.
    \item \textbf{Buffered}: BufferedReader, BufferedOutputStream (કાર્યક્ષમતા માટે).
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BCIF - Byte, Character, Input/Output, File}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Write a java program to create a text file and perform write operation on the text file.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Write to File}]
import java.io.FileWriter;
import java.io.IOException;

public class FileWriteDemo {
    public static void main(String[] args) {
        String data = "Welcome to Summer 2024 Solution.";
        
        // Try-with-resources આપમેળે writer બંધ કરે છે
        try (FileWriter writer = new FileWriter("output.txt")) {
            
            writer.write(data);
            
            System.out.println("Successfully wrote to the file.");
            
        } catch (IOException e) {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
\end{lstlisting}

\textbf{સમજૂતી}:
\begin{enumerate}
    \item \textbf{Import}: \code{java.io.FileWriter} અને \code{IOException}.
    \item \textbf{FileWriter}: File writer object બનાવે છે.
    \item \textbf{write()}: સ્ટ્રિંગ ડેટા ફાઇલમાં લખે છે.
    \item \textbf{close()}: આપમેળે થાય છે, ડેટા સેવ કરે છે અને સંસાધનો મુક્ત કરે છે.
\end{enumerate}

\begin{center}
\captionof{table}{વપરાયેલ Methods}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Method} & \textbf{વર્ણન} \\ \hline
FileWriter(String) & નવી ફાઇલ બનાવે છે (overwrite કરે છે) \\ \hline
write(String) & ટેક્સ્ટ લખે છે \\ \hline
close() & Stream બંધ કરે છે \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CWCH - Create, Write, Close, Handle}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{Explain Divide by Zero Exception in Java with example.}

\begin{solutionbox}
\textbf{Divide by Zero}: પૂર્ણાંક (integer) ને શૂન્ય વડે ભાગવાનો પ્રયાસ કરવો એ Java માં ગેરકાયદેસર ક્રિયા છે.

\begin{center}
\captionof{table}{વર્તન}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Case} & \textbf{પરિણામ} & \textbf{Exception} \\ \hline
Integer / 0 & અમાન્ય & ArithmeticException \\ \hline
Float / 0.0 & Infinity & None \\ \hline
Modulo \% 0 & અમાન્ય & ArithmeticException \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Divide By Zero}]
try {
    int a = 10 / 0; // Throws Exception
} catch (ArithmeticException e) {
    System.out.println("Cannot divide integer by zero");
}

double b = 10.0 / 0.0;
System.out.println(b); // Prints "Infinity"
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{IFM - Integer exception, Float infinity, Modulo error}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{Explain try and catch block with example.}

\begin{solutionbox}
\textbf{Try-Catch}: Exception handling માટેની મુખ્ય પદ્ધતિ.

\begin{itemize}
    \item \textbf{try}: કોડ જે exception ઉત્પન્ન કરી શકે છે તેને ઘેરે છે.
    \item \textbf{catch}: Exception ને કેવી રીતે સંભાળવું તે નક્કી કરે છે.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Try-Catch Example}]
public class Example {
    public static void main(String args[]) {
        try {
            String s = null;
            System.out.println(s.length()); // NullPointer
        } catch(NullPointerException e) {
            System.out.println("Caught Null Pointer Exception");
        }
        
        System.out.println("Rest of the code...");
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{પ્રવાહ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પરિસ્થિતિ} & \textbf{Execution પથ} \\ \hline
No Exception & try ચાલે છે -> catch છોડવામાં આવે છે \\ \hline
Exception & try અટકે છે -> catch ચાલે છે -> આગળ વધે છે \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TCF - Try risky, Catch exception, Finally cleanup}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{Write a java program to display the content of a text file and perform append operation on the text file.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Read and Append}]
import java.io.*;

public class FileReadAppend {
    public static void main(String[] args) {
        String filename = "log.txt";
        
        // 1. Append ક્રિયા
        try (FileWriter fw = new FileWriter(filename, true);
             BufferedWriter bw = new BufferedWriter(fw)) {
            
            bw.write("New Log Entry\n");
            System.out.println("Appended to file.");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 2. Read ક્રિયા
        System.out.println("--- Reading File ---");
        try (FileReader fr = new FileReader(filename);
             BufferedReader br = new BufferedReader(fr)) {
            
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}

\textbf{મુખ્ય ખ્યાલો}:
\begin{itemize}
    \item \textbf{Append Mode}: \code{new FileWriter(file, true)} ફાઇલને append mode માં ખોલે છે.
    \item \textbf{BufferedReader}: લાઇન બાય લાઇન વાંચન માટે કાર્યક્ષમ છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CDADS - Create, Display, Append, Display, Statistics}
\end{mnemonicbox}

\end{document}


