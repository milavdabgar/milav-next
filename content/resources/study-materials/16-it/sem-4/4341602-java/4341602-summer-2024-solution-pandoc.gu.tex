\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4341602 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{Java program નો બેસિક સ્ટ્રક્ચર સમજાવો.}

\begin{solutionbox}

\textbf{મૂળભૂત માળખું કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઘટક & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Package declaration} & વૈકલ્પિક, package સભ્યપદ દર્શાવે છે \\
\textbf{Import statements} & જરૂરી classes/packages આયાત કરે છે \\
\textbf{Class declaration} & મુખ્ય class વ્યાખ્યા \\
\textbf{Main method} & પ્રવેશ બિંદુ: public static void main(String[]
args) \\
\end{longtable}
}

\textbf{આકૃતિ:}

\begin{verbatim}
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
|    Package Declaration  |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
|    Import Statements    |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
|    Class Declaration    |
|  +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |}
|  |   Variables       |  |
|  +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |}
|  |   Methods         |  |
|  |  +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |  |}
|  |  | main method |  |  |
|  |  +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |  |}
|  +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |}
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Package}: સંબંધિત classes ને જૂથબદ્ધ કરે છે
\item
  \textbf{Import}: બાહ્ય classes ને access કરે છે
\item
  \textbf{Class}: objects માટે blueprint
\item
  \textbf{Main method}: પ્રોગ્રામ execution અહીંથી શરૂ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PICM - Package, Import, Class, Main''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{જાવાના વિવિધ લક્ષણોની યાદી આપો. કોઈપણ બે લક્ષણો સમજાવો.}

\begin{solutionbox}

\textbf{Java ના લક્ષણો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
લક્ષણ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Platform Independent} & એક વાર લખો, બધે ચલાવો \\
\textbf{Object Oriented} & બધું object છે \\
\textbf{Simple} & સરળ syntax, pointers નથી \\
\textbf{Secure} & built-in સુરક્ષા લક્ષણો \\
\textbf{Robust} & મજબૂત memory management \\
\textbf{Multithreaded} & concurrent execution આધાર \\
\end{longtable}
}

\textbf{વિગતવાર સમજાવટ:}

\textbf{Platform Independence:}

\begin{itemize}
\tightlist
\item
  Java કોડ bytecode માં compile થાય છે
\item
  JVM કોઈપણ platform પર bytecode interpret કરે છે
\item
  એ જ પ્રોગ્રામ Windows, Linux, Mac પર ચાલે છે
\end{itemize}

\textbf{Object Oriented:}

\begin{itemize}
\tightlist
\item
  Encapsulation: classes માં data hiding
\item
  Inheritance: extends દ્વારા કોડ પુનઃઉપયોગ
\item
  Polymorphism: એક જ method, અલગ વર્તન
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``POSRMM - Platform, Object, Simple, Robust,
Multithreaded, Memory''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{દાખલ કરેલ નંબરના અંકોનો સરવાળો શોધવા માટે Java માં પ્રોગ્રામ લખો. (ઉદા.
સંખ્યા 123 આઉટપુટ 6 છે).}

\begin{solutionbox}

\begin{verbatim}
public class DigitSum \{
    public static void main(String[] args) \{
        int number = Integer.parseInt(args[0]);
        int sum = 0;
        int temp = Math.abs(number);
        
        while (temp {} 0) \{
            sum += temp \% 10;
            temp /= 10;
        \}
        
        System.out.println("અંકોનો સરવાળો: " + sum);
    \}
\}
\end{verbatim}

\textbf{Algorithm કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & ઉદાહરણ (123) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & છેલ્લો અંક કાઢો (n\%10) & 123\%10 = 3 \\
2 & સરવાળામાં ઉમેરો & sum = 0+3 = 3 \\
3 & છેલ્લો અંક હટાવો (n/10) & 123/10 = 12 \\
4 & n=0 સુધી પુનરાવર્તન & ચાલુ રાખો \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Input}: Command line argument
\item
  \textbf{Process}: modulo વાપરીને અંકો કાઢો
\item
  \textbf{Output}: બધા અંકોનો સરવાળો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``EARD - Extract, Add, Remove, Done''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{Command line arguments નો ઉપયોગ કરીને કોઈપણ દસ સંખ્યાઓ માંથી maximum
શોધવા માટે Java માં પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
public class FindMaximum \{
    public static void main(String[] args) \{
        if (args.length {} 10) \{
            System.out.println("કૃપા કરીને 10 સંખ્યાઓ દાખલ કરો");
            return;
        \}
        
        int max = Integer.parseInt(args[0]);
        
        for (int i = 1; i {} 10; i++) \{
            int current = Integer.parseInt(args[i]);
            if (current {} max) \{
                max = current;
            \}
        \}
        
        System.out.println("મહત્તમ સંખ્યા: " + max);
    \}
\}
\end{verbatim}

\textbf{પ્રક્રિયા કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & વિગતો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & \textbf{args તપાસો} & 10 સંખ્યાઓ આપેલી છે કે કેમ \\
2 & \textbf{Max initialize કરો} & પહેલી સંખ્યાને initial max બનાવો \\
3 & \textbf{Compare loop} & બાકીની દરેક સંખ્યા તપાસો \\
4 & \textbf{Max update કરો} & જો current \textgreater{} max, તો update
કરો \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Validation}: argument count ચકાસો
\item
  \textbf{Comparison}: સામાન્ય maximum શોધવાની પદ્ધતિ
\item
  \textbf{Output}: સૌથી મોટી સંખ્યા દર્શાવો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``VCIU - Validate, Compare, Initialize, Update''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{OOP ના Basic concept ની યાદી આપો. કોઈપણ એક વિગતવાર સમજાવો.}

\begin{solutionbox}

\textbf{OOP ની વિભાવનાઓ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિભાવના & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Encapsulation} & ડેટા છુપાવવું અને બાંધવું \\
\textbf{Inheritance} & પિતૃ class થી કોડ પુનઃઉપયોગ \\
\textbf{Polymorphism} & એક interface, અનેક સ્વરૂપ \\
\textbf{Abstraction} & Implementation વિગતો છુપાવવી \\
\end{longtable}
}

\textbf{Encapsulation વિગતો:}

\begin{itemize}
\tightlist
\item
  ડેટા અને methods ને એક unit માં જોડે છે
\item
  ડેટા માટે private access modifiers વાપરે છે
\item
  Public getter/setter methods પ્રદાન કરે છે
\item
  અનધિકૃત access થી ડેટાને સુરક્ષિત કરે છે
\end{itemize}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{સુરક્ષા}: ડેટા સુરક્ષા
\item
  \textbf{જાળવણી}: કોડ updates સરળ
\item
  \textbf{લવચીકતા}: Implementation સરળતાથી બદલી શકાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``EIPA - Encapsulation, Inheritance, Polymorphism,
Abstraction''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{JVM ને વિગતવાર સમજાવો.}

\begin{solutionbox}

\textbf{JVM આર્કિટેક્ચર આકૃતિ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Java Source Code] {-{-}{} B[Java Compiler javac]}
    B {-{-}{} C[Bytecode .class]}
    C {-{-}{} D[JVM]}
    D {-{-}{} E[Class Loader]}
    D {-{-}{} F[Memory Areas]}
    D {-{-}{} G[Execution Engine]}
    G {-{-}{} H[Native OS]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{JVM ઘટકો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઘટક & કાર્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Class Loader} & .class files ને memory માં લોડ કરે છે \\
\textbf{Memory Areas} & Heap, Stack, Method area \\
\textbf{Execution Engine} & Bytecode execute કરે છે \\
\textbf{JIT Compiler} & વારંવાર વપરાતા કોડને optimize કરે છે \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Platform Independence}: એ જ bytecode બધે ચાલે છે
\item
  \textbf{Memory Management}: automatic garbage collection
\item
  \textbf{સુરક્ષા}: execution પહેલાં bytecode verification
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CEMJ - Class loader, Execution, Memory, JIT''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{Constructor overloading ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
public class Student \{
    private String name;
    private int age;
    private String course;
    
    // Default constructor
    public Student() \{
        this.name = "અજ્ઞાત";
        this.age = 0;
        this.course = "ફાળવેલ નથી";
    \}
    
    // Constructor with name
    public Student(String name) \{
        this.name = name;
        this.age = 0;
        this.course = "ફાળવેલ નથી";
    \}
    
    // Constructor with name and age
    public Student(String name, int age) \{
        this.name = name;
        this.age = age;
        this.course = "ફાળવેલ નથી";
    \}
    
    // Constructor with all parameters
    public Student(String name, int age, String course) \{
        this.name = name;
        this.age = age;
        this.course = course;
    \}
\}
\end{verbatim}

\textbf{Constructor પ્રકારો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Constructor & Parameters & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default} & કોઈ નહિ & મૂળભૂત object બનાવટ \\
\textbf{Single param} & માત્ર નામ & આંશિક initialization \\
\textbf{Two param} & નામ, ઉંમર & વધુ નિર્દિષ્ટ ડેટા \\
\textbf{Full param} & બધા fields & સંપૂર્ણ initialization \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{એ જ નામ}: બધા constructors ને class નામ છે
\item
  \textbf{અલગ parameters}: સંખ્યા અથવા પ્રકાર અલગ છે
\item
  \textbf{Compile-time}: compilation દરમિયાન નિર્ણય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SNDF - Same Name, Different Parameters, Flexible''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{Wrapper class શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Wrapper Classes કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Primitive & Wrapper Class \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{byte} & Byte \\
\textbf{int} & Integer \\
\textbf{float} & Float \\
\textbf{double} & Double \\
\textbf{char} & Character \\
\textbf{boolean} & Boolean \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
// Boxing {- primitive to object}
int num = 10;
Integer obj = Integer.valueOf(num);

// Unboxing {- object to primitive}
Integer wrapper = new Integer(20);
int value = wrapper.intValue();

// Auto{-boxing (Java 5+)}
Integer auto = 30;
int autoValue = auto;
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Boxing}: primitive ને wrapper object માં convert કરવું
\item
  \textbf{Unboxing}: wrapper માંથી primitive કાઢવું
\item
  \textbf{Collections}: collections માં માત્ર objects જ સ્વીકાર્ય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BUC - Boxing, Unboxing, Collections''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{Static કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
public class Counter \{
    private static int count = 0;  // Static variable
    private int id;                // Instance variable
    
    public Counter() \{
        count++;                   // Static count વધારો
        this.id = count;
    \}
    
    public static void showCount() \{  // Static method
        System.out.println("કુલ objects: " + count);
    \}
    
    public void showId() \{         // Instance method
        System.out.println("Object ID: " + id);
    \}
\}
\end{verbatim}

\textbf{Static લક્ષણો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
લક્ષણ & લાક્ષણિકતાઓ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Static Variable} & બધા instances વચ્ચે શેર થાય છે \\
\textbf{Static Method} & Object બનાવ્યા વિના કૉલ કરી શકાય \\
\textbf{Static Block} & Class લોડ થાય ત્યારે એક વાર execute થાય \\
\textbf{Memory} & Method area માં સંગ્રહિત \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Class level}: instance નહિ, class નું છે
\item
  \textbf{Memory efficiency}: બધા objects માટે એક જ copy
\item
  \textbf{Access}: class નામ વાપરીને access કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SCMA - Shared, Class-level, Memory, Access''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{Constructor શું છે? Copy constructor ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Constructor વ્યાખ્યા:} Constructor એ એક વિશેષ method છે જે objects
બનાવાયા ત્યારે તેમને initialize કરે છે.

\begin{verbatim}
public class Book \{
    private String title;
    private String author;
    private int pages;
    
    // Default constructor
    public Book() \{
        this.title = "અજ્ઞાત";
        this.author = "અજ્ઞાત";
        this.pages = 0;
    \}
    
    // Parameterized constructor
    public Book(String title, String author, int pages) \{
        this.title = title;
        this.author = author;
        this.pages = pages;
    \}
    
    // Copy constructor
    public Book(Book other) \{
        this.title = other.title;
        this.author = other.author;
        this.pages = other.pages;
    \}
    
    public void display() \{
        System.out.println(title + " લેખક " + author + 
                          " (" + pages + " પાનાં)");
    \}
\}

// ઉપયોગ
Book original = new Book("Java ગાઇડ", "જેમ્સ", 500);
Book copy = new Book(original);  // Copy constructor
\end{verbatim}

\textbf{Constructor પ્રકારો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & હેતુ & Parameters \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default} & મૂળભૂત initialization & કોઈ નહિ \\
\textbf{Parameterized} & કસ્ટમ initialization & User-defined \\
\textbf{Copy} & હાલના object ની નકલ & Same class object \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{એ જ નામ}: Constructor નામ = class નામ
\item
  \textbf{કોઈ return type નહિ}: void પણ નહિ
\item
  \textbf{Automatic કૉલ}: Object બનાવાય ત્યારે કૉલ થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SNAC - Same Name, Automatic Call''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{Java માં કોઈપણ ચાર string functions ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{String Functions કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Function & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{length()} & String ની લંબાઈ આપે છે & ``Hello''.length() \rightarrow 5 \\
\textbf{charAt(index)} & સ્થાને character & ``Java''.charAt(1) \rightarrow `a' \\
\textbf{substring(start)} & ભાગ કાઢે છે & ``Program''.substring(3) \rightarrow
``gram'' \\
\textbf{toUpperCase()} & મોટા અક્ષરોમાં & ``java''.toUpperCase() \rightarrow
``JAVA'' \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
String str = "Java Programming";

int len = str.length();           // 16
char ch = str.charAt(0);          // {J}
String sub = str.substring(5);    // "Programming"
String upper = str.toUpperCase(); // "JAVA PROGRAMMING"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Immutable}: String objects બદલાતા નથી
\item
  \textbf{નવું return}: Methods નવા string objects return કરે છે
\item
  \textbf{Zero-indexed}: સ્થાનની ગણતરી 0 થી શરૂ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``LCST - Length, Character, Substring, Transform''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{Inheritance ના વિવિધ પ્રકારોની યાદી આપો. Multilevel inheritance
સમજાવો.}

\begin{solutionbox}

\textbf{Inheritance પ્રકારો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Single} & એક parent, એક child \\
\textbf{Multilevel} & Inheritance ની શૃંખલા \\
\textbf{Hierarchical} & એક parent, અનેક children \\
\textbf{Multiple} & અનેક parents (interfaces દ્વારા) \\
\end{longtable}
}

\textbf{Multilevel Inheritance આકૃતિ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Vehicle] {-{-}{} B[Car]}
    B {-{-}{} C[SportsCar]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{ઉદાહરણ:}

\begin{verbatim}
class Vehicle \{
    protected String brand;
    public void start() \{
        System.out.println("વાહન ચાલુ થયું");
    \}
\}

class Car extends Vehicle \{
    protected int doors;
    public void drive() \{
        System.out.println("કાર ચાલી રહી છે");
    \}
\}

class SportsCar extends Car \{
    private int maxSpeed;
    public void race() \{
        System.out.println("સ્પોર્ટ્સ કાર રેસિંગ");
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Chain inheritance}: પિતામહ \rightarrow પિતા \rightarrow બાળક
\item
  \textbf{લક્ષણો સંચય}: બાળકને બધા પૂર્વજોના લક્ષણો મળે છે
\item
  \textbf{Method access}: બધા levels ના methods કૉલ કરી શકાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SMHM - Single, Multilevel, Hierarchical,
Multiple''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{Interface શું છે? ઉદાહરણ સાથે multiple inheritance સમજાવો.}

\begin{solutionbox}

\textbf{Interface વ્યાખ્યા:} Interface એ એક કરાર છે જે define કરે છે કે class
માં કયા methods હોવા જોઈએ, implementation આપ્યા વિના.

\begin{verbatim}
interface Flyable \{
    void fly();
    void land();
\}

interface Swimmable \{
    void swim();
    void dive();
\}

// Interfaces દ્વારા multiple inheritance
class Duck implements Flyable, Swimmable \{
    public void fly() \{
        System.out.println("બતક ઉડી રહી છે");
    \}
    
    public void land() \{
        System.out.println("બતક જમીન પર ઉતરી");
    \}
    
    public void swim() \{
        System.out.println("બતક તરી રહી છે");
    \}
    
    public void dive() \{
        System.out.println("બતક પાણીમાં ડૂબી");
    \}
\}
\end{verbatim}

\textbf{Interface vs Class કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & Interface & Class \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Methods} & Abstract (default/static મંજૂર) & Concrete \\
\textbf{Variables} & public static final & કોઈપણ પ્રકાર \\
\textbf{Inheritance} & Multiple મંજૂર & માત્ર Single \\
\textbf{Instantiation} & Objects બનાવી શકાતા નથી & Objects બનાવી શકાય \\
\end{longtable}
}

\textbf{Multiple Inheritance આકૃતિ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[Flyable] {-{-}{} C[Duck]}
    B[Swimmable] {-{-}{} C[Duck]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\begin{itemize}
\tightlist
\item
  \textbf{કરાર}: શું કરવું તે define કરે, કેવી રીતે નહિ
\item
  \textbf{Multiple implementation}: એક class, ઘણા interfaces
\item
  \textbf{Diamond problem ઉકેલ}: Interfaces multiple inheritance ની સમસ્યા
  હલ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CMDS - Contract, Multiple, Diamond-solution''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{This કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{`this' કીવર્ડ ઉપયોગો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઉપયોગ & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Instance variable} & Parameter થી અલગ પાડવા \\
\textbf{Method call} & એ જ class ની બીજી method કૉલ કરવા \\
\textbf{Constructor call} & બીજા constructor ને કૉલ કરવા \\
\textbf{Return object} & વર્તમાન object reference return કરવા \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
public class Person \{
    private String name;
    private int age;
    
    public Person(String name, int age) \{
        this.name = name;  // Parameter અને field વચ્ચે ફરક
        this.age = age;
    \}
    
    public Person setName(String name) \{
        this.name = name;
        return this;       // વર્તમાન object return કરો
    \}
    
    public void display() \{
        this.printDetails(); // એ જ class ની method કૉલ કરો
    \}
    
    private void printDetails() \{
        System.out.println(this.name + " ની ઉંમર " + this.age);
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{વર્તમાન object}: વર્તમાન instance ને refer કરે છે
\item
  \textbf{Parameter conflict}: નામની અસમંજસ હલ કરે છે
\item
  \textbf{Method chaining}: fluent interface સક્ષમ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CRPM - Current, Resolve, Parameter, Method''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{Method overriding ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
class Animal \{
    public void makeSound() \{
        System.out.println("પ્રાણી અવાજ કરે છે");
    \}
    
    public void sleep() \{
        System.out.println("પ્રાણી સૂઈ જાય છે");
    \}
\}

class Dog extends Animal \{
    @Override
    public void makeSound() \{  // Method overriding
        System.out.println("કૂતરો ભસે છે: ભો ભો!");
    \}
    
    // sleep() method જેમ છે તેમ inherit થાય છે
\}

class Cat extends Animal \{
    @Override
    public void makeSound() \{  // Method overriding
        System.out.println("બિલાડી બોલે છે: મ્યાઉં!");
    \}
\}
\end{verbatim}

\textbf{Overriding નિયમો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
નિયમ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Same signature} & Method નામ, parameters મેળ ખાવા જોઈએ \\
\textbf{Inheritance} & Parent-child સંબંધ હોવો જોઈએ \\
\textbf{@Override} & Compiler checking માટે annotation \\
\textbf{Runtime decision} & Object type પ્રમાણે method કૉલ \\
\end{longtable}
}

\textbf{ઉપયોગ:}

\begin{verbatim}
Animal animal1 = new Dog();
Animal animal2 = new Cat();

animal1.makeSound(); // આઉટપુટ: "કૂતરો ભસે છે: ભો ભો!"
animal2.makeSound(); // આઉટપુટ: "બિલાડી બોલે છે: મ્યાઉં!"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Runtime polymorphism}: Execution દરમિયાન નિર્ણય
\item
  \textbf{Same interface}: અલગ classes માટે અલગ વર્તન
\item
  \textbf{Dynamic binding}: Runtime પર method resolution
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SSRD - Same Signature, Runtime Decision''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{Package શું છે? Package બનાવવાના પગલાં લખો અને તેનું ઉદાહરણ આપો.}

\begin{solutionbox}

\textbf{Package વ્યાખ્યા:} Package એ namespace છે જે સંબંધિત classes અને
interfaces ને organize કરે છે, access control પ્રદાન કરે છે અને naming
conflicts ટાળે છે.

\textbf{Package બનાવવાના પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & Command/Code \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & \textbf{Directory બનાવો} & mkdir com/company/utils \\
2 & \textbf{Package declaration ઉમેરો} & package com.company.utils; \\
3 & \textbf{Class લખો} & public class MathUtils \{ \} \\
4 & \textbf{Compile કરો} & javac -d . MathUtils.java \\
5 & \textbf{Import અને ઉપયોગ} & import com.company.utils.*; \\
\end{longtable}
}

\textbf{Package Structure ઉદાહરણ:}

\begin{verbatim}
src/
  com/
    company/
      utils/
        MathUtils.java
        StringUtils.java
      models/
        Student.java
\end{verbatim}

\textbf{MathUtils.java:}

\begin{verbatim}
package com.company.utils;

public class MathUtils \{
    public static int add(int a, int b) \{
        return a + b;
    \}
    
    public static int multiply(int a, int b) \{
        return a * b;
    \}
\}
\end{verbatim}

\textbf{Package ઉપયોગ:}

\begin{verbatim}
import com.company.utils.MathUtils;

public class Calculator \{
    public static void main(String[] args) \{
        int sum = MathUtils.add(5, 3);
        int product = MathUtils.multiply(4, 6);
        
        System.out.println("સરવાળો: " + sum);
        System.out.println("ગુણાકાર: " + product);
    \}
\}
\end{verbatim}

\textbf{Package ફાયદાઓ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફાયદો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સંગઠન} & Classes નું તાર્કિક જૂથીકરણ \\
\textbf{Namespace} & નામની અસમંજસ ટાળે છે \\
\textbf{Access control} & Package-private access \\
\textbf{જાળવણી} & કોડની સરળ management \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ONAM - Organization, Namespace, Access,
Maintenance''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે thread ની પ્રાથમિકતાઓ સમજાવો.}

\begin{solutionbox}

\textbf{Thread Priority કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રાથમિકતા સ્તર & Constant & મૂલ્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ન્યૂનતમ} & MIN\_PRIORITY & 1 \\
\textbf{સામાન્ય} & NORM\_PRIORITY & 5 \\
\textbf{મહત્તમ} & MAX\_PRIORITY & 10 \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
class PriorityDemo extends Thread \{
    public PriorityDemo(String name) \{
        super(name);
    \}
    
    public void run() \{
for (int

i = 1; i {=} 5; i++) \{

            System.out.println(getName() + " {- ગણતરી: "} + i);
        \}
    \}
\}

public class ThreadPriorityExample \{
    public static void main(String[] args) \{
        PriorityDemo t1 = new PriorityDemo("ઉચ્ચ પ્રાથમિકતા");
        PriorityDemo t2 = new PriorityDemo("નીચી પ્રાથમિકતા");
        
        t1.setPriority(Thread.MAX\_PRIORITY);  // પ્રાથમિકતા 10
        t2.setPriority(Thread.MIN\_PRIORITY);  // પ્રાથમિકતા 1
        
        t1.start();
        t2.start();
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઉચ્ચી પ્રાથમિકતા}: CPU સમય મળવાની વધુ શક્યતા
\item
  \textbf{ગેરંટી નથી}: JVM ખરેખર scheduling નક્કી કરે છે
\item
  \textbf{Default priority}: દરેક thread NORM\_PRIORITY સાથે શરૂ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``HNG - Higher priority, Not Guaranteed''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{Thread શું છે? Thread જીવન ચક્ર સમજાવો.}

\begin{solutionbox}

\textbf{Thread વ્યાખ્યા:} Thread એ lightweight sub-process છે જે પ્રોગ્રામની
અંદર અનેક કાર્યોના concurrent execution ની પરવાનગી આપે છે.

\textbf{Thread Life Cycle આકૃતિ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[NEW] {-{-}{} B[RUNNABLE]}
    B {-{-}{} C[RUNNING]}
    C {-{-}{} D[BLOCKED/WAITING]}
    D {-{-}{} B}
    C {-{-}{} E[TERMINATED]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Thread સ્થિતિઓ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
સ્થિતિ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{NEW} & Thread બન્યો પણ શરૂ થયો નથી \\
\textbf{RUNNABLE} & ચાલવા તૈયાર, CPU માટે રાહ જોઈ રહ્યો \\
\textbf{RUNNING} & હાલમાં execute થઈ રહ્યો \\
\textbf{BLOCKED/WAITING} & Resource/condition માટે રાહ જોઈ રહ્યો \\
\textbf{TERMINATED} & Execution પૂર્ણ થયું \\
\end{longtable}
}

\textbf{સ્થિતિ પરિવર્તનો:}

\begin{itemize}
\item
  \textbf{NEW \rightarrow RUNNABLE}: start() method કૉલ થાય
\item
  \textbf{RUNNABLE \rightarrow RUNNING}: Thread scheduler CPU આપે
\item
  \textbf{RUNNING \rightarrow BLOCKED}: I/O અથવા lock માટે રાહ
\item
  \textbf{RUNNING \rightarrow TERMINATED}: run() method પૂર્ણ થાય
\item
  \textbf{Concurrent execution}: અનેક threads એકસાથે ચાલે છે
\item
  \textbf{JVM managed}: Thread scheduler execution control કરે છે
\item
  \textbf{Resource sharing}: Threads memory space શેર કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``NRBT - New, Runnable, Blocked, Terminated''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{Java માં એક પ્રોગ્રામ લખો જે Thread Class અમલ કરીને બહુવિધ threads
બનાવે છે.}

\begin{solutionbox}

\begin{verbatim}
class NumberPrinter extends Thread \{
    private String threadName;
    private int start;
    private int end;
    
    public NumberPrinter(String name, int start, int end) \{
        this.threadName = name;
        this.start = start;
        this.end = end;
    \}
    
    @Override
    public void run() \{
        System.out.println(threadName + " શરૂ થયો");
        
for (int

i = start; i {=} end; i++) \{

            System.out.println(threadName + ": " + i);
            
            try \{
                Thread.sleep(500); // 500ms માટે થોભો
            \} catch (InterruptedException e) \{
                System.out.println(threadName + " બંધ કરાયો");
            \}
        \}
        
        System.out.println(threadName + " પૂર્ણ થયો");
    \}
\}

public class MultipleThreadsExample \{
    public static void main(String[] args) \{
        // અનેક threads બનાવો
        NumberPrinter thread1 = new NumberPrinter("Thread{-1"}, 1, 5);
        NumberPrinter thread2 = new NumberPrinter("Thread{-2"}, 10, 15);
        NumberPrinter thread3 = new NumberPrinter("Thread{-3"}, 20, 25);
        
        // બધા threads શરૂ કરો
        thread1.start();
        thread2.start();
        thread3.start();
        
        System.out.println("Main થી બધા threads શરૂ થયા");
    \}
\}
\end{verbatim}

\textbf{Implementation પગલાં કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પગલું & ક્રિયા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & \textbf{Thread class extends કરો} \\
2 & \textbf{run() method override કરો} \\
3 & \textbf{Thread objects બનાવો} \\
4 & \textbf{start() method કૉલ કરો} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Extends Thread}: Threading capabilities inherit કરો
\item
  \textbf{Override run()}: Thread ની execution logic define કરો
\item
  \textbf{start() method}: Thread execution શરૂ કરો
\item
  \textbf{Concurrent execution}: બધા threads એકસાથે ચાલે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``EOCS - Extend, Override, Create, Start''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{Exception Handling ની મૂળભૂત વિભાવના સમજાવો.}

\begin{solutionbox}

\textbf{Exception Handling વિભાવનાઓ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિભાવના & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Exception} & Runtime error જે સામાન્ય flow ને ખલેલ પહોંચાડે \\
\textbf{try block} & કોડ જે exception ફેંકી શકે \\
\textbf{catch block} & વિશિષ્ટ exception પ્રકારો handle કરે \\
\textbf{finally block} & હંમેશા execute થાય, cleanup કોડ \\
\end{longtable}
}

\textbf{Exception Hierarchy:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Throwable] {-{-}{} B[Exception]}
    A {-{-}{} C[Error]}
    B {-{-}{} D[RuntimeException]}
    B {-{-}{} E[Checked Exceptions]}
    D {-{-}{} F[NullPointerException]}
    D {-{-}{} G[ArrayIndexOutOfBoundsException]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{મૂળભૂત Syntax:}

\begin{verbatim}
try \{
    // જોખમી કોડ
\} catch (ExceptionType e) \{
    // Exception handle કરો
\} finally \{
    // Cleanup કોડ
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Graceful handling}: Exception પછી પ્રોગ્રામ ચાલુ રહે છે
\item
  \textbf{Error prevention}: પ્રોગ્રામ crash ટાળે છે
\item
  \textbf{Resource cleanup}: Finally block cleanup ensure કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TRCF - Try, Runtime error, Catch, Finally''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે multiple catch સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
public class MultipleCatchExample \{
    public static void main(String[] args) \{
        try \{
            int[] numbers = \{10, 20, 30\;}
            int divisor = Integer.parseInt(args[0]);
            
            int result = numbers[5] / divisor;  // અનેક exceptions કારણ બની શકે
            System.out.println("પરિણામ: " + result);
            
        \} catch (ArrayIndexOutOfBoundsException e) \{
            System.out.println("Array index ભૂલ: " + e.getMessage());
            
        \} catch (ArithmeticException e) \{
            System.out.println("ગણિત ભૂલ: " + e.getMessage());
            
        \} catch (NumberFormatException e) \{
            System.out.println("Number format ભૂલ: " + e.getMessage());
            
        \} catch (Exception e) \{  // Generic catch
            System.out.println("સામાન્ય ભૂલ: " + e.getMessage());
            
        \} finally \{
            System.out.println("Cleanup પૂર્ણ થયું");
        \}
    \}
\}
\end{verbatim}

\textbf{Multiple Catch નિયમો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
નિયમ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{વિશિષ્ટ પહેલા} & સામાન્ય પહેલા વિશિષ્ટ exceptions handle કરો \\
\textbf{એક catch execute} & માત્ર પહેલો મેળ ખાતો catch ચાલે \\
\textbf{ક્રમ મહત્વપૂર્ણ} & વધુ વિશિષ્ટ થી વધુ સામાન્ય \\
\textbf{Finally હંમેશા} & Finally block હંમેશા execute થાય \\
\end{longtable}
}

\textbf{Exception Flow:}

\begin{itemize}
\tightlist
\item
  \textbf{ArrayIndexOutOfBoundsException}: અમાન્ય array access
\item
  \textbf{ArithmeticException}: શૂન્ય વડે ભાગાકાર
\item
  \textbf{NumberFormatException}: અમાન્ય number conversion
\item
  \textbf{Exception}: બાકીના કોઈપણ exceptions catch કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SOOF - Specific first, One executes, Order
matters, Finally''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{Exception શું છે? Arithmetic Exception નો ઉપયોગ દર્શાવતો પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\textbf{Exception વ્યાખ્યા:} Exception એ એક ઘટના છે જે પ્રોગ્રામ execution
દરમિયાન થાય છે અને instructions ના સામાન્ય flow ને ખલેલ પહોંચાડે છે.

\begin{verbatim}
public class ArithmeticExceptionDemo \{
    
    public static double divide(int numerator, int denominator) \{
        try \{
            if (denominator == 0) \{
                throw new ArithmeticException("શૂન્ય વડે ભાગાકાર મંજૂર નથી");
            \}
            return (double) numerator / denominator;
            
        \} catch (ArithmeticException e) \{
            System.out.println("Arithmetic Exception પકડાયો:" + e.getMessage());
            return Double.NaN;  // Not{-a{-}Number return કરો}
        \}
    \}
    
    public static void calculatorDemo() \{
        int[] numbers = \{100, 50, 25, 0, {-}10\;}
        
        for (int i = 0; i {} numbers.length; i++) \{
            try \{
                int result = 100 / numbers[i];
                System.out.println("100 / " + numbers[i] + " = " + result);
                
            \} catch (ArithmeticException e) \{
                System.out.println("100 ને " + numbers[i] + " વડે ભાગી શકાતું નથી {- "} + 
                                 e.getMessage());
            \}
        \}
    \}
    
    public static void main(String[] args) \{
        System.out.println("=== Arithmetic Exception ડેમો ===");
        
        // કસ્ટમ divide method ટેસ્ટ
        System.out.println("{n}1. કસ્ટમ divide method:");
        System.out.println("10 / 2 = " + divide(10, 2));
        System.out.println("15 / 0 = " + divide(15, 0));
        
        // કેલક્યુલેટર ડેમો ટેસ્ટ
        System.out.println("{n}2. કેલક્યુલેટર ડેમો:");
        calculatorDemo();
        
        // Try{-catch{-}finally સાથે ટેસ્ટ}
        System.out.println("{n}3. Try{-catch{-}finally ડેમો:"});
        try \{
            int value = 50;
            int zero = 0;
            int result = value / zero;  // આ ArithmeticException ફેંકશે
            
        \} catch (ArithmeticException e) \{
            System.out.println("Exception handle થયો: " + e.toString());
            
        \} finally \{
            System.out.println("Finally block: Cleanup પૂર્ણ થયું");
        \}
        
        System.out.println("Exception handling પછી પ્રોગ્રામ સામાન્ય રીતે ચાલુ રહે છે");
    \}
\}
\end{verbatim}

\textbf{Exception પ્રકારો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Checked} & Compile time પર handle કરવા પડે & IOException \\
\textbf{Unchecked} & Runtime exceptions & ArithmeticException \\
\textbf{Error} & સિસ્ટમ સ્તરની સમસ્યાઓ & OutOfMemoryError \\
\end{longtable}
}

\textbf{ArithmeticException કારણો:}

\begin{itemize}
\tightlist
\item
  \textbf{શૂન્ય વડે ભાગાકાર}: સૌથી સામાન્ય કારણ
\item
  \textbf{શૂન્ય વડે modulo}: બાકી કામગીરી શૂન્ય સાથે
\item
  \textbf{અમાન્ય કામગીરીઓ}: ગાણિતિક અશક્યતાઓ
\end{itemize}

\textbf{પ્રોગ્રામ પ્રવાહ:}

\begin{enumerate}
\tightlist
\item
  \textbf{સામાન્ય execution}: Try block ચાલે છે
\item
  \textbf{Exception થાય}: ArithmeticException ફેંકાય છે
\item
  \textbf{Exception પકડાય}: Catch block તેને handle કરે છે
\item
  \textbf{Cleanup}: Finally block execute થાય છે
\item
  \textbf{ચાલુ રાખો}: Handling પછી પ્રોગ્રામ ચાલુ રહે છે
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``DZMI - Division by Zero, Mathematical Invalid''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{Java માં ArrayIndexOutOfBound Exception ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ArrayIndexOutOfBound Exception કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કારણ & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{નકારાત્મક index} & 0 થી ઓછો index & arr[-1] \\
\textbf{Index \textgreater= length} & Array size થી વધારે index &
arr[5] size 3 માટે \\
\textbf{ખાલી array} & શૂન્ય-લંબાઈ array પર access & arr[0] length 0
માટે \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
public class ArrayIndexDemo \{
    public static void main(String[] args) \{
        int[] numbers = \{10, 20, 30\;}
        
        try \{
            System.out.println(numbers[5]); // Index 5 { length 3}
        \} catch (ArrayIndexOutOfBoundsException e) \{
            System.out.println("ભૂલ: " + e.getMessage());
        \}
        
        try \{
            System.out.println(numbers[{-}1]); // નકારાત્મક index
        \} catch (ArrayIndexOutOfBoundsException e) \{
            System.out.println("ભૂલ: નકારાત્મક index");
        \}
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Runtime exception}: પ્રોગ્રામ execution દરમિયાન થાય છે
\item
  \textbf{Index validation}: હંમેશા array bounds તપાસો
\item
  \textbf{નિવારણ}: Bounds checking માટે array.length વાપરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``NIE - Negative, Index-exceed, Empty''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{Stream classes ની મૂળભૂત બાબતો સમજાવો.}

\begin{solutionbox}

\textbf{Stream Classes Hierarchy:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[InputStream] {-{-}{} B[FileInputStream]}
    A {-{-}{} C[BufferedInputStream]}
    D[OutputStream] {-{-}{} E[FileOutputStream]}
    D {-{-}{} F[BufferedOutputStream]}
    G[Reader] {-{-}{} H[FileReader]}
    G {-{-}{} I[BufferedReader]}
    J[Writer] {-{-}{} K[FileWriter]}
    J {-{-}{} L[BufferedWriter]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Stream પ્રકારો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4815}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1852}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Stream પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Classes
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Byte Streams} & Binary data handle કરે છે & InputStream,
OutputStream \\
\textbf{Character Streams} & Text data handle કરે છે & Reader, Writer \\
\textbf{Buffered Streams} & Performance સુધારે છે & BufferedReader,
BufferedWriter \\
\textbf{File Streams} & File operations & FileInputStream,
FileOutputStream \\
\end{longtable}
}

\textbf{મૂળભૂત કામગીરીઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Input}: સ્ત્રોતમાંથી ડેટા વાંચવો
\item
  \textbf{Output}: લક્ષ્ય પર ડેટા લખવો
\item
  \textbf{Buffering}: કાર્યક્ષમતા માટે ડેટા કામચલાઉ સંગ્રહ
\item
  \textbf{Closing}: સિસ્ટમ resources મુક્ત કરવા
\end{itemize}

\textbf{Stream ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Abstraction}: I/O માટે એકસમાન interface
\item
  \textbf{કાર્યક્ષમતા}: Buffered operations
\item
  \textbf{લવચીકતા}: વિવિધ ડેટા sources/destinations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BCIF - Byte, Character, Input/Output, File''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{ટેક્સ્ટ ફાઇલ બનાવવા માટે Java પ્રોગ્રામ લખો અને ટેક્સ્ટ ફાઇલ પર રાઇટ ઓપરેશન
કરો.}

\begin{solutionbox}

\begin{verbatim}
import java.io.*;

public class FileWriteDemo \{
    
    public static void writeWithFileWriter() \{
        try \{
            FileWriter writer = new FileWriter("student\_data.txt");
            
            writer.write("વિદ્યાર્થી માહિતી સિસ્ટમ{n}");
            writer.write("=========================={n}");
            writer.write("ID: 101{n}");
            writer.write("નામ: રામ શર્મા{n}");
            writer.write("કોર્સ: Java Programming{n}");
            writer.write("ગ્રેડ: A+{n}");
            
            writer.close();
            System.out.println("FileWriter વાપરીને ફાઇલ સફળતાપૂર્વક લખાઈ");
            
        \} catch (IOException e) \{
            System.out.println("ફાઇલ લખવામાં ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void writeWithBufferedWriter() \{
        try \{
            BufferedWriter buffWriter = new BufferedWriter(
                new FileWriter("course\_details.txt")
            );
            
            String[] courses = \{
                "Java Programming {- 4341602"},
                "Database Management {- 4341603"}, 
                "Web Development {- 4341604"},
                "Mobile App Development {- 4341605"}
            \;}
            
            buffWriter.write("ઉપલબ્ધ કોર્સ:{n}");
            buffWriter.write("=================={n}");
            
            for (String course : courses) \{
                buffWriter.write(course + "{n}");
            \}
            
            buffWriter.close();
            System.out.println("BufferedWriter વાપરીને ફાઇલ સફળતાપૂર્વક લખાઈ");
            
        \} catch (IOException e) \{
            System.out.println("ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void writeWithTryWithResources() \{
        try (FileWriter writer = new FileWriter("marks\_record.txt")) \{
            
            writer.write("સેમેસ્ટર 4 માર્ક્સ રેકોર્ડ{n}");
            writer.write("======================={n}");
            writer.write("Java Programming: 85{n}");
            writer.write("Database Management: 78{n}");
            writer.write("Web Development: 92{n}");
            writer.write("કુલ: 255/300{n}");
            writer.write("ટકાવારી: 85\%{n}");
            
            System.out.println("આટોમેટિક resource management સાથે ફાઇલ લખાઈ");
            
        \} catch (IOException e) \{
            System.out.println("ફાઇલ લખવાની ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void main(String[] args) \{
        System.out.println("=== ફાઇલ લખવાની કામગીરીઓ ડેમો ==={n}");
        
        // પદ્ધતિ 1: મૂળભૂત FileWriter
        writeWithFileWriter();
        
        // પદ્ધતિ 2: બહેતર performance માટે BufferedWriter
        writeWithBufferedWriter();
        
        // પદ્ધતિ 3: Try{-with{-}resources (ભલામણ કરેલ)}
        writeWithTryWithResources();
        
        System.out.println("{n}બધી ફાઇલ લખવાની કામગીરીઓ પૂર્ણ!");
    \}
\}
\end{verbatim}

\textbf{ફાઇલ લખવાની પદ્ધતિઓ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
પદ્ધતિ & Performance & Resource Management & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{FileWriter} & મૂળભૂત & Manual close() & સરળ writes \\
\textbf{BufferedWriter} & ઉચ્ચ & Manual close() & મોટો ડેટા \\
\textbf{Try-with-resources} & ઉચ્ચ & આટોમેટિક & ભલામણ કરેલ \\
\end{longtable}
}

\textbf{લખવાના કામગીરી પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{Writer object બનાવો}: FileWriter અથવા BufferedWriter
\item
  \textbf{ડેટા લખો}: write() method વાપરો
\item
  \textbf{Stream બંધ કરો}: Resources મુક્ત કરો
\item
  \textbf{Exceptions handle કરો}: IOException management
\end{enumerate}

\textbf{ફાઇલ કામગીરીઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{બનાવો}: અસ્તિત્વમાં નથી તો નવી ફાઇલ
\item
  \textbf{ઓવરરાઇટ}: હાલની સામગ્રી બદલે છે
\item
  \textbf{Append}: હાલની સામગ્રીમાં ઉમેરે છે (append mode વાપરો)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CWCH - Create, Write, Close, Handle''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{Java માં Divide by Zero Exception ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Divide by Zero Exception કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કામગીરી & પરિણામ & Exception \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Integer division} & અવ્યાખ્યાયિત & ArithmeticException \\
\textbf{Float division} & Infinity & કોઈ exception નહિ \\
\textbf{Modulo by zero} & અવ્યાખ્યાયિત & ArithmeticException \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
public class DivideByZeroDemo \{
    public static void main(String[] args) \{
        // શૂન્ય વડે Integer division
        try \{
            int result = 10 / 0;
        \} catch (ArithmeticException e) \{
            System.out.println("Integer division: " + e.getMessage());
        \}
        
        // શૂન્ય વડે Float division (કોઈ exception નહિ)
        double floatResult = 10.0 / 0.0;
        System.out.println("Float division: " + floatResult); // Infinity
        
        // શૂન્ય વડે Modulo
        try \{
            int remainder = 10 \% 0;
        \} catch (ArithmeticException e) \{
            System.out.println("Modulo ભૂલ: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Integer arithmetic}: ArithmeticException ફેંકે છે
\item
  \textbf{Floating point}: Infinity return કરે છે (IEEE 754 standard)
\item
  \textbf{નિવારણ}: Division પહેલાં denominator તપાસો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``IFM - Integer exception, Float infinity, Modulo
error''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{Try and catch block ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Try-Catch માળખું:}

\begin{verbatim}
try \{
    // જોખમી કોડ જે exception ફેંકી શકે
\} catch (SpecificException e) \{
    // વિશિષ્ટ exception handle કરો
\} catch (GeneralException e) \{
    // સામાન્ય exception handle કરો
\} finally \{
    // હંમેશા execute થાય (વૈકલ્પિક)
\}
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
public class TryCatchExample \{
    public static void validateAge(int age) \{
        try \{
            if (age {} 0) \{
                throw new IllegalArgumentException("ઉંમર નકારાત્મક ન હોઈ શકે");
            \}
            if (age {} 150) \{
                throw new IllegalArgumentException("ઉંમર અવાસ્તવિક લાગે છે");
            \}
            System.out.println("માન્ય ઉંમર: " + age);
            
        \} catch (IllegalArgumentException e) \{
            System.out.println("માન્યતા ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void main(String[] args) \{
        validateAge(25);    // માન્ય
        validateAge({-}5);    // અમાન્ય
        validateAge(200);   // અમાન્ય
    \}
\}
\end{verbatim}

\textbf{Try-Catch પ્રવાહ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Block & હેતુ & Execution \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & જોખમી કોડ સમાવે છે & હંમેશા પહેલા execute \\
\textbf{catch} & Exceptions handle કરે છે & માત્ર exception થાય તો \\
\textbf{finally} & Cleanup કોડ & હંમેશા execute \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Exception matching}: પહેલો મેળ ખાતો catch block execute
\item
  \textbf{Control flow}: Catch block પછી પ્રોગ્રામ ચાલુ રહે
\item
  \textbf{Multiple catches}: અલગ exception પ્રકારો handle કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TCF - Try risky, Catch exception, Finally
cleanup''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{ટેક્સ્ટ ફાઇલના કન્ટેન્ટ ડિસ્પ્લે કરવા માટે Java માં પ્રોગ્રામ લખો અને ટેક્સ્ટ
ફાઇલ પર અપેન્ડ ઓપરેશન કરો.}

\begin{solutionbox}

\begin{verbatim}
import java.io.*;

public class FileReadAppendDemo \{
    
    public static void createInitialFile() \{
        try (FileWriter writer = new FileWriter("student\_log.txt")) \{
            writer.write("વિદ્યાર્થી પ્રવૃત્તિ લોગ{n}");
            writer.write("==================={n}");
            writer.write("2024{-06{-}13: કોર્સ નોંધણી શરૂ}{n}");
            writer.write("2024{-06{-}14: અસાઇનમેન્ટ 1 જમા કર્યું}{n}");
            
            System.out.println("પ્રારંભિક ફાઇલ સફળતાપૂર્વક બનાવાઈ");
            
        \} catch (IOException e) \{
            System.out.println("ફાઇલ બનાવવામાં ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void displayFileContent(String fileName) \{
        System.out.println("{n}=== ફાઇલ સામગ્રી ===");
        
        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) \{
            String line;
            int lineNumber = 1;
            
            while ((line = reader.readLine()) != null) \{
                System.out.println(lineNumber + ": " + line);
                lineNumber++;
            \}
            
        \} catch (FileNotFoundException e) \{
            System.out.println("ફાઇલ મળી નથી: " + fileName);
        \} catch (IOException e) \{
            System.out.println("ફાઇલ વાંચવામાં ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void appendToFile(String fileName, String content) \{
        try (FileWriter writer = new FileWriter(fileName, true)) \{ // true = append mode
            writer.write(content);
            System.out.println("સામગ્રી સફળતાપૂર્વક append થઈ");
            
        \} catch (IOException e) \{
            System.out.println("ફાઇલમાં append કરવામાં ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void appendMultipleEntries(String fileName) \{
        String[] newEntries = \{
            "2024{-06{-}15: ક્વિઝ 1 પૂર્ણ કર્યું}{n}",
            "2024{-06{-}16: પ્રોજેક્ટ પ્રપોઝલ જમા કર્યું}{n}",
            "2024{-06{-}17: ગ્રુપ સ્ટડી સેશન}{n}",
            "2024{-06{-}18: મિડ{-}ટર્મ પરીક્ષાની તૈયારી}{n}"
        \;}
        
        try (BufferedWriter writer = new BufferedWriter(
                new FileWriter(fileName, true))) \{
            
            writer.write("{n}{-{-}{-} તાજેતરની પ્રવૃત્તિઓ {-}{-}{-}}{n}");
            
            for (String entry : newEntries) \{
                writer.write(entry);
            \}
            
            writer.write("{-{-}{-} લોગ અંત {-}{-}{-}}{n}");
            System.out.println("અનેક entries સફળતાપૂર્વક append થઈ");
            
        \} catch (IOException e) \{
            System.out.println("Entries append કરવામાં ભૂલ: " + e.getMessage());
        \}
    \}
    
    public static void main(String[] args) \{
        String fileName = "student\_log.txt";
        
        System.out.println("=== ફાઇલ વાંચવા અને Append કરવાની કામગીરીઓ ===");
        
        // પગલું 1: પ્રારંભિક ફાઇલ બનાવો
        createInitialFile();
        
        // પગલું 2: પ્રારંભિક સામગ્રી દર્શાવો
        displayFileContent(fileName);
        
        // પગલું 3: એક entry append કરો
        appendToFile(fileName, "2024{-06{-}19: લેબ સેશન પૂર્ણ}{n}");
        
        // પગલું 4: પહેલા append પછી સામગ્રી દર્શાવો
        System.out.println("{n}{-{-}{-} પહેલા append પછી {-}{-}{-}"});
        displayFileContent(fileName);
        
        // પગલું 5: અનેક entries append કરો
        appendMultipleEntries(fileName);
        
        // પગલું 6: અંતિમ સામગ્રી દર્શાવો
        System.out.println("{n}{-{-}{-} અંતિમ ફાઇલ સામગ્રી {-}{-}{-}"});
        displayFileContent(fileName);
        
        // પગલું 7: ફાઇલ આંકડાકીય માહિતી
        showFileStatistics(fileName);
    \}
    
    public static void showFileStatistics(String fileName) \{
        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) \{
            int lineCount = 0;
            int charCount = 0;
            String line;
            
            while ((line = reader.readLine()) != null) \{
                lineCount++;
                charCount += line.length();
            \}
            
            System.out.println("{n}=== ફાઇલ આંકડાકીય માહિતી ===");
            System.out.println("કુલ લાઇનો: " + lineCount);
            System.out.println("કુલ અક્ષરો: " + charCount);
            
        \} catch (IOException e) \{
            System.out.println("ફાઇલ આંકડાકીય માહિતી વાંચવામાં ભૂલ: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\textbf{ફાઇલ કામગીરીઓ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કામગીરી & Method & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બનાવો} & FileWriter(filename) & નવી ફાઇલ બનાવો \\
\textbf{વાંચો} & BufferedReader.readLine() & ફાઇલ સામગ્રી વાંચો \\
\textbf{Append} & FileWriter(filename, true) & હાલની ફાઇલમાં ઉમેરો \\
\textbf{દર્શાવો} & System.out.println() & સામગ્રી બતાવો \\
\end{longtable}
}

\textbf{ફાઇલ કામગીરીઓ પ્રવાહ:}

\begin{enumerate}
\tightlist
\item
  \textbf{પ્રારંભિક ફાઇલ બનાવો}: પ્રારંભિક સામગ્રી લખો
\item
  \textbf{સામગ્રી દર્શાવો}: વર્તમાન સામગ્રી વાંચો અને બતાવો
\item
  \textbf{ડેટા append કરો}: નવી માહિતી ઉમેરો
\item
  \textbf{અપડેટેડ દર્શાવો}: સુધારેલી સામગ્રી બતાવો
\item
  \textbf{આંકડાકીય માહિતી}: લાઇન અને અક્ષરોની ગણતરી
\end{enumerate}

\textbf{Append vs Write:}

\begin{itemize}
\tightlist
\item
  \textbf{Write mode}: હાલની સામગ્રીને ઓવરરાઇટ કરે છે
\item
  \textbf{Append mode}: હાલની સામગ્રીના અંતે ઉમેરે છે
\item
  \textbf{Constructor parameter}: બીજો parameter true append enable કરે છે
\end{itemize}

\textbf{Resource Management:}

\begin{itemize}
\tightlist
\item
  \textbf{Try-with-resources}: આટોમેટિક close()
\item
  \textbf{Exception handling}: FileNotFoundException, IOException
\item
  \textbf{Buffered operations}: મોટી ફાઇલો માટે બહેતર performance
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CDADS - Create, Display, Append, Display,
Statistics''

\end{mnemonicbox}

\end{document}
