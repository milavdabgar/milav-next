\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/english-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}
\usetikzlibrary{fit,positioning,shapes,calc,arrows.meta}

\title{Object Oriented Programming With Java (4341602) - Summer 2025 Solution}
\date{May 15, 2025}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{Differentiate between Procedure Oriented Programming (POP) and object-oriented programming (OOP).}

\begin{solutionbox}
\textbf{Difference}:
\begin{center}
\captionof{table}{POP vs OOP}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Aspect} & \textbf{POP} & \textbf{OOP} \\ \hline
\textbf{Approach} & Top-down approach & Bottom-up approach \\ \hline
\textbf{Focus} & Functions and procedures & Objects and classes \\ \hline
\textbf{Data Security} & Less secure, global data & More secure, data encapsulation \\ \hline
\textbf{Problem Solving} & Divides into functions & Divides into objects \\ \hline
\end{tabulary}
\end{center}

\textbf{Key Points}:
\begin{itemize}
    \item \textbf{POP}: Functions are primary building blocks.
    \item \textbf{OOP}: Objects contain both data and methods.
    \item \textbf{Reusability}: OOP provides better code reusability.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{POP Functions, OOP Objects}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Enlist and explain the basic concepts of OOP.}

\begin{solutionbox}
\textbf{Basic OOP Concepts}:
\begin{itemize}
    \item \textbf{Encapsulation}: Binding data and methods together in a class. It hides data from outside interference.
    \item \textbf{Inheritance}: Creating new classes from existing classes. It promotes code reusability.
    \item \textbf{Polymorphism}: Same method name with different implementations (e.g., Overloading, Overriding).
    \item \textbf{Abstraction}: Hiding implementation details from user and showing only functionality.
\end{itemize}

\textbf{Benefits}:
\begin{itemize}
    \item \textbf{Code Reusability}: Through inheritance and polymorphism.
    \item \textbf{Data Security}: Through encapsulation.
    \item \textbf{Easy Maintenance}: Modular approach makes updates easier.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Every Intelligent Person Abstracts}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Define Constructor. Enlist different types of Constructors and explain any 2 of them with a proper example.}

\begin{solutionbox}
\textbf{Constructor Definition}:
A constructor is a special method that initializes objects when they are created. It has the same name as the class and no return type.

\textbf{Types of Constructors}:
\begin{enumerate}
    \item Default Constructor
    \item Parameterized Constructor
    \item Copy Constructor
    \item Private Constructor
\end{enumerate}

\begin{lstlisting}[language=Java,caption={Types of Constructors}]
class Student {
    String name;
    int age;
    
    // 1. Default Constructor
    public Student() {
        name = "Unknown";
        age = 0;
    }
    
    // 2. Parameterized Constructor
    public Student(String n, int a) {
        name = n;
        age = a;
    }
}

class Main {
    public static void main(String[] args) {
        Student s1 = new Student();        // Calls Default
        Student s2 = new Student("John", 20); // Calls Parameterized
    }
}
\end{lstlisting}

\textbf{Key Features}:
\begin{itemize}
    \item \textbf{Automatic Invocation}: Called automatically during object creation.
    \item \textbf{No Return Type}: Constructors don't have a return type (not even void).
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Constructors Create Objects}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Explain String class. Enlist different methods of String class and explain any 3 of them with a proper example.}

\begin{solutionbox}
\textbf{String Class}:
String class in Java represents immutable character sequences. Once created, String objects cannot be modified.

\textbf{String Methods}:
\begin{center}
\captionof{table}{Common String Methods}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Method} & \textbf{Purpose} \\ \hline
\code{length()} & Returns string length \\ \hline
\code{charAt(index)} & Returns character at specified index \\ \hline
\code{substring(start, end)} & Extracts substring from start to end-1 \\ \hline
\code{indexOf(char)} & Finds first position of character \\ \hline
\code{toUpperCase()} & Converts all characters to uppercase \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={String Methods Demo}]
public class StringDemo {
    public static void main(String[] args) {
        String str = "Hello World";
        
        // 1. length() method
        System.out.println("Length: " + str.length()); // 11
        
        // 2. charAt() method
        System.out.println("Char at 0: " + str.charAt(0)); // H
        
        // 3. substring() method
        System.out.println("Substring: " + str.substring(0, 5)); // Hello
    }
}
\end{lstlisting}

\textbf{Key Points}:
\begin{itemize}
    \item \textbf{Immutable}: String objects cannot be changed after creation.
    \item \textbf{Memory Efficient}: Uses String pool for storage optimization.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Strings Store Text}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{Define Garbage collection. Describe the importance of Garbage collection in JAVA Programming.}

\begin{solutionbox}
\textbf{Garbage Collection Definition}:
Automatic memory management process that reclaims memory occupied by objects that are no longer referenced (reachable) in the program.

\textbf{Importance}:
\begin{itemize}
    \item \textbf{Automatic Memory Management}: Developers don't need to manually allocate and deallocate memory.
    \item \textbf{Prevents Memory Leaks}: Automatically frees unused memory, reducing risk of leaks.
    \item \textbf{Application Performance}: Optimizes memory usage by cleaning up heap space.
\end{itemize}

\textbf{Benefits}:
\begin{itemize}
    \item \textbf{Productivity}: Programmer focuses on business logic, not memory.
    \item \textbf{Reliability}: Reduces system crashes due to memory errors.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Garbage Collector Cleans Memory}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{List down the four ways to make an object eligible for garbage collection.}

\begin{solutionbox}
\textbf{Ways for GC Eligibility}:
An object becomes eligible for Garbage Collection when there are no more references to it.

\begin{center}
\captionof{table}{GC Eligibility Methods}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Method} & \textbf{Description} \\ \hline
\textbf{Nullifying Reference} & Explicitly setting an object reference to \code{null}. \\ \hline
\textbf{Reassigning Reference} & Pointing a reference variable to another object. \\ \hline
\textbf{Anonymous Objects} & Creating objects without assigning them to a reference variable. \\ \hline
\textbf{Island of Isolation} & Two or more objects referencing only each other with no external access. \\ \hline
\end{tabulary}
\end{center}

\textbf{Examples}:
\begin{enumerate}
    \item \code{Student s = new Student(); s = null;}
    \item \code{Student s1 = new Student(); Student s2 = new Student(); s1 = s2;}
    \item \code{new Student();}
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Null References Attract Islands}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Write a Java Program to demonstrate a static block that gets executed before main. Explain its significance.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Static Block Demo}]
public class StaticBlockDemo {
    static int count;
    
    // Static block - Executes BEFORE main
    static {
        System.out.println("Static block executed first");
        count = 10;
        System.out.println("Count initialized to: " + count);
    }
    
    public static void main(String[] args) {
        System.out.println("Main method started");
        System.out.println("Count value: " + count);
    }
}
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
Static block executed first
Count initialized to: 10
Main method started
Count value: 10
\end{verbatim}

\textbf{Significance}:
\begin{itemize}
    \item \textbf{Early Initialization}: Executes automatically when the class is loaded into memory, before invoking the \code{main} method.
    \item \textbf{Class Loading}: It runs only once per class loading.
    \item \textbf{Uses}: Ideal for initializing static variables or loading native libraries/configurations.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Static Blocks Start Before Main}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{Describe Minor/Incremental and Major/Full Garbage collection in JAVA.}

\begin{solutionbox}
\textbf{Types of Garbage Collection}:

\begin{center}
\captionof{table}{Minor vs Major GC}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Type} & \textbf{Description} & \textbf{Frequency} \\ \hline
\textbf{Minor GC} & Cleans the \textbf{Young Generation} (Eden space). Removes short-lived objects. & Frequent, Fast \\ \hline
\textbf{Major GC} & Cleans the \textbf{Old Generation} (Tenured space). Involves whole heap (Full GC). & Less Frequent, Slow \\ \hline
\end{tabulary}
\end{center}

\textbf{Details}:
\begin{itemize}
    \item \textbf{Minor GC}: Triggered when Eden space is full. Fast and causes little pause.
    \item \textbf{Major GC}: Triggered when Old Generation is full. Causes "Stop the World" pauses which can affect performance.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Minor Frequent, Major Slow}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{Explicate the finalize() method in java with its advantages.}

\begin{solutionbox}
\textbf{finalize() Method}:
It is a method defined in the \code{Object} class. The Garbage Collector calls this method on an object just before it destroys the object and reclaims its memory. It is used for cleanup processing.

\textbf{Syntax}:
\begin{lstlisting}[language=Java]
protected void finalize() throws Throwable {
    // Cleanup code
}
\end{lstlisting}

\textbf{Advantages}:
\begin{itemize}
    \item \textbf{Resource Cleanup}: Useful for closing non-Java resources like file streams, database connections, or sockets if the programmer forgot to close them.
    \item \textbf{Safety Net}: Acts as a final safety check to ensure critical resources are released.
\end{itemize}

\textbf{Note}: It is deprecated in newer Java versions (since Java 9) in favor of \code{try-with-resources} and \code{Cleaners}.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Finalize Frees Resources}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Explain the syntax of public static void main (String[] args). Write a Java Program to print input taken as command line argument.}

\begin{solutionbox}
\textbf{Main Method Syntax Explanation}:
\code{public static void main(String[] args)}

\begin{itemize}
    \item \textbf{public}: Access modifier making it accessible from anywhere (JVM needs to call it).
    \item \textbf{static}: Allows JVM to call the method without creating an instance of the class.
    \item \textbf{void}: The method does not return any value.
    \item \textbf{main}: The specific identifier name JVM looks for as the starting point.
    \item \textbf{String[] args}: Array of String objects storing command-line arguments.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Command Line Arguments Demo}]
public class CommandLineDemo {
    public static void main(String[] args) {
        System.out.println("Number of arguments: " + args.length);
        
        if(args.length > 0) {
            System.out.println("Command line arguments:");
            for(int i = 0; i < args.length; i++) {
                System.out.println("Arg " + i + ": " + args[i]);
            }
        } else {
            System.out.println("No arguments provided");
        }
    }
}
\end{lstlisting}

\textbf{Execution}:
\code{java CommandLineDemo Hello World 123}

\textbf{Output}:
\begin{verbatim}
Number of arguments: 3
Command line arguments:
Arg 0: Hello
Arg 1: World
Arg 2: 123
\end{verbatim}
\end{solutionbox}

\questionmarks{3(a)}{3}{Enlist and Explain various Java access modifier(s).}

\begin{solutionbox}
\textbf{Java Access Modifiers}:
Access modifiers determine the scope (visibility) of a class, constructor, variable, method, or data member.

\begin{center}
\captionof{table}{Access Modifiers Scope}
\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\textbf{Modifier} & \textbf{Class} & \textbf{Package} & \textbf{Subclass} & \textbf{World} \\ \hline
\textbf{public} & Yes & Yes & Yes & Yes \\ \hline
\textbf{protected} & Yes & Yes & Yes & No \\ \hline
\textbf{default} & Yes & Yes & No & No \\ \hline
\textbf{private} & Yes & No & No & No \\ \hline
\end{tabulary}
\end{center}

\textbf{Usage}:
\begin{itemize}
    \item \textbf{public}: Universal access.
    \item \textbf{protected}: Used for inheritance; accessible within package and outside by subclasses.
    \item \textbf{default}: (No keyword) Package-private.
    \item \textbf{private}: Restricted to the defining class only.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Public Protected Default Private}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Describe interface in JAVA. Demonstrate inheritance of an interface with an executable example.}

\begin{solutionbox}
\textbf{Interface in Java}:
An interface is a reference type in Java. It is similar to a class but represents a contract. It can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot be instantiated—they can only be implemented by classes or extended by other interfaces.

\begin{lstlisting}[language=Java,caption={Interface Inheritance}]
// Parent interface
interface Animal {
    void sound();
}

// Child interface inheriting from Animal
interface Mammal extends Animal {
    void walk();
}

// Class implementing the child interface
class Dog implements Mammal {
    public void sound() {
        System.out.println("Dog barks");
    }
    
    public void walk() {
        System.out.println("Dog walks on four legs");
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
        d.walk();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Interfaces Inherit Contracts}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Define super keyword and demonstrate the use of super keyword with an executable Java Program}

\begin{solutionbox}
\textbf{super Keyword}:
The \code{super} keyword in Java is a reference variable used to refer to the immediate parent class object. It is used to bypass the current class's scope to access members of the parent class.

\textbf{Uses}:
\begin{enumerate}
    \item \textbf{Variable Access}: To refer to immediate parent class instance variable (`super.variable`).
    \item \textbf{Method Call}: To invoke immediate parent class method (`super.method()`).
    \item \textbf{Constructor Call}: To invoke immediate parent class constructor (`super()`).
\end{enumerate}

\begin{lstlisting}[language=Java,caption={Using super Keyword}]
class Animal {
    String name = "Animal";
    
    Animal(String type) {
        System.out.println("Animal constructor: " + type);
    }
    
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    String name = "Dog";
    
    Dog() {
        // 1. Calling parent constructor
        super("Mammal");  
        System.out.println("Dog constructor");
    }
    
    void sound() {
        // 2. Calling parent method
        super.sound();    
        System.out.println("Dog barks");
    }
    
    void display() {
        // 3. Accessing parent variable
        System.out.println("Parent name: " + super.name);
        System.out.println("Child name: " + this.name);
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
        d.display();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Super Calls Parent}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{Explain package in JAVA with workable illustration.}

\begin{solutionbox}
\textbf{Package}:
A package in Java is a mechanism to encapsulate a group of classes, sub-packages, and interfaces.

\textbf{Benefits}:
\begin{itemize}
    \item \textbf{Organization}: Categorizes classes (e.g., `model`, `view`, `controller`) for better code management.
    \item \textbf{Access Control}: Provides access protection (default/protected access).
    \item \textbf{Namespace Management}: Prevents naming conflicts.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Creating and Using Package}]
// File: com/company/model/Student.java
package com.company.model;

public class Student {
    private String name;
    public void setName(String name) { this.name = name; }
}

// File: Main.java
import com.company.model.Student;

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("John");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Packages Organize Classes}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Explain abstract and final keywords with a viable illustration.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Abstract vs Final}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Keyword} & \textbf{Purpose} & \textbf{Usage Level} \\ \hline
\textbf{abstract} & Defines incomplete implementation (template). Cannot be instantiated. & Class, Method \\ \hline
\textbf{final} & Defines constant or unchangeable entity. Prevents modification/extension. & Class, Method, Variable \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Abstract and Final Demo}]
// Abstract class
abstract class Shape {
    final double PI = 3.14;  // final variable (Constant)
    
    abstract void draw();    // abstract method (No body)
    
    final void display() {   // final method (Cannot override)
        System.out.println("Displaying shape");
    }
}

// Final class (Cannot extend)
final class Circle extends Shape {
    void draw() {
        System.out.println("Drawing circle");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Abstract Allows, Final Forbids}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{State Dynamic Method Dispatch in Java Programming language context. Construct an executable program demonstrating Dynamic Method Dispatch.}

\begin{solutionbox}
\textbf{Dynamic Method Dispatch (Runtime Polymorphism)}:
It is a mechanism by which a call to an overridden method is resolved at runtime rather than compile-time. This is implemented using parent class reference variable referring to a child class object.

\textbf{How it works}:
\begin{enumerate}
    \item Retrieve the actual object type referenced by the variable.
    \item Look up the method in the Virtual Method Table (vtable).
    \item Invoke the method implementation corresponding to the actual object.
\end{enumerate}

\begin{lstlisting}[language=Java,caption={Dynamic Dispatch Example}]
// Base class
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

// Derived classes
class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("Cat meows");
    }
}

class DynamicDispatchDemo {
    public static void main(String[] args) {
        Animal ref;  // Reference variable
        
        // Runtime method resolution
        
        ref = new Dog(); // Referencing Dog object
        ref.sound();     // Calls Dog's sound()
        
        ref = new Cat(); // Referencing Cat object
        ref.sound();     // Calls Cat's sound()
        
        ref = new Animal();
        ref.sound();     // Calls Animal's sound()
    }
}
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
Dog barks
Cat meows
Animal makes sound
\end{verbatim}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Dynamic Dispatch Decides Runtime}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Explain throw and finally keywords in Exception Handling.}

\begin{solutionbox}
\textbf{throw}:
\begin{itemize}
    \item Used to explicitly throw an exception from a method or block of code.
    \item Mainly used to throw custom exceptions.
    \item Syntax: \code{throw new Exception("Message");}
\end{itemize}

\textbf{finally}:
\begin{itemize}
    \item A block that follows \code{try} or \code{catch}.
    \item It \textbf{always executes} regardless of whether an exception occurred or not.
    \item Generally used for cleanup code (closing files, releasing resources).
\end{itemize}

\begin{lstlisting}[language=Java,caption={Throw and Finally}]
try {
    if(age < 0)
        throw new IllegalArgumentException("Invalid age");
} catch(Exception e) {
    System.out.println(e);
} finally {
    System.out.println("This always prints.");
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Throw Creates, Finally Cleans}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Write a program demonstrating try…catch block in JAVA}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Try-Catch Demo}]
public class TryCatchDemo {
    public static void main(String[] args) {
        try {
            int[] arr = {1, 2, 3};
            // This line causes ArrayIndexOutOfBoundsException
            System.out.println("Array element: " + arr[5]); 
            
            // This line will not execute
            int result = 10 / 0; 
            
        } catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error: " + e.getMessage());
            
        } catch(ArithmeticException e) {
            System.out.println("Math error: " + e.getMessage());
            
        } catch(Exception e) {
            System.out.println("General error: " + e.getMessage());
        }
        
        System.out.println("Program continues...");
    }
}
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
Array index error: Index 5 out of bounds for length 3
Program continues...
\end{verbatim}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Try Code, Catch Errors}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Define ArrayIndexOutOfBoundsException Exception. Write a workable JAVA program exhibiting it. Also mention input(s) which will raise this Exception.}

\begin{solutionbox}
\textbf{Definition}:
\code{ArrayIndexOutOfBoundsException} is a runtime exception thrown when code attempts to access an array element with an illegal index. The index is either negative or greater than or equal to the size of the array.

\begin{lstlisting}[language=Java,caption={ArrayIndexOutOfBounds Demo}]
public class ArrayExceptionDemo {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50}; // Array size: 5
        
        try {
            // Valid access
            System.out.println("Element at 2: " + numbers[2]);
            
            // INVALID access - raises exception
            // Index 10 is >= length 5
            System.out.println("Element at 10: " + numbers[10]);
            
        } catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Exception caught: " + e.getMessage());
            System.out.println("Invalid index accessed!");
        }
    }
}
\end{lstlisting}

\textbf{Inputs raising Exception}:
\begin{itemize}
    \item \textbf{Negative Index}: \code{numbers[-1]}
    \item \textbf{Index >= Length}: \code{numbers[5]} (since valid indices are 0-4)
    \item \textbf{Empty Array}: \code{numbers[0]} on an empty array
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Array Bounds Break Programs}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{Draw and explain the life cycle of Thread in JAVA with example.}

\begin{solutionbox}
\textbf{Thread Life Cycle}:
A thread goes through various states during its life cycle.

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto, >=stealth]
    % Nodes
    \node [gtu state] (new) {NEW};
    \node [gtu state, right=of new] (runnable) {RUNNABLE};
    \node [gtu state, right=of runnable] (running) {RUNNING};
    \node [gtu state, right=of running] (term) {TERMINATED};
    \node [gtu state, below=of running] (blocked) {BLOCKED/WAITING};
    
    % Edges
    \draw [->, thick] (new) -- node[above] {\small start()} (runnable);
    \draw [->, thick] (runnable) to[bend left=15] node[above] {\small Scheduler} (running);
    \draw [->, thick] (running) to[bend left=15] node[below] {\small yield()} (runnable);
    \draw [->, thick] (running) -- node[above] {\small End} (term);
    
    \draw [->, thick] (running) -- node[right] {\small sleep/wait} (blocked);
    \draw [->, thick] (blocked) -| node[below, near start] {\small notify/time} (runnable);
\end{tikzpicture}
\captionof{figure}{Thread Life Cycle}
\end{center}

\textbf{States}:
\begin{itemize}
    \item \textbf{NEW}: Thread creates but not started.
    \item \textbf{RUNNABLE}: Ready to run, waiting for CPU.
    \item \textbf{RUNNING}: Currently executing.
    \item \textbf{BLOCKED/WAITING}: Waiting for resource or another thread.
    \item \textbf{TERMINATED}: Execution completed.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{New Runs, Blocks Wait, Terminates}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Explain JAVA Optional class. Describe the OfNullable() method of Optional class.}

\begin{solutionbox}
\textbf{Optional Class}:
Introduced in Java 8, \code{java.util.Optional} is a container object that may or may not contain a non-null value. It is used to represent the absence of a value without using \code{null}, helping to avoid \code{NullPointerException}.

\textbf{ofNullable() Method}:
\begin{itemize}
    \item \textbf{Description}: Returns an \code{Optional} describing the specified value, if non-null, otherwise returns an empty \code{Optional}.
    \item \textbf{Syntax}: \code{static <T> Optional<T> ofNullable(T value)}
\end{itemize}

\begin{lstlisting}[language=Java,caption={Optional.ofNullable Demo}]
import java.util.Optional;

public class OptionalDemo {
    public static void main(String[] args) {
        String name1 = "John";
        String name2 = null;
        
        // Returns Optional containing "John"
        Optional<String> opt1 = Optional.ofNullable(name1);
        
        // Returns empty Optional (no Exception thrown)
        Optional<String> opt2 = Optional.ofNullable(name2);
        
        System.out.println("opt1 present: " + opt1.isPresent()); // true
        System.out.println("opt2 present: " + opt2.isPresent()); // false
        
        // usage with orElse
        System.out.println(opt2.orElse("Default Name")); // prints Default Name
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Optional Offers Null Safety}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{Write a workable JAVA program showcasing nested try…catch block.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Nested Try-Catch}]
public class NestedTryCatchDemo {
    public static void main(String[] args) {
        try {
            System.out.println("Outer try block started");
            
            try {
                System.out.println("Inner try block started");
                int[] numbers = {10, 20};
                
                // Causes ArrayIndexOutOfBoundsException
                System.out.println(numbers[5]); 
                
            } catch(ArrayIndexOutOfBoundsException e) {
                System.out.println("Inner catch: Array index error");
                // Modifying exception flow - throwing runtime exception
                throw new RuntimeException("Error from inner block");
            }
            
        } catch(RuntimeException e) {
            System.out.println("Outer catch: Runtime error - " + e.getMessage());
            
        } catch(Exception e) {
            System.out.println("Outer catch: General error");
            
        } finally {
            System.out.println("Outer finally: Cleanup");
        }
    }
}
\end{lstlisting}

\textbf{Key Features}:
\begin{itemize}
    \item \textbf{Layered Handling}: Specific errors handled in inner block, general errors in outer.
    \item \textbf{Flow}: If inner catch handles it, outer catch might not be reached unless re-thrown.
\end{itemize}
\end{solutionbox}

\questionmarks{5(a)}{3}{Explain thread synchronization with an executable code in JAVA.}

\begin{solutionbox}
\textbf{Thread Synchronization}:
Synchronization is the capability to control the access of multiple threads to any shared resource. It prevents thread interference and memory consistency errors.

\begin{lstlisting}[language=Java,caption={Thread Synchronization}]
class Counter {
    private int count = 0;
    
    // Synchronized method
    public synchronized void increment() {
        count++;
    }
    
    public int getCount() { return count; }
}

class SyncDemo extends Thread {
    Counter counter;
    
    SyncDemo(Counter c) { counter = c; }
    
    public void run() {
        for(int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}
\end{lstlisting}

\textbf{Benefits}:
\begin{itemize}
    \item \textbf{Data Consistency}: Essential when multiple threads modify the same data.
    \item \textbf{Thread Safety}: Ensures only one thread accesses the resource at a time.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Synchronize Secures Shared Data}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Enlist various stream classes in JAVA. Explain anyone with an executable example.}

\begin{solutionbox}
\textbf{Stream Classes}:
\begin{center}
\captionof{table}{Common Stream Classes}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Class} & \textbf{Purpose} & \textbf{Type} \\ \hline
\textbf{FileInputStream} & Read bytes from file & Byte Stream \\ \hline
\textbf{FileOutputStream} & Write bytes to file & Byte Stream \\ \hline
\textbf{BufferedReader} & Buffered character reading & Character Stream \\ \hline
\textbf{PrintWriter} & Formatted text output & Character Stream \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={FileInputStream Example}]
import java.io.*;

public class StreamDemo {
    public static void main(String[] args) {
        try {
            // Write data
            FileOutputStream fos = new FileOutputStream("test.txt");
            String data = "Hello World";
            fos.write(data.getBytes());
            fos.close();
            
            // Read data
            FileInputStream fis = new FileInputStream("test.txt");
            int ch;
            while((ch = fis.read()) != -1) {
                System.out.print((char)ch);
            }
            fis.close();
            
        } catch(IOException e) {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Streams Send Data}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Write a JAVA program extending Thread class to display odd numbers between given two integer numbers using thread.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Odd Number Thread}]
class OddNumberThread extends Thread {
    private int start;
    private int end;
    
    public OddNumberThread(int start, int end) {
        this.start = start;
        this.end = end;
    }
    
    @Override
    public void run() {
        System.out.println("Thread started: " + getName());
        
        for(int i = start; i <= end; i++) {
            if(i % 2 != 0) {  // Check if odd
                System.out.println("Odd number: " + i);
                try {
                    Thread.sleep(500);  // Pause
                } catch(InterruptedException e) {
                    System.out.println("Thread interrupted");
                }
            }
        }
        System.out.println("Thread completed: " + getName());
    }
}

public class OddNumberDemo {
    public static void main(String[] args) {
        // Create threads
        OddNumberThread t1 = new OddNumberThread(1, 10);
        
        t1.setName("OddThread-1");
        t1.start();
        
        try {
            t1.join(); // Wait for completion
        } catch(InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("Main thread completed");
    }
}
\end{lstlisting}

\textbf{Output}:
\begin{verbatim}
Thread started: OddThread-1
Odd number: 1
Odd number: 3
...
Odd number: 9
Thread completed: OddThread-1
Main thread completed
\end{verbatim}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Threads Take Turns}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{Explain join() and alive() methods of Thread class in JAVA.}

\begin{solutionbox}
\textbf{Thread Methods}:
\begin{itemize}
    \item \textbf{join()}: This method allows one thread to wait for the completion of another. If \code{t.join()} is called, the current thread pauses execution until thread \code{t} terminates.
    \item \textbf{isAlive()}: This method checks if a thread is still running. It returns \code{true} if the thread has started and not yet died, otherwise \code{false}.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Join and IsAlive}]
class TestThread extends Thread {
    public void run() {
        try { sleep(500); } catch(InterruptedException e) {}
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        TestThread t = new TestThread();
        System.out.println("Before start: " + t.isAlive()); // false
        
        t.start();
        System.out.println("After start: " + t.isAlive()); // true
        
        t.join(); // Wait for completion
        System.out.println("After join: " + t.isAlive()); // false
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Join Waits, Alive Checks}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{Define user-defined exceptions in JAVA. Write a program to show user defined exception.}

\begin{solutionbox}
\textbf{User-defined Exceptions}:
Java allows users to define their own exception classes by extending the \code{Exception} class (checked) or \code{RuntimeException} class (unchecked). These are used to handle application-specific logical errors.

\begin{lstlisting}[language=Java,caption={Custom Exception}]
// 1. Create custom exception class
class AgeValidationException extends Exception {
    public AgeValidationException(String message) {
        super(message);
    }
}

class Person {
    public void setAge(int age) throws AgeValidationException {
        if(age < 0) {
            throw new AgeValidationException("Age cannot be negative: " + age);
        }
        System.out.println("Valid age: " + age);
    }
}

public class UserDefinedExceptionDemo {
    public static void main(String[] args) {
        Person p = new Person();
        try {
            p.setAge(-5); // Invalid
        } catch(AgeValidationException e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Custom Exceptions Catch Specific Errors}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{Write a JAVA program to copy content of file a.txt to b.txt.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={File Copy Program}]
import java.io.*;

public class FileCopyDemo {
    public static void main(String[] args) {
        String source = "a.txt";
        String target = "b.txt";
        
        // Method: Using FileInputStream and FileOutputStream
        copyFile(source, target);
    }
    
    public static void copyFile(String src, String dest) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        
        try {
            // Initialize streams
            fis = new FileInputStream(src);
            fos = new FileOutputStream(dest);
            
            // Read and write byte by byte
            int ch;
            while((ch = fis.read()) != -1) {
                fos.write(ch);
            }
            
            System.out.println("File copied successfully!");
            
        } catch(FileNotFoundException e) {
            System.out.println("File not found: " + e.getMessage());
        } catch(IOException e) {
            System.out.println("IO Error: " + e.getMessage());
        } finally {
            // Close streams in finally block
            try {
                if(fis != null) fis.close();
                if(fos != null) fos.close();
            } catch(IOException e) {
                e.printStackTrace();
            }
        }
    }
}
\end{lstlisting}

\textbf{Logic}:
\begin{enumerate}
    \item Open source file in read mode using \code{FileInputStream}.
    \item Open destination file in write mode using \code{FileOutputStream}.
    \item Read byte from source and write to destination until end of file (-1).
    \item Close both streams to release system resources.
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Files Flow From Source To Target}
\end{mnemonicbox}

\end{document}


