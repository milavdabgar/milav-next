\documentclass{article}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Object Oriented Programming with Java (4341602) - Winter 2023 Solution}
\date{January 19, 2024}

\begin{document}
\questionmarks{1(અ)}{3}{OOP ના બેસિક કન્સેપ્ટની યાદી આપો. કોઈપણ એક વિગતવાર સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Basic OOP Concepts}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Basic OOP Concepts} & \textbf{વર્ણન} \\ \hline
\textbf{Class} & ઓબ્જેક્ટ માટે બ્લુપ્રિન્ટ \\ \hline
\textbf{Object} & ક્લાસનું ઇન્સ્ટન્સ \\ \hline
\textbf{Encapsulation} & ડેટા છુપાવવાની પદ્ધતિ \\ \hline
\textbf{Inheritance} & પેરેન્ટ થી પ્રોપર્ટીઝ મેળવવી \\ \hline
\textbf{Polymorphism} & એક ઇન્ટરફેસ, વિવિધ સ્વરૂપો \\ \hline
\textbf{Abstraction} & ઇમ્પ્લિમેન્ટેશન વિગતો છુપાવવા \\ \hline
\end{tabulary}
\end{center}

\textbf{Encapsulation} એ ડેટા અને મેથડ્સને એક સાથે ક્લાસમાં બાંધવાની અને બાહ્ય વિશ્વથી આંતરિક ઇમ્પ્લિમેન્ટેશન છુપાવવાની પ્રક્રિયા છે. તે વેરિયેબલ્સને private બનાવીને અને public મેથડ્સ દ્વારા એક્સેસ કરીને ડેટા સિક્યોરિટી પ્રદાન કરે છે.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEO-IPA} (Class, Encapsulation, Object, Inheritance, Polymorphism, Abstraction)
\end{mnemonicbox}

\questionmarks{1(બ)}{4}{JVM ને વિગતવાર સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block] (source) {Java Source Code};
    \node [gtu block, right=of source] (compiler) {Java Compiler};
    \node [gtu block, right=of compiler] (bytecode) {Bytecode .class};
    \node [gtu block, below=of bytecode] (jvm) {JVM};
    \node [gtu block, left=of jvm] (code) {Machine Code};
    \node [gtu block, left=of code] (output) {Output};

    \path [gtu arrow] (source) -- (compiler);
    \path [gtu arrow] (compiler) -- (bytecode);
    \path [gtu arrow] (bytecode) -- (jvm);
    \path [gtu arrow] (jvm) -- (code);
    \path [gtu arrow] (code) -- (output);
\end{tikzpicture}
\end{center}

\textbf{JVM (Java Virtual Machine)} એક રનટાઇમ એન્વાયરનમેન્ટ છે જે Java bytecode ને એક્ઝિક્યુટ કરે છે. તે bytecode ને મશીન-સ્પેસિફિક કોડમાં કન્વર્ટ કરીને પ્લેટફોર્મ ઇન્ડિપેન્ડન્સ પ્રદાન કરે છે.

\begin{itemize}
    \item \textbf{Class Loader}: ક્લાસ ફાઇલ્સને મેમરીમાં લોડ કરે છે
    \item \textbf{Memory Management}: heap અને stack મેમરી હેન્ડલ કરે છે
    \item \textbf{Execution Engine}: bytecode instructions ને એક્ઝિક્યુટ કરે છે
    \item \textbf{Garbage Collector}: ઓટોમેટિકલી મેમરી મેનેજ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CMEG} (Class loader, Memory, Execution, Garbage collection)
\end{mnemonicbox}

\questionmarks{1(ક)}{7}{Fibonacci series પ્રિન્ટ કરવા માટે n ટર્મ્સ માટે Java માં પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Fibonacci Series Program}]
public class Fibonacci {
    public static void main(String[] args) {
        int n = 10, first = 0, second = 1;
        System.out.print("Fibonacci Series: " + first + " " + second);
        
        for(int i = 2; i < n; i++) {
            int next = first + second;
            System.out.print(" " + next);
            first = second;
            second = next;
        }
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{લોજિક}: 0,1 થી શરૂ કરીને પાછલા બે નંબર્સ ઉમેરો
    \item \textbf{લૂપ}: n ટર્મ્સ માટે ચાલુ રહે છે
    \item \textbf{વેરિયેબલ્સ}: first, second, next કેલ્ક્યુલેશન માટે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FSN} (First, Second, Next)
\end{mnemonicbox}

\questionmarks{1(ક OR)}{7}{કમાન્ડ લાઇન arguments નો ઉપયોગ કરીને કોઈપણ દસ સંખ્યાઓ માંથી ન્યૂનતમ શોધવા માટે Java માં પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Find Minimum using CommandLine Arguments}]
public class FindMinimum {
    public static void main(String[] args) {
        if(args.length != 10) {
            System.out.println("Please enter exactly 10 numbers");
            return;
        }
        
        int min = Integer.parseInt(args[0]);
        for(int i = 1; i < args.length; i++) {
            int num = Integer.parseInt(args[i]);
            if(num < min) {
                min = num;
            }
        }
        System.out.println("Minimum number: " + min);
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{કમાન્ડ લાઇન}: \code{java FindMinimum 5 3 8 1 9 2 7 4 6 0}
    \item \textbf{લોજિક}: દરેક નંબરને કરન્ટ મિનિમમ સાથે કમ્પેર કરો
    \item \textbf{મેથડ}: \code{Integer.parseInt()} સ્ટ્રિંગને integer માં કન્વર્ટ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CIM} (Check, Integer.parseInt, Minimum)
\end{mnemonicbox}

\questionmarks{2(અ)}{3}{Wrapper ક્લાસ શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Wrapper Classes}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Primitive} & \textbf{Wrapper Class} \\ \hline
int & Integer \\ \hline
char & Character \\ \hline
boolean & Boolean \\ \hline
double & Double \\ \hline
\end{tabulary}
\end{center}

\textbf{Wrapper classes} primitive ડેટા ટાઇપ્સને ઓબ્જેક્ટ્સમાં કન્વર્ટ કરે છે. તેઓ utility મેથડ્સ પ્રદાન કરે છે અને primitives ને collections માં ઉપયોગ કરવા માટે સક્ષમ બનાવે છે.

\textbf{ઉદાહરણ}: \code{Integer obj = new Integer(25);} અથવા \code{Integer obj = 25;} (autoboxing)
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{POC} (Primitive to Object Conversion)
\end{mnemonicbox}

\questionmarks{2(બ)}{4}{Java ના વિવિધ લક્ષણોની યાદી આપો. કોઈપણ બે સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Java Features}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Java ના લક્ષણો} & \textbf{વર્ણન} \\ \hline
\textbf{Platform Independent} & એકવાર લખો, ગમે ત્યાં ચલાવો \\ \hline
\textbf{Object Oriented} & બધું ઓબ્જેક્ટ છે \\ \hline
\textbf{Simple} & સરળ સિન્ટેક્સ, પોઇન્ટર્સ નથી \\ \hline
\textbf{Secure} & Bytecode વેરિફિકેશન \\ \hline
\textbf{Robust} & મજબૂત મેમરી મેનેજમેન્ટ \\ \hline
\textbf{Multithreaded} & સમાંતર એક્ઝિક્યુશન \\ \hline
\end{tabulary}
\end{center}

\textbf{Platform Independence}: Java સોર્સ કોડ bytecode માં કમ્પાઇલ થાય છે જે JVM ઇન્સ્ટોલ કરેલા કોઈપણ પ્લેટફોર્મ પર ચાલે છે.

\textbf{Object Oriented}: Java બહેતર કોડ સંગઠન માટે encapsulation, inheritance, અને polymorphism જેવા OOP સિદ્ધાંતોને અનુસરે છે.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{POSSMR} (Platform, Object, Simple, Secure, Multithreaded, Robust)
\end{mnemonicbox}

\questionmarks{2(ક)}{7}{Method overload શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{Method Overloading} એ જ ક્લાસમાં સમાન નામ પરંતુ અલગ પેરામીટર્સ સાથે બહુવિધ મેથડ્સની મંજૂરી આપે છે.

\begin{lstlisting}[language=Java,caption={Method Overloading}]
class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{નિયમો}: અલગ પેરામીટર ટાઇપ્સ અથવા પેરામીટર્સની સંખ્યા
    \item \textbf{Compile Time}: કમ્પાઇલેશન દરમિયાન નિર્ણય લેવાય છે
    \item \textbf{Return Type}: માત્ર તફાવત હોઈ શકતો નથી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SNRT} (Same Name, different paRameters, compile Time)
\end{mnemonicbox}

\questionmarks{2(અ OR)}{3}{Java માં Garbage collection સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[node distance=0cm]
    \node [gtu block, text width=6cm, fill=blue!5] (method) {Method Area\\(Class Definitions)};
    \node [gtu block, text width=6cm, fill=green!5, above=of method] (stack) {Stack\\(Method Calls)};
    \node [gtu block, text width=6cm, fill=red!5, above=of stack] (heap) {Heap\\(Objects Stored Here)};
    
    \node [right=0.5cm of heap, align=left] {$\leftarrow$ Objects stored here};
    \node [right=0.5cm of stack, align=left] {$\leftarrow$ Method calls};
    \node [right=0.5cm of method, align=left] {$\leftarrow$ Class definitions};
\end{tikzpicture}
\end{center}

\textbf{Garbage Collection} અનરેફરન્સ્ડ ઓબ્જેક્ટ્સની મેમરી ઓટોમેટિકલી deallocate કરે છે. JVM પીરિયોડિકલી garbage collector ચલાવીને heap મેમરી મુક્ત કરે છે.

\begin{itemize}
    \item \textbf{ઓટોમેટિક}: મેન્યુઅલ મેમરી મેનેજમેન્ટની જરૂર નથી
    \item \textbf{Mark and Sweep}: અનરેફરન્સ્ડ ઓબ્જેક્ટ્સને માર્ક કરે છે, પછી દૂર કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ARMS} (Automatic Reference Management System)
\end{mnemonicbox}

\questionmarks{2(બ OR)}{4}{final કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Final Keyword Usage}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઉપયોગ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{final variable} & બદલી શકાતું નથી & \code{final int x = 10;} \\ \hline
\textbf{final method} & ઓવરરાઇડ થઈ શકતું નથી & \code{final void display()} \\ \hline
\textbf{final class} & inherit થઈ શકતું નથી & \code{final class MyClass} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Final Keyword Example}]
final class FinalClass {
    final int value = 100;
    final void show() {
        System.out.println("Final method");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{VCM} (Variable constant, Class not inherited, Method not overridden)
\end{mnemonicbox}

\questionmarks{2(ક OR)}{7}{કન્સ્ટ્રક્ટર શું છે? parameterized કન્સ્ટ્રક્ટરને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{Constructor} એક વિશેષ મેથડ છે જે ઓબ્જેક્ટ્સ બનાવવામાં આવે ત્યારે initialize કરે છે. તેનું નામ ક્લાસ જેવું જ હોય છે અને કોઈ return type નથી.

\begin{lstlisting}[language=Java,caption={Parameterized Constructor}]
class Student {
    String name;
    int age;
    
    // Parameterized Constructor
    public Student(String n, int a) {
        name = n;
        age = a;
    }
    
    public void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}

class Main {
    public static void main(String[] args) {
        Student s1 = new Student("John", 20);
        s1.display();
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{હેતુ}: ઓબ્જેક્ટને સ્પેસિફિક વેલ્યુઝ સાથે initialize કરવો
    \item \textbf{પેરામીટર્સ}: initial state સેટ કરવા માટે arguments સ્વીકારે છે
    \item \textbf{ઓટોમેટિક}: ઓબ્જેક્ટ બનાવવામાં આવે ત્યારે ઓટોમેટિકલી કોલ થાય છે
\end{itemize}
\end{solutionbox}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SPA} (Same name, Parameters, Automatic call)
\end{mnemonicbox}

\questionmarks{3(અ)}{3}{super કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{super કીવર્ડ} પેરેન્ટ ક્લાસના મેમ્બર્સ અને કન્સ્ટ્રક્ટરનો સંદર્ભ આપે છે. તે પેરેન્ટ અને ચાઇલ્ડ ક્લાસ વચ્ચેના naming conflicts ને ઉકેલે છે.

\begin{lstlisting}[language=Java,caption={Super Keyword Example}]
class Parent {
    int x = 10;
}
class Child extends Parent {
    int x = 20;
    void display() {
        System.out.println(super.x); // 10
        System.out.println(x);       // 20
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{super.variable}: પેરેન્ટ ક્લાસ variable ને એક્સેસ કરે છે
    \item \textbf{super.method()}: પેરેન્ટ ક્લાસ method ને કોલ કરે છે
    \item \textbf{super()}: પેરેન્ટ ક્લાસ constructor ને કોલ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{VMC} (Variable, Method, Constructor)
\end{mnemonicbox}

\questionmarks{3(બ)}{4}{inheritance ના વિવિધ પ્રકારોની યાદી આપો. multilevel inheritance સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Inheritance Types}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Inheritance ના પ્રકારો} & \textbf{વર્ણન} \\ \hline
\textbf{Single} & એક પેરેન્ટ, એક ચાઇલ્ડ \\ \hline
\textbf{Multilevel} & inheritance ની ચેઇન \\ \hline
\textbf{Hierarchical} & એક પેરેન્ટ, બહુવિધ બાળકો \\ \hline
\textbf{Multiple} & બહુવિધ પેરેન્ટ્સ (interfaces દ્વારા) \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block] (animal) {Animal};
    \node [gtu block, right=of animal] (mammal) {Mammal};
    \node [gtu block, right=of mammal] (dog) {Dog};
    
    \path [gtu arrow] (animal) -- (mammal);
    \path [gtu arrow] (mammal) -- (dog);
\end{tikzpicture}
\end{center}

\textbf{Multilevel Inheritance}: ક્લાસ બીજી ક્લાસથી inherit કરે છે જે પોતે બીજી ક્લાસથી inherit કરે છે, ચેઇન બનાવે છે.

\begin{lstlisting}[language=Java,caption={Multilevel Inheritance}]
class Animal {
    void eat() { System.out.println("Eating"); }
}
class Mammal extends Animal {
    void walk() { System.out.println("Walking"); }
}
class Dog extends Mammal {
    void bark() { System.out.println("Barking"); }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SMHM} (Single, Multilevel, Hierarchical, Multiple)
\end{mnemonicbox}

\questionmarks{3(ક)}{7}{Interface શું છે? ઉદાહરણ સાથે multiple inheritance સમજાવો.}

\begin{solutionbox}
\textbf{Interface} એક કોન્ટ્રાક્ટ છે જે વ્યાખ્યાયિત કરે છે કે ક્લાસે કયા મેથડ્સ implement કરવા જોઈએ. તેમાં માત્ર abstract methods અને constants હોય છે.

\begin{lstlisting}[language=Java,caption={Multiple Inheritance with Interface}]
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    public void fly() {
        System.out.println("Duck is flying");
    }
    
    public void swim() {
        System.out.println("Duck is swimming");
    }
}
\end{lstlisting}

\textbf{Multiple Inheritance}: ક્લાસ બહુવિધ interfaces implement કરી શકે છે, behavior નું multiple inheritance પ્રાપ્ત કરે છે.

\begin{itemize}
    \item \textbf{Abstract Methods}: બધા મેથડ્સ ડિફોલ્ટ રીતે abstract હોય છે
    \item \textbf{Constants}: બધા variables public, static, final હોય છે
    \item \textbf{implements}: interface implement કરવા માટેનો કીવર્ડ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ACI} (Abstract methods, Constants, implements keyword)
\end{mnemonicbox}

\questionmarks{3(અ OR)}{3}{static કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{static કીવર્ડ} ક્લાસ-લેવલ મેમ્બર્સ બનાવે છે જે instances ને બદલે ક્લાસના હોય છે. ક્લાસ લોડ થાય ત્યારે એકવાર મેમરી allocate થાય છે.

\begin{lstlisting}[language=Java,caption={Static Keyword}]
class Counter {
    static int count = 0;
    static void increment() {
        count++;
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{static variable}: બધા ઓબ્જેક્ટ્સ વચ્ચે શેર થાય છે
    \item \textbf{static method}: ઓબ્જેક્ટ બનાવ્યા વિના કોલ કરી શકાય છે
    \item \textbf{મેમરી}: method area માં allocate થાય છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SOM} (Shared, Object not needed, Method area)
\end{mnemonicbox}

\questionmarks{3(બ OR)}{4}{Java માં વિવિધ એક્સેસ કંટ્રોલ સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Access Modifiers}
\begin{tabulary}{\linewidth}{|L|C|C|C|C|}
\hline
\textbf{Access Modifier} & \textbf{Same Class} & \textbf{Same Package} & \textbf{Subclass} & \textbf{Diff Package} \\ \hline
\textbf{private} & \checkmark & \ding{55} & \ding{55} & \ding{55} \\ \hline
\textbf{default} & \checkmark & \checkmark & \ding{55} & \ding{55} \\ \hline
\textbf{protected} & \checkmark & \checkmark & \checkmark & \ding{55} \\ \hline
\textbf{public} & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline
\end{tabulary}
\end{center}

\textbf{Access Control} ક્લાસિસ, મેથડ્સ અને variables ની visibility અને accessibility નક્કી કરે છે.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PriDef ProPub} (Private, Default, Protected, Public)
\end{mnemonicbox}

\questionmarks{3(ક OR)}{7}{પેકેજ શું છે? પેકેજ બનાવવાના પગલાં લખો અને તેનું ઉદાહરણ આપો.}

\begin{solutionbox}
\textbf{Package} એક namespace છે જે સંબંધિત ક્લાસિસ અને interfaces ને ગોઠવે છે. તે access protection અને namespace management પ્રદાન કરે છે.

\textbf{પેકેજ બનાવવાના પગલાં}:
\begin{enumerate}
    \item ફાઇલની ટોચે \code{package} statement નો ઉપયોગ કરો
    \item પેકેજ નામને મેચ કરતી directory structure બનાવો
    \item \code{-d} ઓપ્શન સાથે કમ્પાઇલ કરો
    \item અન્ય ફાઇલ્સમાં પેકેજ import કરો
\end{enumerate}

\begin{lstlisting}[language=Java,caption={Package creation and usage}]
// File: com/mycompany/MyClass.java
package com.mycompany;

public class MyClass {
    public void display() {
        System.out.println("Package example");
    }
}

// પેકેજનો ઉપયોગ
import com.mycompany.MyClass;

class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.display();
    }
}
\end{lstlisting}

\textbf{કમ્પાઇલેશન}: \code{javac -d . MyClass.java}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PDCI} (Package statement, Directory, Compile, Import)
\end{mnemonicbox}

\questionmarks{4(અ)}{3}{યોગ્ય ઉદાહરણ સાથે thread ની પ્રાથમિકતાઓ સમજાવો.}

\begin{solutionbox}
\textbf{Thread Priority} threads ના execution order નક્કી કરે છે. Java 1 (સૌથી નીચું) થી 10 (સૌથી ઊંચું) સુધી 10 priority levels પ્રદાન કરે છે.

\begin{lstlisting}[language=Java,caption={Thread Priority}]
class MyThread extends Thread {
    public void run() {
        System.out.println(getName() + " Priority: " + getPriority());
    }
}

class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        t1.setPriority(Thread.MIN_PRIORITY); // 1
        t2.setPriority(Thread.MAX_PRIORITY); // 10
        
        t1.start();
        t2.start();
    }
}
\end{lstlisting}

\textbf{Priority Constants}: MIN\_PRIORITY (1), NORM\_PRIORITY (5), MAX\_PRIORITY (10)
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MNM} (MIN, NORM, MAX)
\end{mnemonicbox}

\questionmarks{4(બ)}{4}{Thread શું છે? Thread લાઇફ સાઇકલ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu state] (new) {New};
    \node [gtu state, right=of new] (runnable) {Runnable};
    \node [gtu state, right=of runnable] (running) {Running};
    \node [gtu state, right=of running] (dead) {Dead};
    \node [gtu state, below=of running] (blocked) {Blocked};

    \path [gtu arrow] (new) -- node {start()} (runnable);
    \path [gtu arrow] (runnable) -- node {Scheduler} (running);
    \path [gtu arrow] (running) -- node {completes} (dead);
    \path [gtu arrow] (running) edge[bend right] node[left] {wait/sleep} (blocked);
    \path [gtu arrow] (blocked) edge[bend right] node[right] {notify/timeout} (runnable);
    \path [gtu arrow] (running) edge[bend left] node[above] {yield()} (runnable);
\end{tikzpicture}
\end{center}

\textbf{Thread} એક lightweight subprocess છે જે પ્રોગ્રામની અંદર concurrent execution ને સક્ષમ બનાવે છે.

\textbf{Thread Life Cycle States}:
\begin{itemize}
    \item \textbf{New}: Thread બનાવ્યો પરંતુ શરૂ નથી કર્યો
    \item \textbf{Runnable}: ચલાવવા માટે તૈયાર, CPU ની રાહ જોઈ રહ્યો
    \item \textbf{Running}: હાલમાં execute થઈ રહ્યો
    \item \textbf{Blocked}: resource અથવા I/O ની રાહ જોઈ રહ્યો
    \item \textbf{Dead}: Thread execution પૂર્ણ થયું
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NRRBD} (New, Runnable, Running, Blocked, Dead)
\end{mnemonicbox}

\questionmarks{4(ક)}{7}{Java માં એક પ્રોગ્રામ લખો જે Thread ક્લાસ implement કરીને બહુવિધ threads બનાવે છે.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Multiple Threads}]
class MyThread extends Thread {
    private String threadName;
    
    public MyThread(String name) {
        threadName = name;
        setName(threadName);
    }
    
    public void run() {
        for(int i = 1; i <= 5; i++) {
            System.out.println(threadName + " - Count: " + i);
            try {
                Thread.sleep(1000);
            } catch(InterruptedException e) {
                System.out.println(threadName + " interrupted");
            }
        }
        System.out.println(threadName + " completed");
    }
}

class Main {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread("Thread-1");
        MyThread thread2 = new MyThread("Thread-2");
        MyThread thread3 = new MyThread("Thread-3");
        
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{extends Thread}: Thread ક્લાસની કાર્યક્ષમતા inherit કરે છે
    \item \textbf{Override run()}: Thread execution લોજિક વ્યાખ્યાયિત કરે છે
    \item \textbf{start()}: Thread execution શરૂ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EOS} (Extends, Override run, Start method)
\end{mnemonicbox}

\questionmarks{4(અ OR)}{3}{ચાર અલગ-અલગ ઇનબિલ્ટ exception ની યાદી આપો. કોઈપણ એક ઇનબિલ્ટ exception સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Inbuilt Exceptions}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Inbuilt Exceptions} & \textbf{વર્ણન} \\ \hline
\textbf{NullPointerException} & Null reference access \\ \hline
\textbf{ArrayIndexOutOfBoundsException} & Invalid array index \\ \hline
\textbf{NumberFormatException} & Invalid number format \\ \hline
\textbf{ClassCastException} & Invalid type casting \\ \hline
\end{tabulary}
\end{center}

\textbf{NullPointerException} ત્યારે થાય છે જ્યારે null reference ના methods અથવા variables ને access કરવાનો પ્રયાસ કરવામાં આવે છે.

\begin{lstlisting}[language=Java,caption={NullPointerException}]
String str = null;
int length = str.length(); // Throws NullPointerException
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NANC} (NullPointer, ArrayIndex, NumberFormat, ClassCast)
\end{mnemonicbox}

\questionmarks{4(બ OR)}{4}{યોગ્ય ઉદાહરણ સાથે multiple catch સમજાવો.}

\begin{solutionbox}
\textbf{Multiple catch} blocks try block માં થઈ શકતા વિવિધ પ્રકારના exceptions ને handle કરે છે. દરેક catch સ્પેસિફિક exception type ને handle કરે છે.

\begin{lstlisting}[language=Java,caption={Multiple Catch Blocks}]
class MultipleCatch {
    public static void main(String[] args) {
        try {
            int[] arr = {1, 2, 3};
            System.out.println(arr[5]); // ArrayIndexOutOfBoundsException
            int result = 10/0;          // ArithmeticException
        }
        catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error: " + e.getMessage());
        }
        catch(ArithmeticException e) {
            System.out.println("Arithmetic error: " + e.getMessage());
        }
        catch(Exception e) {
            System.out.println("General error: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\textbf{ક્રમ}: પહેલા સ્પેસિફિક exceptions, છેલ્લે જનરલ exceptions
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SGO} (Specific first, General last, Ordered)
\end{mnemonicbox}

\questionmarks{4(ક OR)}{7}{Exception શું છે? Arithmetic Exception નો ઉપયોગ દર્શાવતો પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{Exception} એક અસામાન્ય સ્થિતિ છે જે સામાન્ય પ્રોગ્રામ flow ને વિક્ષેપિત કરે છે. તે error condition ને દર્શાવતો ઓબ્જેક્ટ છે.

\begin{lstlisting}[language=Java,caption={ArithmeticException Handling}]
class ArithmeticExceptionDemo {
    public static void main(String[] args) {
        int numerator = 100;
        int[] denominators = {5, 0, 2, 0, 10};
        
        for(int i = 0; i < denominators.length; i++) {
            try {
                int result = numerator / denominators[i];
                System.out.println(numerator + " / " + denominators[i] + " = " + result);
            }
            catch(ArithmeticException e) {
                System.out.println("Error: Cannot divide by zero!");
                System.out.println("Exception message: " + e.getMessage());
            }
        }
        
        System.out.println("Program continues after exception handling");
    }
}
\end{lstlisting}

\textbf{ArithmeticException} ત્યારે throw થાય છે જ્યારે ગાણિતિક ભૂલ થાય છે જેમ કે શૂન્ય વડે ભાગાકાર.

\textbf{Exception Hierarchy}: Object $\to$ Throwable $\to$ Exception $\to$ RuntimeException $\to$ ArithmeticException
\end{solutionbox}


\begin{mnemonicbox}
\mnemonic{OTERRA} (Object, Throwable, Exception, RuntimeException, ArithmeticException)
\end{mnemonicbox}

\questionmarks{5(અ)}{3}{Java માં ArrayIndexOutOfBound Exception ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{ArrayIndexOutOfBoundsException} ત્યારે થાય છે જ્યારે invalid index (negative અથવા >= array length) સાથે array element access કરવામાં આવે છે.

\begin{lstlisting}[language=Java,caption={ArrayIndexOutOfBoundsException}]
class ArrayException {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30};
        
        try {
            System.out.println(numbers[5]); // Invalid index
        }
        catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Invalid array index: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{Valid Range}: 0 થી (length-1)
    \item \textbf{Runtime Exception}: Unchecked exception
    \item \textbf{સામાન્ય કારણ}: Loop condition errors
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{VRC} (Valid range, Runtime exception, Common in loops)
\end{mnemonicbox}

\questionmarks{5(બ)}{4}{Stream classes ના બેઝિક્સ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block] (stream) {Stream Classes};
    \node [gtu block, below left=of stream, text width=3cm] (byte) {Byte Streams};
    \node [gtu block, below right=of stream, text width=3cm] (char) {Character Streams};
    
    \node [gtu block, below=0.5cm of byte, text width=3cm] (input) {InputStream};
    \node [gtu block, below=0.5cm of input, text width=3cm] (output) {OutputStream};
    
    \node [gtu block, below=0.5cm of char, text width=3cm] (reader) {Reader};
    \node [gtu block, below=0.5cm of reader, text width=3cm] (writer) {Writer};

    \path [gtu arrow] (stream) -- (byte);
    \path [gtu arrow] (stream) -- (char);
    \path [gtu arrow] (byte) -- (input);
    \path [gtu arrow] (byte) -- (output);
    \path [gtu arrow] (char) -- (reader);
    \path [gtu arrow] (char) -- (writer);
\end{tikzpicture}
\end{center}

\textbf{Stream Classes} ડેટા વાંચવા અને લખવા માટે input/output operations પ્રદાન કરે છે.

\begin{center}
\captionof{table}{Stream Classes}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Stream Type} & \textbf{હેતુ} & \textbf{Base Classes} \\ \hline
\textbf{Byte Streams} & Binary ડેટા & InputStream, OutputStream \\ \hline
\textbf{Character Streams} & Text ડેટા & Reader, Writer \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{Input Streams}: સોર્સ માંથી ડેટા વાંચે છે
    \item \textbf{Output Streams}: ડેસ્ટિનેશન પર ડેટા લખે છે
    \item \textbf{Buffered Streams}: Buffering સાથે પર્ફોર્મન્સ સુધારે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BIOC} (Byte, Input/Output, Character streams)
\end{mnemonicbox}

\questionmarks{5(ક)}{7}{Text ફાઇલ બનાવવા અને text ફાઇલ પર read operation કરવા માટે java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={File Create and Read}]
import java.io.*;

class FileOperations {
    public static void main(String[] args) {
        // ફાઇલ બનાવો અને લખો
        try {
            FileWriter writer = new FileWriter("sample.txt");
            writer.write("Hello World!\n");
            writer.write("This is Java file handling example.\n");
            writer.write("Learning Input/Output operations.");
            writer.close();
            System.out.println("File created and written successfully.");
        }
        catch(IOException e) {
            System.out.println("Error creating file: " + e.getMessage());
        }
        
        // ફાઇલ માંથી વાંચો
        try {
            FileReader reader = new FileReader("sample.txt");
            BufferedReader bufferedReader = new BufferedReader(reader);
            String line;
            
            System.out.println("\nFile contents:");
            while((line = bufferedReader.readLine()) != null) {
                System.out.println(line);
            }
            
            bufferedReader.close();
            reader.close();
        }
        catch(IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{FileWriter}: ટેક્સ્ટ ફાઇલ બનાવે છે અને લખે છે
    \item \textbf{FileReader}: ટેક્સ્ટ ફાઇલ માંથી વાંચે છે
    \item \textbf{BufferedReader}: કાર્યક્ષમ line-by-line વાંચન
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{WRB} (Writer creates, Reader reads, Buffered for efficiency)
\end{mnemonicbox}

\questionmarks{5(અ OR)}{3}{Java માં Divide by Zero Exception ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{ArithmeticException (Divide by Zero)} ત્યારે થાય છે જ્યારે integer ને શૂન્ય વડે ભાગવામાં આવે છે. Floating-point division by zero Infinity પરત કરે છે.

\begin{lstlisting}[language=Java,caption={Divide By Zero}]
class DivideByZeroExample {
    public static void main(String[] args) {
        try {
            int result = 10 / 0; // Throws ArithmeticException
            System.out.println("Result: " + result);
        }
        catch(ArithmeticException e) {
            System.out.println("Cannot divide by zero!");
        }
        
        // Floating point division
        double floatResult = 10.0 / 0.0; // Returns Infinity
        System.out.println("Float result: " + floatResult);
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{Integer Division}: ArithmeticException throw કરે છે
    \item \textbf{Float Division}: Infinity અથવા NaN પરત કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{IFI} (Integer throws exception, Float returns Infinity)
\end{mnemonicbox}

\questionmarks{5(બ OR)}{4}{Java I/O process સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block, text width=3cm] (source) {Source\\(File, Keyboard, Network)};
    \node [gtu block, right=of source, text width=3cm] (stream) {Stream\\(Reader/Writer, IO Stream)};
    \node [gtu block, right=of stream, text width=3cm] (dest) {Destination\\(File, Screen, Network)};
    
    \path [gtu arrow] (source) -- (stream);
    \path [gtu arrow] (stream) -- (dest);
\end{tikzpicture}
\end{center}

\textbf{Java I/O Process} streams નો ઉપયોગ કરીને પ્રોગ્રામ અને બાહ્ય સોર્સિસ વચ્ચે ડેટા ટ્રાન્સફર handle કરે છે.

\begin{center}
\captionof{table}{I/O Process Components}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઘટક} & \textbf{હેતુ} \\ \hline
\textbf{Source} & ડેટા મૂળ (ફાઇલ, કીબોર્ડ, નેટવર્ક) \\ \hline
\textbf{Stream} & ડેટા પથ (byte/character streams) \\ \hline
\textbf{Destination} & ડેટા લક્ષ્ય (ફાઇલ, સ્ક્રીન, નેટવર્ક) \\ \hline
\end{tabulary}
\end{center}

\textbf{પ્રક્રિયાના પગલાં}:
\begin{enumerate}
    \item \textbf{Open Stream}: સોર્સ/ડેસ્ટિનેશન સાથે કનેક્શન બનાવો
    \item \textbf{Process Data}: રીડ/રાઇટ ઓપરેશન્સ
    \item \textbf{Close Stream}: રિસોર્સિસ મુક્ત કરો
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{OPC} (Open, Process, Close)
\end{mnemonicbox}

\questionmarks{5(ક OR)}{7}{ટેક્સ્ટ ફાઇલના કન્ટેન્ટ ડિસ્પ્લે કરવા માટે Java પ્રોગ્રામ લખો અને ટેક્સ્ટ ફાઇલ પર append ઓપરેશન કરો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={File Append Operation}]
import java.io.*;

class FileAppendExample {
    public static void main(String[] args) {
        String fileName = "data.txt";
        
        // પ્રારંભિક ફાઇલ કન્ટેન્ટ બનાવો
        try {
            FileWriter writer = new FileWriter(fileName);
            writer.write("Initial content line 1\n");
            writer.write("Initial content line 2\n");
            writer.close();
            System.out.println("Initial file created.");
        }
        catch(IOException e) {
            System.out.println("Error creating file: " + e.getMessage());
        }
        
        // ફાઇલ કન્ટેન્ટ ડિસ્પ્લે કરો
        displayFileContent(fileName);
        
        // ફાઇલમાં append કરો
        try {
            FileWriter appendWriter = new FileWriter(fileName, true); // true for append
            appendWriter.write("Appended line 1\n");
            appendWriter.write("Appended line 2\n");
            appendWriter.close();
            System.out.println("\nContent appended successfully.");
        }
        catch(IOException e) {
            System.out.println("Error appending to file: " + e.getMessage());
        }
        
        // અપડેટેડ કન્ટેન્ટ ડિસ્પ્લે કરો
        System.out.println("\nFile content after append:");
        displayFileContent(fileName);
    }
    
    static void displayFileContent(String fileName) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            String line;
            System.out.println("\nFile contents:");
            while((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            reader.close();
        }
        catch(IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{FileWriter(filename, true)}: Append mode સક્ષમ
    \item \textbf{displayFileContent()}: રીડિંગ માટે પુનઃઉપયોગ કરી શકાય તેવી મેથડ
    \item \textbf{BufferedReader}: કાર્યક્ષમ line રીડિંગ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ARB} (Append mode, Reusable method, Buffered reading)
\end{mnemonicbox}

\end{document}


