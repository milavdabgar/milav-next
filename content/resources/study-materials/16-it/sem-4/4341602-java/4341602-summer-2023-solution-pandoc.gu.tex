\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4341602 -- Summer 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{પ્રોસિજર-ઓરિએન્ટેડ પ્રોગ્રામિંગ (POP) અને ઑબ્જેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગ (OOP)
વચ્ચે તફાવત કરો.}

\begin{solutionbox}

\textbf{ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3125}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3125}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
POP
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
OOP
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ધ્યાન} & ફંક્શન્સ/પ્રોસિજર્સ & ઑબ્જેક્ટ્સ અને ક્લાસ્સિઝ \\
\textbf{ડેટા સિક્યોરિટી} & ઓછી સુરક્ષા, ગ્લોબલ ડેટા & વધુ સુરક્ષા, ડેટા
encapsulation \\
\textbf{સમસ્યા ઉકેલ} & ટોપ-ડાઉન એપ્રોચ & બોટમ-અપ એપ્રોચ \\
\textbf{કોડ પુનઃઉપયોગ} & મર્યાદિત & inheritance દ્વારા વધુ \\
\textbf{ઉદાહરણો} & C, Pascal & Java, C++, Python \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{POP}: પ્રોગ્રામ ફંક્શન્સમાં વિભાજિત, ડેટા ફંક્શન્સ વચ્ચે વહે છે
\item
  \textbf{OOP}: પ્રોગ્રામ ઑબ્જેક્ટ્સની આસપાસ ગોઠવાયેલું જેમાં ડેટા અને મેથડ્સ બંને હોય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``POP ફંક્શન્સ, OOP ઑબ્જેક્ટ્સ''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે inheritance માં Super કીવર્ડ સમજાવો.}

\begin{solutionbox}

\textbf{Super કીવર્ડ} નો ઉપયોગ child class માંથી parent class ના members ને
access કરવા માટે થાય છે.

\textbf{ટેબલ: Super કીવર્ડના ઉપયોગો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઉપયોગ & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{super()} & parent constructor ને કૉલ કરે & super(name, age) \\
\textbf{super.method()} & parent method ને કૉલ કરે & super.display() \\
\textbf{super.variable} & parent variable ને access કરે & super.name \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Animal \{
    String name = "Animal";
    void eat() \{ System.out.println("Animal eats"); \}
\}

class Dog extends Animal \{
    String name = "Dog";
    void eat() \{
        super.eat(); // parent method ને કૉલ કરે છે
        System.out.println("Dog eats bones");
    \}
    void display() \{
        System.out.println(super.name); // "Animal" પ્રિન્ટ કરે છે
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Super Parent ને કૉલ કરે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{વ્યાખ્યાયિત કરો: મેથડ ઓવરરાઇડિંગ. મેથડ ઓવરરાઇડિંગ માટેના નિયમોની યાદી
બનાવો. એક જાવા પ્રોગ્રામ લખો જે મેથડ ઓવરરાઇડિંગને implement કરે છે.}

\begin{solutionbox}

\textbf{મેથડ ઓવરરાઇડિંગ}: Child class પોતાની parent class ના method નું
specific implementation આપે છે સમાન signature સાથે.

\textbf{ટેબલ: મેથડ ઓવરરાઇડિંગના નિયમો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
નિયમ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સમાન નામ} & મેથડનું નામ સમાન હોવું જોઈએ \\
\textbf{સમાન parameters} & Parameter list બરાબર મેચ થવી જોઈએ \\
\textbf{IS-A સંબંધ} & inheritance હોવું જરૂરી \\
\textbf{Access modifier} & visibility ઘટાડી શકાતી નથી \\
\textbf{Return type} & સમાન અથવા covariant હોવું જોઈએ \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Shape \{
    void draw() \{
        System.out.println("Drawing a shape");
    \}
\}

class Circle extends Shape \{
    @Override
    void draw() \{
        System.out.println("Drawing a circle");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Shape s = new Circle();
        s.draw(); // આઉટપુટ: Drawing a circle
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Override સમાન Signature''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{વર્ણવો: ઇન્ટરફેસ. મલ્ટિપલ inheritance ને દર્શાવવા માટે interface નો
ઉપયોગ કરીને જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{Interface}: blueprint જેમાં abstract methods અને constants હોય છે.
Classes interfaces ને implement કરીને multiple inheritance પ્રાપ્ત કરે છે.

\textbf{ટેબલ: Interface ની વિશેષતાઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Abstract methods} & કોઈ implementation નથી (Java 8 પહેલાં) \\
\textbf{Constants} & બધા variables public static final છે \\
\textbf{Multiple inheritance} & Class અનેક interfaces implement કરી શકે \\
\textbf{Default methods} & Concrete methods (Java 8+) \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
interface Flyable \{
    void fly();
\}

interface Swimmable \{
    void swim();
\}

class Duck implements Flyable, Swimmable \{
    public void fly() \{
        System.out.println("Duck flies");
    \}
    
    public void swim() \{
        System.out.println("Duck swims");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Duck d = new Duck();
        d.fly();
        d.swim();
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Interface Multiple Implementation''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{ઉદાહરણ સાથે Java પ્રોગ્રામ સ્ટ્રક્ચર સમજાવો.}

\begin{solutionbox}

\textbf{Java પ્રોગ્રામ સ્ટ્રક્ચર} માં package, imports, class declaration અને
main method હોય છે.

\textbf{આકૃતિ:}

\begin{verbatim}
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Package statement|
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Import statements|
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Class declaration|
| +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |}
| | Variables   |  |
| +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |}
| | Methods     |  |
| +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+  |}
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
package com.example;        // Package
import java.util.*;         // Import

public class HelloWorld \{   // Class
    static int count = 0;   // Variable
    
    public static void main(String[] args) \{ // Main method
        System.out.println("Hello World");
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Package Import Class Main''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે static કીવર્ડ સમજાવો.}

\begin{solutionbox}

\textbf{Static કીવર્ડ} class નું છે instance નું નહીં. memory એક વાર allocate
થાય છે.

\textbf{ટેબલ: Static ના ઉપયોગો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Static variable} & બધા objects દ્વારા shared & static int
count \\
\textbf{Static method} & object વિના કૉલ થાય & static void display() \\
\textbf{Static block} & main પહેલાં execute થાય & static \{ \} \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Student \{
    static String college = "GTU";  // static variable
    String name;
    
    static void showCollege() \{     // static method
        System.out.println(college);
    \}
    
    static \{                        // static block
        System.out.println("Static block executed");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Student.showCollege(); // કોઈ object ની જરૂર નથી
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Static Class દ્વારા Shared''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{વ્યાખ્યાયિત કરો: કન્સ્ટ્રક્ટર. તેના પ્રકારોની યાદી બનાવો. પેરામીટરાઇઝ્ડ અને
કોપી કન્સ્ટ્રક્ટરને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{કન્સ્ટ્રક્ટર}: objects ને initialize કરવા માટેની special method, class
જેવું જ નામ, કોઈ return type નથી.

\textbf{ટેબલ: કન્સ્ટ્રક્ટરના પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default} & કોઈ parameters નથી & Student() \\
\textbf{Parameterized} & parameters સાથે & Student(String name) \\
\textbf{Copy} & object ની copy બનાવે & Student(Student s) \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Student \{
    String name;
    int age;
    
    // Parameterized constructor
    Student(String n, int a) \{
        name = n;
        age = a;
    \}
    
    // Copy constructor
    Student(Student s) \{
        name = s.name;
        age = s.age;
    \}
    
    void display() \{
        System.out.println(name + " " + age);
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Student s1 = new Student("John", 20);  // Parameterized
        Student s2 = new Student(s1);          // Copy
        s1.display();
        s2.display();
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Constructor Objects ને Initialize કરે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{જાવામાં પ્રિમિટિવ ડેટા પ્રકારો અને યુઝર ડિફાઇન્ડ ડેટા પ્રકારો સમજાવો.}

\begin{solutionbox}

\textbf{પ્રિમિટિવ ડેટા ટાઇપ્સ}: Java language દ્વારા આપવામાં આવેલા built-in
types. \textbf{યુઝર ડિફાઇન્ડ ટાઇપ્સ}: programmer દ્વારા classes વાપરીને
બનાવવામાં આવેલા custom types.

\textbf{ટેબલ: ડેટા ટાઇપ્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
કેટેગરી & પ્રકારો & સાઇઝ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Primitive} & byte, short, int, long & 1,2,4,8 bytes & int x =
10; \\
\textbf{Primitive} & float, double & 4,8 bytes & double d = 3.14; \\
\textbf{Primitive} & char, boolean & 2,1 bytes & char c = `A'; \\
\textbf{User Defined} & Class, Interface, Array & Variable & Student
s; \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Primitive}: stack માં store થાય, ઝડપી access
\item
  \textbf{User Defined}: heap માં store થાય, જટિલ operations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Primitive Built-in, User Custom''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે this કીવર્ડ સમજાવો.}

\begin{solutionbox}

\textbf{This કીવર્ડ} વર્તમાન object instance ને refer કરે છે, instance અને
local variables વચ્ચે ભેદ પાડવા માટે વાપરાય છે.

\textbf{ટેબલ: This કીવર્ડના ઉપયોગો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2381}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4286}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{this.variable} & instance variable ને access કરે & this.name =
name; \\
\textbf{this.method()} & instance method ને કૉલ કરે & this.display(); \\
\textbf{this()} & constructor ને કૉલ કરે & this(name, age); \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Student \{
    String name;
    int age;
    
    Student(String name, int age) \{
        this.name = name;    // this instance અને parameter વચ્ચે
        this.age = age;      // ભેદ પાડે છે
    \}
    
    void setData(String name) \{
        this.name = name;    // this વર્તમાન object ને refer કરે
    \}
    
    void display() \{
        System.out.println(this.name + " " + this.age);
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``This વર્તમાન Object''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{ઇનહેરિટન્સ વ્યાખ્યાયિત કરો. તેના પ્રકારોની યાદી બનાવો. multilevel અને
hierarchical ઇનહેરિટન્સને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Inheritance}: mechanism જેમાં child class parent class ના
properties અને methods મેળવે છે.

\textbf{ટેબલ: Inheritance ના પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & સ્ટ્રક્ચર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Single} & એક parent, એક child & A \rightarrow B \\
\textbf{Multilevel} & inheritance ની chain & A \rightarrow B \rightarrow C \\
\textbf{Hierarchical} & એક parent, અનેક children & A \rightarrow B, A \rightarrow C \\
\textbf{Multiple} & અનેક parents (interfaces દ્વારા) & B,C \rightarrow A \\
\end{longtable}
}

\textbf{આકૃતિ - Multilevel:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Animal] {-{-}{} B[Mammal]}
    B {-{-}{} C[Dog]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ બ્લોક - Multilevel:}

\begin{verbatim}
class Animal \{
    void eat() \{ System.out.println("Animal eats"); \}
\}

class Mammal extends Animal \{
    void breathe() \{ System.out.println("Mammal breathes"); \}
\}

class Dog extends Mammal \{
    void bark() \{ System.out.println("Dog barks"); \}
\}
\end{verbatim}

\textbf{આકૃતિ - Hierarchical:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[Shape] {-{-}{} B[Circle]}
    A {-{-}{} C[Rectangle]}
    A {-{-}{} D[Triangle]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ બ્લોક - Hierarchical:}

\begin{verbatim}
class Shape \{
    void draw() \{ System.out.println("Drawing shape"); \}
\}

class Circle extends Shape \{
    void drawCircle() \{ System.out.println("Drawing circle"); \}
\}

class Rectangle extends Shape \{
    void drawRectangle() \{ System.out.println("Drawing rectangle"); \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Inheritance Properties શેર કરે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{જાવામાં ટાઇપ કન્વર્ઝન અને કાસ્ટિંગ સમજાવો.}

\begin{solutionbox}

\textbf{Type Conversion}: એક data type ને બીજામાં બદલવું. \textbf{Casting}:
programmer દ્વારા explicit type conversion.

\textbf{ટેબલ: Type Conversion}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4643}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Implicit (Widening)} & Automatic, smaller to larger & int to
double \\
\textbf{Explicit (Narrowing)} & Manual, larger to smaller & double to
int \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
// Implicit conversion
int i = 10;
double d = i;        // int થી double (automatic)

// Explicit casting
double x = 10.5;
int y = (int) x;     // double થી int (manual)

// String conversion
String s = String.valueOf(i);    // int થી String
int z = Integer.parseInt("123"); // String થી int
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Implicit Auto, Explicit Manual''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{Java માં ઉપયોગમાં લેવાતા વિવિધ visibility controls સમજાવો.}

\begin{solutionbox}

\textbf{Visibility Controls (Access Modifiers)}: classes, methods અને
variables ના access ને control કરે છે.

\textbf{ટેબલ: Access Modifiers}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Modifier & Same Class & Same Package & Subclass & Different Package \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{private} & ✓ & ✗ & ✗ & ✗ \\
\textbf{default} & ✓ & ✓ & ✗ & ✗ \\
\textbf{protected} & ✓ & ✓ & ✓ & ✗ \\
\textbf{public} & ✓ & ✓ & ✓ & ✓ \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Example \{
    private int x = 10;      // માત્ર class અંદર
    int y = 20;              // Package level
    protected int z = 30;    // Package + subclass
    public int w = 40;       // દરેક જગ્યાએ
    
    private void method1() \{ \}    // Private method
    public void method2() \{ \}     // Public method
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Private Package Protected Public''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{વ્યાખ્યાયિત કરો: થ્રેડ. થ્રેડ બનાવવા માટે ઉપયોગમાં લેવાતી વિવિધ પદ્ધતિઓની
સૂચિ બનાવો. થ્રેડની લાઇફ સાઇકલ વિગતવાર સમજાવો.}

\begin{solutionbox}

\textbf{Thread}: lightweight subprocess જે program ના અનેક ભાગોને
concurrent execution ની મંજૂરી આપે છે.

\textbf{ટેબલ: Thread બનાવવાની પદ્ધતિઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3913}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ્ધતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Thread વિસ્તરવું} & Thread class ને inherit કરવું & class MyThread
extends Thread \\
\textbf{Runnable implement કરવું} & Runnable interface implement કરવું &
class MyTask implements Runnable \\
\end{longtable}
}

\textbf{આકૃતિ: Thread Life Cycle}

\begin{verbatim}
stateDiagram{-v2}
        direction LR
    [*] {-{-} NEW}
    NEW {-{-} RUNNABLE : start()}
    RUNNABLE {-{-} RUNNING : CPU allocation}
    RUNNING {-{-} RUNNABLE : yield()}
    RUNNING {-{-} BLOCKED : wait()/sleep()}
    BLOCKED {-{-} RUNNABLE : notify()/interrupt()}
    RUNNING {-{-} TERMINATED : completion}
    TERMINATED {-{-} [*]}
\end{verbatim}

\textbf{ટેબલ: Thread States}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
સ્થિતિ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{NEW} & Thread બન્યું પણ શરૂ નથી થયું \\
\textbf{RUNNABLE} & ચાલવા તૈયાર, CPU ની રાહમાં \\
\textbf{RUNNING} & હાલમાં execute થઈ રહ્યું છે \\
\textbf{BLOCKED} & resource અથવા sleep ની રાહમાં \\
\textbf{TERMINATED} & execution પૂર્ણ થયું \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
// પદ્ધતિ 1: Thread વિસ્તરવું
class MyThread extends Thread \{
    public void run() \{
        System.out.println("Thread running");
    \}
\}

// પદ્ધતિ 2: Runnable implement કરવું
class MyTask implements Runnable \{
    public void run() \{
        System.out.println("Task running");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        MyThread t1 = new MyThread();
        Thread t2 = new Thread(new MyTask());
        t1.start();
        t2.start();
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Thread Concurrent Execution''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{java માં JVM નો હેતુ સમજાવો.}

\begin{solutionbox}

\textbf{JVM (Java Virtual Machine)}: runtime environment જે Java bytecode
execute કરે છે અને platform independence પ્રદાન કરે છે.

\textbf{ટેબલ: JVM Components}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Component & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Class Loader} & .class files ને memory માં લોડ કરે \\
\textbf{Execution Engine} & bytecode execute કરે \\
\textbf{Memory Area} & heap અને stack memory ને manage કરે \\
\textbf{Garbage Collector} & automatic memory management \\
\end{longtable}
}

\textbf{આકૃતિ:}

\begin{verbatim}
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Java Source    |
| (.java)        |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        v
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Java Compiler  |
| (javac)        |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        v
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Bytecode       |
| (.class)       |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        v
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| JVM            |
| (Platform      |
|  Specific)     |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Platform Independence}: ``એકવાર લખો, દરેક જગ્યાએ ચલાવો''
\item
  \textbf{Memory Management}: automatic garbage collection
\item
  \textbf{Security}: Bytecode verification
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``JVM Java Virtual Machine''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{વ્યાખ્યાયિત કરો: પેકેજ. યોગ્ય ઉદાહરણ સાથે પેકેજ બનાવવા માટેના પગલાંઓ લખો.}

\begin{solutionbox}

\textbf{Package}: સંબંધિત classes અને interfaces નો સંગ્રહ, namespace અને
access control પ્રદાન કરે છે.

\textbf{ટેબલ: Package ના ફાયદા}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફાયદો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Namespace} & નામની ટકરાર ટાળે \\
\textbf{Access Control} & બહેતર encapsulation \\
\textbf{Organization} & logical grouping \\
\textbf{Reusability} & maintain કરવું સરળ \\
\end{longtable}
}

\textbf{Package બનાવવાના પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{Package declare કરો} file ની ટોચે
\item
  \textbf{Directory structure બનાવો} package name મુજબ
\item
  \textbf{Compile કરો} package structure સાથે
\item
  \textbf{Import કરો} અન્ય classes માં
\end{enumerate}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
// File: com/company/utilities/Calculator.java
package com.company.utilities;

public class Calculator \{
    public int add(int a, int b) \{
        return a + b;
    \}
\}

// File: Main.java
import com.company.utilities.Calculator;

class Main \{
    public static void main(String[] args) \{
        Calculator calc = new Calculator();
        System.out.println(calc.add(5, 3));
    \}
\}
\end{verbatim}

\textbf{Directory Structure:}

\begin{verbatim}
com/
  company/
    utilities/
      Calculator.class
Main.class
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Package Classes ને Group કરે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{થ્રેડમાં Synchronization ને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Synchronization}: shared resources ના access ને multiple threads
દ્વારા control કરવાની mechanism, data inconsistency ટાળવા માટે.

\textbf{ટેબલ: Synchronization ના પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Synchronized method} & આખી method lock થાય & synchronized void
method() \\
\textbf{Synchronized block} & ચોક્કસ code block lock થાય &
synchronized(object) \{ \} \\
\textbf{Static synchronization} & Class level locking & synchronized
static void method() \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Counter \{
    private int count = 0;
    
    // Synchronized method
    public synchronized void increment() \{
        count++;
    \}
    
    // Synchronized block
    public void decrement() \{
        synchronized(this) \{
            count{-{-};}
        \}
    \}
    
    public int getCount() \{
        return count;
    \}
\}

class CounterThread extends Thread \{
    Counter counter;
    
    CounterThread(Counter c) \{
        counter = c;
    \}
    
    public void run() \{
        for(int i = 0; i {} 1000; i++) \{
            counter.increment();
        \}
    \}
\}

class Main \{
    public static void main(String[] args) throws InterruptedException \{
        Counter c = new Counter();
        CounterThread t1 = new CounterThread(c);
        CounterThread t2 = new CounterThread(c);
        
        t1.start();
        t2.start();
        
        t1.join();
        t2.join();
        
        System.out.println("Final count: " + c.getCount());
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Synchronization Race Conditions અટકાવે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{સ્ટ્રિંગ ક્લાસ અને સ્ટ્રિંગબફર ક્લાસ વચ્ચે તફાવત કરો.}

\begin{solutionbox}

\textbf{ટેબલ: String vs StringBuffer}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પાસું & String & StringBuffer \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mutability} & Immutable (બદલાતું નથી) & Mutable (બદલાય છે) \\
\textbf{Performance} & concatenation માટે ધીમું & concatenation માટે ઝડપું \\
\textbf{Memory} & દર વખતે નવું object બનાવે & હાલનું object modify કરે \\
\textbf{Thread Safety} & Thread safe & Thread safe \\
\textbf{Methods} & concat(), substring() & append(), insert(),
delete() \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
// String {- Immutable}
String s1 = "Hello";
s1 = s1 + " World";  // નવું String object બનાવે છે

// StringBuffer {- Mutable}
StringBuffer sb = new StringBuffer("Hello");
sb.append(" World");  // હાલનું object modify કરે છે
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{String}: જ્યારે content વારંવાર બદલાતું નથી ત્યારે વાપરો
\item
  \textbf{StringBuffer}: જ્યારે વારંવાર modifications જરૂરી હોય ત્યારે વાપરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``String Immutable, StringBuffer Mutable''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{એરેની 10 સંખ્યાઓનો સરવાળો અને સરેરાશ મેળવવા માટે જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class ArraySum \{
    public static void main(String[] args) \{
        // 10 numbers સાથે array initialize કરો
        int[] numbers = \{10, 20, 30, 40, 50, 60, 70, 80, 90, 100\;}
        
        int sum = 0;
        
        // સરવાળો calculate કરો
        for(int i = 0; i {} numbers.length; i++) \{
            sum += numbers[i];
        \}
        
        // સરેરાશ calculate કરો
        double average = (double) sum / numbers.length;
        
        // પરિણામો display કરો
        System.out.println("Array elements: ");
        for(int num : numbers) \{
            System.out.print(num + " ");
        \}
        
        System.out.println("{n}Sum: " + sum);
        System.out.println("Average: " + average);
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
Array elements: 10 20 30 40 50 60 70 80 90 100
Sum: 550
Average: 55.0
\end{verbatim}

\textbf{લોજિક પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{Initialize} 10 numbers સાથે array
\item
  \textbf{Loop} array માં સરવાળો calculate કરવા માટે
\item
  \textbf{Calculate} સરેરાશ = સરવાળો / length
\item
  \textbf{Display} પરિણામો
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Loop Sum Divide Average''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{I) યોગ્ય ઉદાહરણ સાથે abstract class સમજાવો. II) યોગ્ય ઉદાહરણ સાથે
final class સમજાવો.}

\begin{solutionbox}

\textbf{I) Abstract Class}: class જેનું instantiation થઈ શકતું નથી, abstract
methods હોય છે જેનું implementation subclasses માં જરૂરી છે.

\textbf{ટેબલ: Abstract Class ની વિશેષતાઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Cannot instantiate} & object બનાવી શકાતું નથી \\
\textbf{Abstract methods} & implementation વિનાની methods \\
\textbf{Concrete methods} & implementation સાથેની methods \\
\textbf{Inheritance} & Subclasses માં abstract methods implement કરવા
જરૂરી \\
\end{longtable}
}

\textbf{કોડ બ્લોક - Abstract Class:}

\begin{verbatim}
abstract class Shape \{
    String color;
    
    // Abstract method
    abstract void draw();
    
    // Concrete method
    void setColor(String c) \{
        color = c;
    \}
\}

class Circle extends Shape \{
    void draw() \{
        System.out.println("Drawing Circle");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        // Shape s = new Shape(); // ભૂલ: Instantiate કરી શકાતું નથી
        Circle c = new Circle();
        c.draw();
    \}
\}
\end{verbatim}

\textbf{II) Final Class}: class જેનું extension થઈ શકતું નથી (inheritance
નથી).

\textbf{ટેબલ: Final Class ની વિશેષતાઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{No inheritance} & extend કરી શકાતું નથી \\
\textbf{Security} & modification અટકાવે છે \\
\textbf{Performance} & બહેતર optimization \\
\textbf{ઉદાહરણો} & String, Integer, System \\
\end{longtable}
}

\textbf{કોડ બ્લોક - Final Class:}

\begin{verbatim}
final class FinalClass \{
    void display() \{
        System.out.println("This is final class");
    \}
\}

// class SubClass extends FinalClass \{ \ // ભૂલ: Extend કરી શકાતું નથી}

class Main \{
    public static void main(String[] args) \{
        FinalClass obj = new FinalClass();
        obj.display();
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Abstract અધૂરું, Final પૂરું''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{જાવામાં Garbage Collection સમજાવો.}

\begin{solutionbox}

\textbf{Garbage Collection}: automatic memory management process જે heap
memory માંથી unused objects ને remove કરે છે.

\textbf{ટેબલ: GC ના ફાયદા}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફાયદો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Automatic} & manual memory management નથી \\
\textbf{Memory leak prevention} & unreferenced objects ને દૂર કરે \\
\textbf{Performance} & memory usage optimize કરે \\
\textbf{Safety} & memory errors અટકાવે \\
\end{longtable}
}

\textbf{આકૃતિ:}

\begin{verbatim}
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Object created   |
| (new keyword)    |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        v
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Object in use    |
| (has references) |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        v
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| No references    |
| (eligible for GC)|
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        v
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
| Garbage Collector|
| removes object   |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ક્યારે થાય}: જ્યારે heap memory ઓછી હોય અથવા System.gc() કૉલ થાય
\item
  \textbf{Process}: Mark and Sweep algorithm
\item
  \textbf{Guarantee કરી શકાતું નથી}: garbage collection નો exact timing
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``GC Automatic Memory Cleanup''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{`Divide by Zero' એરર માટે યુઝર ડિફાઇન્ડ એક્સેપ્શન હેન્ડલ કરવા માટે જાવા
પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
// યુઝર ડિફાઇન્ડ exception class
class DivideByZeroException extends Exception \{
    public DivideByZeroException(String message) \{
        super(message);
    \}
\}

class Calculator \{
    public static double divide(int a, int b) throws DivideByZeroException \{
        if(b == 0) \{
            throw new DivideByZeroException("શૂન્ય થી ભાગ નથી આપી શકાતો!");
        \}
        return (double) a / b;
    \}
\}

class Main \{
    public static void main(String[] args) \{
        try \{
            int num1 = 10;
            int num2 = 0;
            
            double result = Calculator.divide(num1, num2);
            System.out.println("પરિણામ: " + result);
            
        \} catch(DivideByZeroException e) \{
            System.out.println("ભૂલ: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
ભૂલ: શૂન્ય થી ભાગ નથી આપી શકાતો!
\end{verbatim}

\textbf{પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{Custom exception class બનાવો} Exception extend કરીને
\item
  \textbf{Exception throw કરો} જ્યારે condition આવે
\item
  \textbf{Exception handle કરો} try-catch block સાથે
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Custom Exception Error Handle કરે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{Multiple try block અને multiple catch block exception દર્શાવવા માટે
જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class MultipleExceptionDemo \{
    public static void main(String[] args) \{
        // પહેલો try block
        try \{
            int[] arr = \{1, 2, 3\;}
            System.out.println("Array element: " + arr[5]); // ArrayIndexOutOfBounds
        \} 
        catch(ArrayIndexOutOfBoundsException e) \{
            System.out.println("Array index ભૂલ: " + e.getMessage());
        \}
        catch(Exception e) \{
            System.out.println("સામાન્ય exception: " + e.getMessage());
        \}
        
        // બીજો try block
        try \{
            String str = null;
            System.out.println("String length: " + str.length()); // NullPointer
        \}
        catch(NullPointerException e) \{
            System.out.println("Null pointer ભૂલ: " + e.getMessage());
        \}
        
        // ત્રીજો try block multiple catch સાથે
        try \{
            int a = 10;
            int b = 0;
            int result = a / b;  // ArithmeticException
            
            String s = "abc";
            int num = Integer.parseInt(s);  // NumberFormatException
        \}
        catch(ArithmeticException e) \{
            System.out.println("Arithmetic ભૂલ: " + e.getMessage());
        \}
        catch(NumberFormatException e) \{
            System.out.println("Number format ભૂલ: " + e.getMessage());
        \}
        catch(Exception e) \{
            System.out.println("અન્ય ભૂલ: " + e.getMessage());
        \}
        finally \{
            System.out.println("પ્રોગ્રામ પૂર્ણ થયું");
        \}
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
Array index ભૂલ: Index 5 out of bounds for length 3
Null pointer ભૂલ: null
Arithmetic ભૂલ: / by zero
પ્રોગ્રામ પૂર્ણ થયું
\end{verbatim}

\textbf{દર્શાવેલી વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Multiple try blocks}: દરેક અલગ operations handle કરે
\item
  \textbf{Multiple catch blocks}: દરેક specific exception type handle કરે
\item
  \textbf{Exception hierarchy}: સામાન્ય Exception બધાને catch કરે
\item
  \textbf{Finally block}: હંમેશા execute થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Multiple Try Multiple Catch''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{ફાઇલ બનાવવા અને આ ફાઇલ પર write operation કરવા માટે જાવામાં પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
import java.io.*;

class FileWriteDemo \{
    public static void main(String[] args) \{
        try \{
            // ફાઇલ બનાવો
            File file = new File("demo.txt");
            
            // FileWriter object બનાવો
            FileWriter writer = new FileWriter(file);
            
            // ફાઇલમાં ડેટા લખો
            writer.write("નમસ્તે દુનિયા!{n}");
            writer.write("આ Java ફાઇલ લેખન ડેમો છે.{n}");
            writer.write("ફાઇલ સફળતાપૂર્વક બનાવવામાં આવી.");
            
            // writer બંધ કરો
            writer.close();
            
            System.out.println("ફાઇલ બનાવવામાં અને ડેટા લખવામાં સફળતા!");
            
        \} catch(IOException e) \{
            System.out.println("ભૂલ: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\textbf{પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{Import} java.io package
\item
  \textbf{File object બનાવો} filename સાથે
\item
  \textbf{FileWriter object બનાવો}
\item
  \textbf{ડેટા લખો} write() method વાપરીને
\item
  \textbf{Writer બંધ કરો} changes save કરવા માટે
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``File Writer Write Close''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{Throw અને finally ને Exception Handling માં ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Throw}: keyword જેનો ઉપયોગ explicitly exception throw કરવા માટે
થાય. \textbf{Finally}: block જે exception આવે કે ન આવે હંમેશા execute થાય છે.

\textbf{ટેબલ: Throw vs Finally}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કીવર્ડ & હેતુ & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{throw} & Explicitly exception throw કરે & throw new
Exception() \\
\textbf{finally} & હંમેશા cleanup code execute કરે & finally \{ \} \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class ThrowFinallyDemo \{
    public static void checkAge(int age) throws Exception \{
        if(age {} 18) \{
            throw new Exception("ઉંમર 18 કે તેથી વધુ હોવી જોઈએ");
        \}
        System.out.println("માન્ય ઉંમર: " + age);
    \}
    
    public static void main(String[] args) \{
        try \{
            checkAge(15);  // Exception throw કરશે
        \}
        catch(Exception e) \{
            System.out.println("ભૂલ: " + e.getMessage());
        \}
        finally \{
            System.out.println("Finally block હંમેશા execute થાય છે");
        \}
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
ભૂલ: ઉંમર 18 કે તેથી વધુ હોવી જોઈએ
Finally block હંમેશા execute થાય છે
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Throw}: Exception બળપૂર્વક બનાવે
\item
  \textbf{Finally}: Cleanup code, resources બંધ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Throw Exception, Finally હંમેશા''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{વર્ણવો: પોલીમોર્ફિઝમ. જાવામાં યોગ્ય ઉદાહરણ સાથે રન ટાઇમ પોલીમોર્ફિઝમ
સમજાવો.}

\begin{solutionbox}

\textbf{Polymorphism}: એક interface, અનેક implementations. Object તેના
actual type પર આધાર રાખીને અલગ રીતે વર્તે છે.

\textbf{ટેબલ: Polymorphism ના પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & ક્યારે નક્કી થાય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Compile-time} & Method overloading & Compilation વખતે \\
\textbf{Run-time} & Method overriding & Execution વખતે \\
\end{longtable}
}

\textbf{Run-time Polymorphism}: Method call runtime પર actual object
type આધારે resolve થાય.

\textbf{આકૃતિ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Animal reference] {-{-}{} B[Dog object]}
    A {-{-}{} C[Cat object]}
    B {-{-}{} D[Dog sound]}
    C {-{-}{} E[Cat sound]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class Animal \{
    void makeSound() \{
        System.out.println("પ્રાણી અવાજ કરે છે");
    \}
\}

class Dog extends Animal \{
    @Override
    void makeSound() \{
        System.out.println("કૂતરો ભસે છે");
    \}
\}

class Cat extends Animal \{
    @Override
    void makeSound() \{
        System.out.println("બિલાડી મ્યાં કરે છે");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Animal animal1 = new Dog();  // Upcasting
        Animal animal2 = new Cat();  // Upcasting
        
        animal1.makeSound();  // આઉટપુટ: કૂતરો ભસે છે
        animal2.makeSound();  // આઉટપુટ: બિલાડી મ્યાં કરે છે
        
        // Animals નો array
        Animal[] animals = \{new Dog(), new Cat(), new Dog()\;}
        for(Animal a : animals) \{
            a.makeSound();  // Dynamic method dispatch
        \}
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
કૂતરો ભસે છે
બિલાડી મ્યાં કરે છે
કૂતરો ભસે છે
બિલાડી મ્યાં કરે છે
કૂતરો ભસે છે
\end{verbatim}

\textbf{વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic Method Dispatch}: JVM runtime પર નક્કી કરે છે કઈ method
  કૉલ કરવી
\item
  \textbf{Upcasting}: Child object ને parent reference દ્વારા reference
  કરવું
\item
  \textbf{Flexibility}: સમાન કોડ વિવિધ object types સાથે કામ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Polymorphism અનેક રૂપ Runtime''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{જાવામાં એક પ્રોગ્રામ લખો જે બાઇટ બાય બાઇટ ફાઇલના કન્ટેન્ટ વાંચે અને તેને
બીજી ફાઇલમાં કોપી કરે.}

\begin{solutionbox}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
import java.io.*;

class FileCopyDemo \{
    public static void main(String[] args) \{
        try \{
            // source file માંથી વાંચવા માટે input stream બનાવો
            FileInputStream input = new FileInputStream("source.txt");
            
            // destination file માં લખવા માટે output stream બનાવો
            FileOutputStream output = new FileOutputStream("destination.txt");
            
            int byteData;
            
            // બાઇટ બાય બાઇટ વાંચો અને કોપી કરો
            while((byteData = input.read()) != {-}1) \{
                output.write(byteData);
            \}
            
            // streams બંધ કરો
            input.close();
            output.close();
            
            System.out.println("ફાઇલ સફળતાપૂર્વક કોપી થઈ!");
            
        \} catch(IOException e) \{
            System.out.println("ભૂલ: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\textbf{પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{FileInputStream બનાવો} વાંચવા માટે
\item
  \textbf{FileOutputStream બનાવો} લખવા માટે
\item
  \textbf{બાઇટ બાય બાઇટ વાંચો} read() વાપરીને
\item
  \textbf{દરેક બાઇટ લખો} write() વાપરીને
\item
  \textbf{બંને streams બંધ કરો}
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Read Byte Write Byte''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{Java સાથે ઉપલબ્ધ વિવિધ I/O વર્ગો સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Java I/O Classes}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Class Type & Class Name & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Byte Stream} & FileInputStream & ફાઇલમાંથી bytes વાંચે \\
\textbf{Byte Stream} & FileOutputStream & ફાઇલમાં bytes લખે \\
\textbf{Character Stream} & FileReader & ફાઇલમાંથી characters વાંચે \\
\textbf{Character Stream} & FileWriter & ફાઇલમાં characters લખે \\
\textbf{Buffered} & BufferedReader & કાર્યક્ષમ character reading \\
\textbf{Buffered} & BufferedWriter & કાર્યક્ષમ character writing \\
\end{longtable}
}

\textbf{આકૃતિ: I/O Class Hierarchy}

\begin{verbatim}
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
|    InputStream   |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        +{-{-} FileInputStream}
        +{-{-} BufferedInputStream}
        
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
|   OutputStream   |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        +{-{-} FileOutputStream}
        +{-{-} BufferedOutputStream}
        
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
|      Reader      |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        +{-{-} FileReader}
        +{-{-} BufferedReader}
        
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
|      Writer      |
+{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
        |
        +{-{-} FileWriter}
        +{-{-} BufferedWriter}
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
// Byte streams
FileInputStream fis = new FileInputStream("file.txt");
FileOutputStream fos = new FileOutputStream("output.txt");

// Character streams
FileReader fr = new FileReader("file.txt");
FileWriter fw = new FileWriter("output.txt");

// Buffered streams
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"));
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Byte Character Buffered Streams''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{જાવા પ્રોગ્રામ લખો જે બે થ્રેડોને એક્ઝિક્યુટ કરે છે. એક થ્રેડ દર 3 સેકન્ડે ``Java
Programming'' દર્શાવે છે, અને બીજો દર 6 સેકન્ડે ``Semester - 4th IT'' દર્શાવે છે.
(થ્રેડને extending the Thread class દ્વારા બનાવો)}

\begin{solutionbox}

\textbf{કોડ બ્લોક:}

\begin{verbatim}
class JavaThread extends Thread \{
    public void run() \{
        try \{
            while(true) \{
                System.out.println("Java Programming");
                Thread.sleep(3000);  // 3 સેકન્ડ માટે સૂઈ જાઓ
            \}
        \} catch(InterruptedException e) \{
            System.out.println("JavaThread અટકાવવામાં આવ્યું");
        \}
    \}
\}

class SemesterThread extends Thread \{
    public void run() \{
        try \{
            while(true) \{
                System.out.println("Semester {- 4th IT"});
                Thread.sleep(6000);  // 6 સેકન્ડ માટે સૂઈ જાઓ
            \}
        \} catch(InterruptedException e) \{
            System.out.println("SemesterThread અટકાવવામાં આવ્યું");
        \}
    \}
\}

class Main \{
    public static void main(String[] args) \{
        // thread objects બનાવો
        JavaThread javaThread = new JavaThread();
        SemesterThread semesterThread = new SemesterThread();
        
        // બંને threads શરૂ કરો
        javaThread.start();
        semesterThread.start();
        
        // threads ને 20 સેકન્ડ ચલાવો પછી બંધ કરો
        try \{
            Thread.sleep(20000);
            javaThread.interrupt();
            semesterThread.interrupt();
        \} catch(InterruptedException e) \{
            System.out.println("Main thread અટકાવવામાં આવ્યું");
        \}
    \}
\}
\end{verbatim}

\textbf{નમૂના આઉટપુટ:}

\begin{verbatim}
Java Programming
Semester - 4th IT
Java Programming
Java Programming
Semester - 4th IT
Java Programming
Java Programming
Semester - 4th IT
...
\end{verbatim}

\textbf{વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{બે અલગ threads}: દરેક અલગ timing સાથે
\item
  \textbf{Thread.sleep()}: ચોક્કસ milliseconds માટે execution પોઝ કરે
\item
  \textbf{Concurrent execution}: બંને threads એકસાથે ચાલે છે
\item
  \textbf{Thread class વિસ્તારવું}: run() method ને override કરવું
\end{itemize}

\textbf{Execution Pattern:}

\begin{itemize}
\tightlist
\item
  JavaThread: દર 3 સેકન્ડે દર્શાવે
\item
  SemesterThread: દર 6 સેકન્ડે દર્શાવે
\item
  બંને concurrent રીતે અલગ timing બતાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``બે Threads અલગ Timing''

\end{mnemonicbox}

\end{document}
