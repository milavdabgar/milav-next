\documentclass{article}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}
\usetikzlibrary{fit,positioning,shapes,calc,arrows.meta}

\title{Object Oriented Programming With Java (4341602) - Summer 2025 Solution}
\date{May 15, 2025}

\begin{document}
\maketitle

\questionmarks{1(અ)}{3}{પ્રોસિજર ઓરિએન્ટેડ પ્રોગ્રામિંગ (POP) અને ઓબ્જેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગ (OOP) વચ્ચે તફાવત કરો.}

\begin{solutionbox}
\textbf{તફાવત}:
\begin{center}
\captionof{table}{POP vs OOP}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસાં} & \textbf{POP} & \textbf{OOP} \\ \hline
\textbf{અભિગમ} & ટોપ-ડાઉન અભિગમ & બોટમ-અપ અભિગમ \\ \hline
\textbf{ફોકસ} & ફંક્શન્સ અને પ્રોસિજર્સ & ઓબ્જેક્ટ્સ અને ક્લાસેસ \\ \hline
\textbf{ડેટા સિક્યોરિટી} & ઓછી સુરક્ષિત, ગ્લોબલ ડેટા & વધુ સુરક્ષિત, ડેટા encapsulation \\ \hline
\textbf{સમસ્યા ઉકેલ} & ફંક્શન્સમાં વિભાજન & ઓબ્જેક્ટ્સમાં વિભાજન \\ \hline
\end{tabulary}
\end{center}

\textbf{મુખ્ય મુદ્દા}:
\begin{itemize}
    \item \textbf{POP}: ફંક્શન્સ પ્રાથમિક બિલ્ડિંગ બ્લોક્સ છે.
    \item \textbf{OOP}: ઓબ્જેક્ટ્સમાં ડેટા અને મેથડ્સ બંને સામેલ છે.
    \item \textbf{પુનઃઉપયોગ}: OOP કોડની વધુ સારી પુનઃઉપયોગિતા (Reusability) પ્રદાન કરે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{POP Functions, OOP Objects}
\end{mnemonicbox}

\questionmarks{1(બ)}{4}{OOP ના મૂળભૂત ખ્યાલોની નોંધણી કરો અને સમજાવો.}

\begin{solutionbox}
\textbf{OOP ના મૂળભૂત ખ્યાલો}:
\begin{itemize}
    \item \textbf{Encapsulation}: ક્લાસમાં ડેટા અને મેથડ્સને એકસાથે બાંધવું. તે ડેટાને બહારની દખલથી સુરક્ષિત રાખે છે.
    \item \textbf{Inheritance}: હાલની ક્લાસેસમાંથી નવી ક્લાસેસ બનાવવી. તે કોડના પુનઃઉપયોગને પ્રોત્સાહન આપે છે.
    \item \textbf{Polymorphism}: સમાન મેથડ નામ સાથે વિવિધ implementations (દા.ત., Overloading, Overriding).
    \item \textbf{Abstraction}: યુઝરથી જટિલ implementation વિગતો છુપાવવી અને માત્ર જરૂરી કાર્યક્ષમતા દર્શાવવી.
\end{itemize}

\textbf{ફાયદા}:
\begin{itemize}
    \item \textbf{કોડ પુનઃઉપયોગ}: Inheritance અને polymorphism દ્વારા.
    \item \textbf{ડેટા સિક્યોરિટી}: Encapsulation દ્વારા.
    \item \textbf{સરળ Maintenance}: મોડ્યુલર અભિગમ અપડેટ્સને સરળ બનાવે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Every Intelligent Person Abstracts}
\end{mnemonicbox}

\questionmarks{1(ક)}{7}{Constructor વ્યાખ્યાયિત કરો. વિવિધ પ્રકારના Constructors ની નોંધણી કરો અને તેમાંથી કોઈપણ 2 ને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{Constructor વ્યાખ્યા}:
Constructor એ એક વિશેષ મેથડ છે જે ઓબ્જેક્ટ બનાવવામાં આવે ત્યારે તેને initialize કરે છે. તેનું નામ ક્લાસ જેવું જ હોય છે અને તેનો કોઈ return type હોતો નથી.

\textbf{Constructor ના પ્રકારો}:
\begin{enumerate}
    \item Default Constructor
    \item Parameterized Constructor
    \item Copy Constructor
    \item Private Constructor
\end{enumerate}

\begin{lstlisting}[language=Java,caption={Constructor ઉદાહરણ}]
class Student {
    String name;
    int age;
    
    // 1. Default Constructor
    public Student() {
        name = "Unknown";
        age = 0;
    }
    
    // 2. Parameterized Constructor
    public Student(String n, int a) {
        name = n;
        age = a;
    }
}

class Main {
    public static void main(String[] args) {
        Student s1 = new Student();        // Default કૉલ કરે છે
        Student s2 = new Student("John", 20); // Parameterized કૉલ કરે છે
    }
}
\end{lstlisting}

\textbf{મુખ્ય લક્ષણો}:
\begin{itemize}
    \item \textbf{આપોઆપ કૉલ}: ઓબ્જેક્ટ બનાવવા દરમિયાન આપોઆપ કૉલ થાય છે.
    \item \textbf{કોઈ Return Type નથી}: Constructor નો કોઈ return type (void પણ નહીં) હોતો નથી.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Constructors Create Objects}
\end{mnemonicbox}

\questionmarks{1(ક OR)}{7}{String class સમજાવો. String class ની વિવિધ methods ની યાદી બનાવો અને તેમાંથી કોઈપણ 3 ને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{String Class}:
Java માં \code{String} ક્લાસ immutable (બદલી ન શકાય તેવા) character sequences ને રિપ્રેઝેન્ટ કરે છે. એકવાર બનાવ્યા પછી, String ઓબ્જેક્ટ્સ બદલી શકાતા નથી.

\textbf{String Methods}:
\begin{center}
\captionof{table}{String Methods}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Method} & \textbf{હેતુ} \\ \hline
\code{length()} & string ની લંબાઈ પરત કરે છે. \\ \hline
\code{charAt(index)} & આપેલ index પર રહેલો character પરત કરે છે. \\ \hline
\code{substring(start, end)} & start થી end-1 સુધીની substring કાઢે છે. \\ \hline
\code{indexOf(char)} & character ની પ્રથમ પોઝિશન શોધે છે. \\ \hline
\code{toUpperCase()} & બધા characters ને uppercase માં કન્વર્ટ કરે છે. \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={String Methods Demo}]
public class StringDemo {
    public static void main(String[] args) {
        String str = "Hello World";
        
        // 1. length() method
        System.out.println("Length: " + str.length()); // 11
        
        // 2. charAt() method
        System.out.println("Char at 0: " + str.charAt(0)); // H
        
        // 3. substring() method
        System.out.println("Substring: " + str.substring(0, 5)); // Hello
    }
}
\end{lstlisting}

\textbf{મુખ્ય મુદ્દા}:
\begin{itemize}
    \item \textbf{Immutable}: String ઓબ્જેક્ટ્સ બદલી શકાતા નથી.
    \item \textbf{Memory Efficient}: Storage માટે string pool નો ઉપયોગ કરે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Strings Store Text}
\end{mnemonicbox}

\questionmarks{2(અ)}{3}{Garbage Collection વ્યાખ્યાયિત કરો. JAVA પ્રોગ્રામિંગમાં Garbage Collection નું મહત્વ જણાવો.}

\begin{solutionbox}
\textbf{Garbage Collection વ્યાખ્યા}:
આ એક ઓટોમેટિક મેમરી મેનેજમેન્ટ પ્રક્રિયા છે જે એવા ઓબ્જેક્ટ્સ દ્વારા કબજે કરાયેલી મેમરી પાછી મેળવે છે (reclaim કરે છે) જેનો હવે પ્રોગ્રામમાં કોઈ reference (ઉપયોગ) નથી.

\textbf{મહત્વ}:
\begin{itemize}
    \item \textbf{આપોઆપ મેમરી મેનેજમેન્ટ}: ડેવલપરે મેન્યુઅલી મેમરી allocate કે deallocate કરવાની જરૂર રહેતી નથી.
    \item \textbf{Memory Leaks ટાળે છે}: આપોઆપ unused મેમરી મુક્ત કરે છે, જેનાથી leaks નું જોખમ ઘટે છે.
    \item \textbf{Application Performance}: મેમરી ઉપયોગને optimize કરે છે.
\end{itemize}

\textbf{ફાયદા}:
\begin{itemize}
    \item \textbf{Productivity}: પ્રોગ્રામર મેમરીને બદલે business logic પર ધ્યાન આપી શકે છે.
    \item \textbf{Reliability}: મેમરી issues ને લીધે થતા crashes ઘટાડે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Garbage Collector Cleans Memory}
\end{mnemonicbox}

\questionmarks{2(બ)}{4}{Object ને Garbage collection માટે eligible બનાવવાની ચાર રીતોની યાદી બનાવો.}

\begin{solutionbox}
\textbf{GC Eligibility ની રીતો}:
જ્યારે કોઈ ઓબ્જેક્ટનો કોઈ reference રહેતો નથી ત્યારે તે Garbage Collection માટે eligible બને છે.

\begin{center}
\captionof{table}{GC Eligibility Methods}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{રીત} & \textbf{વર્ણન} \\ \hline
\textbf{Reference ને Null કરવું} & સ્પષ્ટપણે object reference ને \code{null} સેટ કરવું. \\ \hline
\textbf{Reference ફરીથી Assign કરવું} & Reference variable ને બીજા કોઈ object પર point કરવું. \\ \hline
\textbf{Anonymous Objects} & Reference variable વિના objects બનાવવા. \\ \hline
\textbf{Island of Isolation} & જ્યારે બે કે વધુ ઓબ્જેક્ટ્સ માત્ર એકબીજાને refer કરતા હોય અને બહારથી કોઈ access ન હોય. \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણો}:
\begin{enumerate}
    \item \code{Student s = new Student(); s = null;}
    \item \code{Student s1 = new Student(); s1 = new Student();}
    \item \code{new Student();}
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Null References Attract Islands}
\end{mnemonicbox}

\questionmarks{2(ક)}{7}{Static block દર્શાવવા માટે JAVA પ્રોગ્રામ લખો જે main પહેલા execute થાય છે. તેનું મહત્વ સમજાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Static Block Demo}]
public class StaticBlockDemo {
    static int count;
    
    // Static block - Main પહેલા execute થાય છે
    static {
        System.out.println("Static block executed first");
        count = 10;
        System.out.println("Count initialized to: " + count);
    }
    
    public static void main(String[] args) {
        System.out.println("Main method started");
        System.out.println("Count value: " + count);
    }
}
\end{lstlisting}

\textbf{આઉટપુટ}:
\begin{verbatim}
Static block executed first
Count initialized to: 10
Main method started
Count value: 10
\end{verbatim}

\textbf{મહત્વ અને ઉપયોગ}:
\begin{itemize}
    \item \textbf{પ્રારંભિક Initialization}: જ્યારે ક્લાસ મેમરીમાં લોડ થાય છે ત્યારે મેઈન મેથડ પહેલા જ static block આપોઆપ execute થાય છે.
    \item \textbf{Class Loading}: તે class loading વખતે માત્ર એક જ વાર રન થાય છે.
    \item \textbf{ઉપયોગ}: Static variables initialize કરવા અથવા native libraries લોડ કરવા માટે ઉપયોગી છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Static Blocks Start Before Main}
\end{mnemonicbox}

\questionmarks{2(અ OR)}{3}{JAVA માં Minor/Incremental અને Major/Full Garbage collection નું વર્ણન કરો.}

\begin{solutionbox}
\textbf{Garbage Collection ના પ્રકારો}:

\begin{center}
\captionof{table}{Minor vs Major GC}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વર્ણન} & \textbf{આવર્તન (Frequency)} \\ \hline
\textbf{Minor GC} & \textbf{Young Generation} (Eden space) સાફ કરે છે. ટૂંકા-જીવનવાળા ઓબ્જેક્ટ્સ દૂર કરે છે. & વારંવાર, ઝડપી \\ \hline
\textbf{Major GC} & \textbf{Old Generation} (Tenured space) સાફ કરે છે. આખી heap (Full GC) આવરી લે છે. & ઓછું વારંવાર, ધીમું \\ \hline
\end{tabulary}
\end{center}

\textbf{વિગતો}:
\begin{itemize}
    \item \textbf{Minor GC}: Eden space ભરાઈ જાય ત્યારે trigger થાય છે. તે ઝડપી છે અને ઓછું pause આપે છે.
    \item \textbf{Major GC}: Old Generation ભરાઈ જાય ત્યારે trigger થાય છે. તે "Stop the World" pauses આપી શકે છે જે performance ને અસર કરે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Minor Frequent, Major Slow}
\end{mnemonicbox}

\questionmarks{2(બ OR)}{4}{JAVA માં finalize() method ને તેના ફાયદાઓ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{finalize() Method}:
આ \code{Object} ક્લાસમાં વ્યાખ્યાયિત એક મેથડ છે. Garbage Collector ઓબ્જેક્ટને destroy કરતા અને મેમરી reclaim કરતા પહેલા આ મેથડને કૉલ કરે છે. તેનો ઉપયોગ cleanup processing માટે થાય છે.

\textbf{Syntax}:
\begin{lstlisting}[language=Java]
protected void finalize() throws Throwable {
    // Cleanup code
}
\end{lstlisting}

\textbf{ફાયદા}:
\begin{itemize}
    \item \textbf{Resource Cleanup}: જો પ્રોગ્રામર ફાઇલ સ્ટ્રીમ્સ અથવા ડેટાબેઝ કનેક્શન્સ બંધ કરવાનું ભૂલી જાય, તો આ મેથડ ઉપયોગી બને છે.
    \item \textbf{Safety Net}: તે resources મુક્ત કરવા માટે છેલ્લી તક પૂરી પાડે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Finalize Frees Resources}
\end{mnemonicbox}

\questionmarks{2(ક OR)}{7}{public static void main(String[] args) ની syntax સમજાવો. Command line argument તરીકે લેવાયેલ input ને છાપવા માટે JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{Main Method Syntax સમજૂતી}:
\code{public static void main(String[] args)}

\begin{itemize}
    \item \textbf{public}: Access modifier છે, જે મેથડને ગમે ત્યાંથી accessible બનાવે છે (JVM તેને કૉલ કરી શકે).
    \item \textbf{static}: ઓબ્જેક્ટ બનાવ્યા વિના JVM આ મેથડને કૉલ કરી શકે છે.
    \item \textbf{void}: આ મેથડ કોઈ value return કરતી નથી.
    \item \textbf{main}: આ JVM દ્વારા ઓળખાતું ચોક્કસ મેથડ નામ છે.
    \item \textbf{String[] args}: Command-line arguments સ્ટોર કરતું String array.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Command Line Arguments Demo}]
public class CommandLineDemo {
    public static void main(String[] args) {
        System.out.println("Arguments ની સંખ્યા: " + args.length);
        
        if(args.length > 0) {
            System.out.println("Command line arguments:");
            for(int i = 0; i < args.length; i++) {
                System.out.println("Arg " + i + ": " + args[i]);
            }
        } else {
            System.out.println("કોઈ arguments મળ્યા નથી");
        }
    }
}
\end{lstlisting}

\textbf{Execution અને Output}:
\code{java CommandLineDemo Hello World 123}

\begin{verbatim}
Arguments ની સંખ્યા: 3
Command line arguments:
Arg 0: Hello
Arg 1: World
Arg 2: 123
\end{verbatim}
\end{solutionbox}

\questionmarks{3(અ)}{3}{વિવિધ Java access modifiers ની યાદી બનાવો અને સમજાવો.}

\begin{solutionbox}
\textbf{Java Access Modifiers}:
Access modifiers ક્લાસ, કન્સ્ટ્રક્ટર, વેરિયેબલ, મેથડ અથવા ડેટા મેમ્બરનો scope (visibility) નક્કી કરે છે.

\begin{center}
\captionof{table}{Access Modifiers Scope}
\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\textbf{Modifier} & \textbf{Class} & \textbf{Package} & \textbf{Subclass} & \textbf{World} \\ \hline
\textbf{public} & હા & હા & હા & હા \\ \hline
\textbf{protected} & હા & હા & હા & ના \\ \hline
\textbf{default} & હા & હા & ના & ના \\ \hline
\textbf{private} & હા & ના & ના & ના \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉપયોગ}:
\begin{itemize}
    \item \textbf{public}: બધે accessible છે.
    \item \textbf{protected}: Inheritance માટે વપરાય છે; package માં અને બહાર subclasses દ્વારા accessible છે.
    \item \textbf{default}: (કોઈ keyword નહીં) Package-private છે.
    \item \textbf{private}: માત્ર defining ક્લાસમાં જ restricted છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Public Protected Default Private}
\end{mnemonicbox}

\questionmarks{3(બ)}{4}{JAVA માં interface નું વર્ણન કરો. Executable ઉદાહરણ સાથે interface નો inheritance દર્શાવો.}

\begin{solutionbox}
\textbf{Java માં Interface}:
Interface એ Java માં એક reference type છે. તે ક્લાસ જેવું જ છે પરંતુ તે કરાર (contract) રજૂ કરે છે. તેમાં માત્ર constants, method signatures, default methods, static methods, અને nested types હોઈ શકે છે. Interfaces ને instantiate કરી શકાતા નથી—તે માત્ર ક્લાસ દ્વારા implement અથવા અન્ય interfaces દ્વારા extend કરી શકાય છે.

\begin{lstlisting}[language=Java,caption={Interface Inheritance}]
// Parent interface
interface Animal {
    void sound();
}

// Child interface Animal થી inherit કરે છે
interface Mammal extends Animal {
    void walk();
}

// Child interface ને implement કરતી class
class Dog implements Mammal {
    public void sound() {
        System.out.println("Dog barks");
    }
    
    public void walk() {
        System.out.println("Dog walks on four legs");
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
        d.walk();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Interfaces Inherit Contracts}
\end{mnemonicbox}

\questionmarks{3(ક)}{7}{super keyword વ્યાખ્યાયિત કરો અને executable JAVA પ્રોગ્રામ સાથે super keyword નો ઉપયોગ દર્શાવો}

\begin{solutionbox}
\textbf{super Keyword}:
Java માં \code{super} keyword એ એક reference variable છે જેનો ઉપયોગ immediate parent class ના object ને refer કરવા માટે થાય છે. તેનો ઉપયોગ current class ના scope ને bypass કરીને parent class ના members ને access કરવા માટે થાય છે.

\textbf{ઉપયોગ}:
\begin{enumerate}
    \item \textbf{Variable Access}: Immediate parent class instance variable ને refer કરવા (`super.variable`).
    \item \textbf{Method Call}: Immediate parent class method ને invoke કરવા (`super.method()`).
    \item \textbf{Constructor Call}: Immediate parent class constructor ને invoke કરવા (`super()`).
\end{enumerate}

\begin{lstlisting}[language=Java,caption={super Keyword નો ઉપયોગ}]
class Animal {
    String name = "Animal";
    
    Animal(String type) {
        System.out.println("Animal constructor: " + type);
    }
    
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    String name = "Dog";
    
    Dog() {
        // 1. Calling parent constructor
        super("Mammal");  
        System.out.println("Dog constructor");
    }
    
    void sound() {
        // 2. Calling parent method
        super.sound();    
        System.out.println("Dog barks");
    }
    
    void display() {
        // 3. Accessing parent variable
        System.out.println("Parent name: " + super.name);
        System.out.println("Child name: " + this.name);
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
        d.display();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Super Calls Parent}
\end{mnemonicbox}

\questionmarks{3(અ OR)}{3}{JAVA માં package ને વ્યવહારુ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{Package}:
Java માં package એ ક્લાસીસ, સબ-પેકેજીસ અને ઈન્ટરફેસના જૂથને સમાવિષ્ટ (encapsulate) કરવાની એક પદ્ધતિ છે.

\textbf{ફાયદા}:
\begin{itemize}
    \item \textbf{Organization}: બહેતર કોડ મેનેજમેન્ટ માટે વર્ગો (દા.ત., `model`, `view`, `controller`) ને વર્ગીકૃત કરે છે.
    \item \textbf{Access Control}: Access protection પ્રદાન કરે છે (default/protected access).
    \item \textbf{Namespace Management}: નામકરણ સંઘર્ષો (naming conflicts) અટકાવે છે.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Package બનાવવું અને વાપરવું}]
// File: com/company/model/Student.java
package com.company.model;

public class Student {
    private String name;
    public void setName(String name) { this.name = name; }
}

// File: Main.java
import com.company.model.Student;

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("John");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Packages Organize Classes}
\end{mnemonicbox}

\questionmarks{3(બ OR)}{4}{વ્યવહારુ ઉદાહરણ સાથે abstract અને final keywords સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Abstract vs Final}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Keyword} & \textbf{હેતુ} & \textbf{ઉપયોગ સ્તર} \\ \hline
\textbf{abstract} & અધૂરી implementation (template) વ્યાખ્યાયિત કરે છે. Instantiate કરી શકાતું નથી. & Class, Method \\ \hline
\textbf{final} & અચલ (constant) અથવા ન બદલી શકાય તેવી entity વ્યાખ્યાયિત કરે છે. ફેરફાર/એક્સ્ટેંશન અટકાવે છે. & Class, Method, Variable \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Abstract અને Final Demo}]
// Abstract class
abstract class Shape {
    final double PI = 3.14;  // final variable (Constant)
    
    abstract void draw();    // abstract method (No body)
    
    final void display() {   // final method (Override ન કરી શકાય)
        System.out.println("Displaying shape");
    }
}

// Final class (Extend ન કરી શકાય)
final class Circle extends Shape {
    void draw() {
        System.out.println("Drawing circle");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Abstract Allows, Final Forbids}
\end{mnemonicbox}

\questionmarks{3(ક OR)}{7}{Java Programming language context માં Dynamic Method Dispatch વ્યાખ્યાયિત કરો. Dynamic Method Dispatch દર્શાવતો executable પ્રોગ્રામ બનાવો.}

\begin{solutionbox}
\textbf{Dynamic Method Dispatch (Runtime Polymorphism)}:
આ એક પદ્ધતિ છે જેના દ્વારા overridden method નો કૉલ compile-time ને બદલે runtime એ resolve થાય છે. આ parent class reference variable નો ઉપયોગ કરીને child class object ને refer કરીને implement કરવામાં આવે છે.

\textbf{તે કેવી રીતે કામ કરે છે}:
\begin{enumerate}
    \item Variable દ્વારા refer થતા actual object type ને retrieve કરે છે.
    \item Virtual Method Table (vtable) માં method શોધે છે.
    \item Actual object ને અનુરૂપ method implementation invoke કરે છે.
\end{enumerate}

\begin{lstlisting}[language=Java,caption={Dynamic Dispatch ઉદાહરણ}]
// Base class
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

// Derived classes
class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("Cat meows");
    }
}

class DynamicDispatchDemo {
    public static void main(String[] args) {
        Animal ref;  // Reference variable
        
        // Runtime method resolution
        
        ref = new Dog(); // Dog object ને refer કરે છે
        ref.sound();     // Dog ની sound() કૉલ થાય છે
        
        ref = new Cat(); // Cat object ને refer કરે છે
        ref.sound();     // Cat ની sound() કૉલ થાય છે
        
        ref = new Animal();
        ref.sound();     // Animal ની sound() કૉલ થાય છે
    }
}
\end{lstlisting}

\textbf{આઉટપુટ}:
\begin{verbatim}
Dog barks
Cat meows
Animal makes sound
\end{verbatim}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Dynamic Dispatch Decides Runtime}
\end{mnemonicbox}

\questionmarks{4(અ)}{3}{Exception Handling માં throw અને finally keywords સમજાવો.}

\begin{solutionbox}
\textbf{throw}:
\begin{itemize}
    \item Method અથવા code block માંથી સ્પષ્ટપણે exception throw કરવા માટે વપરાય છે.
    \item મુખ્યત્વે custom exceptions throw કરવા માટે વપરાય છે.
    \item Syntax: \code{throw new Exception("Message");}
\end{itemize}

\textbf{finally}:
\begin{itemize}
    \item \code{try} અથવા \code{catch} પછીનો બ્લોક છે.
    \item Exception આવ્યું હોય કે ન આવ્યું હોય, તે \textbf{હંમેશા execute થાય છે}.
    \item સામાન્ય રીતે cleanup code (files બંધ કરવા, resources release કરવા) માટે વપરાય છે.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Throw અને Finally}]
try {
    if(age < 0)
        throw new IllegalArgumentException("Invalid age");
} catch(Exception e) {
    System.out.println(e);
} finally {
    System.out.println("આ હંમેશા પ્રિન્ટ થશે.");
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Throw Creates, Finally Cleans}
\end{mnemonicbox}

\questionmarks{4(બ)}{4}{JAVA માં try…catch block દર્શાવતો પ્રોગ્રામ લખો}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Try-Catch Demo}]
public class TryCatchDemo {
    public static void main(String[] args) {
        try {
            int[] arr = {1, 2, 3};
            // આ લાઇન ArrayIndexOutOfBoundsException આપશે
            System.out.println("Array element: " + arr[5]); 
            
            // આ લાઇન execute નહીં થાય
            int result = 10 / 0; 
            
        } catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error: " + e.getMessage());
            
        } catch(ArithmeticException e) {
            System.out.println("Math error: " + e.getMessage());
            
        } catch(Exception e) {
            System.out.println("General error: " + e.getMessage());
        }
        
        System.out.println("Program continues...");
    }
}
\end{lstlisting}

\textbf{આઉટપુટ}:
\begin{verbatim}
Array index error: Index 5 out of bounds for length 3
Program continues...
\end{verbatim}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Try Code, Catch Errors}
\end{mnemonicbox}

\questionmarks{4(ક)}{7}{ArrayIndexOutOfBoundsException Exception વ્યાખ્યાયિત કરો. તેને પ્રદર્શિત કરતો એક કાર્યક્ષમ JAVA પ્રોગ્રામ લખો. Input(ઓ) નો પણ ઉલ્લેખ કરો જે આ Exception ને વધારશે.}

\begin{solutionbox}
\textbf{વ્યાખ્યા}:
\code{ArrayIndexOutOfBoundsException} એ એક runtime exception છે જે ત્યારે thrown થાય છે જ્યારે કોડ અયોગ્ય index સાથે array element ને access કરવાનો પ્રયાસ કરે છે. Index નકારાત્મક હોય અથવા array ના કદ કરતા મોટો કે બરાબર હોય ત્યારે આવું થાય છે.

\begin{lstlisting}[language=Java,caption={ArrayIndexOutOfBounds Demo}]
public class ArrayExceptionDemo {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50}; // Array size: 5
        
        try {
            // Valid access
            System.out.println("Element at 2: " + numbers[2]);
            
            // INVALID access - exception raise કરશે
            // Index 10 એ length 5 કરતા મોટો છે
            System.out.println("Element at 10: " + numbers[10]);
            
        } catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("Exception caught: " + e.getMessage());
            System.out.println("Invalid index accessed!");
        }
    }
}
\end{lstlisting}

\textbf{Exception raise કરતા Inputs}:
\begin{itemize}
    \item \textbf{નકારાત્મક Index}: \code{numbers[-1]}
    \item \textbf{Index >= Length}: \code{numbers[5]} (કેમ કે valid indices 0-4 છે)
    \item \textbf{Empty Array}: ખાલી array પર \code{numbers[0]}
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Array Bounds Break Programs}
\end{mnemonicbox}

\questionmarks{4(અ OR)}{3}{JAVA માં Thread ના life cycle ને ઉદાહરણ સાથે દોરો અને સમજાવો.}

\begin{solutionbox}
\textbf{Thread Life Cycle}:
Thread તેના જીવનકાળ દરમિયાન વિવિધ અવસ્થાઓમાંથી પસાર થાય છે.

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto, >=stealth]
    % Nodes
    \node [gtu state] (new) {NEW};
    \node [gtu state, right=of new] (runnable) {RUNNABLE};
    \node [gtu state, right=of runnable] (running) {RUNNING};
    \node [gtu state, right=of running] (term) {TERMINATED};
    \node [gtu state, below=of running] (blocked) {BLOCKED/WAITING};
    
    % Edges
    \draw [->, thick] (new) -- node[above] {\small start()} (runnable);
    \draw [->, thick] (runnable) to[bend left=15] node[above] {\small Scheduler} (running);
    \draw [->, thick] (running) to[bend left=15] node[below] {\small yield()} (runnable);
    \draw [->, thick] (running) -- node[above] {\small End} (term);
    
    \draw [->, thick] (running) -- node[right] {\small sleep/wait} (blocked);
    \draw [->, thick] (blocked) -| node[below, near start] {\small notify/time} (runnable);
\end{tikzpicture}
\captionof{figure}{Thread Life Cycle}
\end{center}

\textbf{અવસ્થાઓ (States)}:
\begin{itemize}
    \item \textbf{NEW}: Thread બન્યો છે પણ શરૂ થયો નથી.
    \item \textbf{RUNNABLE}: Run કરવા માટે તૈયાર છે, CPU ની રાહ જોઈ રહ્યો છે.
    \item \textbf{RUNNING}: હાલમાં execute થઈ રહ્યો છે.
    \item \textbf{BLOCKED/WAITING}: Resource અથવા અન્ય thread માટે રાહ જોઈ રહ્યો છે.
    \item \textbf{TERMINATED}: Execution પૂર્ણ થયું છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{New Runs, Blocks Wait, Terminates}
\end{mnemonicbox}

\questionmarks{4(બ OR)}{4}{JAVA Optional class સમજાવો. Optional class ની OfNullable() પદ્ધતિનું વર્ણન કરો.}

\begin{solutionbox}
\textbf{Optional Class}:
Java 8 માં દાખલ કરાયેલ, \code{java.util.Optional} એ એક container object છે જે non-null value ધરાવી શકે છે અથવા ન પણ ધરાવી શકે. \code{null} નો ઉપયોગ કર્યા વિના value ની ગેરહાજરી રજૂ કરવા માટે તેનો ઉપયોગ થાય છે, જે \code{NullPointerException} ટાળવામાં મદદ કરે છે.

\textbf{ofNullable() Method}:
\begin{itemize}
    \item \textbf{વર્ણન}: જો value non-null હોય, તો તે value સાથેનું \code{Optional} પરત કરે છે, અન્યથા ખાલી \code{Optional} પરત કરે છે.
    \item \textbf{Syntax}: \code{static <T> Optional<T> ofNullable(T value)}
\end{itemize}

\begin{lstlisting}[language=Java,caption={Optional.ofNullable Demo}]
import java.util.Optional;

public class OptionalDemo {
    public static void main(String[] args) {
        String name1 = "John";
        String name2 = null;
        
        // "John" ધરાવતું Optional પરત કરે છે
        Optional<String> opt1 = Optional.ofNullable(name1);
        
        // ખાલી Optional પરત કરે છે (کوئی Exception throw થતું નથી)
        Optional<String> opt2 = Optional.ofNullable(name2);
        
        System.out.println("opt1 હાજર: " + opt1.isPresent()); // true
        System.out.println("opt2 હાજર: " + opt2.isPresent()); // false
        
        // orElse સાથે ઉપયોગ
        System.out.println(opt2.orElse("Default Name")); // prints Default Name
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Optional Offers Null Safety}
\end{mnemonicbox}

\questionmarks{4(ક OR)}{7}{નેસ્ટેડ try…catch block દર્શાવતો કાર્યક્ષમ JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Nested Try-Catch}]
public class NestedTryCatchDemo {
    public static void main(String[] args) {
        try {
            System.out.println("બાહ્ય try block શરૂ થયો");
            
            try {
                System.out.println("આંતરિક try block શરૂ થયો");
                int[] numbers = {10, 20};
                
                // Causes ArrayIndexOutOfBoundsException
                System.out.println(numbers[5]); 
                
            } catch(ArrayIndexOutOfBoundsException e) {
                System.out.println("આંતરિક catch: Array index error");
                // Modifying exception flow - throwing runtime exception
                throw new RuntimeException("આંતરિક block માં error");
            }
            
        } catch(RuntimeException e) {
            System.out.println("બાહ્ય catch: Runtime error - " + e.getMessage());
            
        } catch(Exception e) {
            System.out.println("બાહ્ય catch: સામાન્ય error");
            
        } finally {
            System.out.println("બાહ્ય finally: Cleanup");
        }
    }
}
\end{lstlisting}

\textbf{મુખ્ય લક્ષણો}:
\begin{itemize}
    \item \textbf{સ્તરીય Handling}: વિશિષ્ટ errors આંતરિક બ્લોકમાં, સામાન્ય errors બાહ્ય બ્લોકમાં handle થાય છે.
    \item \textbf{Flow}: જો આંતરિક catch તેને handle કરે, તો re-throw ન થાય ત્યાં સુધી બાહ્ય catch સુધી વાત પહોંચતી નથી.
\end{itemize}
\end{solutionbox}

\questionmarks{5(અ)}{3}{JAVA માં executable કોડ સાથે thread synchronization સમજાવો.}

\begin{solutionbox}
\textbf{Thread Synchronization}:
Synchronization એ બહુવિધ threads દ્વારા shared resources ના access ને control કરવાની ક્ષમતા છે. તે thread interference અને memory consistency errors અટકાવે છે.

\begin{lstlisting}[language=Java,caption={Thread Synchronization}]
class Counter {
    private int count = 0;
    
    // Synchronized method
    public synchronized void increment() {
        count++;
    }
    
    public int getCount() { return count; }
}

class SyncDemo extends Thread {
    Counter counter;
    
    SyncDemo(Counter c) { counter = c; }
    
    public void run() {
        for(int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}
\end{lstlisting}

\textbf{ફાયદા}:
\begin{itemize}
    \item \textbf{Data Consistency}: જ્યારે બહુવિધ threads સમાન ડેટામાં ફેરફાર કરે ત્યારે આવશ્યક છે.
    \item \textbf{Thread Safety}: ખાતરી કરે છે કે એક સમયે માત્ર એક જ thread resource ને access કરે છે.
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Synchronize Secures Shared Data}
\end{mnemonicbox}

\questionmarks{5(બ)}{4}{JAVA માં વિવિધ stream classes ની નોંધણી કરો. Executable ઉદાહરણ સાથે કોઈપણ એકને સમજાવો.}

\begin{solutionbox}
\textbf{Stream Classes}:
\begin{center}
\captionof{table}{Common Stream Classes}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Class} & \textbf{હેતુ} & \textbf{પ્રકાર} \\ \hline
\textbf{FileInputStream} & File માંથી bytes વાંચવા & Byte Stream \\ \hline
\textbf{FileOutputStream} & File માં bytes લખવા & Byte Stream \\ \hline
\textbf{BufferedReader} & Buffered character reading & Character Stream \\ \hline
\textbf{PrintWriter} & Formatted text output & Character Stream \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={FileInputStream Example}]
import java.io.*;

public class StreamDemo {
    public static void main(String[] args) {
        try {
            // Write data
            FileOutputStream fos = new FileOutputStream("test.txt");
            String data = "Hello World";
            fos.write(data.getBytes());
            fos.close();
            
            // Read data
            FileInputStream fis = new FileInputStream("test.txt");
            int ch;
            while((ch = fis.read()) != -1) {
                System.out.print((char)ch);
            }
            fis.close();
            
        } catch(IOException e) {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Streams Send Data}
\end{mnemonicbox}

\questionmarks{5(ક)}{7}{Thread નો ઉપયોગ કરીને આપેલ બે પૂર્ણાંક સંખ્યાઓ વચ્ચે વિષમ સંખ્યાઓ દર્શાવવા માટે Thread class ને વિસ્તારતો JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Odd Number Thread}]
class OddNumberThread extends Thread {
    private int start;
    private int end;
    
    public OddNumberThread(int start, int end) {
        this.start = start;
        this.end = end;
    }
    
    @Override
    public void run() {
        System.out.println("Thread started: " + getName());
        
        for(int i = start; i <= end; i++) {
            if(i % 2 != 0) {  // Check if odd
                System.out.println("Odd number: " + i);
                try {
                    Thread.sleep(500);  // Pause
                } catch(InterruptedException e) {
                    System.out.println("Thread interrupted");
                }
            }
        }
        System.out.println("Thread completed: " + getName());
    }
}

public class OddNumberDemo {
    public static void main(String[] args) {
        // Create threads
        OddNumberThread t1 = new OddNumberThread(1, 10);
        
        t1.setName("OddThread-1");
        t1.start();
        
        try {
            t1.join(); // Wait for completion
        } catch(InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("Main thread completed");
    }
}
\end{lstlisting}

\textbf{આઉટપુટ}:
\begin{verbatim}
Thread started: OddThread-1
Odd number: 1
Odd number: 3
...
Odd number: 9
Thread completed: OddThread-1
Main thread completed
\end{verbatim}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Threads Take Turns}
\end{mnemonicbox}

\questionmarks{5(અ OR)}{3}{JAVA માં Thread class ની join() અને alive() પદ્ધતિઓ સમજાવો.}

\begin{solutionbox}
\textbf{Thread Methods}:
\begin{itemize}
    \item \textbf{join()}: આ મેથડ એક thread ને બીજા thread ના completion ની રાહ જોવાની મંજૂરી આપે છે. જો \code{t.join()} કૉલ કરવામાં આવે, તો વર્તમાન thread જ્યાં સુધી thread \code{t} સમાપ્ત ન થાય ત્યાં સુધી execution અટકાવી દે છે.
    \item \textbf{isAlive()}: આ મેથડ ચકાસે છે કે thread હજુ ચાલી રહ્યો છે કે નહીં. જો thread શરૂ થયો હોય અને હજુ સુધી મૃત્યુ પામ્યો ન હોય તો તે \code{true} પરત કરે છે, અન્યથા \code{false}.
\end{itemize}

\begin{lstlisting}[language=Java,caption={Join અને IsAlive}]
class TestThread extends Thread {
    public void run() {
        try { sleep(500); } catch(InterruptedException e) {}
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        TestThread t = new TestThread();
        System.out.println("Before start: " + t.isAlive()); // false
        
        t.start();
        System.out.println("After start: " + t.isAlive()); // true
        
        t.join(); // Wait for completion
        System.out.println("After join: " + t.isAlive()); // false
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Join Waits, Alive Checks}
\end{mnemonicbox}

\questionmarks{5(બ OR)}{4}{JAVA માં user-defined exceptions ને વ્યાખ્યાયિત કરો. User-defined exceptions બતાવવા માટે પ્રોગ્રામ લખો}

\begin{solutionbox}
\textbf{User-defined Exceptions}:
Java યુઝર્સને \code{Exception} ક્લાસ (checked) અથવા \code{RuntimeException} ક્લાસ (unchecked) ને extend કરીને તેમના પોતાના exception classes વ્યાખ્યાયિત કરવાની મંજૂરી આપે છે. તેનો ઉપયોગ application-specific logical errors ને handle કરવા માટે થાય છે.

\begin{lstlisting}[language=Java,caption={Custom Exception}]
// 1. Create custom exception class
class AgeValidationException extends Exception {
    public AgeValidationException(String message) {
        super(message);
    }
}

class Person {
    public void setAge(int age) throws AgeValidationException {
        if(age < 0) {
            throw new AgeValidationException("Age cannot be negative: " + age);
        }
        System.out.println("Valid age: " + age);
    }
}

public class UserDefinedExceptionDemo {
    public static void main(String[] args) {
        Person p = new Person();
        try {
            p.setAge(-5); // Invalid
        } catch(AgeValidationException e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Custom Exceptions Catch Specific Errors}
\end{mnemonicbox}

\questionmarks{5(ક OR)}{7}{ફાઇલ a.txt ની સામગ્રીને b.txt પર કોપી કરવા માટે JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={File Copy Program}]
import java.io.*;

public class FileCopyDemo {
    public static void main(String[] args) {
        String source = "a.txt";
        String target = "b.txt";
        
        // Method: FileInputStream અને FileOutputStream નો ઉપયોગ કરીને
        copyFile(source, target);
    }
    
    public static void copyFile(String src, String dest) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        
        try {
            // Initialize streams
            fis = new FileInputStream(src);
            fos = new FileOutputStream(dest);
            
            // Read and write byte by byte
            int ch;
            while((ch = fis.read()) != -1) {
                fos.write(ch);
            }
            
            System.out.println("File copied successfully!");
            
        } catch(FileNotFoundException e) {
            System.out.println("File not found: " + e.getMessage());
        } catch(IOException e) {
            System.out.println("IO Error: " + e.getMessage());
        } finally {
            // Close streams in finally block
            try {
                if(fis != null) fis.close();
                if(fos != null) fos.close();
            } catch(IOException e) {
                e.printStackTrace();
            }
        }
    }
}
\end{lstlisting}

\textbf{Logic}:
\begin{enumerate}
    \item \code{FileInputStream} નો ઉપયોગ કરીને source file ને read mode માં ખોલો.
    \item \code{FileOutputStream} નો ઉપયોગ કરીને destination file ને write mode માં ખોલો.
    \item Source માંથી byte વાંચો અને જ્યાં સુધી file નો અંત (-1) ન આવે ત્યાં સુધી destination પર લખો.
    \item બંને streams ને બંધ કરો જેથી system resources મુક્ત થાય.
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Files Flow From Source To Target}
\end{mnemonicbox}

\end{document}


