\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4341602 -- Summer 2025}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{પ્રોસિજર ઓરિએન્ટેડ પ્રોગ્રામિંગ (POP) અને ઓબ્જેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગ (OOP)
વચ્ચે તફાવત કરો.}

\begin{solutionbox}

\textbf{ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4118}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2941}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2941}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસાં
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
POP
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
OOP
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{અભિગમ} & ટોપ-ડાઉન અભિગમ & બોટમ-અપ અભિગમ \\
\textbf{ફોકસ} & ફંક્શન્સ અને પ્રોસિજર્સ & ઓબ્જેક્ટ્સ અને ક્લાસેસ \\
\textbf{ડેટા સિક્યોરિટી} & ઓછી સુરક્ષિત, ગ્લોબલ ડેટા & વધુ સુરક્ષિત, ડેટા
encapsulation \\
\textbf{સમસ્યા ઉકેલ} & ફંક્શન્સમાં વિભાજન & ઓબ્જેક્ટ્સમાં વિભાજન \\
\end{longtable}
}

\textbf{મુખ્ય મુદ્દા:}

\begin{itemize}
\tightlist
\item
  \textbf{POP}: ફંક્શન્સ પ્રાથમિક બિલ્ડિંગ બ્લોક્સ છે
\item
  \textbf{OOP}: ઓબ્જેક્ટ્સમાં ડેટા અને મેથડ્સ બંને સામેલ છે
\item
  \textbf{પુનઃઉપયોગ}: OOP વધુ સારી કોડ પુનઃઉપયોગિતા પ્રદાન કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``POP ફંક્શન્સ, OOP ઓબ્જેક્ટ્સ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{OOP ના મૂળભૂત ખ્યાલોની નોંધણી કરો અને સમજાવો.}

\begin{solutionbox}

\textbf{OOP ના મૂળભૂત ખ્યાલો:}

\begin{itemize}
\tightlist
\item
  \textbf{Encapsulation}: ક્લાસમાં ડેટા અને મેથડ્સને એકસાથે બાંધવું
\item
  \textbf{Inheritance}: હાલની ક્લાસેસમાંથી નવી ક્લાસેસ બનાવવી
\item
  \textbf{Polymorphism}: સમાન મેથડ નામ સાથે વિવિધ implementations
\item
  \textbf{Abstraction}: યુઝરથી implementation વિગતો છુપાવવી
\end{itemize}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{કોડ પુનઃઉપયોગ}: inheritance અને polymorphism દ્વારા
\item
  \textbf{ડેટા સિક્યોરિટી}: encapsulation દ્વારા
\item
  \textbf{સરળ maintenance}: મોડ્યુલર અભિગમ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``દરેક હુશિયાર વ્યક્તિ અમૂર્ત વિચાર કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{Constructor વ્યાખ્યાયિત કરો. વિવિધ પ્રકારના Constructors ની નોંધણી
કરો અને તેમાંથી કોઈપણ 2 ને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Constructor વ્યાખ્યા:} Constructor એ વિશેષ મેથડ છે જે ઓબ્જેક્ટ બનાવવામાં
આવે ત્યારે તેને initialize કરે છે. તેનું નામ ક્લાસ જેવું જ હોય છે અને કોઈ return type
નથી.

\textbf{Constructor ના પ્રકારો:}

\begin{itemize}
\tightlist
\item
  \textbf{Default Constructor}: કોઈ પેરામીટર નથી
\item
  \textbf{Parameterized Constructor}: પેરામીટર લે છે
\item
  \textbf{Copy Constructor}: અન્ય ઓબ્જેક્ટમાંથી ઓબ્જેક્ટ બનાવે છે
\item
  \textbf{Private Constructor}: ઓબ્જેક્ટ બનાવવાને મર્યાદિત કરે છે
\end{itemize}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Student \{
    String name;
    int age;
    
    // Default Constructor
    public Student() \{
        name = "Unknown";
        age = 0;
    \}
    
    // Parameterized Constructor
    public Student(String n, int a) \{
        name = n;
        age = a;
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Student s1 = new Student();        // Default
        Student s2 = new Student("John", 20); // Parameterized
    \}
\}
\end{verbatim}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{આપોઆપ કૉલ}: ઓબ્જેક્ટ બનાવવા દરમિયાન આપોઆપ કૉલ થાય છે
\item
  \textbf{કોઈ Return Type નથી}: Constructor નો કોઈ return type નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Constructor ઓબ્જેક્ટ બનાવે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{String class સમજાવો. String class ની વિવિધ methods ની યાદી બનાવો
અને તેમાંથી કોઈપણ 3 ને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{String Class:} Java માં String class immutable character
sequences ને રિપ્રેઝેન્ટ કરે છે. એકવાર બનાવ્યા પછી, String ઓબ્જેક્ટ્સ બદલી શકાતા
નથી.

\textbf{String Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Method & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
length() & string ની લંબાઈ પરત કરે છે \\
charAt(index) & આપેલ index પર character પરત કરે છે \\
substring(start, end) & substring કાઢે છે \\
indexOf(char) & character ની પોઝિશન શોધે છે \\
toUpperCase() & uppercase માં કન્વર્ટ કરે છે \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
public class StringDemo \{
    public static void main(String[] args) \{
        String str = "Hello World";
        
        // length() method
        System.out.println("Length: " + str.length()); // 11
        
        // charAt() method
        System.out.println("Char at 0: " + str.charAt(0)); // H
        
        // substring() method
        System.out.println("Substring: " + str.substring(0, 5)); // Hello
    \}
\}
\end{verbatim}

\textbf{મુખ્ય મુદ્દા:}

\begin{itemize}
\tightlist
\item
  \textbf{Immutable}: String ઓબ્જેક્ટ્સ બદલી શકાતા નથી
\item
  \textbf{Memory Efficient}: Storage માટે string pool
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Strings ટેક્સ્ટ સ્ટોર કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{Garbage Collection વ્યાખ્યાયિત કરો. JAVA પ્રોગ્રામિંગમાં Garbage
Collection નું મહત્વ જણાવો.}

\begin{solutionbox}

\textbf{Garbage Collection વ્યાખ્યા:} આપોઆપ મેમરી મેનેજમેન્ટ પ્રક્રિયા જે એવા
ઓબ્જેક્ટ્સ દ્વારા કબજે કરાયેલી મેમરી પાછી મેળવે છે જેનો હવે કોઈ reference નથી.

\textbf{મહત્વ:}

\begin{itemize}
\tightlist
\item
  \textbf{આપોઆપ મેમરી મેનેજમેન્ટ}: મેન્યુઅલ મેમરી deallocation ની જરૂર નથી
\item
  \textbf{Memory Leaks ટાળે છે}: આપોઆપ unused મેમરી મુક્ત કરે છે
\item
  \textbf{Application Performance}: મેમરી ઉપયોગને optimize કરે છે
\end{itemize}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{Programmer Productivity}: મેમરી મેનેજમેન્ટ પર નહીં, logic પર ધ્યાન
\item
  \textbf{Reliability}: મેમરી issues ને લીધે crashes ઘટાડે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Garbage Collector મેમરી સાફ કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{Object ને Garbage collection માટે eligible બનાવવાની ચાર રીતોની
યાદી બનાવો.}

\begin{solutionbox}

\textbf{GC Eligibility ની ચાર રીતો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
રીત
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Reference ને Null કરવું} & Object reference ને null સેટ કરવું \\
\textbf{Reference ફરીથી Assign કરવું} & Reference ને બીજા object પર point
કરવું \\
\textbf{Anonymous Objects} & Reference વિના objects બનાવવા \\
\textbf{Island of Isolation} & Objects માત્ર એકબીજાને refer કરે \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{itemize}
\tightlist
\item
  \textbf{Nullifying}: \texttt{obj\ =\ null;}
\item
  \textbf{Reassigning}: \texttt{obj1\ =\ obj2;}
\item
  \textbf{Anonymous}: \texttt{new\ Student();}
\item
  \textbf{Island}: બાહ્ય access વિના circular references
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Null References Islands ને આકર્ષે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{Static block દર્શાવવા માટે JAVA પ્રોગ્રામ લખો જે main પહેલા execute
થાય છે. તેનું મહત્વ સમજાવો.}

\begin{solutionbox}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
public class StaticBlockDemo \{
    static int count;
    
    // Static block
    static \{
        System.out.println("Static block executed first");
        count = 10;
        System.out.println("Count initialized to: " + count);
    \}
    
    public static void main(String[] args) \{
        System.out.println("Main method started");
        System.out.println("Count value: " + count);
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
Static block executed first
Count initialized to: 10
Main method started
Count value: 10
\end{verbatim}

\textbf{મહત્વ:}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રારંભિક Initialization}: main method પહેલા execute થાય છે
\item
  \textbf{Class Loading}: ક્લાસ પ્રથમ વખત લોડ થાય ત્યારે ચાલે છે
\item
  \textbf{એક વખત Execute}: ક્લાસ દીઠ માત્ર એક વખત execute થાય છે
\end{itemize}

\textbf{ઉપયોગ:}

\begin{itemize}
\tightlist
\item
  \textbf{Static Variable Initialization}: static variables ને initialize
  કરવા
\item
  \textbf{Resource Loading}: configuration files લોડ કરવા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Static Blocks Main પહેલા શરૂ થાય છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{JAVA માં Minor/Incremental અને Major/Full Garbage collection નું
વર્ણન કરો.}

\begin{solutionbox}

\textbf{Garbage Collection ના પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & આવર્તન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Minor GC} & Young generation સાફ કરે છે & વારંવાર \\
\textbf{Major GC} & Old generation સાફ કરે છે & ઓછું વારંવાર \\
\end{longtable}
}

\textbf{Minor GC:}

\begin{itemize}
\tightlist
\item
  \textbf{લક્ષ્ય}: Young generation objects
\item
  \textbf{ઝડપ}: ઝડપી execution
\item
  \textbf{પ્રભાવ}: ઓછું application pause
\end{itemize}

\textbf{Major GC:}

\begin{itemize}
\tightlist
\item
  \textbf{લક્ષ્ય}: Old generation objects
\item
  \textbf{ઝડપ}: ધીમું execution
\item
  \textbf{પ્રભાવ}: વધારે application pause
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Minor વારંવાર, Major ધીમું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{JAVA માં finalize() method ને તેના ફાયદાઓ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{finalize() Method:} Garbage collector દ્વારા object destruction
પહેલા cleanup operations માટે કૉલ કરાતી વિશેષ method.

\textbf{Syntax:}

\begin{verbatim}
protected void finalize() throws Throwable \{
    // Cleanup code
\}
\end{verbatim}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{Resource Cleanup}: Files, database connections બંધ કરવા
\item
  \textbf{Memory Management}: Native resources મુક્ત કરવા
\item
  \textbf{Safety Net}: Cleanup માટે છેલ્લી તક
\end{itemize}

\textbf{ઉદાહરણ:}

\begin{verbatim}
class FileHandler \{
    protected void finalize() throws Throwable \{
        System.out.println("Cleanup before destruction");
        super.finalize();
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Finalize Resources મુક્ત કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{public static void main(String[] args) ની syntax સમજાવો.
Command line argument તરીકે લેવાયેલ input ને છાપવા માટે JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{Main Method Syntax:}

\begin{verbatim}
public static void main(String[] args)
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{public}: ગમે ત્યાંથી accessible
\item
  \textbf{static}: Object બનાવ્યા વિના કૉલ કરી શકાય
\item
  \textbf{void}: કોઈ return value નથી
\item
  \textbf{main}: JVM દ્વારા ઓળખાતું method નામ
\item
  \textbf{String[] args}: Command line arguments array
\end{itemize}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
public class CommandLineDemo \{
    public static void main(String[] args) \{
        System.out.println("Arguments ની સંખ્યા: " + args.length);
        
        if(args.length {} 0) \{
            System.out.println("Command line arguments:");
            for(int i = 0; i {} args.length; i++) \{
                System.out.println("Arg " + i + ": " + args[i]);
            \}
        \} else \{
            System.out.println("કોઈ arguments પ્રદાન કરાયા નથી");
        \}
    \}
\}
\end{verbatim}

\textbf{Execution:}

\begin{verbatim}
java CommandLineDemo Hello World 123
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
Arguments ની સંખ્યા: 3
Command line arguments:
Arg 0: Hello
Arg 1: World
Arg 2: 123
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Public Static Void Main Args''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{વિવિધ Java access modifiers ની યાદી બનાવો અને સમજાવો.}

\begin{solutionbox}

\textbf{Java Access Modifiers:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Modifier & Class & Package & Subclass & World \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{public} & ✓ & ✓ & ✓ & ✓ \\
\textbf{protected} & ✓ & ✓ & ✓ & ✗ \\
\textbf{default} & ✓ & ✓ & ✗ & ✗ \\
\textbf{private} & ✓ & ✗ & ✗ & ✗ \\
\end{longtable}
}

\textbf{ઉપયોગ:}

\begin{itemize}
\tightlist
\item
  \textbf{public}: બધે accessible
\item
  \textbf{protected}: Package અને subclasses માં accessible
\item
  \textbf{default}: માત્ર package-level access
\item
  \textbf{private}: માત્ર class-level access
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Public Protected Default Private''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{JAVA માં interface નું વર્ણન કરો. Executable ઉદાહરણ સાથે interface નો
inheritance દર્શાવો.}

\begin{solutionbox}

\textbf{Java માં Interface:} એક contract જે implementation વિના method
signatures વ્યાખ્યાયિત કરે છે. Classes interface ને implement કરીને method
definitions પ્રદાન કરે છે.

\textbf{Interface Inheritance ઉદાહરણ:}

\begin{verbatim}
// Parent interface
interface Animal \{
    void sound();
\}

// Child interface Animal થી inherit કરે છે
interface Mammal extends Animal \{
    void walk();
\}

// Child interface ને implement કરતી class
class Dog implements Mammal \{
    public void sound() \{
        System.out.println("કૂતરો ભસે છે");
    \}
    
    public void walk() \{
        System.out.println("કૂતરો ચાર પગ પર ચાલે છે");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Dog d = new Dog();
        d.sound();
        d.walk();
    \}
\}
\end{verbatim}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{Multiple Inheritance}: Interface multiple inheritance support
  કરે છે
\item
  \textbf{Contract}: Class શું implement કરવું જોઈએ તે વ્યાખ્યાયિત કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Interfaces Contracts Inherit કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{super keyword વ્યાખ્યાયિત કરો અને executable JAVA પ્રોગ્રામ સાથે super
keyword નો ઉપયોગ દર્શાવો}

\begin{solutionbox}

\textbf{super Keyword:} Immediate parent class object ને reference કરે છે.
Parent class ના methods, variables, અને constructors ને access કરવા માટે
વપરાય છે.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Animal \{
    String name = "પ્રાણી";
    
    Animal(String type) \{
        System.out.println("Animal constructor: " + type);
    \}
    
    void sound() \{
        System.out.println("પ્રાણી અવાજ કરે છે");
    \}
\}

class Dog extends Animal \{
    String name = "કૂતરો";
    
    Dog() \{
        super("સસ્તન");  // Parent constructor કૉલ કરે છે
        System.out.println("Dog constructor");
    \}
    
    void sound() \{
        super.sound();    // Parent method કૉલ કરે છે
        System.out.println("કૂતરો ભસે છે");
    \}
    
    void display() \{
        System.out.println("Parent name: " + super.name);
        System.out.println("Child name: " + this.name);
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Dog d = new Dog();
        d.sound();
        d.display();
    \}
\}
\end{verbatim}

\textbf{super ના ઉપયોગો:}

\begin{itemize}
\tightlist
\item
  \textbf{Constructor Call}: \texttt{super(parameters)}
\item
  \textbf{Method Call}: \texttt{super.methodName()}
\item
  \textbf{Variable Access}: \texttt{super.variableName}
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Super Parent ને કૉલ કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{JAVA માં package ને વ્યવહારુ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Java માં Package:} સંબંધિત classes અને interfaces ને એકસાથે organize
કરતું namespace. Access control અને namespace management પ્રદાન કરે છે.

\textbf{Package Structure:}

\begin{verbatim}
com.company.project
├── model
│   └── Student.java
├── service
│   └── StudentService.java
└── Main.java
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
// File: com/company/model/Student.java
package com.company.model;

public class Student \{
    private String name;
    public String getName() \{ return name; \}
    public void setName(String name) \{ this.name = name; \}
\}

// File: Main.java
import com.company.model.Student;

public class Main \{
    public static void main(String[] args) \{
        Student s = new Student();
        s.setName("જોહ્ન");
    \}
\}
\end{verbatim}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{Organization}: સંબંધિત classes ને group કરે છે
\item
  \textbf{Access Control}: Package-level access
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Packages Classes ને Organize કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{વ્યવહારુ ઉદાહરણ સાથે abstract અને final keywords સમજાવો.}

\begin{solutionbox}

\textbf{Keywords સમજૂતી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Keyword & હેતુ & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{abstract} & અધૂરી implementation & Classes અને methods \\
\textbf{final} & Modification અટકાવવું & Classes, methods, variables \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
// Abstract class
abstract class Shape \{
    final double PI = 3.14;  // final variable
    
    abstract void draw();    // abstract method
    
    final void display() \{   // final method
        System.out.println("આકાર દર્શાવી રહ્યા છીએ");
    \}
\}

// Final class
final class Circle extends Shape \{
    void draw() \{
        System.out.println("વર્તુળ દોરી રહ્યા છીએ");
    \}
\}

// Final ને લીધે Circle class ને extend કરી શકાતું નથી
// class Oval extends Circle \{ \ // Error!}
\end{verbatim}

\textbf{મુખ્ય મુદ્દા:}

\begin{itemize}
\tightlist
\item
  \textbf{abstract}: Subclass માં override કરવું જોઈએ
\item
  \textbf{final}: Override અથવા extend કરી શકાતું નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Abstract મંજૂરી આપે છે, Final મનાઈ કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{Java Programming language context માં Dynamic Method Dispatch
વ્યાખ્યાયિત કરો. Dynamic Method Dispatch દર્શાવતો executable પ્રોગ્રામ
બનાવો.}

\begin{solutionbox}

\textbf{Dynamic Method Dispatch:} Runtime polymorphism જ્યાં method call
execution દરમિયાન actual object type આધારે resolve થાય છે, reference type
આધારે નહીં.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
// Base class
class Animal \{
    void sound() \{
        System.out.println("પ્રાણી અવાજ કરે છે");
    \}
\}

// Derived classes
class Dog extends Animal \{
    void sound() \{
        System.out.println("કૂતરો ભસે છે");
    \}
\}

class Cat extends Animal \{
    void sound() \{
        System.out.println("બિલાડી મ્યાવ કરે છે");
    \}
\}

class DynamicDispatchDemo \{
    public static void main(String[] args) \{
        Animal ref;  // Reference variable
        
        // Runtime method resolution
        ref = new Dog();
        ref.sound();  // Dog નો sound() કૉલ થાય છે
        
        ref = new Cat();
        ref.sound();  // Cat નો sound() કૉલ થાય છે
        
        ref = new Animal();
        ref.sound();  // Animal નો sound() કૉલ થાય છે
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
કૂતરો ભસે છે
બિલાડી મ્યાવ કરે છે
પ્રાણી અવાજ કરે છે
\end{verbatim}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{Runtime Resolution}: Runtime પર method નક્કી થાય છે
\item
  \textbf{Polymorphism}: સમાન interface, વિવિધ behavior
\item
  \textbf{Virtual Method Table}: JVM method lookup માટે vtable વાપરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dynamic Dispatch Runtime નક્કી કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{Exception Handling માં throw અને finally keywords સમજાવો.}

\begin{solutionbox}

\textbf{Exception Handling Keywords:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Keyword & હેતુ & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{throw} & મેન્યુઅલી exception throw કરવું &
\texttt{throw\ new\ Exception();} \\
\textbf{finally} & હંમેશા execute થતો block & try-catch પછી \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{verbatim}
// throw ઉદાહરણ
if(age {} 0) \{
    throw new IllegalArgumentException("અયોગ્ય વય");
\}

// finally ઉદાહરણ
try \{
    // જોખમી કોડ
\} catch(Exception e) \{
    // exception handle કરો
\} finally \{
    // cleanup કોડ {- હંમેશા execute થાય છે}
\}
\end{verbatim}

\textbf{મુખ્ય મુદ્દા:}

\begin{itemize}
\tightlist
\item
  \textbf{throw}: સ્પષ્ટપણે exception બનાવે છે અને throw કરે છે
\item
  \textbf{finally}: Exception આવે કે ન આવે તે ને ધ્યાને લીધા વિના execute થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Throw બનાવે છે, Finally સાફ કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{JAVA માં try\ldots catch block દર્શાવતો પ્રોગ્રામ લખો}

\begin{solutionbox}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
public class TryCatchDemo \{
    public static void main(String[] args) \{
        try \{
            int[] arr = \{1, 2, 3\;}
            System.out.println("Array element: " + arr[5]); // Index out of bounds
            
            int result = 10 / 0; // Division by zero
            
        \} catch(ArrayIndexOutOfBoundsException e) \{
            System.out.println("Array index error: " + e.getMessage());
            
        \} catch(ArithmeticException e) \{
            System.out.println("ગણિત error: " + e.getMessage());
            
        \} catch(Exception e) \{
            System.out.println("સામાન્ય error: " + e.getMessage());
        \}
        
        System.out.println("પ્રોગ્રામ ચાલુ રહે છે...");
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
Array index error: Index 5 out of bounds for length 3
પ્રોગ્રામ ચાલુ રહે છે...
\end{verbatim}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{Exception Handling}: સુંદર error management
\item
  \textbf{Program Continuity}: પ્રોગ્રામ crash નથી થતો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try કોડ, Catch Errors''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{ArrayIndexOutOfBoundsException Exception વ્યાખ્યાયિત કરો. તેને
પ્રદર્શિત કરતો એક કાર્યક્ષમ JAVA પ્રોગ્રામ લખો. Input(ઓ) નો પણ ઉલ્લેખ કરો જે આ
Exception ને વધારશે.}

\begin{solutionbox}

\textbf{ArrayIndexOutOfBoundsException:} Runtime exception જે અયોગ્ય index
(નકારાત્મક અથવા \textgreater= array length) સાથે array element ને access
કરવાનો પ્રયાસ કરતી વખતે thrown થાય છે.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
public class ArrayExceptionDemo \{
    public static void main(String[] args) \{
        int[] numbers = \{10, 20, 30, 40, 50\;} // Array size: 5
        
        try \{
            System.out.println("Array લંબાઈ: " + numbers.length);
            
            // Valid access
            System.out.println("Index 2 પર element: " + numbers[2]);
            
            // Invalid access {- exception throw કરશે}
            System.out.println("Index 10 પર element: " + numbers[10]);
            
        \} catch(ArrayIndexOutOfBoundsException e) \{
            System.out.println("Exception પકડાયું: " + e.getMessage());
            System.out.println("અયોગ્ય index access કર્યું!");
        \}
        
        System.out.println("પ્રોગ્રામ સફળતાપૂર્વક પૂર્ણ થયો");
    \}
\}
\end{verbatim}

\textbf{Exception raise કરતા inputs:}

\begin{itemize}
\tightlist
\item
  \textbf{નકારાત્મક Index}: \texttt{arr[-1]}
\item
  \textbf{Index \textgreater= Length}: size 5 ના array માટે
  \texttt{arr[5]}
\item
  \textbf{Empty Array Access}: ખાલી array માટે \texttt{arr[0]}
\end{itemize}

\textbf{બચાવ:}

\begin{itemize}
\tightlist
\item
  \textbf{Bounds Checking}: Access પહેલા index verify કરો
\item
  \textbf{Array Length}: \texttt{array.length} property વાપરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Array Bounds Programs તોડે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{JAVA માં Thread ના life cycle ને ઉદાહરણ સાથે દોરો અને સમજાવો.}

\begin{solutionbox}

\textbf{Thread Life Cycle:}

\begin{verbatim}
stateDiagram{-v2}
        direction LR
    [*] {-{-} NEW}
    NEW {-{-} RUNNABLE : start()}
    RUNNABLE {-{-} RUNNING : CPU allocation}
    RUNNING {-{-} RUNNABLE : yield()}
    RUNNING {-{-} BLOCKED : wait for resource}
    BLOCKED {-{-} RUNNABLE : resource available}
    RUNNING {-{-} WAITING : wait()}
    WAITING {-{-} RUNNABLE : notify()}
    RUNNING {-{-} TIMED\_WAITING : sleep()}
    TIMED\_WAITING {-{-} RUNNABLE : timeout}
    RUNNING {-{-} TERMINATED : completion}
    TERMINATED {-{-} [*]}
\end{verbatim}

\textbf{States:}

\begin{itemize}
\tightlist
\item
  \textbf{NEW}: Thread બનાવ્યો પણ શરૂ કર્યો નથી
\item
  \textbf{RUNNABLE}: Run કરવા માટે તૈયાર અથવા running
\item
  \textbf{BLOCKED}: Resource માટે waiting
\item
  \textbf{WAITING}: અનિશ્ચિત સમય માટે waiting
\item
  \textbf{TIMED\_WAITING}: નિર્દિષ્ટ સમય માટે waiting
\item
  \textbf{TERMINATED}: Thread execution પૂર્ણ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``New Runs, Blocks Wait, Terminates''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{JAVA Optional class સમજાવો. Optional class ની OfNullable()
પદ્ધતિનું વર્ણન કરો.}

\begin{solutionbox}

\textbf{Optional Class:} Container object જે value હોઈ શકે કે ન પણ હોઈ શકે.
NullPointerException ટાળવામાં મદદ કરે છે અને કોડને વધુ readable બનાવે છે.

\textbf{ofNullable() Method:} Value non-null હોય તો તે સાથેનું Optional પરત
કરે છે, અન્યથા empty Optional પરત કરે છે.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
import java.util.Optional;

public class OptionalDemo \{
    public static void main(String[] args) \{
        String name1 = "જોહ્ન";
        String name2 = null;
        
        // ofNullable() ઉદાહરણો
        Optional{}String{} opt1 = Optional.ofNullable(name1);
        Optional{}String{} opt2 = Optional.ofNullable(name2);
        
        System.out.println("opt1 હાજર: " + opt1.isPresent()); // true
        System.out.println("opt2 હાજર: " + opt2.isPresent()); // false
        
        // Safe value retrieval
        System.out.println("Name1: " + opt1.orElse("અજ્ઞાત"));
        System.out.println("Name2: " + opt2.orElse("અજ્ઞાત"));
    \}
\}
\end{verbatim}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{Null Safety}: NullPointerException અટકાવે છે
\item
  \textbf{Readable Code}: Optional values નું સ્પષ્ટ indication
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Optional Null Safety ઓફર કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{નેસ્ટેડ try\ldots catch block દર્શાવતો કાર્યક્ષમ JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
public class NestedTryCatchDemo \{
    public static void main(String[] args) \{
        try \{
            System.out.println("બાહ્ય try block શરૂ થયો");
            
            int[] numbers = \{10, 20, 30\;}
            
            try \{
                System.out.println("આંતરિક try block શરૂ થયો");
                
                // આ ArrayIndexOutOfBoundsException આપશે
                System.out.println("Index 5 access કરવું: " + numbers[5]);
                
                // આ લાઇન execute નહીં થાય
                int result = 100 / 0;
                
            \} catch(ArrayIndexOutOfBoundsException e) \{
                System.out.println("આંતરિક catch: Array index error {- "} + e.getMessage());
                
                // આંતરિક catch માંથી નવું exception throw કરવું
                throw new RuntimeException("આંતરિક block માં error");
            \}
            
            System.out.println("આંતરિક try{-catch પછી"});
            
        \} catch(RuntimeException e) \{
            System.out.println("બાહ્ય catch: Runtime error {- "} + e.getMessage());
            
        \} catch(Exception e) \{
            System.out.println("બાહ્ય catch: સામાન્ય error {- "} + e.getMessage());
            
        \} finally \{
            System.out.println("બાહ્ય finally: Cleanup operations");
        \}
        
        System.out.println("પ્રોગ્રામ execution પૂર્ણ થયું");
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
બાહ્ય try block શરૂ થયો
આંતરિક try block શરૂ થયો
આંતરિક catch: Array index error - Index 5 out of bounds for length 3
બાહ્ય catch: Runtime error - આંતરિક block માં error
બાહ્ય finally: Cleanup operations
પ્રોગ્રામ execution પૂર્ણ થયું
\end{verbatim}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{બહુવિધ સ્તરો}: આંતરિક અને બાહ્ય exception handling
\item
  \textbf{Exception Propagation}: આંતરિક exceptions બાહ્ય blocks દ્વારા
  પકડાઈ શકે છે
\item
  \textbf{વિશિષ્ટ Handling}: વિવિધ સ્તરો પર વિવિધ exceptions
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Nested Try સ્તરો Catches કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{JAVA માં executable કોડ સાથે thread synchronization સમજાવો.}

\begin{solutionbox}

\textbf{Thread Synchronization:} Data inconsistency અને race conditions
અટકાવવા માટે બહુવિધ threads દ્વારા shared resources ના access ને control
કરવાની પદ્ધતિ.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Counter \{
    private int count = 0;
    
    // Synchronized method
    public synchronized void increment() \{
        count++;
    \}
    
    public int getCount() \{
        return count;
    \}
\}

class SyncDemo extends Thread \{
    Counter counter;
    
    SyncDemo(Counter c) \{
        counter = c;
    \}
    
    public void run() \{
        for(int i = 0; i {} 1000; i++) \{
            counter.increment();
        \}
    \}
\}
\end{verbatim}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{Data Consistency}: Race conditions અટકાવે છે
\item
  \textbf{Thread Safety}: Shared resources ને safe access
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Synchronize Shared Data ને સુરક્ષિત કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{JAVA માં વિવિધ stream classes ની નોંધણી કરો. Executable ઉદાહરણ સાથે
કોઈપણ એકને સમજાવો.}

\begin{solutionbox}

\textbf{Stream Classes:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Class & હેતુ & પ્રકાર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{FileInputStream} & File માંથી bytes વાંચવા & Input \\
\textbf{FileOutputStream} & File માં bytes લખવા & Output \\
\textbf{BufferedReader} & Buffered character reading & Input \\
\textbf{PrintWriter} & Formatted text output & Output \\
\end{longtable}
}

\textbf{FileInputStream ઉદાહરણ:}

\begin{verbatim}
import java.io.*;

public class StreamDemo \{
    public static void main(String[] args) \{
        try \{
            // File બનાવો અને data લખો
            FileOutputStream fos = new FileOutputStream("test.txt");
            String data = "નમસ્તે વિશ્વ";
            fos.write(data.getBytes());
            fos.close();
            
            // FileInputStream વાપરીને file વાંચો
            FileInputStream fis = new FileInputStream("test.txt");
            int ch;
            while((ch = fis.read()) != {-}1) \{
                System.out.print((char)ch);
            \}
            fis.close();
            
        \} catch(IOException e) \{
            e.printStackTrace();
        \}
    \}
\}
\end{verbatim}

\textbf{Stream લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{Byte-oriented}: Binary data handle કરે છે
\item
  \textbf{Character-oriented}: Text data handle કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Streams Data મોકલે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{Thread નો ઉપયોગ કરીને આપેલ બે પૂર્ણાંક સંખ્યાઓ વચ્ચે વિષમ સંખ્યાઓ દર્શાવવા
માટે Thread class ને વિસ્તારતો JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class OddNumberThread extends Thread \{
    private int start;
    private int end;
    
    public OddNumberThread(int start, int end) \{
        this.start = start;
        this.end = end;
    \}
    
    @Override
    public void run() \{
        System.out.println("Thread શરૂ થયો: " + Thread.currentThread().getName());
        System.out.println(start + " અને " + end + " વચ્ચે વિષમ સંખ્યાઓ શોધી રહ્યા છીએ");
        
for(int

i = start; i {=} end; i++) \{

            if(i \% 2 != 0) \{  // સંખ્યા વિષમ છે કે તે ચકાસો
                System.out.println("વિષમ સંખ્યા: " + i);
                try \{
                    Thread.sleep(500);  // 500ms માટે pause
                \} catch(InterruptedException e) \{
                    System.out.println("Thread interrupted");
                \}
            \}
        \}
        
        System.out.println("Thread પૂર્ણ થયો: " + Thread.currentThread().getName());
    \}
\}

public class OddNumberDemo \{
    public static void main(String[] args) \{
        // Thread objects બનાવો
        OddNumberThread thread1 = new OddNumberThread(1, 10);
        OddNumberThread thread2 = new OddNumberThread(11, 20);
        
        // Thread names સેટ કરો
        thread1.setName("OddThread{-1"});
        thread2.setName("OddThread{-2"});
        
        // Threads શરૂ કરો
        thread1.start();
        thread2.start();
        
        try \{
            // Threads પૂર્ણ થવાની રાહ જુઓ
            thread1.join();
            thread2.join();
        \} catch(InterruptedException e) \{
            e.printStackTrace();
        \}
        
        System.out.println("બધા threads પૂર્ણ થયા!");
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
Thread શરૂ થયો: OddThread-1
1 અને 10 વચ્ચે વિષમ સંખ્યાઓ શોધી રહ્યા છીએ
Thread શરૂ થયો: OddThread-2
11 અને 20 વચ્ચે વિષમ સંખ્યાઓ શોધી રહ્યા છીએ
વિષમ સંખ્યા: 1
વિષમ સંખ્યા: 11
વિષમ સંખ્યા: 3
વિષમ સંખ્યા: 13
...
\end{verbatim}

\textbf{Thread લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{Concurrent Execution}: બહુવિધ threads એકસાથે ચાલે છે
\item
  \textbf{Thread Extension}: Custom behavior માટે Thread class extend કરે
  છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Threads વારા લે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{JAVA માં Thread class ની join() અને alive() પદ્ધતિઓ સમજાવો.}

\begin{solutionbox}

\textbf{Thread Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & હેતુ & Return Type \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{join()} & Thread completion માટે રાહ જોવું & void \\
\textbf{isAlive()} & Thread running છે કે તે ચકાસવું & boolean \\
\end{longtable}
}

\textbf{Method સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{join()}: Current thread આપેલ thread complete થાય ત્યાં સુધી રાહ જુએ
  છે
\item
  \textbf{isAlive()}: Thread હજુ running છે તો true, complete થયો હોય તો
  false પરત કરે છે
\end{itemize}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class TestThread extends Thread \{
    public void run() \{
for(int

i = 1; i {=} 3; i++) \{

            System.out.println("ચાલી રહ્યું: " + i);
            try \{ sleep(1000); \} catch(InterruptedException e) \{\}
        \}
    \}
\}

public class Main \{
    public static void main(String[] args) throws InterruptedException \{
        TestThread t = new TestThread();
        System.out.println("Start પહેલા: " + t.isAlive()); // false
        
        t.start();
        System.out.println("Start પછી: " + t.isAlive()); // true
        
        t.join(); // Completion માટે રાહ જુઓ
        System.out.println("Join પછી: " + t.isAlive()); // false
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Join રાહ જુએ છે, Alive ચકાસે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{JAVA માં user-defined exceptions ને વ્યાખ્યાયિત કરો. User-defined
exceptions બતાવવા માટે પ્રોગ્રામ લખો}

\begin{solutionbox}

\textbf{User-defined Exceptions:} Exception class અથવા તેની subclasses ને
extend કરીને વિશિષ્ટ application errors handle કરવા માટે બનાવાતી custom
exception classes.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
// Custom exception class
class AgeValidationException extends Exception \{
    public AgeValidationException(String message) \{
        super(message);
    \}
\}

class Person \{
    private int age;
    
    public void setAge(int age) throws AgeValidationException \{
        if(age {} 0) \{
            throw new AgeValidationException("વય નકારાત્મક હોઈ શકે નહીં: " + age);
        \}
        if(age {} 150) \{
            throw new AgeValidationException("વય 150 કરતાં વધારે હોઈ શકે નહીં: " + age);
        \}
        this.age = age;
        System.out.println("માન્ય વય સેટ કર્યો: " + age);
    \}
    
    public int getAge() \{
        return age;
    \}
\}

public class UserDefinedExceptionDemo \{
    public static void main(String[] args) \{
        Person person = new Person();
        
        try \{
            person.setAge(25);    // માન્ય વય
            person.setAge({-}5);    // અમાન્ય વય {- exception throw કરશે}
            
        \} catch(AgeValidationException e) \{
            System.out.println("Custom Exception: " + e.getMessage());
        \}
        
        try \{
            person.setAge(200);   // અમાન્ય વય {- exception throw કરશે}
        \} catch(AgeValidationException e) \{
            System.out.println("Custom Exception: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
માન્ય વય સેટ કર્યો: 25
Custom Exception: વય નકારાત્મક હોઈ શકે નહીં: -5
Custom Exception: વય 150 કરતાં વધારે હોઈ શકે નહીં: 200
\end{verbatim}

\textbf{ફાયદા:}

\begin{itemize}
\tightlist
\item
  \textbf{વિશિષ્ટ Error Handling}: Application-specific errors handle કરે
  છે
\item
  \textbf{બહેતર Code Organization}: Exception logic અલગ રાખે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Custom Exceptions વિશિષ્ટ Errors પકડે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{ફાઇલ a.txt ની સામગ્રીને b.txt પર કોપી કરવા માટે JAVA પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
import java.io.*;

public class FileCopyDemo \{
    public static void main(String[] args) \{
        String sourceFile = "a.txt";
        String targetFile = "b.txt";
        
        // Method 1: FileInputStream અને FileOutputStream વાપરીને
        copyUsingStream(sourceFile, targetFile);
        
        // Method 2: BufferedReader અને PrintWriter વાપરીને
        copyUsingBuffered(sourceFile, targetFile);
    \}
    
    // Method 1: Byte{-by{-}byte copy}
    public static void copyUsingStream(String source, String target) \{
        try \{
            // Sample data સાથે source file બનાવો
            FileOutputStream createFile = new FileOutputStream(source);
            String data = "નમસ્તે વિશ્વ!{n}આ sample text છે.{n}Java File Operations.";
            createFile.write(data.getBytes());
            createFile.close();
            System.out.println("Sample data સાથે source file બનાવી");
            
            // File copy કરો
            FileInputStream fis = new FileInputStream(source);
            FileOutputStream fos = new FileOutputStream(target);
            
            int ch;
            while((ch = fis.read()) != {-}1) \{
                fos.write(ch);
            \}
            
            fis.close();
            fos.close();
            System.out.println("Stream વાપરીને file સફળતાપૂર્વક copy કરી");
            
        \} catch(IOException e) \{
            System.out.println("File copy દરમિયાન error: " + e.getMessage());
        \}
    \}
    
    // Method 2: Buffering સાથે line{-by{-}line copy}
    public static void copyUsingBuffered(String source, String target) \{
        try \{
            BufferedReader reader = new BufferedReader(new FileReader(source));
            PrintWriter writer = new PrintWriter(new FileWriter("buffered\_" + target));
            
            String line;
            while((line = reader.readLine()) != null) \{
                writer.println(line);
            \}
            
            reader.close();
            writer.close();
            System.out.println("BufferedReader વાપરીને file સફળતાપૂર્વક copy કરી");
            
            // Copy કરેલ content દર્શાવો
            displayFileContent("buffered\_" + target);
            
        \} catch(IOException e) \{
            System.out.println("Buffered copy દરમિયાન error: " + e.getMessage());
        \}
    \}
    
    // File content દર્શાવવા માટે helper method
    public static void displayFileContent(String filename) \{
        try \{
            System.out.println("{n}" + filename + " ની સામગ્રી:");
            BufferedReader reader = new BufferedReader(new FileReader(filename));
            String line;
            while((line = reader.readLine()) != null) \{
                System.out.println(line);
            \}
            reader.close();
            
        \} catch(IOException e) \{
            System.out.println("File વાંચતી વખતે error: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\textbf{આઉટપુટ:}

\begin{verbatim}
Sample data સાથે source file બનાવી
Stream વાપરીને file સફળતાપૂર્વક copy કરી
BufferedReader વાપરીને file સફળતાપૂર્વક copy કરી

buffered_b.txt ની સામગ્રી:
નમસ્તે વિશ્વ!
આ sample text છે.
Java File Operations.
\end{verbatim}

\textbf{File Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{FileInputStream/FileOutputStream}: Byte-level operations
\item
  \textbf{BufferedReader/PrintWriter}: Buffering સાથે line-level
  operations
\item
  \textbf{Exception Handling}: યોગ્ય error management
\end{itemize}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{બહુવિધ Methods}: File copying માટે વિવિધ approaches
\item
  \textbf{Error Handling}: IOException માટે try-catch blocks
\item
  \textbf{Resource Management}: File streams નું યોગ્ય closing
\end{itemize}

\textbf{શ્રેષ્ઠ પ્રથાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Streams બંધ કરો}: ઉપયોગ પછી હંમેશા file streams બંધ કરો
\item
  \textbf{Exception Handling}: IOException ને યોગ્ય રીતે handle કરો
\item
  \textbf{Buffer Usage}: બહેતર performance માટે buffered streams વાપરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Files Source થી Target તરફ Flow કરે છે''

\end{mnemonicbox}

\end{document}
