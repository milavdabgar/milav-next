\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4341602 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{OOP ના બેસિક કન્સેપ્ટની યાદી આપો. કોઈપણ એક વિગતવાર સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
મૂળભૂત OOP કન્સેપ્ટ્સ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Class} & ઓબ્જેક્ટ માટે બ્લુપ્રિન્ટ \\
\textbf{Object} & ક્લાસનું ઇન્સ્ટન્સ \\
\textbf{Encapsulation} & ડેટા છુપાવવાની પદ્ધતિ \\
\textbf{Inheritance} & પેરેન્ટ થી પ્રોપર્ટીઝ મેળવવી \\
\textbf{Polymorphism} & એક ઇન્ટરફેસ, વિવિધ સ્વરૂપો \\
\textbf{Abstraction} & ઇમ્પ્લિમેન્ટેશન વિગતો છુપાવવા \\
\end{longtable}
}

\textbf{Encapsulation} એ ડેટા અને મેથડ્સને એક સાથે ક્લાસમાં બાંધવાની અને બાહ્ય
વિશ્વથી આંતરિક ઇમ્પ્લિમેન્ટેશન છુપાવવાની પ્રક્રિયા છે. તે વેરિયેબલ્સને private બનાવીને અને
public મેથડ્સ દ્વારા એક્સેસ કરીને ડેટા સિક્યોરિટી પ્રદાન કરે છે.

\end{solutionbox}
\begin{mnemonicbox}
``CEO-IPA'' (Class, Encapsulation, Object,
Inheritance, Polymorphism, Abstraction)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{JVM ને વિગતવાર સમજાવો.}

\begin{solutionbox}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Java Source Code] {-{-}{} B[Java Compiler]}
    B {-{-}{} C[Bytecode .class]}
    C {-{-}{} D[JVM]}
    D {-{-}{} E[Machine Code]}
    E {-{-}{} F[Output]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{JVM (Java Virtual Machine)} એક રનટાઇમ એન્વાયરનમેન્ટ છે જે Java
bytecode ને એક્ઝિક્યુટ કરે છે. તે bytecode ને મશીન-સ્પેસિફિક કોડમાં કન્વર્ટ કરીને
પ્લેટફોર્મ ઇન્ડિપેન્ડન્સ પ્રદાન કરે છે.

\begin{itemize}
\tightlist
\item
  \textbf{Class Loader}: ક્લાસ ફાઇલ્સને મેમરીમાં લોડ કરે છે
\item
  \textbf{Memory Management}: heap અને stack મેમરી હેન્ડલ કરે છે
\item
  \textbf{Execution Engine}: bytecode instructions ને એક્ઝિક્યુટ કરે છે
\item
  \textbf{Garbage Collector}: ઓટોમેટિકલી મેમરી મેનેજ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CMEG'' (Class loader, Memory, Execution, Garbage
collection)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{Fibonacci series પ્રિન્ટ કરવા માટે n ટર્મ્સ માટે Java માં પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
public class Fibonacci \{
    public static void main(String[] args) \{
int

n = 10, first = 0, second = 1;

        System.out.print("Fibonacci Series: " + first + " " + second);
        
        for(int i = 2; i {} n; i++) \{
            int next = first + second;
            System.out.print(" " + next);
            first = second;
            second = next;
        \}
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{લોજિક}: 0,1 થી શરૂ કરીને પાછલા બે નંબર્સ ઉમેરો
\item
  \textbf{લૂપ}: n ટર્મ્સ માટે ચાલુ રહે છે
\item
  \textbf{વેરિયેબલ્સ}: first, second, next કેલ્ક્યુલેશન માટે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FSN'' (First, Second, Next)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{કમાન્ડ લાઇન arguments નો ઉપયોગ કરીને કોઈપણ દસ સંખ્યાઓ માંથી ન્યૂનતમ
શોધવા માટે Java માં પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
public class FindMinimum \{
    public static void main(String[] args) \{
        if(args.length != 10) \{
            System.out.println("Please enter exactly 10 numbers");
            return;
        \}
        
        int min = Integer.parseInt(args[0]);
        for(int i = 1; i {} args.length; i++) \{
            int num = Integer.parseInt(args[i]);
            if(num {} min) \{
                min = num;
            \}
        \}
        System.out.println("Minimum number: " + min);
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કમાન્ડ લાઇન}: java FindMinimum 5 3 8 1 9 2 7 4 6 0
\item
  \textbf{લોજિક}: દરેક નંબરને કરન્ટ મિનિમમ સાથે કમ્પેર કરો
\item
  \textbf{મેથડ}: Integer.parseInt() સ્ટ્રિંગને integer માં કન્વર્ટ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CIM'' (Check, Integer.parseInt, Minimum)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{Wrapper ક્લાસ શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Primitive & Wrapper Class \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int & Integer \\
char & Character \\
boolean & Boolean \\
double & Double \\
\end{longtable}
}

\textbf{Wrapper classes} primitive ડેટા ટાઇપ્સને ઓબ્જેક્ટ્સમાં કન્વર્ટ કરે છે. તેઓ
utility મેથડ્સ પ્રદાન કરે છે અને primitives ને collections માં ઉપયોગ કરવા માટે
સક્ષમ બનાવે છે.

\textbf{ઉદાહરણ}: \texttt{Integer\ obj\ =\ new\ Integer(25);} અથવા
\texttt{Integer\ obj\ =\ 25;} (autoboxing)

\end{solutionbox}
\begin{mnemonicbox}
``POC'' (Primitive to Object Conversion)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{Java ના વિવિધ લક્ષણોની યાદી આપો. કોઈપણ બે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Java ના લક્ષણો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Platform Independent} & એકવાર લખો, ગમે ત્યાં ચલાવો \\
\textbf{Object Oriented} & બધું ઓબ્જેક્ટ છે \\
\textbf{Simple} & સરળ સિન્ટેક્સ, પોઇન્ટર્સ નથી \\
\textbf{Secure} & Bytecode વેરિફિકેશન \\
\textbf{Robust} & મજબૂત મેમરી મેનેજમેન્ટ \\
\textbf{Multithreaded} & સમાંતર એક્ઝિક્યુશન \\
\end{longtable}
}

\textbf{Platform Independence}: Java સોર્સ કોડ bytecode માં કમ્પાઇલ થાય છે જે
JVM ઇન્સ્ટોલ કરેલા કોઈપણ પ્લેટફોર્મ પર ચાલે છે.

\textbf{Object Oriented}: Java બહેતર કોડ સંગઠન માટે encapsulation,
inheritance, અને polymorphism જેવા OOP સિદ્ધાંતોને અનુસરે છે.

\end{solutionbox}
\begin{mnemonicbox}
``POSSMR'' (Platform, Object, Simple, Secure,
Multithreaded, Robust)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{Method overload શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Method Overloading} એ જ ક્લાસમાં સમાન નામ પરંતુ અલગ પેરામીટર્સ સાથે
બહુવિધ મેથડ્સની મંજૂરી આપે છે.

\begin{verbatim}
class Calculator \{
    public int add(int a, int b) \{
        return a + b;
    \}
    
    public double add(double a, double b) \{
        return a + b;
    \}
    
    public int add(int a, int b, int c) \{
        return a + b + c;
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{નિયમો}: અલગ પેરામીટર ટાઇપ્સ અથવા પેરામીટર્સની સંખ્યા
\item
  \textbf{Compile Time}: કમ્પાઇલેશન દરમિયાન નિર્ણય લેવાય છે
\item
  \textbf{Return Type}: માત્ર તફાવત હોઈ શકતો નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SNRT'' (Same Name, different paRameters, compile
Time)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{Java માં Garbage collection સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
Memory Areas:
┌─────────────┐
│    Heap     │  Objects stored here
├─────────────┤
│   Stack     │  Method calls
├─────────────┤
│   Method    │  Class definitions
│    Area     │
└─────────────┘
\end{verbatim}

\textbf{Garbage Collection} અનરેફરન્સ્ડ ઓબ્જેક્ટ્સની મેમરી ઓટોમેટિકલી deallocate
કરે છે. JVM પીરિયોડિકલી garbage collector ચલાવીને heap મેમરી મુક્ત કરે છે.

\begin{itemize}
\tightlist
\item
  \textbf{ઓટોમેટિક}: મેન્યુઅલ મેમરી મેનેજમેન્ટની જરૂર નથી
\item
  \textbf{Mark and Sweep}: અનરેફરન્સ્ડ ઓબ્જેક્ટ્સને માર્ક કરે છે, પછી દૂર કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ARMS'' (Automatic Reference Management System)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{final કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઉપયોગ & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{final variable} & બદલી શકાતું નથી &
\texttt{final\ int\ x\ =\ 10;} \\
\textbf{final method} & ઓવરરાઇડ થઈ શકતું નથી &
\texttt{final\ void\ display()} \\
\textbf{final class} & inherit થઈ શકતું નથી &
\texttt{final\ class\ MyClass} \\
\end{longtable}
}

\textbf{ઉદાહરણ}:

\begin{verbatim}
final class FinalClass \{
    final int value = 100;
    final void show() \{
        System.out.println("Final method");
    \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``VCM'' (Variable constant, Class not inherited,
Method not overridden)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{કન્સ્ટ્રક્ટર શું છે? parameterized કન્સ્ટ્રક્ટરને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Constructor} એક વિશેષ મેથડ છે જે ઓબ્જેક્ટ્સ બનાવવામાં આવે ત્યારે initialize
કરે છે. તેનું નામ ક્લાસ જેવું જ હોય છે અને કોઈ return type નથી.

\begin{verbatim}
class Student \{
    String name;
    int age;
    
    // Parameterized Constructor
    public Student(String n, int a) \{
        name = n;
        age = a;
    \}
    
    public void display() \{
        System.out.println("Name: " + name + ", Age: " + age);
    \}
\}

class Main \{
    public static void main(String[] args) \{
        Student s1 = new Student("John", 20);
        s1.display();
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{હેતુ}: ઓબ્જેક્ટને સ્પેસિફિક વેલ્યુઝ સાથે initialize કરવો
\item
  \textbf{પેરામીટર્સ}: initial state સેટ કરવા માટે arguments સ્વીકારે છે
\item
  \textbf{ઓટોમેટિક}: ઓબ્જેક્ટ બનાવવામાં આવે ત્યારે ઓટોમેટિકલી કોલ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SPA'' (Same name, Parameters, Automatic call)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{super કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{super કીવર્ડ} પેરેન્ટ ક્લાસના મેમ્બર્સ અને કન્સ્ટ્રક્ટરનો સંદર્ભ આપે છે. તે પેરેન્ટ
અને ચાઇલ્ડ ક્લાસ વચ્ચેના naming conflicts ને ઉકેલે છે.

\begin{verbatim}
class Parent \{
    int x = 10;
\}
class Child extends Parent \{
    int x = 20;
    void display() \{
        System.out.println(super.x); // 10
        System.out.println(x);       // 20
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{super.variable}: પેરેન્ટ ક્લાસ variable ને એક્સેસ કરે છે
\item
  \textbf{super.method()}: પેરેન્ટ ક્લાસ method ને કોલ કરે છે
\item
  \textbf{super()}: પેરેન્ટ ક્લાસ constructor ને કોલ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``VMC'' (Variable, Method, Constructor)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{inheritance ના વિવિધ પ્રકારોની યાદી આપો. multilevel inheritance
સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Inheritance ના પ્રકારો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Single} & એક પેરેન્ટ, એક ચાઇલ્ડ \\
\textbf{Multilevel} & inheritance ની ચેઇન \\
\textbf{Hierarchical} & એક પેરેન્ટ, બહુવિધ બાળકો \\
\textbf{Multiple} & બહુવિધ પેરેન્ટ્સ (interfaces દ્વારા) \\
\end{longtable}
}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Animal] {-{-}{} B[Mammal]}
    B {-{-}{} C[Dog]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Multilevel Inheritance}: ક્લાસ બીજી ક્લાસથી inherit કરે છે જે પોતે
બીજી ક્લાસથી inherit કરે છે, ચેઇન બનાવે છે.

\begin{verbatim}
class Animal \{
    void eat() \{ System.out.println("Eating"); \}
\}
class Mammal extends Animal \{
    void walk() \{ System.out.println("Walking"); \}
\}
class Dog extends Mammal \{
    void bark() \{ System.out.println("Barking"); \}
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SMHM'' (Single, Multilevel, Hierarchical,
Multiple)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{Interface શું છે? ઉદાહરણ સાથે multiple inheritance સમજાવો.}

\begin{solutionbox}

\textbf{Interface} એક કોન્ટ્રાક્ટ છે જે વ્યાખ્યાયિત કરે છે કે ક્લાસે કયા મેથડ્સ
implement કરવા જોઈએ. તેમાં માત્ર abstract methods અને constants હોય છે.

\begin{verbatim}
interface Flyable \{
    void fly();
\}

interface Swimmable \{
    void swim();
\}

class Duck implements Flyable, Swimmable \{
    public void fly() \{
        System.out.println("Duck is flying");
    \}
    
    public void swim() \{
        System.out.println("Duck is swimming");
    \}
\}
\end{verbatim}

\textbf{Multiple Inheritance}: ક્લાસ બહુવિધ interfaces implement કરી શકે છે,
behavior નું multiple inheritance પ્રાપ્ત કરે છે.

\begin{itemize}
\tightlist
\item
  \textbf{Abstract Methods}: બધા મેથડ્સ ડિફોલ્ટ રીતે abstract હોય છે
\item
  \textbf{Constants}: બધા variables public, static, final હોય છે
\item
  \textbf{implements}: interface implement કરવા માટેનો કીવર્ડ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ACI'' (Abstract methods, Constants, implements
keyword)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{static કીવર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{static કીવર્ડ} ક્લાસ-લેવલ મેમ્બર્સ બનાવે છે જે instances ને બદલે ક્લાસના હોય
છે. ક્લાસ લોડ થાય ત્યારે એકવાર મેમરી allocate થાય છે.

\begin{verbatim}
class Counter \{
    static int count = 0;
    static void increment() \{
        count++;
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{static variable}: બધા ઓબ્જેક્ટ્સ વચ્ચે શેર થાય છે
\item
  \textbf{static method}: ઓબ્જેક્ટ બનાવ્યા વિના કોલ કરી શકાય છે
\item
  \textbf{મેમરી}: method area માં allocate થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SOM'' (Shared, Object not needed, Method area)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{Java માં વિવિધ એક્સેસ કંટ્રોલ સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2254}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1690}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1972}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1408}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2676}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Access Modifier
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Same Class
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Same Package
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Subclass
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Different Package
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{private} & ✓ & ✗ & ✗ & ✗ \\
\textbf{default} & ✓ & ✓ & ✗ & ✗ \\
\textbf{protected} & ✓ & ✓ & ✓ & ✗ \\
\textbf{public} & ✓ & ✓ & ✓ & ✓ \\
\end{longtable}
}

\textbf{Access Control} ક્લાસિસ, મેથડ્સ અને variables ની visibility અને
accessibility નક્કી કરે છે.

\end{solutionbox}
\begin{mnemonicbox}
``PriDef ProPub'' (Private, Default, Protected,
Public)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{પેકેજ શું છે? પેકેજ બનાવવાના પગલાં લખો અને તેનું ઉદાહરણ આપો.}

\begin{solutionbox}

\textbf{Package} એક namespace છે જે સંબંધિત ક્લાસિસ અને interfaces ને ગોઠવે છે. તે
access protection અને namespace management પ્રદાન કરે છે.

\textbf{પેકેજ બનાવવાના પગલાં}:

\begin{enumerate}
\tightlist
\item
  ફાઇલની ટોચે \texttt{package} statement નો ઉપયોગ કરો
\item
  પેકેજ નામને મેચ કરતી directory structure બનાવો
\item
  \texttt{-d} ઓપ્શન સાથે કમ્પાઇલ કરો
\item
  અન્ય ફાઇલ્સમાં પેકેજ import કરો
\end{enumerate}

\begin{verbatim}
// File: com/mycompany/MyClass.java
package com.mycompany;

public class MyClass \{
    public void display() \{
        System.out.println("Package example");
    \}
\}

// પેકેજનો ઉપયોગ
import com.mycompany.MyClass;

class Main \{
    public static void main(String[] args) \{
        MyClass obj = new MyClass();
        obj.display();
    \}
\}
\end{verbatim}

\textbf{કમ્પાઇલેશન}: \texttt{javac\ -d\ .\ MyClass.java}

\end{solutionbox}
\begin{mnemonicbox}
``PDCI'' (Package statement, Directory, Compile,
Import)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે thread ની પ્રાથમિકતાઓ સમજાવો.}

\begin{solutionbox}

\textbf{Thread Priority} threads ના execution order નક્કી કરે છે. Java 1
(સૌથી નીચું) થી 10 (સૌથી ઊંચું) સુધી 10 priority levels પ્રદાન કરે છે.

\begin{verbatim}
class MyThread extends Thread \{
    public void run() \{
        System.out.println(getName() + " Priority: " + getPriority());
    \}
\}

class Main \{
    public static void main(String[] args) \{
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        t1.setPriority(Thread.MIN\_PRIORITY); // 1
        t2.setPriority(Thread.MAX\_PRIORITY); // 10
        
        t1.start();
        t2.start();
    \}
\}
\end{verbatim}

\textbf{Priority Constants}: MIN\_PRIORITY (1), NORM\_PRIORITY (5),
MAX\_PRIORITY (10)

\end{solutionbox}
\begin{mnemonicbox}
``MNM'' (MIN, NORM, MAX)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{Thread શું છે? Thread લાઇફ સાઇકલ સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
stateDiagram{-v2}
        direction LR
    [*] {-{-} New}
    New {-{-} Runnable : start()}
    Runnable {-{-} Running : Scheduler}
    Running {-{-} Blocked : wait/sleep}
    Blocked {-{-} Runnable : notify/timeout}
    Running {-{-} Dead : completes}
    Running {-{-} Runnable : yield()}
\end{verbatim}

\textbf{Thread} એક lightweight subprocess છે જે પ્રોગ્રામની અંદર concurrent
execution ને સક્ષમ બનાવે છે.

\textbf{Thread Life Cycle States}:

\begin{itemize}
\tightlist
\item
  \textbf{New}: Thread બનાવ્યો પરંતુ શરૂ નથી કર્યો
\item
  \textbf{Runnable}: ચલાવવા માટે તૈયાર, CPU ની રાહ જોઈ રહ્યો
\item
  \textbf{Running}: હાલમાં execute થઈ રહ્યો
\item
  \textbf{Blocked}: resource અથવા I/O ની રાહ જોઈ રહ્યો
\item
  \textbf{Dead}: Thread execution પૂર્ણ થયું
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``NRRBD'' (New, Runnable, Running, Blocked, Dead)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{Java માં એક પ્રોગ્રામ લખો જે Thread ક્લાસ implement કરીને બહુવિધ
threads બનાવે છે.}

\begin{solutionbox}

\begin{verbatim}
class MyThread extends Thread \{
    private String threadName;
    
    public MyThread(String name) \{
        threadName = name;
        setName(threadName);
    \}
    
    public void run() \{
for(int

i = 1; i {=} 5; i++) \{

            System.out.println(threadName + " {- Count: "} + i);
            try \{
                Thread.sleep(1000);
            \} catch(InterruptedException e) \{
                System.out.println(threadName + " interrupted");
            \}
        \}
        System.out.println(threadName + " completed");
    \}
\}

class Main \{
    public static void main(String[] args) \{
        MyThread thread1 = new MyThread("Thread{-1"});
        MyThread thread2 = new MyThread("Thread{-2"});
        MyThread thread3 = new MyThread("Thread{-3"});
        
        thread1.start();
        thread2.start();
        thread3.start();
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{extends Thread}: Thread ક્લાસની કાર્યક્ષમતા inherit કરે છે
\item
  \textbf{Override run()}: Thread execution લોજિક વ્યાખ્યાયિત કરે છે
\item
  \textbf{start()}: Thread execution શરૂ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``EOS'' (Extends, Override run, Start method)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{ચાર અલગ-અલગ ઇનબિલ્ટ exception ની યાદી આપો. કોઈપણ એક ઇનબિલ્ટ
exception સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Inbuilt Exceptions & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{NullPointerException} & Null reference access \\
\textbf{ArrayIndexOutOfBoundsException} & Invalid array index \\
\textbf{NumberFormatException} & Invalid number format \\
\textbf{ClassCastException} & Invalid type casting \\
\end{longtable}
}

\textbf{NullPointerException} ત્યારે થાય છે જ્યારે null reference ના methods
અથવા variables ને access કરવાનો પ્રયાસ કરવામાં આવે છે.

\begin{verbatim}
String str = null;
int length = str.length(); // Throws NullPointerException
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``NANC'' (NullPointer, ArrayIndex, NumberFormat,
ClassCast)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે multiple catch સમજાવો.}

\begin{solutionbox}

\textbf{Multiple catch} blocks try block માં થઈ શકતા વિવિધ પ્રકારના
exceptions ને handle કરે છે. દરેક catch સ્પેસિફિક exception type ને handle કરે
છે.

\begin{verbatim}
class MultipleCatch \{
    public static void main(String[] args) \{
        try \{
            int[] arr = \{1, 2, 3\;}
            System.out.println(arr[5]); // ArrayIndexOutOfBoundsException
            int result = 10/0;          // ArithmeticException
        \}
        catch(ArrayIndexOutOfBoundsException e) \{
            System.out.println("Array index error: " + e.getMessage());
        \}
        catch(ArithmeticException e) \{
            System.out.println("Arithmetic error: " + e.getMessage());
        \}
        catch(Exception e) \{
            System.out.println("General error: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\textbf{ક્રમ}: પહેલા સ્પેસિફિક exceptions, છેલ્લે જનરલ exceptions

\end{solutionbox}
\begin{mnemonicbox}
``SGO'' (Specific first, General last, Ordered)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{Exception શું છે? Arithmetic Exception નો ઉપયોગ દર્શાવતો પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\textbf{Exception} એક અસામાન્ય સ્થિતિ છે જે સામાન્ય પ્રોગ્રામ flow ને વિક્ષેપિત કરે
છે. તે error condition ને દર્શાવતો ઓબ્જેક્ટ છે.

\begin{verbatim}
class ArithmeticExceptionDemo \{
    public static void main(String[] args) \{
        int numerator = 100;
        int[] denominators = \{5, 0, 2, 0, 10\;}
        
        for(int i = 0; i {} denominators.length; i++) \{
            try \{
                int result = numerator / denominators[i];
                System.out.println(numerator + " / " + denominators[i] + " = " + result);
            \}
            catch(ArithmeticException e) \{
                System.out.println("Error: Cannot divide by zero!");
                System.out.println("Exception message: " + e.getMessage());
            \}
        \}
        
        System.out.println("Program continues after exception handling");
    \}
\}
\end{verbatim}

\textbf{ArithmeticException} ત્યારે throw થાય છે જ્યારે ગાણિતિક ભૂલ થાય છે જેમ કે
શૂન્ય વડે ભાગાકાર.

\textbf{Exception Hierarchy}: Object \rightarrow Throwable \rightarrow Exception \rightarrow
RuntimeException \rightarrow ArithmeticException

\end{solutionbox}
\begin{mnemonicbox}
``OTERRA'' (Object, Throwable, Exception,
RuntimeException, ArithmeticException)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{Java માં ArrayIndexOutOfBound Exception ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ArrayIndexOutOfBoundsException} ત્યારે થાય છે જ્યારે અમાન્ય index
(નકારાત્મક અથવા \textgreater= array length) સાથે array element ને access
કરવામાં આવે છે.

\begin{verbatim}
class ArrayException \{
    public static void main(String[] args) \{
        int[] numbers = \{10, 20, 30\;}
        
        try \{
            System.out.println(numbers[5]); // Invalid index
        \}
        catch(ArrayIndexOutOfBoundsException e) \{
            System.out.println("Invalid array index: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{માન્ય રેન્જ}: 0 થી (length-1)
\item
  \textbf{Runtime Exception}: Unchecked exception
\item
  \textbf{સામાન્ય કારણ}: લૂપ condition ની ભૂલો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``VRC'' (Valid range, Runtime exception, Common in
loops)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{Stream classes ની મૂળભૂત બાબતો સમજાવો.}

\begin{solutionbox}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[Stream Classes] {-{-}{} B[Byte Streams]}
    A {-{-}{} C[Character Streams]}
    B {-{-}{} D[InputStream]}
    B {-{-}{} E[OutputStream]}
    C {-{-}{} F[Reader]}
    C {-{-}{} G[Writer]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Stream Classes} ડેટા રીડ અને રાઇટ કરવા માટે input/output operations
પ્રદાન કરે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Stream Type & હેતુ & બેસ ક્લાસિસ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Byte Streams} & બાઇનરી ડેટા & InputStream, OutputStream \\
\textbf{Character Streams} & ટેક્સ્ટ ડેટા & Reader, Writer \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Input Streams}: સોર્સથી ડેટા રીડ કરે છે
\item
  \textbf{Output Streams}: ડેસ્ટિનેશનમાં ડેટા રાઇટ કરે છે
\item
  \textbf{Buffered Streams}: બફરિંગ સાથે પરફોર્મન્સ સુધારે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BIOC'' (Byte, Input/Output, Character streams)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{ટેક્સ્ટ ફાઇલ બનાવવા માટે Java પ્રોગ્રામ લખો અને ટેક્સ્ટ ફાઇલ પર રીડ ઓપરેશન
કરો.}

\begin{solutionbox}

\begin{verbatim}
import java.io.*;

class FileOperations \{
    public static void main(String[] args) \{
        // ફાઇલ બનાવો અને લખો
        try \{
            FileWriter writer = new FileWriter("sample.txt");
            writer.write("Hello World!{n}");
            writer.write("This is Java file handling example.{n}");
            writer.write("Learning Input/Output operations.");
            writer.close();
            System.out.println("File created and written successfully.");
        \}
        catch(IOException e) \{
            System.out.println("Error creating file: " + e.getMessage());
        \}
        
        // ફાઇલમાંથી રીડ કરો
        try \{
            FileReader reader = new FileReader("sample.txt");
            BufferedReader bufferedReader = new BufferedReader(reader);
            String line;
            
            System.out.println("{n}File contents:");
            while((line = bufferedReader.readLine()) != null) \{
                System.out.println(line);
            \}
            
            bufferedReader.close();
            reader.close();
        \}
        catch(IOException e) \{
            System.out.println("Error reading file: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{FileWriter}: ટેક્સ્ટ ફાઇલ બનાવે અને લખે છે
\item
  \textbf{FileReader}: ટેક્સ્ટ ફાઇલમાંથી રીડ કરે છે
\item
  \textbf{BufferedReader}: કાર્યક્ષમ line-by-line રીડિંગ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``WRB'' (Writer creates, Reader reads, Buffered for
efficiency)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{Java માં Divide by Zero Exception ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ArithmeticException (Divide by Zero)} ત્યારે થાય છે જ્યારે integer ને
શૂન્ય વડે ભાગવામાં આવે છે. Floating-point division by zero Infinity પરત કરે છે.

\begin{verbatim}
class DivideByZeroExample \{
    public static void main(String[] args) \{
        try \{
            int result = 10 / 0; // Throws ArithmeticException
            System.out.println("Result: " + result);
        \}
        catch(ArithmeticException e) \{
            System.out.println("Cannot divide by zero!");
        \}
        
        // Floating point division
        double floatResult = 10.0 / 0.0; // Returns Infinity
        System.out.println("Float result: " + floatResult);
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Integer Division}: ArithmeticException throw કરે છે
\item
  \textbf{Float Division}: Infinity અથવા NaN પરત કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``IFI'' (Integer throws exception, Float returns
Infinity)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{Java I/O પ્રક્રિયા સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
Java I/O Process:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Source    │───▶│   Stream    │───▶│ Destination │
│  (File,     │    │  (Reader/   │    │ (File,      │
│  Keyboard,  │    │   Writer,   │    │  Screen,    │
│  Network)   │    │ Input/Output│    │  Network)   │
└─────────────┘    │   Stream)   │    └─────────────┘
                   └─────────────┘
\end{verbatim}

\textbf{Java I/O Process} streams નો ઉપયોગ કરીને પ્રોગ્રામ અને બાહ્ય સોર્સિસ
વચ્ચે ડેટા ટ્રાન્સફર handle કરે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઘટક & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Source} & ડેટા મૂળ (ફાઇલ, કીબોર્ડ, નેટવર્ક) \\
\textbf{Stream} & ડેટા પથ (byte/character streams) \\
\textbf{Destination} & ડેટા લક્ષ્ય (ફાઇલ, સ્ક્રીન, નેટવર્ક) \\
\end{longtable}
}

\textbf{પ્રક્રિયાના પગલાં}:

\begin{enumerate}
\tightlist
\item
  \textbf{Open Stream}: સોર્સ/ડેસ્ટિનેશન સાથે કનેક્શન બનાવો
\item
  \textbf{Process Data}: રીડ/રાઇટ ઓપરેશન્સ
\item
  \textbf{Close Stream}: રિસોર્સિસ મુક્ત કરો
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``OPC'' (Open, Process, Close)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{ટેક્સ્ટ ફાઇલના કન્ટેન્ટ ડિસ્પ્લે કરવા માટે Java પ્રોગ્રામ લખો અને ટેક્સ્ટ ફાઇલ
પર append ઓપરેશન કરો.}

\begin{solutionbox}

\begin{verbatim}
import java.io.*;

class FileAppendExample \{
    public static void main(String[] args) \{
        String fileName = "data.txt";
        
        // પ્રારંભિક ફાઇલ કન્ટેન્ટ બનાવો
        try \{
            FileWriter writer = new FileWriter(fileName);
            writer.write("Initial content line 1{n}");
            writer.write("Initial content line 2{n}");
            writer.close();
            System.out.println("Initial file created.");
        \}
        catch(IOException e) \{
            System.out.println("Error creating file: " + e.getMessage());
        \}
        
        // ફાઇલ કન્ટેન્ટ ડિસ્પ્લે કરો
        displayFileContent(fileName);
        
        // ફાઇલમાં append કરો
        try \{
            FileWriter appendWriter = new FileWriter(fileName, true); // true for append
            appendWriter.write("Appended line 1{n}");
            appendWriter.write("Appended line 2{n}");
            appendWriter.close();
            System.out.println("{n}Content appended successfully.");
        \}
        catch(IOException e) \{
            System.out.println("Error appending to file: " + e.getMessage());
        \}
        
        // અપડેટેડ કન્ટેન્ટ ડિસ્પ્લે કરો
        System.out.println("{n}File content after append:");
        displayFileContent(fileName);
    \}
    
    static void displayFileContent(String fileName) \{
        try \{
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            String line;
            System.out.println("{n}File contents:");
            while((line = reader.readLine()) != null) \{
                System.out.println(line);
            \}
            reader.close();
        \}
        catch(IOException e) \{
            System.out.println("Error reading file: " + e.getMessage());
        \}
    \}
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{FileWriter(filename, true)}: Append mode સક્ષમ
\item
  \textbf{displayFileContent()}: રીડિંગ માટે પુનઃઉપયોગ કરી શકાય તેવી મેથડ
\item
  \textbf{BufferedReader}: કાર્યક્ષમ line રીડિંગ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ARB'' (Append mode, Reusable method, Buffered
reading)

\end{mnemonicbox}

\end{document}
