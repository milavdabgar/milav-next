\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4331601 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Define best case, worst case and average case for time
complexity.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Time Complexity Cases}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3438}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2812}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Case Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Best Case} & Minimum time needed for algorithm execution &
Linear search finds element at first position \\
\textbf{Worst Case} & Maximum time needed for algorithm execution &
Linear search finds element at last position \\
\textbf{Average Case} & Expected time for typical input scenarios &
Linear search finds element in middle \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Best Case}: Algorithm performs optimally with ideal input
  conditions
\item
  \textbf{Worst Case}: Algorithm takes maximum possible time with
  unfavorable input
\item
  \textbf{Average Case}: Mathematical expectation of execution time
  across all possible inputs
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BWA - Best, Worst, Average''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{What is Class and Object in OOP? Give suitable example.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Class vs Object}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3478}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3478}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Class
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Object
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Definition} & Blueprint/template for creating objects & Instance
of a class \\
\textbf{Memory} & No memory allocated & Memory allocated when created \\
\textbf{Example} & Car (template) & my\_car = Car() \\
\end{longtable}
}

\begin{verbatim}
\# Class definition
class Student:
    def \_\_init\_\_(self, name, age):
        self.name = name
        self.age = age
    
    def display(self):
        print(f"Name: \{self.name\}, Age: \{self.age\}")

\# Object creation
student1 = Student("John", 20)
student1.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Class}: Template defining attributes and methods
\item
  \textbf{Object}: Real instance with actual values
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Class = Cookie Cutter, Object = Actual Cookie''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Write a program for two matrix multiplication using simple
nested loop and numpy module.}

\begin{solutionbox}

\begin{verbatim}
\# Method 1: Using Simple Nested Loop
def matrix\_multiply\_nested(A, B):
    rows\_A, cols\_A = len(A), len(A[0])
    rows\_B, cols\_B = len(B), len(B[0])
    
    \# Initialize result matrix
    result = [[0 for \_ in range(cols\_B)] for \_ in range(rows\_A)]
    
    \# Matrix multiplication
    for i in range(rows\_A):
        for j in range(cols\_B):
            for k in range(cols\_A):
                result[i][j] += A[i][k] * B[k][j]
    
    return result

\# Method 2: Using NumPy
import numpy as np

def matrix\_multiply\_numpy(A, B):
    A\_np = np.array(A)
    B\_np = np.array(B)
    return np.dot(A\_np, B\_np)

\# Example usage
A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]

print("Nested Loop Result:", matrix\_multiply\_nested(A, B))
print("NumPy Result:", matrix\_multiply\_numpy(A, B))
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Nested Loop}: Three loops for row, column, and multiplication
\item
  \textbf{NumPy}: Built-in dot() function for efficient multiplication
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Row \times Column = Result''

\end{mnemonicbox}
\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Write a program to implement basic operations on arrays.}

\begin{solutionbox}

\begin{verbatim}
import array

\# Create array
arr = array.array({i}, [1, 2, 3, 4, 5])

def array\_operations():
    print("Original array:", arr)
    
    \# Insert element
    arr.insert(2, 10)
    print("After insert(2, 10):", arr)
    
    \# Append element
    arr.append(6)
    print("After append(6):", arr)
    
    \# Remove element
    arr.remove(10)
    print("After remove(10):", arr)
    
    \# Pop element
    popped = arr.pop()
    print(f"Popped element: \{popped\}, Array: \{arr\}")
    
    \# Search element
    index = arr.index(3)
    print(f"Index of 3: \{index\}")
    
    \# Count occurrences
    count = arr.count(2)
    print(f"Count of 2: \{count\}")

array\_operations()
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Array Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Method & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insert} & insert(index, value) & Add element at specific
position \\
\textbf{Append} & append(value) & Add element at end \\
\textbf{Remove} & remove(value) & Remove first occurrence \\
\textbf{Pop} & pop() & Remove and return last element \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``IARP - Insert, Append, Remove, Pop''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Explain Big `O' Notation.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Big O Complexity}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Notation & Name & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{O(1)} & Constant & Array access \\
\textbf{O(n)} & Linear & Linear search \\
\textbf{O(n^{2})} & Quadratic & Bubble sort \\
\textbf{O(log n)} & Logarithmic & Binary search \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Big O}: Describes upper bound of algorithm's time complexity
\item
  \textbf{Purpose}: Compare efficiency of different algorithms
\item
  \textbf{Focus}: Worst-case scenario analysis
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Big O = Big Order of growth''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Differentiate between class method and static method.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Method Types Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2162}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3784}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4054}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Class Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Static Method
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Decorator} & @classmethod & @staticmethod \\
\textbf{First Parameter} & cls (class reference) & No special
parameter \\
\textbf{Access} & Can access class variables & Cannot access
class/instance variables \\
\textbf{Usage} & Alternative constructors & Utility functions \\
\end{longtable}
}

\begin{verbatim}
class MyClass:
    class\_var = "I am class variable"
    
    @classmethod
    def class\_method(cls):
        return f"Class method accessing: \{cls.class\_var\}"
    
    @staticmethod
    def static\_method():
        return "Static method {- no class access"}

\# Usage
print(MyClass.class\_method())
print(MyClass.static\_method())
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Class method has CLS, Static method is STandalone''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Implement a class for single level inheritance using public and
private type derivation.}

\begin{solutionbox}

\begin{verbatim}
\# Base class
class Vehicle:
    def \_\_init\_\_(self, brand, model):
        self.brand = brand          \# Public attribute
        self.\_model = model         \# Protected attribute
        self.\_\_year = 2023          \# Private attribute
    
    def start\_engine(self):
        return f"\{self.brand\} engine started"
    
    def \_display\_model(self):       \# Protected method
        return f"Model: \{self.\_model\}"
    
    def \_\_private\_method(self):     \# Private method
        return f"Year: \{self.\_\_year\}"

\# Derived class (Single level inheritance)
class Car(Vehicle):
    def \_\_init\_\_(self, brand, model, doors):
        super().\_\_init\_\_(brand, model)
        self.doors = doors
    
    def car\_info(self):
        \# Can access public and protected members
        return f"Car: \{self.brand\}, \{self.\_display\_model()\}, Doors: \{self.doors\}"
    
    def demonstrate\_access(self):
        print("Public access:", self.brand)
        print("Protected access:", self.\_model)
        \# print("Private access:", self.\_\_year)  \# This would cause error

\# Usage
my\_car = Car("Toyota", "Camry", 4)
print(my\_car.car\_info())
print(my\_car.start\_engine())
my\_car.demonstrate\_access()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Public}: Accessible everywhere (brand)
\item
  \textbf{Protected}: Accessible in class and subclasses (\_model)
\item
  \textbf{Private}: Only accessible within same class (\_\_year)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Public = Everyone, Protected = Family, Private =
Personal''

\end{mnemonicbox}
\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{Explain constructor with example.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Constructor Types}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2609}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3478}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3913}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default} & \texttt{\_\_init\_\_(self)} & Initialize with default
values \\
\textbf{Parameterized} & \texttt{\_\_init\_\_(self,\ params)} &
Initialize with custom values \\
\end{longtable}
}

\begin{verbatim}
class Student:
    def \_\_init\_\_(self, name="Unknown", age=18):  \# Constructor
        self.name = name
        self.age = age
        print(f"Student \{name\} created")
    
    def display(self):
        print(f"Name: \{self.name\}, Age: \{self.age\}")

\# Object creation calls constructor automatically
s1 = Student("Alice", 20)
s2 = Student()  \# Uses default values
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Constructor}: Special method called when object is created
\item
  \textbf{Purpose}: Initialize object attributes
\item
  \textbf{Automatic}: Called automatically during object creation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Constructor = Object's Birth Certificate''

\end{mnemonicbox}
\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{Write a program to demonstrate Polymorphism.}

\begin{solutionbox}

\begin{verbatim}
\# Base class
class Animal:
    def make\_sound(self):
        pass

\# Derived classes
class Dog(Animal):
    def make\_sound(self):
        return "Woof!"

class Cat(Animal):
    def make\_sound(self):
        return "Meow!"

class Cow(Animal):
    def make\_sound(self):
        return "Moo!"

\# Polymorphism demonstration
def animal\_sound(animal):
    return animal.make\_sound()

\# Creating objects
animals = [Dog(), Cat(), Cow()]

\# Same method call, different behavior
for animal in animals:
    print(f"\{animal.\_\_class\_\_.\_\_name\_\_\}: \{animal\_sound(animal)\}")
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Polymorphism Benefits}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Benefit & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Flexibility} & Same interface, different implementations \\
\textbf{Maintainability} & Easy to add new types \\
\textbf{Code Reuse} & Common interface for different objects \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Poly = Many, Morph = Forms''

\end{mnemonicbox}
\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Write a Python to implement multiple and hierarchical
inheritance.}

\begin{solutionbox}

\begin{verbatim}
\# Multiple Inheritance
class Teacher:
    def \_\_init\_\_(self, subject):
        self.subject = subject
    
    def teach(self):
        return f"Teaching \{self.subject\}"

class Researcher:
    def \_\_init\_\_(self, field):
        self.field = field
    
    def research(self):
        return f"Researching in \{self.field\}"

\# Multiple inheritance
class Professor(Teacher, Researcher):
    def \_\_init\_\_(self, name, subject, field):
        self.name = name
        Teacher.\_\_init\_\_(self, subject)
        Researcher.\_\_init\_\_(self, field)
    
    def profile(self):
        return f"Prof. \{self.name\}: \{self.teach()\} and \{self.research()\}"

\# Hierarchical Inheritance
class Vehicle:
    def \_\_init\_\_(self, brand):
        self.brand = brand
    
    def start(self):
        return f"\{self.brand\} started"

class Car(Vehicle):
    def drive(self):
        return f"\{self.brand\} car driving"

class Bike(Vehicle):
    def ride(self):
        return f"\{self.brand\} bike riding"

\# Usage
prof = Professor("Smith", "Python", "AI")
print(prof.profile())

car = Car("Honda")
bike = Bike("Yamaha")
print(car.drive())
print(bike.ride())
\end{verbatim}

\textbf{Diagram:}

\begin{verbatim}
Multiple Inheritance:    Hierarchical Inheritance:
   Teacher  Researcher         Vehicle
      {        /                /    }
       {      /               Car    Bike}
      Professor
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Multiple = Many Parents, Hierarchical = Tree
Structure''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Explain Push and Pop operations on Stack.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Stack Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Description & Time Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Push} & Add element to top & O(1) \\
\textbf{Pop} & Remove element from top & O(1) \\
\textbf{Peek/Top} & View top element & O(1) \\
\textbf{isEmpty} & Check if stack is empty & O(1) \\
\end{longtable}
}

\begin{verbatim}
stack = []

\# Push operation
stack.append(10)  \# Push 10
stack.append(20)  \# Push 20
print("After push:", stack)  \# [10, 20]

\# Pop operation
item = stack.pop()  \# Pop 20
print(f"Popped: \{item\}, Stack: \{stack\}")  \# [10]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{LIFO}: Last In, First Out principle
\item
  \textbf{Top}: Only accessible element for operations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Stack = Plate Stack - Last plate In, First plate
Out''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Explain Enqueue and Dequeue operations on Queue.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Queue Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operation & Description & Position & Time Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Enqueue} & Add element & Rear & O(1) \\
\textbf{Dequeue} & Remove element & Front & O(1) \\
\textbf{Front} & View front element & Front & O(1) \\
\textbf{Rear} & View rear element & Rear & O(1) \\
\end{longtable}
}

\begin{verbatim}
from collections import deque

queue = deque()

\# Enqueue operation
queue.append(10)  \# Enqueue 10
queue.append(20)  \# Enqueue 20
print("After enqueue:", list(queue))  \# [10, 20]

\# Dequeue operation
item = queue.popleft()  \# Dequeue 10
print(f"Dequeued: \{item\}, Queue: \{list(queue)\}")  \# [20]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{FIFO}: First In, First Out principle
\item
  \textbf{Two ends}: Front for removal, Rear for insertion
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Queue = Line at Store - First person In, First
person Out''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Explain various applications of Stack.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Stack Applications}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Expression Evaluation} & Convert infix to postfix & (a+b)\emph{c
\rightarrow ab+c} \\
\textbf{Function Calls} & Manage function call sequence & Recursion
handling \\
\textbf{Undo Operations} & Reverse recent actions & Text editor undo \\
\textbf{Browser History} & Navigate back through pages & Back button \\
\textbf{Parentheses Matching} & Check balanced brackets & \{[()]\}
validation \\
\end{longtable}
}

\begin{verbatim}
\# Example: Parentheses matching
def is\_balanced(expression):
    stack = []
    pairs = \{{(}: {)}, {[}: {]}, {\{}: {\}}\}
    
    for char in expression:
        if char in pairs:  \# Opening bracket
            stack.append(char)
        elif char in pairs.values():  \# Closing bracket
            if not stack:
                return False
            if pairs[stack.pop()] != char:
                return False
    
    return len(stack) == 0

\# Test
print(is\_balanced("(\{[]\)"}))  \# True
print(is\_balanced("(\{[\])"}))  \# False
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Memory Management}: Function call stack in programming
\item
  \textbf{Backtracking}: Maze solving, game algorithms
\item
  \textbf{Compiler Design}: Syntax analysis and parsing
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Stack Applications = UFPB (Undo, Function,
Parentheses, Browser)''

\end{mnemonicbox}
\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

\textbf{List out limitations of Single Queue.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Single Queue Limitations}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3529}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3824}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2647}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Limitation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Problem
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Memory Wastage} & Front space becomes unusable & Inefficient
memory usage \\
\textbf{Fixed Size} & Cannot resize dynamically & Space constraints \\
\textbf{False Overflow} & Queue appears full when front space empty &
Premature capacity limit \\
\textbf{No Reuse} & Dequeued positions not reusable & Linear space
utilization \\
\end{longtable}
}

\begin{verbatim}
Single Queue Problem:
Front               Rear
  ↓                  ↓
[X][X][3][4][5][ ][ ][ ]
 ↑  ↑
Wasted space (cannot reuse)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Linear Implementation}: Cannot utilize dequeued space
\item
  \textbf{Static Array}: Fixed size allocation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Single Queue = One-Way Street (No U-Turn)''

\end{mnemonicbox}
\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Differentiate circular and simple queues.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Queue Types Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2105}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3684}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4211}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Simple Queue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Circular Queue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Memory Usage} & Linear, wasteful & Circular, efficient \\
\textbf{Space Reuse} & No reuse of dequeued space & Reuses all
positions \\
\textbf{Overflow} & False overflow possible & True overflow only \\
\textbf{Implementation} & Front and rear pointers & Front and rear with
modulo \\
\end{longtable}
}

\begin{verbatim}
Simple Queue:          Circular Queue:
[X][X][3][4][ ][ ]    [5][6][3][4]
Front    Rear        ↑Rear Front
(Wasted space)         (Space reused)
\end{verbatim}

\begin{verbatim}
\# Circular Queue Implementation
class CircularQueue:
    def \_\_init\_\_(self, size):
        self.size = size
        self.queue = [None] * size
        self.front = {-}1
        self.rear = {-}1
    
    def enqueue(self, item):
        if (self.rear + 1) \% self.size == self.front:
            print("Queue Full")
            return
        if self.front == {-}1:
            self.front = 0
        self.rear = (self.rear + 1) \% self.size
        self.queue[self.rear] = item
    
    def dequeue(self):
        if self.front == {-}1:
            print("Queue Empty")
            return None
        item = self.queue[self.front]
        if self.front == self.rear:
            self.front = self.rear = {-}1
        else:
            self.front = (self.front + 1) \% self.size
        return item
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Circular = Ring Road (Continuous), Simple = Dead
End Street''

\end{mnemonicbox}
\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{Convert the following infix expression into postfix: (a * b) *
(c \^{} (d + e) -- f)}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Operator Precedence}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Precedence & Associativity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\^{}} & 3 & Right to Left \\
\textbf{*, /} & 2 & Left to Right \\
\textbf{+, -} & 1 & Left to Right \\
\end{longtable}
}

\textbf{Step-by-step conversion:}

\begin{verbatim}
Expression: (a * b) * (c ^ (d + e) – f)

Step 1: (a * b) \rightarrow ab*
Step 2: (d + e) \rightarrow de+
Step 3: c ^ (de+) \rightarrow c de+ ^
Step 4: (c de+ ^) – f \rightarrow c de+ ^ f -
Step 5: (ab*) * (c de+ ^ f -) \rightarrow ab* c de+ ^ f - *

Final Answer: ab*cde+^f-*
\end{verbatim}

\textbf{Algorithm:}

\begin{enumerate}
\tightlist
\item
  \textbf{Operand}: Add to output
\item
  \textbf{`('}: Push to stack
\item
  \textbf{`)'}: Pop until `('
\item
  \textbf{Operator}: Pop higher/equal precedence, then push
\item
  \textbf{End}: Pop all remaining operators
\end{enumerate}

\begin{verbatim}
def infix\_to\_postfix(expression):
    precedence = \{{+}: 1, {{-}}: 1, {*}: 2, {/}: 2, {\^{}}: 3\}
    stack = []
    output = []
    
    for char in expression:
        if char.isalnum():
            output.append(char)
        elif char == {(}:
            stack.append(char)
        elif char == {)}:
            while stack and stack[{-}1] != {(}:
                output.append(stack.pop())
            stack.pop()  \# Remove {(}
        elif char in precedence:
            while (stack and stack[{-}1] != {(} and 
                   stack[{-}1] in precedence and
                   precedence[stack[{-}1]] {=} precedence[char]):
                output.append(stack.pop())
            stack.append(char)
    
    while stack:
        output.append(stack.pop())
    
    return {}.join(output)

\# Test
result = infix\_to\_postfix("(a*b)*(c\^{(d+e){-}f)"})
print("Postfix:", result)  \# ab*cde+\^{f{-}*}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``PEMDAS for precedence, Stack for operators''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{List types of Linked List.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Linked List Types}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1875}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4062}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4062}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key Feature
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Singly Linked} & One pointer to next node & Forward traversal
only \\
\textbf{Doubly Linked} & Pointers to next and previous & Bidirectional
traversal \\
\textbf{Circular Linked} & Last node points to first & No NULL
pointer \\
\textbf{Doubly Circular} & Doubly + Circular features & Both directions
+ circular \\
\end{longtable}
}

\begin{verbatim}
Singly:     [A][B][C]

Doubly:     NULL[A]⇄[B]⇄[C]

Circular:   [A][B][C]
             ↑\_\_\_\_\_\_\_\_\_|

Doubly Circular: [A]⇄[B]⇄[C]
                  ↑\_\_\_\_\_\_\_\_\_|
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Memory}: Each node contains data and pointer(s)
\item
  \textbf{Dynamic}: Size can change during runtime
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SDCD - Singly, Doubly, Circular, Doubly-Circular''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Differentiate between circular linked list and singly linked
list.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Singly vs Circular Linked List}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Aspect & Singly Linked List & Circular Linked List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Last Node} & Points to NULL & Points to first node \\
\textbf{Traversal} & Ends at NULL & Continuous loop \\
\textbf{Memory} & Last node stores NULL & No NULL pointer \\
\textbf{Detection} & Check for NULL & Check for starting node \\
\end{longtable}
}

\begin{verbatim}
\# Singly Linked List Node
class SinglyNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

\# Circular Linked List Node
class CircularNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

def traverse\_singly(head):
    current = head
    while current:  \# Stops at NULL
        print(current.data)
        current = current.next

def traverse\_circular(head):
    if not head:
        return
    current = head
    while True:
        print(current.data)
        current = current.next
        if current == head:  \# Back to start
            break
\end{verbatim}

\textbf{Diagram:}

\begin{verbatim}
Singly:    [1][2][3]

Circular:  [1][2][3]
            ↑\_\_\_\_\_\_\_|
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Singly = Dead End, Circular = Race Track''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Implement a program to perform following operation on singly
linked list:} \textbf{a. Insert a node at the beginning of a singly
linked list.} \textbf{b. Insert a node at the end of a singly linked
list.}

\begin{solutionbox}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def insert\_at\_beginning(self, data):
        """Insert node at the beginning"""
        new\_node = Node(data)
        new\_node.next = self.head
        self.head = new\_node
        print(f"Inserted \{data\} at beginning")
    
    def insert\_at\_end(self, data):
        """Insert node at the end"""
        new\_node = Node(data)
        
        if not self.head:  \# Empty list
            self.head = new\_node
            print(f"Inserted \{data\} at end (first node)")
            return
        
        \# Traverse to last node
        current = self.head
        while current.next:
            current = current.next
        
        current.next = new\_node
        print(f"Inserted \{data\} at end")
    
    def display(self):
        """Display the linked list"""
        if not self.head:
            print("List is empty")
            return
        
        current = self.head
        elements = []
        while current:
            elements.append(str(current.data))
            current = current.next
        
        print("  ".join(elements) + "  NULL")

\# Usage example
sll = SinglyLinkedList()

\# Insert at beginning
sll.insert\_at\_beginning(10)
sll.insert\_at\_beginning(20)
sll.display()  \# 20  10  NULL

\# Insert at end
sll.insert\_at\_end(30)
sll.insert\_at\_end(40)
sll.display()  \# 20  10  30  40  NULL
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Insertion Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Time Complexity
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Steps
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Beginning} & O(1) & 1. Create node 2. Point to head 3. Update
head \\
\textbf{End} & O(n) & 1. Create node 2. Traverse to end 3. Link last
node \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Beginning = Quick (O(1)), End = Journey (O(n))''

\end{mnemonicbox}
\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{Explain doubly linked list.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Doubly Linked List Features}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Two Pointers} & prev and next in each node \\
\textbf{Bidirectional} & Can traverse forward and backward \\
\textbf{Memory} & Extra space for prev pointer \\
\textbf{Flexibility} & Easy insertion/deletion anywhere \\
\end{longtable}
}

\begin{verbatim}
class DoublyNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None
        self.prev = None

\# Structure visualization
\# NULL  [prev|data|next] ⇄ [prev|data|next]  NULL
\end{verbatim}

\begin{verbatim}
Doubly Linked List Structure:
NULL[A]⇄[B]⇄[C]
     prev next
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Advantages}: Bidirectional traversal, easier deletion
\item
  \textbf{Disadvantages}: Extra memory for prev pointer
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Doubly = Two-Way Street''

\end{mnemonicbox}
\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Describe applications of Linked List.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Linked List Applications}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Application & Use Case & Benefit \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Arrays} & When size varies & Efficient memory usage \\
\textbf{Stack/Queue} & LIFO/FIFO operations & Dynamic size \\
\textbf{Graphs} & Adjacency list representation & Space efficient \\
\textbf{Music Playlist} & Previous/Next songs & Easy navigation \\
\textbf{Browser History} & Back/Forward navigation & Dynamic history \\
\textbf{Undo Operations} & Text editors & Efficient undo/redo \\
\end{longtable}
}

\begin{verbatim}
\# Example: Browser History using Doubly Linked List
class Page:
    def \_\_init\_\_(self, url):
        self.url = url
        self.prev = None
        self.next = None

class BrowserHistory:
    def \_\_init\_\_(self):
        self.current = None
    
    def visit(self, url):
        page = Page(url)
        if self.current:
            self.current.next = page
            page.prev = self.current
        self.current = page
    
    def back(self):
        if self.current and self.current.prev:
            self.current = self.current.prev
            return self.current.url
        return "No previous page"
    
    def forward(self):
        if self.current and self.current.next:
            self.current = self.current.next
            return self.current.url
        return "No next page"
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists = Dynamic, Flexible, Connected''

\end{mnemonicbox}
\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Implement Merge Sort algorithm.}

\begin{solutionbox}

\begin{verbatim}
def merge\_sort(arr):
    """Merge Sort implementation"""
    if len(arr) {=} 1:
        return arr
    
    \# Divide the array into two halves
    mid = len(arr) // 2
    left\_half = arr[:mid]
    right\_half = arr[mid:]
    
    \# Recursively sort both halves
    left\_sorted = merge\_sort(left\_half)
    right\_sorted = merge\_sort(right\_half)
    
    \# Merge the sorted halves
    return merge(left\_sorted, right\_sorted)

def merge(left, right):
    """Merge two sorted arrays"""
    result = []
    i = j = 0
    
    \# Compare elements and merge
    while i {} len(left) and j {} len(right):
        if left[i] {=} right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    \# Add remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

\# Example usage
def demonstrate\_merge\_sort():
    arr = [64, 34, 25, 12, 22, 11, 90]
    print("Original array:", arr)
    
    sorted\_arr = merge\_sort(arr)
    print("Sorted array:", sorted\_arr)

demonstrate\_merge\_sort()
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Merge Sort Analysis}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Aspect & Value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Time Complexity} & O(n log n) \\
\textbf{Space Complexity} & O(n) \\
\textbf{Stability} & Stable \\
\textbf{Type} & Divide and Conquer \\
\end{longtable}
}

\textbf{Algorithm Steps:}

\begin{enumerate}
\tightlist
\item
  \textbf{Divide}: Split array into two halves
\item
  \textbf{Conquer}: Recursively sort both halves
\item
  \textbf{Combine}: Merge sorted halves
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Merge Sort = Divide, Sort, Merge''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Describe applications of binary tree.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Binary Tree Applications}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Expression Trees} & Mathematical expression representation &
(a+b)*c \\
\textbf{Decision Trees} & Decision making in AI/ML & Classification
algorithms \\
\textbf{File Systems} & Directory structure organization & Folder
hierarchy \\
\textbf{Database Indexing} & B-trees for efficient searching & Database
indices \\
\textbf{Huffman Coding} & Data compression technique & File
compression \\
\textbf{Heap Operations} & Priority queues implementation & Task
scheduling \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Hierarchical Data}: Naturally represents tree-like structures
\item
  \textbf{Efficient Search}: Binary search trees provide O(log n)
  operations
\item
  \textbf{Memory Management}: Used in compiler design for syntax trees
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Trees = EDFDHH (Expression, Decision, File,
Database, Huffman, Heap)''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Explain Indegree and Outdegree of Binary Tree with example.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Degree Definitions}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1622}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3243}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5135}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Term
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Binary Tree Value
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Indegree} & Number of edges coming into a node & 0 (root) or 1
(others) \\
\textbf{Outdegree} & Number of edges going out of a node & 0, 1, or 2 \\
\textbf{Degree} & Total edges connected to node & Indegree +
Outdegree \\
\end{longtable}
}

\begin{verbatim}
Binary Tree Example:
        A (indegree=0, outdegree=2)
       / {}
      B   C (indegree=1, outdegree=1)
     /   /
    D   E (indegree=1, outdegree=0)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Root Node}: Always has indegree = 0
\item
  \textbf{Leaf Nodes}: Always have outdegree = 0
\item
  \textbf{Internal Nodes}: Have outdegree = 1 or 2
\end{itemize}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Example Analysis}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Node & Indegree & Outdegree & Node Type \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & 0 & 2 & Root \\
B & 1 & 1 & Internal \\
C & 1 & 1 & Internal \\
D & 1 & 0 & Leaf \\
E & 1 & 0 & Leaf \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``In = Coming In, Out = Going Out''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Write a program to implement construction of binary search
trees.}

\begin{solutionbox}

\begin{verbatim}
class TreeNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    def \_\_init\_\_(self):
        self.root = None
    
    def insert(self, data):
        """Insert a node in BST"""
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self.\_insert\_recursive(self.root, data)
    
    def \_insert\_recursive(self, node, data):
        if data {} node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self.\_insert\_recursive(node.left, data)
        elif data {} node.data:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self.\_insert\_recursive(node.right, data)
    
    def search(self, data):
        """Search for a node in BST"""
        return self.\_search\_recursive(self.root, data)
    
    def \_search\_recursive(self, node, data):
        if node is None or node.data == data:
            return node
        
        if data {} node.data:
            return self.\_search\_recursive(node.left, data)
        else:
            return self.\_search\_recursive(node.right, data)
    
    def inorder\_traversal(self):
        """Inorder traversal (Left, Root, Right)"""
        result = []
        self.\_inorder\_recursive(self.root, result)
        return result
    
    def \_inorder\_recursive(self, node, result):
        if node:
            self.\_inorder\_recursive(node.left, result)
            result.append(node.data)
            self.\_inorder\_recursive(node.right, result)
    
    def display\_tree(self):
        """Simple tree display"""
        if self.root:
            self.\_display\_recursive(self.root, 0)
    
    def \_display\_recursive(self, node, level):
        if node:
            self.\_display\_recursive(node.right, level + 1)
            print("  " * level + str(node.data))
            self.\_display\_recursive(node.left, level + 1)

\# Example usage
bst = BinarySearchTree()
values = [50, 30, 70, 20, 40, 60, 80]

print("Inserting values:", values)
for value in values:
    bst.insert(value)

print("{n}Tree structure:")
bst.display\_tree()

print("{n}Inorder traversal:", bst.inorder\_traversal())

\# Search examples
print(f"{n}Search 40: \{{Found} if bst.search(40) else {Not Found}\}")
print(f"Search 90: \{{Found} if bst.search(90) else {Not Found}\}")
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{BST Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Time Complexity & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insert} & O(log n) average, O(n) worst & Add new node \\
\textbf{Search} & O(log n) average, O(n) worst & Find specific node \\
\textbf{Delete} & O(log n) average, O(n) worst & Remove node \\
\textbf{Traversal} & O(n) & Visit all nodes \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``BST Rule = Left \textless{} Root \textless{}
Right''

\end{mnemonicbox}
\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{Define level, degree and leaf node in binary tree.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Binary Tree Terms}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Term
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Level} & Distance from root (root = level 0) & Root=0,
Children=1, etc. \\
\textbf{Degree} & Number of children a node has & 0, 1, or 2 \\
\textbf{Leaf Node} & Node with no children (degree = 0) & Terminal
nodes \\
\end{longtable}
}

\begin{verbatim}
Binary Tree with Levels:
Level 0:        A
               / {}
Level 1:      B   C
             /   / {}
Level 2:    D   E   F
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Example Analysis}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Node & Level & Degree & Type \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & 0 & 2 & Root \\
B & 1 & 1 & Internal \\
C & 1 & 2 & Internal \\
D & 2 & 0 & Leaf \\
E & 2 & 0 & Leaf \\
F & 2 & 0 & Leaf \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Height}: Maximum level in tree
\item
  \textbf{Depth}: Same as level for a node
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Level = Floor number, Degree = Children count, Leaf
= No children''

\end{mnemonicbox}
\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Explain complete binary tree with example.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Binary Tree Types}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2069}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4483}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3448}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Property
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Complete} & All levels filled except last, left-filled &
Efficient array representation \\
\textbf{Full} & Every node has 0 or 2 children & No single-child
nodes \\
\textbf{Perfect} & All levels completely filled & 2\^{}h - 1 nodes \\
\end{longtable}
}

\begin{verbatim}
Complete Binary Tree:
        A
       / {}
      B   C
     / { /}
    D  E F

NOT Complete:
        A
       / {}
      B   C
       { / }
        E F G
\end{verbatim}

\begin{verbatim}
class CompleteBinaryTree:
    def \_\_init\_\_(self):
        self.tree = []
    
    def insert(self, data):
        """Insert in complete binary tree manner"""
        self.tree.append(data)
    
    def get\_parent\_index(self, i):
        return (i {-} 1) // 2
    
    def get\_left\_child\_index(self, i):
        return 2 * i + 1
    
    def get\_right\_child\_index(self, i):
        return 2 * i + 2
    
    def display\_level\_order(self):
        """Display tree level by level"""
        if not self.tree:
            return
        
        level = 0
        while (2 ** level) {=} len(self.tree):
            start = 2 ** level {-} 1
            end = min(2 ** (level + 1) {-} 1, len(self.tree))
            print(f"Level \{level\}: \{self.tree[start:end]\}")
            level += 1

\# Example
cbt = CompleteBinaryTree()
for i in [1, 2, 3, 4, 5, 6]:
    cbt.insert(i)

cbt.display\_level\_order()
\end{verbatim}

\textbf{Properties:}

\begin{itemize}
\tightlist
\item
  \textbf{Array Representation}: Parent at i, children at 2i+1 and 2i+2
\item
  \textbf{Heap Property}: Forms foundation for heap data structure
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Complete = All floors full except last, filled left
to right''

\end{mnemonicbox}
\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{Construct a Binary Search Tree (BST) for the following sequence
of numbers: 50, 70, 60, 20, 90, 10, 40, 100}

\begin{solutionbox}

\textbf{Step-by-step BST Construction:}

\begin{verbatim}
Insert 50: (Root)
    50

Insert 70: (70 > 50, go right)
    50
     \
      70

Insert 60: (60 > 50, go right; 60 < 70, go left)
    50
     \
      70
     /
    60

Insert 20: (20 < 50, go left)
    50
   /  \
  20   70
       /
      60

Insert 90: (90 > 50, right; 90 > 70, right)
    50
   /  \
  20   70
       / \
      60  90

Insert 10: (10 < 50, left; 10 < 20, left)
    50
   /  \
  20   70
 /    / \
10   60  90

Insert 40: (40 < 50, left; 40 > 20, right)
    50
   /  \
  20   70
 / \   / \
10  40 60 90

Insert 100: (100 > 50, right; 100 > 70, right; 100 > 90, right)
    50
   /  \
  20   70
 / \   / \
10  40 60 90
             \
              100
\end{verbatim}

\textbf{Final BST Structure:}

\begin{verbatim}
        50
       /  {}
      20   70
     / {   / }
    10  40 60 90
              {}
               100
\end{verbatim}

\begin{verbatim}
\# Implementation code for the construction
class BST:
    def \_\_init\_\_(self):
        self.root = None
    
    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
            print(f"Inserted \{data\} as root")
        else:
            self.\_insert(self.root, data)
    
    def \_insert(self, node, data):
        if data {} node.data:
            if node.left is None:
                node.left = TreeNode(data)
                print(f"Inserted \{data\} to left of \{node.data\}")
            else:
                self.\_insert(node.left, data)
        else:
            if node.right is None:
                node.right = TreeNode(data)
                print(f"Inserted \{data\} to right of \{node.data\}")
            else:
                self.\_insert(node.right, data)

\# Construct the BST
bst = BST()
sequence = [50, 70, 60, 20, 90, 10, 40, 100]

for num in sequence:
    bst.insert(num)
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Traversal Results}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Traversal & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Inorder} & 10, 20, 40, 50, 60, 70, 90, 100 \\
\textbf{Preorder} & 50, 20, 10, 40, 70, 60, 90, 100 \\
\textbf{Postorder} & 10, 40, 20, 60, 100, 90, 70, 50 \\
\end{longtable}
}

\textbf{Properties Verified:}

\begin{itemize}
\tightlist
\item
  \textbf{BST Property}: Left subtree \textless{} Root \textless{} Right
  subtree
\item
  \textbf{Inorder}: Gives sorted sequence
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BST Construction = Compare, Choose direction,
Insert''

\end{mnemonicbox}

\end{document}
