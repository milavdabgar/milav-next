\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4331601 -- Summer 2025}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Differentiate between Linear and Non Linear Data Structure.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Linear Data Structure} & \textbf{Non-Linear Data Structure} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Elements stored sequentially & Elements stored hierarchically \\
Single level arrangement & Multi-level arrangement \\
Easy traversal & Complex traversal \\
Examples: Array, Stack, Queue & Examples: Tree, Graph \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Linear flows Like water, Non-linear Navigates
Networks''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Explain different concepts of Object Oriented programming.}

\begin{solutionbox}

\textbf{Table of OOP Concepts:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Concept} & \textbf{Description} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Encapsulation} & Binding data and methods together \\
\textbf{Inheritance} & Acquiring properties from parent class \\
\textbf{Polymorphism} & One name, multiple forms \\
\textbf{Abstraction} & Hiding implementation details \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Encapsulation}: Data hiding and bundling
\item
  \textbf{Inheritance}: Code reusability through parent-child
  relationship
\item
  \textbf{Polymorphism}: Method overriding and overloading
\item
  \textbf{Abstraction}: Interface without implementation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Every Intelligent Programmer Abstracts''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Define Polymorphism. Write a python program for polymorphism
through inheritance.}

\begin{solutionbox}

\textbf{Polymorphism} means ``many forms'' - same method name behaving
differently in different classes.

\textbf{Code:}

\begin{verbatim}
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"

class Cat(Animal):
    def sound(self):
        return "Meow"

\# Polymorphism in action
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.sound())
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Polymorphism}: Same interface, different implementation
\item
  \textbf{Runtime binding}: Method called based on object type
\item
  \textbf{Code flexibility}: Easy to extend with new classes
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Polymorphism Provides Perfect Programming''

\end{mnemonicbox}
\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Define Abstraction. Write a python program to understand the
concept of abstract class.}

\begin{solutionbox}

\textbf{Abstraction} hides implementation details and shows only
essential features.

\textbf{Code:}

\begin{verbatim}
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def \_\_init\_\_(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width

\# Usage
rect = Rectangle(5, 3)
print(f"Area: \{rect.area()\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Abstract class}: Cannot be instantiated directly
\item
  \textbf{Abstract method}: Must be implemented by child classes
\item
  \textbf{Interface definition}: Provides template for subclasses
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Abstraction Avoids Actual implementation''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Define Following terms: I. Best case II. Worst case III. Average
case}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Case} & \textbf{Definition} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Best case} & Minimum time required for algorithm \\
\textbf{Worst case} & Maximum time required for algorithm \\
\textbf{Average case} & Expected time for random input \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Best-Worst-Average = Performance Analysis''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Explain infix, postfix \& prefix expressions.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Expression} & \textbf{Operator Position} & \textbf{Example} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Infix} & Between operands & A + B \\
\textbf{Prefix} & Before operands & + A B \\
\textbf{Postfix} & After operands & A B + \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Infix}: Natural mathematical notation
\item
  \textbf{Prefix}: Polish notation
\item
  \textbf{Postfix}: Reverse Polish notation
\item
  \textbf{Stack usage}: Postfix eliminates parentheses
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``In-Pre-Post = Position of operator''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Define circular queue. Explain INSERT and DELETE operations of
circular queue with diagrams.}

\begin{solutionbox}

\textbf{Circular Queue}: Linear data structure where last position
connects to first position.

\textbf{Diagram:}

\begin{verbatim}
     [0] [1] [2] [3]
      ↑           ↑
   front        rear
\end{verbatim}

\textbf{INSERT Operation:}

\begin{verbatim}
1. Check if queue is full
2. If not full, increment rear
3. If rear exceeds size, set rear = 0
4. Insert element at rear position
\end{verbatim}

\textbf{DELETE Operation:}

\begin{verbatim}
1. Check if queue is empty
2. If not empty, remove element from front
3. Increment front
4. If front exceeds size, set front = 0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Circular nature}: Efficient memory utilization
\item
  \textbf{No shifting}: Elements remain in place
\item
  \textbf{Front-rear pointers}: Track queue boundaries
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Saves Space''

\end{mnemonicbox}
\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{List out different Data Structure with examples.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Type} & \textbf{Data Structure} & \textbf{Example} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Linear} & Array & [1,2,3,4] \\
\textbf{Linear} & Stack & Function calls \\
\textbf{Linear} & Queue & Printer queue \\
\textbf{Non-Linear} & Tree & File system \\
\textbf{Non-Linear} & Graph & Social network \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Arrays-Stacks-Queues = Linear, Trees-Graphs =
Non-linear''

\end{mnemonicbox}
\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{Discuss how the concept of circular queue is different from
simple queue.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Simple Queue} & \textbf{Circular Queue} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Linear arrangement & Circular arrangement \\
Memory wastage & Efficient memory use \\
Fixed front and rear & Wraparound pointers \\
False overflow & True overflow detection \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Memory efficiency}: Circular reuses deleted spaces
\item
  \textbf{Pointer management}: Modulo arithmetic for wraparound
\item
  \textbf{Performance}: Better space utilization
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Conquers memory problems''

\end{mnemonicbox}
\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Define stack. Explain PUSH \& POP operation with example. Write
an algorithm for PUSH and POP operations of stack.}

\begin{solutionbox}

\textbf{Stack}: LIFO (Last In First Out) data structure.

\textbf{PUSH Algorithm:}

\begin{verbatim}
1. Check if stack is full
2. If not full, increment top
3. Insert element at top position
4. Update top pointer
\end{verbatim}

\textbf{POP Algorithm:}

\begin{verbatim}
1. Check if stack is empty
2. If not empty, store top element
3. Decrement top pointer
4. Return stored element
\end{verbatim}

\textbf{Example:}

\begin{verbatim}
Stack: [10, 20, 30] \leftarrow top
PUSH 40: [10, 20, 30, 40] \leftarrow top
POP: returns 40, stack: [10, 20, 30] \leftarrow top
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{LIFO principle}: Last element added is first removed
\item
  \textbf{Top pointer}: Tracks current stack position
\item
  \textbf{Overflow/Underflow}: Check before operations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Stack Stores in Last-in-first-out''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Convert following infix expression to postfix: ( ( ( A - B ) * C
) + ( ( D - E ) / F ) )}

\begin{solutionbox}

\textbf{Step-by-step conversion:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\textbf{Step} & \textbf{Scanned} & \textbf{Stack} & \textbf{Postfix} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & ( & ( & \\
2 & ( & (( & \\
3 & ( & ((( & \\
4 & A & ((( & A \\
5 & - & (((- & A \\
6 & B & (((- & AB \\
7 & ) & (( & AB- \\
8 & * & ((* & AB- \\
9 & C & ((* & AB-C \\
10 & ) & ( & AB-C* \\
11 & + & (+ & AB-C* \\
12 & ( & (+( & AB-C* \\
13 & ( & (+(( & AB-C* \\
14 & D & (+(( & AB-C*D \\
15 & - & (+((- & AB-C*D \\
16 & E & (+((- & AB-C*DE \\
17 & ) & (+ & AB-C*DE- \\
18 & / & (+(/ & AB-C*DE- \\
19 & F & (+(/ & AB-C*DE-F \\
20 & ) & (+ & AB-C*DE-F/ \\
21 & ) & & AB-C*DE-F/+ \\
\end{longtable}
}

**Final Answer: AB-C*DE-F/+**

\end{solutionbox}
\begin{mnemonicbox}
``Postfix Places operators after operands''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Write a short note on doubly linked list.}

\begin{solutionbox}

\textbf{Doubly Linked List}: Linear data structure with bidirectional
links.

\textbf{Structure:}

\begin{verbatim}
NULL  [prev|data|next]  [prev|data|next]  [prev|data|next]  NULL
\end{verbatim}

\textbf{Advantages:}

\begin{itemize}
\tightlist
\item
  \textbf{Bidirectional traversal}: Forward and backward navigation
\item
  \textbf{Efficient deletion}: No need for previous node reference
\item
  \textbf{Better insertion}: Can insert before given node easily
\end{itemize}

\textbf{Disadvantages:}

\begin{itemize}
\tightlist
\item
  \textbf{Extra memory}: Additional pointer storage
\item
  \textbf{Complex operations}: More pointer manipulations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Doubly Delivers Bidirectional Benefits''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Write a Python Program to delete first and last node from singly
linked list.}

\begin{solutionbox}

\textbf{Code:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def delete\_first(self):
        if self.head is None:
            return "List is empty"
        self.head = self.head.next
        return "First node deleted"
    
    def delete\_last(self):
        if self.head is None:
            return "List is empty"
        if self.head.next is None:
            self.head = None
            return "Last node deleted"
        
        current = self.head
        while current.next.next:
            current = current.next
        current.next = None
        return "Last node deleted"
    
    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        return elements

\# Usage
ll = LinkedList()
\# Add nodes and test deletion
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Delete first}: Update head pointer
\item
  \textbf{Delete last}: Traverse to second last node
\item
  \textbf{Edge cases}: Empty list and single node
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Delete Delivers by pointer updates''

\end{mnemonicbox}
\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

\textbf{List different applications of Queue.}

\begin{solutionbox}

\textbf{Queue Applications:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Application} & \textbf{Usage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{CPU Scheduling} & Process management \\
\textbf{Print Queue} & Document printing \\
\textbf{BFS Algorithm} & Graph traversal \\
\textbf{Buffer} & Data streaming \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{FIFO nature}: First come first served
\item
  \textbf{Real-time systems}: Handle requests in order
\item
  \textbf{Resource sharing}: Fair allocation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Queues Quietly handle ordered operations''

\end{mnemonicbox}
\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Explain different operations which we can perform on singly
linked list.}

\begin{solutionbox}

\textbf{Singly Linked List Operations:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Operation} & \textbf{Description} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insertion} & Add node at beginning/end/middle \\
\textbf{Deletion} & Remove node from any position \\
\textbf{Traversal} & Visit all nodes sequentially \\
\textbf{Search} & Find specific data in list \\
\textbf{Count} & Count total number of nodes \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic size}: Grow/shrink during runtime
\item
  \textbf{Memory efficiency}: Allocate as needed
\item
  \textbf{Sequential access}: No random access
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Insert-Delete-Traverse-Search-Count''

\end{mnemonicbox}
\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{Write an algorithm to insert a new node at the end of doubly
linked list.}

\begin{solutionbox}

\textbf{Algorithm for insertion at end:}

\begin{verbatim}
1. Create new node with given data
2. Set new node's next = NULL
3. If list is empty:
   - Set head = new node
   - Set new node's prev = NULL
4. Else:
   - Traverse to last node
   - Set last node's next = new node
   - Set new node's prev = last node
5. Return success
\end{verbatim}

\textbf{Code:}

\begin{verbatim}
def insert\_at\_end(self, data):
    new\_node = Node(data)
    if self.head is None:
        self.head = new\_node
        return
    
    current = self.head
    while current.next:
        current = current.next
    
    current.next = new\_node
    new\_node.prev = current
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Two-way linking}: Update both next and prev pointers
\item
  \textbf{End insertion}: Traverse to find last node
\item
  \textbf{Bidirectional connection}: Maintain list integrity
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Insert Intelligently with bidirectional links''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Write a python program for linear search.}

\begin{solutionbox}

\textbf{Code:}

\begin{verbatim}
def linear\_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return {-}1

\# Example usage
data = [10, 20, 30, 40, 50]
result = linear\_search(data, 30)
print(f"Element found at index: \{result\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Sequential search}: Check each element one by one
\item
  \textbf{Time complexity}: O(n)
\item
  \textbf{Simple implementation}: Easy to understand
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Linear Looks through every element''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Write a short note on Circular linked list.}

\begin{solutionbox}

\textbf{Circular Linked List}: Last node points back to first node
forming a circle.

\textbf{Diagram:}

\begin{verbatim}
[data|next]  [data|next]  [data|next]
     ↑                           ↓
     
\end{verbatim}

\textbf{Characteristics:}

\begin{itemize}
\tightlist
\item
  \textbf{No NULL pointers}: Last node connects to first
\item
  \textbf{Continuous traversal}: Can traverse infinitely
\item
  \textbf{Memory efficiency}: Better cache performance
\item
  \textbf{Applications}: Round-robin scheduling, multiplayer games
\end{itemize}

\textbf{Advantages:}

\begin{itemize}
\tightlist
\item
  \textbf{Efficient insertion}: At any position
\item
  \textbf{No wasted pointers}: All nodes connected
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Connects everything in a loop''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Explain Quick sort algorithm with an example.}

\begin{solutionbox}

\textbf{Quick Sort}: Divide and conquer sorting algorithm using pivot
element.

\textbf{Algorithm:}

\begin{verbatim}
1. Choose pivot element
2. Partition array around pivot
3. Recursively sort left subarray
4. Recursively sort right subarray
\end{verbatim}

\textbf{Example: Sort [64, 34, 25, 12, 22, 11, 90]}

\textbf{Step 1:} Pivot = 64

\begin{verbatim}
[34, 25, 12, 22, 11] 64 [90]
\end{verbatim}

\textbf{Step 2:} Sort left partition [34, 25, 12, 22, 11] Pivot = 34

\begin{verbatim}
[25, 12, 22, 11] 34 []
\end{verbatim}

\textbf{Final sorted:} [11, 12, 22, 25, 34, 64, 90]

\begin{itemize}
\tightlist
\item
  \textbf{Divide and conquer}: Break problem into smaller parts
\item
  \textbf{In-place sorting}: Minimal extra memory
\item
  \textbf{Average complexity}: O(n log n)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Quick Partitions then conquers''

\end{mnemonicbox}
\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{Explain Binary search algorithm with an example.}

\begin{solutionbox}

\textbf{Binary Search}: Search algorithm for sorted arrays using divide
and conquer.

\textbf{Algorithm:}

\begin{verbatim}
1. Set left = 0, right = array length - 1
2. While left <= right:
   - Calculate mid = (left + right) / 2
   - If target = array[mid], return mid
   - If target < array[mid], right = mid - 1
   - If target > array[mid], left = mid + 1
3. Return -1 if not found
\end{verbatim}

\textbf{Example: Search 22 in [11, 12, 22, 25, 34, 64, 90]}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llllll@{}}
\toprule\noalign{}
\textbf{Step} & \textbf{Left} & \textbf{Right} & \textbf{Mid} &
\textbf{Value} & \textbf{Action} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 0 & 6 & 3 & 25 & 22 \textless{} 25, right = 2 \\
2 & 0 & 2 & 1 & 12 & 22 \textgreater{} 12, left = 2 \\
3 & 2 & 2 & 2 & 22 & Found! \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Bisects to find quickly''

\end{mnemonicbox}
\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Discuss different applications of linked list.}

\begin{solutionbox}

\textbf{Linked List Applications:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Application} & \textbf{Usage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Arrays} & Resizable data storage \\
\textbf{Stack/Queue Implementation} & LIFO/FIFO structures \\
\textbf{Graph Representation} & Adjacency lists \\
\textbf{Memory Management} & Free memory blocks \\
\textbf{Music Playlist} & Next/previous song navigation \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic memory}: Allocate as needed
\item
  \textbf{Efficient insertion/deletion}: No shifting required
\item
  \textbf{Flexible structure}: Adapt to changing requirements
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists Live in dynamic applications''

\end{mnemonicbox}
\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Write a python program for insertion sort with an example.}

\begin{solutionbox}

\textbf{Code:}

\begin{verbatim}
def insertion\_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i {-} 1
        
        while j {=} 0 and arr[j] {} key:
            arr[j + 1] = arr[j]
            j {-=} 1
        
        arr[j + 1] = key
    
    return arr

\# Example
data = [64, 34, 25, 12, 22, 11, 90]
sorted\_data = insertion\_sort(data)
print(f"Sorted array: \{sorted\_data\}")
\end{verbatim}

\textbf{Step-by-step example:}

\begin{verbatim}
Initial: [64, 34, 25, 12, 22, 11, 90]
Pass 1:  [34, 64, 25, 12, 22, 11, 90]
Pass 2:  [25, 34, 64, 12, 22, 11, 90]
Pass 3:  [12, 25, 34, 64, 22, 11, 90]
Pass 4:  [12, 22, 25, 34, 64, 11, 90]
Pass 5:  [11, 12, 22, 25, 34, 64, 90]
Pass 6:  [11, 12, 22, 25, 34, 64, 90]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Card sorting analogy}: Like arranging playing cards
\item
  \textbf{Stable sort}: Maintains relative order of equal elements
\item
  \textbf{Online algorithm}: Can sort list as it receives data
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Insertion Inserts in right position''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Define following terms: I. Complete Binary tree II. In-degree
III. Out-degree.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3846}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6154}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Term}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Definition}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Complete Binary Tree} & All levels filled except possibly last
level from left \\
\textbf{In-degree} & Number of edges coming into a node \\
\textbf{Out-degree} & Number of edges going out from a node \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Complete-In-Out = Tree terminology''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Explain bubble sort algorithm with an example.}

\begin{solutionbox}

\textbf{Bubble Sort}: Compare adjacent elements and swap if in wrong
order.

\textbf{Algorithm:}

\begin{verbatim}
1. For each pass (0 to n-1):
   2. For each element (0 to n-pass-1):
      3. If arr[j] > arr[j+1]:
         4. Swap arr[j] and arr[j+1]
\end{verbatim}

\textbf{Example: [64, 34, 25, 12]}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Pass} & \textbf{Comparisons} & \textbf{Result} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 64\textgreater34(swap), 64\textgreater25(swap),
64\textgreater12(swap) & [34,25,12,64] \\
2 & 34\textgreater25(swap), 34\textgreater12(swap) &
[25,12,34,64] \\
3 & 25\textgreater12(swap) & [12,25,34,64] \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Bubble up}: Largest element bubbles to end
\item
  \textbf{Multiple passes}: Each pass places one element correctly
\item
  \textbf{Simple implementation}: Easy to understand
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Bubble Brings biggest to back''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Create a Binary Search Tree for the keys 15, 35, 12, 48, 5, 25,
58, 8 and write the Preorder, Inorder and Postorder traversal
sequences.}

\begin{solutionbox}

\textbf{BST Construction:}

\begin{verbatim}
        15
       /  {}
      12   35
     /    /  {}
    5    25   48
     {          }
      8          58
\end{verbatim}

\textbf{Traversal Sequences:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Traversal} & \textbf{Sequence} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Preorder} & 15, 12, 5, 8, 35, 25, 48, 58 \\
\textbf{Inorder} & 5, 8, 12, 15, 25, 35, 48, 58 \\
\textbf{Postorder} & 8, 5, 12, 25, 58, 48, 35, 15 \\
\end{longtable}
}

\textbf{Traversal Rules:}

\begin{itemize}
\tightlist
\item
  \textbf{Preorder}: Root \rightarrow Left \rightarrow Right
\item
  \textbf{Inorder}: Left \rightarrow Root \rightarrow Right (gives sorted order)
\item
  \textbf{Postorder}: Left \rightarrow Right \rightarrow Root
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Pre-In-Post = Root position''

\end{mnemonicbox}
\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{Define binary tree. Explain searching a node in binary tree.}

\begin{solutionbox}

\textbf{Binary Tree}: Hierarchical data structure where each node has at
most two children.

\textbf{Search Algorithm:}

\begin{verbatim}
1. Start from root
2. If target = current node, return found
3. If target < current node, go left
4. If target > current node, go right
5. Repeat until found or reach NULL
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Hierarchical structure}: Parent-child relationship
\item
  \textbf{Binary property}: Maximum two children per node
\item
  \textbf{Search efficiency}: O(log n) for balanced trees
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Branches into two paths''

\end{mnemonicbox}
\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Give the trace to sort the given data using bubble sort method.
Data are: 44, 72, 94, 28, 18, 442, 41}

\begin{solutionbox}

\textbf{Bubble Sort Trace:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Pass} & \textbf{Array State} & \textbf{Swaps} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Initial & [44, 72, 94, 28, 18, 442, 41] & - \\
Pass 1 & [44, 72, 28, 18, 94, 41, 442] & 94\textgreater28,
94\textgreater18, 442\textgreater41 \\
Pass 2 & [44, 28, 18, 72, 41, 94, 442] & 72\textgreater28,
72\textgreater18, 94\textgreater41 \\
Pass 3 & [28, 18, 44, 41, 72, 94, 442] & 44\textgreater28,
44\textgreater18, 72\textgreater41 \\
Pass 4 & [18, 28, 41, 44, 72, 94, 442] & 28\textgreater18,
44\textgreater41 \\
Pass 5 & [18, 28, 41, 44, 72, 94, 442] & No swaps \\
\end{longtable}
}

\textbf{Final sorted array:} [18, 28, 41, 44, 72, 94, 442]

\end{solutionbox}
\begin{mnemonicbox}
``Bubble sort Bubbles largest to end each pass''

\end{mnemonicbox}
\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{List applications of trees. Explain the technique for converting
general tree into a Binary Search Tree with example.}

\begin{solutionbox}

\textbf{Tree Applications:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Application} & \textbf{Usage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{File System} & Directory hierarchy \\
\textbf{Expression Trees} & Mathematical expressions \\
\textbf{Decision Trees} & AI and machine learning \\
\textbf{Heap} & Priority queues \\
\end{longtable}
}

\textbf{General Tree to BST Conversion:}

\textbf{Technique: First Child - Next Sibling Representation}

\textbf{Original General Tree:}

\begin{verbatim}
    A
   /|\
  B C D
 /| |
E F G
\end{verbatim}

\textbf{Converted to Binary Tree:}

\begin{verbatim}
    A
   /
  B
   {}
    C
   / {}
  E   D
   {}
    F
     {}
      G
\end{verbatim}

\textbf{Steps:}

\begin{enumerate}
\tightlist
\item
  \textbf{First child}: Becomes left child in binary tree
\item
  \textbf{Next sibling}: Becomes right child in binary tree
\item
  \textbf{Recursive application}: Apply to all nodes
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \textbf{Systematic conversion}: Preserves tree structure
\item
  \textbf{Binary representation}: Uses only two pointers per node
\item
  \textbf{Space efficiency}: Standard binary tree operations apply
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``First-child Left, Next-sibling Right''

\end{mnemonicbox}

\end{document}
