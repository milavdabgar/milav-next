\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4331601 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Differentiate between array and list.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5385}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4615}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Array
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
List
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Fixed size} at creation & \textbf{Dynamic size} - can
grow/shrink \\
\textbf{Homogeneous} data (same type) & \textbf{Heterogeneous} data
(mixed types) \\
\textbf{Memory efficient} - contiguous allocation & \textbf{Flexible}
but uses more memory \\
\textbf{Faster access} for calculations & \textbf{Built-in methods} for
operations \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Arrays are Fixed Friends, Lists are Loose Leaders''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Explain the concept of class and object with the help of python
program.}

\begin{solutionbox}

\textbf{Class} એ એક blueprint છે જે objects ના structure અને behavior
define કરે છે. \textbf{Object} એ class નો instance છે.

\begin{verbatim}
class Student:
    def \_\_init\_\_(self, name, age):
        self.name = name
        self.age = age
    
    def display(self):
        print(f"Name: \{self.name\}, Age: \{self.age\}")

\# Creating objects
s1 = Student("Ram", 20)
s2 = Student("Sita", 19)
s1.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Class}: Template બનાવે છે
\item
  \textbf{Object}: Real instance બનાવે છે\\
\item
  \textbf{Constructor}: Object initialize કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Class Blueprints Create Object Instances''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Define constructor. Discuss different types of constructors with
suitable python program.}

\begin{solutionbox}

\textbf{Constructor} એ special method છે જે object creation time પર
automatically call થાય છે. Python માં \texttt{\_\_init\_\_()} method
constructor છે.

\begin{verbatim}
class Demo:
    \# Default Constructor
    def \_\_init\_\_(self):
        self.value = 0
    
    \# Parameterized Constructor
    def \_\_init\_\_(self, x, y=10):
        self.x = x
        self.y = y

\# Usage
d1 = Demo(5)      \#

x=5,

y=10 (default)

d2 = Demo(3, 7)   \#

x=3,

y=7

\end{verbatim}

\textbf{Types of Constructors:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Description & Usage \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default} & No parameters & Object initialization \\
\textbf{Parameterized} & With parameters & Custom initialization \\
\textbf{Copy} & Creates copy of object & Object duplication \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Default Parameters Copy Objects''

\end{mnemonicbox}
\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Define Polymorphism. Write a python program for polymorphism
through inheritance.}

\begin{solutionbox}

\textbf{Polymorphism} એ same interface વાપરીને different objects પર
different operations perform કરવાની ability છે.

\begin{verbatim}
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Woof!"

class Cat(Animal):
    def sound(self):
        return "Meow!"

\# Polymorphic behavior
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.sound())
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Method Overriding}: Child class માં same method name
\item
  \textbf{Dynamic Binding}: Runtime પર method selection
\item
  \textbf{Code Reusability}: Same interface, different implementation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Many Objects, One Interface''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Explain Python specific data structure List, Tuple and
Dictionary.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4324}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3243}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2432}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Data Structure
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Properties
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{List} & Mutable, ordered, allows duplicates &
\texttt{[1,\ 2,\ 3,\ 2]} \\
\textbf{Tuple} & Immutable, ordered, allows duplicates &
\texttt{(1,\ 2,\ 3,\ 2)} \\
\textbf{Dictionary} & Mutable, key-value pairs, no duplicate keys &
\texttt{\{\textquotesingle{}a\textquotesingle{}:\ 1,\ \textquotesingle{}b\textquotesingle{}:\ 2\}} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Lists Change, Tuples Stay, Dictionaries Map''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Explain application of stack.}

\begin{solutionbox}

\textbf{Stack Applications:}

\begin{itemize}
\tightlist
\item
  \textbf{Function Calls}: Call stack management
\item
  \textbf{Expression Evaluation}: Infix to postfix conversion
\item
  \textbf{Undo Operations}: Text editors, browsers
\item
  \textbf{Parentheses Matching}: Syntax checking
\end{itemize}

\begin{verbatim}
     +{-{-}{-}+}
     | 3 | {{-} Top}
     +{-{-}{-}+}
     | 2 |
     +{-{-}{-}+}
     | 1 |
     +{-{-}{-}+}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Functions Evaluate Undo Parentheses''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Define stack. Explain PUSH \& POP operation with example. Write
an algorithm for PUSH and POP operations of stack.}

\begin{solutionbox}

\textbf{Stack} એ LIFO (Last In First Out) principle follow કરતું linear
data structure છે.

\textbf{PUSH Algorithm:}

\begin{verbatim}
1. Check if stack is full
2. If full, print "Stack Overflow"
3. Else, increment top
4. Add element at top position
\end{verbatim}

\textbf{POP Algorithm:}

\begin{verbatim}
1. Check if stack is empty
2. If empty, print "Stack Underflow"  
3. Else, remove element from top
4. Decrement top
\end{verbatim}

\textbf{Example:}

\begin{verbatim}
stack = []
stack.append(10)  \# PUSH
stack.append(20)  \# PUSH
item = stack.pop()  \# POP returns 20
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Last In, First Out - Like Plates''

\end{mnemonicbox}
\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{Define Following terms: I. Time Complexity II. Space Complexity
III. Best case}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Term
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Time Complexity} & Algorithm execution time analysis & O(n),
O(log n) \\
\textbf{Space Complexity} & Memory usage analysis & O(1), O(n) \\
\textbf{Best Case} & Minimum time/space needed & Sorted array search \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Time Space Best Performance''

\end{mnemonicbox}
\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{Convert A -- (B / C + (D \% E * F) / G)* H into postfix
expression}

\begin{solutionbox}

\textbf{Step-by-step conversion:}

\begin{verbatim}
Infix: A – (B / C + (D % E * F) / G) * H

1. A B C / D E % F * G / + - H *

Stack operations:
- Operators: -, (, /, +, (, %, *, ), /, ), *
- Final: A B C / D E % F * G / + - H *
\end{verbatim}

\textbf{Postfix Result:
\texttt{A\ B\ C\ /\ D\ E\ \%\ F\ *\ G\ /\ +\ -\ H\ *}}

\end{solutionbox}
\begin{mnemonicbox}
``Operands First, Operators Follow''

\end{mnemonicbox}
\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Define circular queue. Explain INSERT and DELETE operations of
circular queue with diagrams.}

\begin{solutionbox}

\textbf{Circular Queue} એ queue નું modified version છે જ્યાં last position
first position સાથે connected હોય છે.

\begin{verbatim}
     +{-{-}{-}+{-}{-}{-}+{-}{-}{-}+{-}{-}{-}+}
     | 1 | 2 | 3 |   |
     +{-{-}{-}+{-}{-}{-}+{-}{-}{-}+{-}{-}{-}+}
       \^{           \^{}}
     front        rear
\end{verbatim}

\textbf{INSERT Algorithm:}

\begin{verbatim}
1. Check if queue is full
2. rear = (rear + 1) % size
3. queue[rear] = element
4. If first element, set front = 0
\end{verbatim}

\textbf{DELETE Algorithm:}

\begin{verbatim}
1. Check if queue is empty
2. element = queue[front]
3. front = (front + 1) % size
4. Return element
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Advantage}: Memory efficiency
\item
  \textbf{Application}: CPU scheduling, buffering
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circle Back When Full''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Explain Implementation of Stack using List.}

\begin{solutionbox}

Stack operations Python List વડે:

\begin{verbatim}
stack = []  \# Empty stack
stack.append(10)  \# PUSH
stack.append(20)  \# PUSH
top = stack.pop()  \# POP
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{PUSH}: \texttt{append()} method
\item
  \textbf{POP}: \texttt{pop()} method\\
\item
  \textbf{TOP}: \texttt{stack[-1]} for peek
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Append Pushes, Pop Pulls''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Discuss different applications of linked list.}

\begin{solutionbox}

\textbf{Linked List Applications:}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic Memory}: Size varies at runtime
\item
  \textbf{Insertion/Deletion}: Efficient at any position
\item
  \textbf{Implementation}: Stacks, queues, graphs
\item
  \textbf{Undo Functionality}: Browser history, text editors
\end{itemize}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3824}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3235}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2941}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Advantage
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use Case
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Music Playlist} & Easy add/remove & Media players \\
\textbf{Memory Management} & Dynamic allocation & Operating systems \\
\textbf{Polynomial Representation} & Efficient storage & Mathematical
operations \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Dynamic Implementation Undo Memory''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Explain doubly linked list. Write an algorithm to delete a node
from the beginning of doubly linked list}

\begin{solutionbox}

\textbf{Doubly Linked List} માં દરેક node માં data, next pointer અને
previous pointer હોય છે.

\begin{verbatim}
    +{-{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+}
    | prev | data | next |
    +{-{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+}
         \^{         \^{}}
       NULL     points to next
\end{verbatim}

\textbf{Delete from Beginning Algorithm:}

\begin{verbatim}
1. If list is empty, return
2. If only one node:
   - head = NULL
3. Else:
   - temp = head
   - head = head.next
   - head.prev = NULL
   - delete temp
\end{verbatim}

\begin{verbatim}
def delete\_beginning(self):
    if self.head is None:
        return
    if self.head.next is None:
        self.head = None
    else:
        self.head = self.head.next
        self.head.prev = None
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Two Way Navigation''

\end{mnemonicbox}
\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

**Convert this Infix expression into Postfix expression: A+B/C*D-E/F-G**

\begin{solutionbox}

\textbf{Step-by-step conversion:}

\begin{verbatim}
Infix: A+B/C*D-E/F-G

Postfix: A B C / D * + E F / - G -

Operator precedence: *, / > +, -
Left to right associativity
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Multiply Divide Before Add Subtract''

\end{mnemonicbox}
\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Explain Circular Linked List with its disadvantages.}

\begin{solutionbox}

\textbf{Circular Linked List} માં last node નો next pointer first node ને
point કરે છે.

\begin{verbatim}
    +{-{-}{-}+    +{-}{-}{-}+    +{-}{-}{-}+}
    | 1 |{-{-}{-}| 2 |{-}{-}{-}| 3 |}
    +{-{-}{-}+    +{-}{-}{-}+    +{-}{-}{-}+}
      \^{                 |}
      +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\textbf{Disadvantages:}

\begin{itemize}
\tightlist
\item
  \textbf{Infinite Loop Risk}: Improper traversal
\item
  \textbf{Complex Implementation}: Extra care needed
\item
  \textbf{Memory Overhead}: Additional pointer management
\item
  \textbf{Debugging Difficulty}: Circular references
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circles Can Cause Confusion''

\end{mnemonicbox}
\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{Write a Python Program to perform Insert operation in doubly
Linked List. Explain with neat diagrams.}

\begin{solutionbox}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def insert\_beginning(self, data):
        new\_node = Node(data)
        if self.head is None:
            self.head = new\_node
        else:
            new\_node.next = self.head
            self.head.prev = new\_node
            self.head = new\_node
\end{verbatim}

\begin{verbatim}
Before:  NULL {{-} [10] {-} [20] {-} NULL}

After:   NULL {{-} [5] {-} [10] {-} [20] {-} NULL}
                 \^{}
               new head
\end{verbatim}

\textbf{Insert Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{Beginning}: Update head pointer
\item
  \textbf{End}: Traverse to last node
\item
  \textbf{Middle}: Update prev/next pointers
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Begin End Middle Insertions''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Write an algorithm for Merge sort.}

\begin{solutionbox}

\textbf{Merge Sort Algorithm:}

\begin{verbatim}
1. If array size <= 1, return
2. Divide array into two halves
3. Recursively sort both halves  
4. Merge sorted halves
\end{verbatim}

\textbf{Time Complexity}: O(n log n) \textbf{Space Complexity}: O(n)

\end{solutionbox}
\begin{mnemonicbox}
``Divide Conquer Merge''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Differentiate between Singly Linked List and Doubly Linked
List.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Singly Linked List & Doubly Linked List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{One pointer} (next) & \textbf{Two pointers} (next, prev) \\
\textbf{Forward traversal} only & \textbf{Bidirectional traversal} \\
\textbf{Less memory} usage & \textbf{More memory} usage \\
\textbf{Simple implementation} & \textbf{Complex implementation} \\
\end{longtable}
}

\begin{verbatim}
Singly:  [data|next] {- [data|next] {-} NULL}

Doubly:  NULL {{-} [prev|data|next] {-} [prev|data|next] {-} NULL}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Single Forward, Double Bidirectional''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Write an algorithm for selection sort. Give the trace to sort
the given data using selection sort method. Data are: 13, 2, 6, 54, 18,
42, 11}

\begin{solutionbox}

\textbf{Selection Sort Algorithm:}

\begin{verbatim}
1. For i = 0 to n-2:
   2. Find minimum in array[i...n-1]
   3. Swap minimum with array[i]
\end{verbatim}

\textbf{Trace for [13, 2, 6, 54, 18, 42, 11]:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Pass & Array State & Min Found & Swap \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & [13, 2, 6, 54, 18, 42, 11] & 2 & 13\leftrightarrow2 \\
1 & [2, 13, 6, 54, 18, 42, 11] & 6 & 13\leftrightarrow6 \\
2 & [2, 6, 13, 54, 18, 42, 11] & 11 & 13\leftrightarrow11 \\
3 & [2, 6, 11, 54, 18, 42, 13] & 13 & 54\leftrightarrow13 \\
4 & [2, 6, 11, 13, 18, 42, 54] & 18 & No swap \\
5 & [2, 6, 11, 13, 18, 42, 54] & 42 & No swap \\
\end{longtable}
}

\textbf{Final Result: [2, 6, 11, 13, 18, 42, 54]}

\end{solutionbox}
\begin{mnemonicbox}
``Select Minimum, Swap Position''

\end{mnemonicbox}
\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{Write an algorithm for Insertion sort.}

\begin{solutionbox}

\textbf{Insertion Sort Algorithm:}

\begin{verbatim}
1. For i = 1 to n-1:
   2. key = array[i]
   3. j = i-1
   4. While j >= 0 and array[j] > key:
      5. array[j+1] = array[j]
      6. j = j-1
   7. array[j+1] = key
\end{verbatim}

\textbf{Time Complexity}: O(n^{2}) \textbf{Best Case}: O(n) for sorted
array

\end{solutionbox}
\begin{mnemonicbox}
``Insert In Right Position''

\end{mnemonicbox}
\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Write an algorithm to insert a new node at the end of circular
linked list.}

\begin{solutionbox}

\textbf{Algorithm:}

\begin{verbatim}
1. Create new_node with data
2. If list is empty:
   - head = new_node
   - new_node.next = new_node
3. Else:
   - temp = head
   - While temp.next != head:
     - temp = temp.next
   - temp.next = new_node
   - new_node.next = head
\end{verbatim}

\begin{verbatim}
def insert\_end(self, data):
    new\_node = Node(data)
    if self.head is None:
        self.head = new\_node
        new\_node.next = new\_node
    else:
        temp = self.head
        while temp.next != self.head:
            temp = temp.next
        temp.next = new\_node
        new\_node.next = self.head
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Circle Back To Head''

\end{mnemonicbox}
\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Write an algorithm for bubble sort. Give the trace to sort the
given data using bubble sort method. Data are: 37, 22, 64, 84, 58, 52,
11}

\begin{solutionbox}

\textbf{Bubble Sort Algorithm:}

\begin{verbatim}
1. For i = 0 to n-2:
   2. For j = 0 to n-2-i:
      3. If array[j] > array[j+1]:
         4. Swap array[j] and array[j+1]
\end{verbatim}

\textbf{Trace for [37, 22, 64, 84, 58, 52, 11]:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Pass & Comparisons \& Swaps & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 37\leftrightarrow22, 64\leftrightarrow84, 84\leftrightarrow58, 84\leftrightarrow52, 84\leftrightarrow11 & [22, 37, 64, 58, 52, 11,
84] \\
2 & 37\leftrightarrow64, 64\leftrightarrow58, 64\leftrightarrow52, 64\leftrightarrow11 & [22, 37, 58, 52, 11, 64, 84] \\
3 & 37\leftrightarrow58, 58\leftrightarrow52, 58\leftrightarrow11 & [22, 37, 52, 11, 58, 64, 84] \\
4 & 37\leftrightarrow52, 52\leftrightarrow11 & [22, 37, 11, 52, 58, 64, 84] \\
5 & 37\leftrightarrow11 & [22, 11, 37, 52, 58, 64, 84] \\
6 & 22\leftrightarrow11 & [11, 22, 37, 52, 58, 64, 84] \\
\end{longtable}
}

\textbf{Final Result: [11, 22, 37, 52, 58, 64, 84]}

\end{solutionbox}
\begin{mnemonicbox}
``Bubble Up The Largest''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Explain Binary search tree and application of it.}

\begin{solutionbox}

\textbf{Binary Search Tree (BST)} એ binary tree છે જ્યાં left subtree માં
smaller values અને right subtree માં larger values હોય છે.

\textbf{Properties:}

\begin{itemize}
\tightlist
\item
  \textbf{Left child} \textless{} \textbf{Parent} \textless{}
  \textbf{Right child}
\item
  \textbf{Inorder traversal} gives sorted sequence
\item
  \textbf{Search time}: O(log n) average case
\end{itemize}

\textbf{Applications:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Application & Benefit & Use Case \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Database Indexing} & Fast search & DBMS systems \\
\textbf{Expression Trees} & Evaluation & Compilers \\
\textbf{Huffman Coding} & Compression & Data compression \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Search Trees Organize Data''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Write Python Program for Linear Search and explain it with an
example}

\begin{solutionbox}

\begin{verbatim}
def linear\_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return {-}1

\# Example
numbers = [10, 25, 30, 45, 60]
result = linear\_search(numbers, 30)
print(f"Element found at index: \{result\}")  \# Output: 2
\end{verbatim}

\textbf{Working:}

\begin{itemize}
\tightlist
\item
  \textbf{Sequential check}: Element by element
\item
  \textbf{Time Complexity}: O(n)
\item
  \textbf{Space Complexity}: O(1)
\item
  \textbf{Works on}: Unsorted arrays
\end{itemize}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Element & Found? \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 10 & No \\
2 & 25 & No \\
3 & 30 & Yes! \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Linear Line By Line''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Create a Binary Search Tree for the keys 45, 35, 12, 58, 5, 55,
58, 80, 35, 42 and write the Preorder, Inorder and Postorder traversal
sequences.}

\begin{solutionbox}

\textbf{BST Construction (duplicates ignored):}

\begin{verbatim}
         45
        /  {}
      35    58
     / {   / }
   12  42 55 80
   /
  5
\end{verbatim}

\textbf{Insertion Order:} 45(root), 35(left), 12(left of 35), 58(right),
5(left of 12), 55(left of 58), 80(right of 58), 42(right of 12)

\textbf{Traversals:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Traversal & Sequence & Rule \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Preorder} & 45, 35, 12, 5, 42, 58, 55, 80 & Root-Left-Right \\
\textbf{Inorder} & 5, 12, 35, 42, 45, 55, 58, 80 & Left-Root-Right \\
\textbf{Postorder} & 5, 42, 12, 35, 55, 80, 58, 45 & Left-Right-Root \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Pre-Root First, In-Sorted, Post-Root Last''

\end{mnemonicbox}
\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{Define following terms: I. Binary tree II. level number III.
Leaf-node}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Term
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Binary tree} & Tree with max 2 children per node & Each node has
\leq 2 children \\
\textbf{Level number} & Distance from root (root = level 0) & Root=0,
children=1, etc. \\
\textbf{Leaf-node} & Node with no children & Terminal nodes \\
\end{longtable}
}

\begin{verbatim}
      A     {{-} Level 0 (Root)}
     / {}
    B   C   {{-} Level 1}
   /
  D         {{-} Level 2 (Leaf)}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Levels Lead To Leaves''

\end{mnemonicbox}
\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Differentiate between Linear Search and Binary search.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Linear Search & Binary Search \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Works on unsorted} arrays & \textbf{Requires sorted} array \\
\textbf{Sequential checking} & \textbf{Divide and conquer} \\
\textbf{Time}: O(n) & \textbf{Time}: O(log n) \\
\textbf{Simple implementation} & \textbf{Complex implementation} \\
\textbf{No preprocessing} needed & \textbf{Sorting required} \\
\end{longtable}
}

\begin{verbatim}
Linear:  [1][2][3][4][5] {- Check each}
Binary:  [1][2][3][4][5] {- Check middle, divide}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Linear Line, Binary Bisect''

\end{mnemonicbox}
\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{Write an algorithm for insertion and deletion a node in Binary
search tree.}

\begin{solutionbox}

\textbf{Insertion Algorithm:}

\begin{verbatim}
1. If root is NULL, create new node as root
2. If data < root.data, insert in left subtree
3. If data > root.data, insert in right subtree
4. If data == root.data, no insertion (duplicate)
\end{verbatim}

\textbf{Deletion Algorithm:}

\begin{verbatim}
1. If node is leaf: Simply delete
2. If node has one child: Replace with child
3. If node has two children:
   - Find inorder successor
   - Replace data with successor's data
   - Delete successor
\end{verbatim}

\begin{verbatim}
def insert(root, data):
    if root is None:
        return Node(data)
    if data {} root.data:
        root.left = insert(root.left, data)
    elif data {} root.data:
        root.right = insert(root.right, data)
    return root

def delete(root, data):
    if root is None:
        return root
    if data {} root.data:
        root.left = delete(root.left, data)
    elif data {} root.data:
        root.right = delete(root.right, data)
    else:
        \# Node to be deleted found
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        \# Node with two children
        temp = find\_min(root.right)
        root.data = temp.data
        root.right = delete(root.right, temp.data)
    return root
\end{verbatim}

\textbf{Cases:}

\begin{itemize}
\tightlist
\item
  \textbf{Leaf deletion}: Direct removal
\item
  \textbf{One child}: Replace with child\\
\item
  \textbf{Two children}: Replace with successor
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Insert Compare, Delete Replace''

\end{mnemonicbox}

\end{document}
