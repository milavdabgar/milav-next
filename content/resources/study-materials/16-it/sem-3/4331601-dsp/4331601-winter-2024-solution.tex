\documentclass{article}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/english-boxes.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Data Structure with Python (4331601) - Winter 2024 Solution}
\date{December 03, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{Explain set data structure in python?}
\begin{solutionbox}
    A \keyword{set} is an unordered collection of unique elements in Python. Sets are mutable but contain only immutable elements.

    \textbf{Key Properties:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Set Properties}
        \centering
        \begin{tabulary}{\linewidth}{LC}
            \toprule
            \textbf{Property} & \textbf{Description} \\
            \midrule
            \textbf{Unique Elements} & No duplicate values allowed \\
            \textbf{Unordered} & No indexing or slicing \\
            \textbf{Mutable} & Can add/remove elements \\
            \textbf{Iterable} & Can loop through elements \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Basic Operations:}
    \begin{lstlisting}[language=Python, caption=Set Operations]
# Create set
my_set = {1, 2, 3, 4}
# Add element
my_set.add(5)
# Remove element
my_set.remove(2)
    \end{lstlisting}

    \begin{mnemonicbox}
        "Sets are Unique Unordered Collections"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(b)}{4}{Define Tuple in python? Explain operations of tuple data structure in python.}
\begin{solutionbox}
    A \keyword{tuple} is an ordered collection of items that is immutable (cannot be changed after creation).

    \textbf{Tuple Definition:}
    \begin{itemize}
        \item \textbf{Ordered}: Elements have defined order
        \item \textbf{Immutable}: Cannot modify after creation
        \item \textbf{Allow duplicates}: Same values can appear multiple times
        \item \textbf{Indexed}: Access elements using index
    \end{itemize}

    \textbf{Tuple Operations:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Tuple Operations}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Operation} & \textbf{Example} & \textbf{Description} \\
            \midrule
            \textbf{Creation} & \code{t = (1, 2, 3)} & Create tuple \\
            \textbf{Indexing} & \code{t[0]} & Access first element \\
            \textbf{Slicing} & \code{t[1:3]} & Get subset \\
            \textbf{Length} & \code{len(t)} & Count elements \\
            \textbf{Concatenation} & \code{t1 + t2} & Join tuples \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{lstlisting}[language=Python, caption=Tuple Examples]
# Example operations
tup = (10, 20, 30, 40)
print(tup[1])      # Output: 20
print(tup[1:3])    # Output: (20, 30)
    \end{lstlisting}

    \begin{mnemonicbox}
        "Tuples are Immutable Ordered Collections"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(c)}{7}{Explain Types of constructors in python? Write a python program to multiplication of two numbers using static method.}
\begin{solutionbox}
    \textbf{Types of Constructors:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Constructor Types}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Constructor Type} & \textbf{Description} & \textbf{Usage} \\
            \midrule
            \textbf{Default Constructor} & No parameters & \code{\_\_init\_\_(self)} \\
            \textbf{Parameterized Constructor} & Takes parameters & \code{\_\_init\_\_(self, params)} \\
            \textbf{Non-parameterized Constructor} & Only self parameter & Basic initialization \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Static Method Program:}
    \begin{lstlisting}[language=Python, caption=Static Method for Multiplication]
class Calculator:
    def __init__(self):
        pass
    
    @staticmethod
    def multiply(num1, num2):
        return num1 * num2

# Usage
result = Calculator.multiply(5, 3)
print(f"Multiplication: {result}")  # Output: 15
    \end{lstlisting}

    \textbf{Key Points:}
    \begin{itemize}
        \item \textbf{Static methods}: Don't need object instance
        \item \textbf{\@staticmethod decorator}: Defines static method
        \item \textbf{No self parameter}: Independent of class instance
    \end{itemize}

    \begin{mnemonicbox}
        "Static methods Stand Separate from Self"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(c) OR}{7}{Define Data Encapsulation. List out different types of methods in python. Write a python program to multilevel inheritances.}
\begin{solutionbox}
    \textbf{Data Encapsulation:}
    Data encapsulation is the concept of bundling data and methods within a class and restricting direct access to some components.

    \textbf{Types of Methods:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Method Types}
        \centering
        \begin{tabulary}{\linewidth}{LCc}
            \toprule
            \textbf{Method Type} & \textbf{Access Level} & \textbf{Example} \\
            \midrule
            \textbf{Public} & Accessible everywhere & \code{method()} \\
            \textbf{Protected} & Class and subclass & \code{\_method()} \\
            \textbf{Private} & Only within class & \code{\_\_method()} \\
            \textbf{Static} & Class level & \code{\@staticmethod} \\
            \textbf{Class} & Class and subclasses & \code{\@classmethod} \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Multilevel Inheritance Program:}
    \begin{lstlisting}[language=Python, caption=Multilevel Inheritance]
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(f"{self.name} makes sound")

class Mammal(Animal):
    def __init__(self, name, warm_blooded):
        super().__init__(name)
        self.warm_blooded = warm_blooded

class Dog(Mammal):
    def __init__(self, name, breed):
        super().__init__(name, True)
        self.breed = breed
    
    def bark(self):
        print(f"{self.name} barks")

# Usage
dog = Dog("Buddy", "Golden Retriever")
dog.speak()  # From Animal class
dog.bark()   # From Dog class
    \end{lstlisting}

    \begin{mnemonicbox}
        "Encapsulation Hides Internal Details"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(a)}{3}{Differentiate between simple queue and circular queue.}
\begin{solutionbox}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Simple vs Circular Queue}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Feature} & \textbf{Simple Queue} & \textbf{Circular Queue} \\
            \midrule
            \textbf{Structure} & Linear arrangement & Circular arrangement \\
            \textbf{Memory Usage} & Wasteful (empty spaces) & Efficient (reuses space) \\
            \textbf{Rear Pointer} & Moves linearly & Wraps around \\
            \textbf{Front Pointer} & Moves linearly & Wraps around \\
            \textbf{Space Utilization} & Poor & Excellent \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Key Differences:}
    \begin{itemize}
        \item \textbf{Simple Queue}: Front and rear move in one direction only
        \item \textbf{Circular Queue}: Rear connects back to front position
        \item \textbf{Efficiency}: Circular queue eliminates memory waste
    \end{itemize}

    \begin{mnemonicbox}
        "Circular Queues Complete the Circle"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(b)}{4}{Explain polymorphism in python with example.}
\begin{solutionbox}
    \keyword{Polymorphism} means "many forms" - same method name behaves differently in different classes.

    \textbf{Types of Polymorphism:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Polymorphism Types}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Type} & \textbf{Description} & \textbf{Implementation} \\
            \midrule
            \textbf{Method Overriding} & Child class redefines parent method & Inheritance \\
            \textbf{Duck Typing} & Same method in different classes & Interface similarity \\
            \textbf{Operator Overloading} & Same operator different behavior & Magic methods \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{lstlisting}[language=Python, caption=Polymorphism Example]
class Animal:
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

# Polymorphic behavior
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.make_sound())
    \end{lstlisting}

    \begin{mnemonicbox}
        "Polymorphism Provides Multiple Personalities"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(c)}{7}{Define a).Infix b).postfix. Given equation to conversion from infix to postfix using stack. A+(B*C/D)}
\begin{solutionbox}
    \textbf{Definitions:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Expression Types}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Expression Type} & \textbf{Description} & \textbf{Example} \\
            \midrule
            \textbf{Infix} & Operator between operands & \code{A + B} \\
            \textbf{Postfix} & Operator after operands & \code{A B +} \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Conversion Algorithm:}
    \begin{enumerate}
        \item Scan infix expression left to right.
        \item If operand, add to output.
        \item If operator, compare precedence with stack top.
        \item Higher precedence $\rightarrow$ push to stack.
        \item Lower/equal precedence $\rightarrow$ pop and add to output.
    \end{enumerate}

    \textbf{Step-by-step Conversion: A+(B*C/D)}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Infix to Postfix Trace}
        \centering
        \begin{tabulary}{\linewidth}{C C L L}
            \toprule
            \textbf{Step} & \textbf{Symbol} & \textbf{Stack} & \textbf{Output} \\
            \midrule
            1 & A & [ ] & A \\
            2 & + & [+] & A \\
            3 & ( & [+, (] & A \\
            4 & B & [+, (] & AB \\
            5 & * & [+, (, *] & AB \\
            6 & C & [+, (, *] & ABC \\
            7 & / & [+, (, /] & ABC* \\
            8 & D & [+, (, /] & ABC*D \\
            9 & ) & [+] & ABC*D/ \\
            10 & End & [ ] & ABC*D/+ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Final Answer:} \code{ABC*D/+}

    \begin{mnemonicbox}
        "Stack Stores Operators Strategically"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(a) OR}{3}{Explain disadvantages of Queue.}
\begin{solutionbox}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Queue Disadvantages}
        \centering
        \begin{tabulary}{\linewidth}{LLL}
            \toprule
            \textbf{Disadvantage} & \textbf{Description} & \textbf{Impact} \\
            \midrule
            \textbf{Memory Waste} & Empty spaces not reused & Poor space utilization \\
            \textbf{Fixed Size} & Limited capacity & Overflow issues \\
            \textbf{No Random Access} & Only front/rear access & Limited flexibility \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Key Issues:}
    \begin{itemize}
        \item \textbf{Linear Queue}: Front spaces become unusable
        \item \textbf{Insertion/Deletion}: Only at specific ends
        \item \textbf{Search Operations}: Not efficient for searching
    \end{itemize}

    \begin{mnemonicbox}
        "Queues Quietly Queue with Quirks"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(b) OR}{4}{Define Abstract class in python? Explain the declaration of abstract method in python?}
\begin{solutionbox}
    \textbf{Abstract Class:}
    A class that cannot be instantiated and contains one or more abstract methods that must be implemented by subclasses.

    \textbf{Abstract Method Declaration:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Abstract Methods}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Component} & \textbf{Purpose} & \textbf{Syntax} \\
            \midrule
            \textbf{ABC Module} & Provides abstract base class & \code{from abc import ABC} \\
            \textbf{@abstractmethod} & Decorator for abstract methods & \code{@abstractmethod} \\
            \textbf{Implementation} & Must override in subclass & Required \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{lstlisting}[language=Python, caption=Abstract Class Example]
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width
    
    def perimeter(self):
        return 2 * (self.length + self.width)
    \end{lstlisting}

    \begin{mnemonicbox}
        "Abstract classes Are Blueprints Only"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(c) OR}{7}{Write an algorithm for Infix to postfix expression. Evaluate Postfix expression as: 5 6 2 + * 12 4 / -}
\begin{solutionbox}
    \textbf{Infix to Postfix Algorithm:}
    \begin{enumerate}
        \item Initialize empty stack and output string.
        \item Scan infix expression from left to right.
        \item If operand $\rightarrow$ add to output.
        \item If '(' $\rightarrow$ push to stack.
        \item If ')' $\rightarrow$ pop until '('.
        \item If operator $\rightarrow$ pop higher/equal precedence operators.
        \item Push current operator to stack.
        \item Pop remaining operators.
    \end{enumerate}

    \textbf{Postfix Evaluation: 5 6 2 + * 12 4 / -}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Postfix Evaluation Trace}
        \centering
        \begin{tabulary}{\linewidth}{C C L L}
            \toprule
            \textbf{Step} & \textbf{Token} & \textbf{Stack} & \textbf{Operation} \\
            \midrule
            1 & 5 & [5] & Push operand \\
            2 & 6 & [5, 6] & Push operand \\
            3 & 2 & [5, 6, 2] & Push operand \\
            4 & + & [5, 8] & Pop 2, 6 $\rightarrow$ $6+2=8$ \\
            5 & * & [40] & Pop 8, 5 $\rightarrow$ $5*8=40$ \\
            6 & 12 & [40, 12] & Push operand \\
            7 & 4 & [40, 12, 4] & Push operand \\
            8 & / & [40, 3] & Pop 4, 12 $\rightarrow$ $12/4=3$ \\
            9 & - & [37] & Pop 3, 40 $\rightarrow$ $40-3=37$ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Final Result: 37}

    \begin{mnemonicbox}
        "Postfix Processing Pops Pairs Precisely"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(a)}{3}{Write an algorithm to traverse node in single linked list.}
\begin{solutionbox}
    \textbf{Traversal Algorithm:}
    \begin{lstlisting}[language=Python, caption=Linked List Traversal]
def traverse_linked_list(head):
    current = head
    while current is not None:
        print(current.data)
        current = current.next
    \end{lstlisting}

    \textbf{Algorithm Steps:}
    \begin{enumerate}
        \item Start from head node.
        \item Check if current $\neq$ NULL.
        \item Process current node.
        \item Move to next node.
        \item Repeat until end.
    \end{enumerate}

    \begin{mnemonicbox}
        "Traverse Through Till The Tail"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(b)}{4}{Write an algorithm for Dequeue operation in queue using List.}
\begin{solutionbox}
    \textbf{Dequeue Algorithm:}
    \begin{lstlisting}[language=Python, caption=Dequeue Operation]
def dequeue(queue):
    if len(queue) == 0:
        print("Queue is empty")
        return None
    else:
        element = queue.pop(0)
        return element
    \end{lstlisting}

    \textbf{Algorithm Steps:}
    \begin{enumerate}
        \item Check empty: If queue is empty.
        \item Handle underflow: Display error message.
        \item Remove element: Delete front element.
        \item Return element: Return removed value.
        \item Update structure: Adjust queue pointers.
    \end{enumerate}

    \textbf{Time Complexity:} $O(n)$ due to list shifting

    \begin{mnemonicbox}
        "Dequeue Deletes from Front Door"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(c)}{7}{Define double linked list. Enlist major operation of Linked List. Write an algorithm to insert a node at beginning in singly linked list.}
\begin{solutionbox}
    \textbf{Double Linked List:}
    A linear data structure where each node contains data and two pointers - one pointing to the next node and another to the previous node.

    \textbf{Major Linked List Operations:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Linked List Operations}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Operation} & \textbf{Description} & \textbf{Time Complexity} \\
            \midrule
            \textbf{Insertion} & Add new node & $O(1)$ at beginning \\
            \textbf{Deletion} & Remove node & $O(1)$ if node known \\
            \textbf{Traversal} & Visit all nodes & $O(n)$ \\
            \textbf{Search} & Find specific node & $O(n)$ \\
            \textbf{Update} & Modify node data & $O(1)$ if node known \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Insert at Beginning Algorithm:}
    \begin{lstlisting}[language=Python, caption=Insert at Beginning]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def insert_at_beginning(head, data):
    new_node = Node(data)
    new_node.next = head
    head = new_node
    return head
    \end{lstlisting}

    \textbf{Algorithm Steps:}
    \begin{enumerate}
        \item Create new node with given data.
        \item Set new node's next to current head.
        \item Update head to point to new node.
        \item Return new head.
    \end{enumerate}

    \begin{mnemonicbox}
        "Insert at Beginning Builds Better Lists"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(a) OR}{3}{Explain the applications of single linked list.}
\begin{solutionbox}
    \textbf{Single Linked List Applications:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Applications}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Application} & \textbf{Use Case} & \textbf{Advantage} \\
            \midrule
            \textbf{Dynamic Memory} & Variable size data & Memory efficient \\
            \textbf{Stack Implementation} & LIFO operations & Easy push/pop \\
            \textbf{Queue Implementation} & FIFO operations & Dynamic sizing \\
            \textbf{Music Playlist} & Sequential playback & Easy navigation \\
            \textbf{Browser History} & Page navigation & Forward traversal \\
            \textbf{Polynomial Representation} & Mathematical operations & Coefficient storage \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Key Benefits:}
    \begin{itemize}
        \item \textbf{Dynamic Size}: Grows/shrinks during runtime
        \item \textbf{Memory Efficiency}: Allocates as needed
        \item \textbf{Insertion/Deletion}: Efficient at any position
    \end{itemize}

    \begin{mnemonicbox}
        "Linked Lists Link Many Applications"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(b) OR}{4}{Write an algorithm for PUSH operation of stack using List.}
\begin{solutionbox}
    \textbf{PUSH Algorithm:}
    \begin{lstlisting}[language=Python, caption=Stack Push]
def push(stack, element):
    stack.append(element)
    print(f"Pushed {element} to stack")
    \end{lstlisting}

    \textbf{Algorithm Steps:}
    \begin{enumerate}
        \item \textbf{Check capacity}: Verify stack not full (for fixed size).
        \item \textbf{Add element}: Append to end of list.
        \item \textbf{Update top}: Top points to last element.
        \item \textbf{Confirm}: Display success message.
    \end{enumerate}

    \textbf{Time Complexity: O(1)}

    \begin{mnemonicbox}
        "PUSH Puts on Stack Summit"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(c) OR}{7}{Explain advantages of a linked list. Write an algorithm to delete node at last from single linked list.}
\begin{solutionbox}
    \textbf{Linked List Advantages:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Advantages}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Advantage} & \textbf{Description} & \textbf{Benefit} \\
            \midrule
            \textbf{Dynamic Size} & Size changes at runtime & Memory flexible \\
            \textbf{Memory Efficient} & Allocates as needed & No waste \\
            \textbf{Easy Insertion} & Add anywhere efficiently & O(1) operation \\
            \textbf{Easy Deletion} & Remove efficiently & O(1) operation \\
            \textbf{No Memory Shift} & Elements don't move & Fast operations \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Delete Last Node Algorithm:}
    \begin{lstlisting}[language=Python, caption=Delete Last Node]
def delete_last_node(head):
    # Empty list
    if head is None:
        return None
    
    # Single node
    if head.next is None:
        return None
    
    # Multiple nodes
    current = head
    while current.next.next is not None:
        current = current.next
    
    current.next = None
    return head
    \end{lstlisting}

    \begin{mnemonicbox}
        "Linked Lists Lead to Logical Advantages"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(a)}{3}{Write an algorithm of Bubble sort.}
\begin{solutionbox}
    \textbf{Bubble Sort Algorithm:}
    \begin{lstlisting}[language=Python, caption=Bubble Sort]
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
    \end{lstlisting}

    \textbf{Time Complexity: O(n\textsuperscript{2})}

    \begin{mnemonicbox}
        "Bubbles Rise to Surface Slowly"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(b)}{4}{Explain circular linked list with its advantages.}
\begin{solutionbox}
    \textbf{Circular Linked List:}
    A linked list where the last node points to the first node, forming a circular structure.

    \textbf{Advantages:}
    \begin{itemize}
        \item \textbf{Memory Efficient}: No NULL pointers
        \item \textbf{Circular Traversal}: Can loop continuously
        \item \textbf{Queue Implementation}: Efficient enqueue/dequeue
        \item \textbf{Round Robin Scheduling}: CPU time sharing
    \end{itemize}

    \begin{center}
    \begin{tikzpicture}[node distance=1.5cm]
        \node[gtu block] (A) {A};
        \node[gtu block, right=of A] (B) {B};
        \node[gtu block, right=of B] (C) {C};
        \node[gtu block, right=of C] (D) {D};
        
        \draw[gtu arrow] (A) -- (B);
        \draw[gtu arrow] (B) -- (C);
        \draw[gtu arrow] (C) -- (D);
        \draw[gtu arrow] (D.south) -- ++(0,-0.5) -| (A.south);
    \end{tikzpicture}
    \captionof{figure}{Circular Linked List}
    \end{center}

    \begin{mnemonicbox}
        "Circular Lists Create Continuous Connections"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(c)}{7}{Explain merge sort with suitable example.}
\begin{solutionbox}
    \keyword{Merge Sort} is a divide-and-conquer algorithm that divides array into halves, sorts them separately, and merges back.

    \textbf{Algorithm Phases:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Merge Sort Phases}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Phase} & \textbf{Action} & \textbf{Description} \\
            \midrule
            \textbf{Divide} & Split array & Divide into two halves \\
            \textbf{Conquer} & Sort subarrays & Recursively sort halves \\
            \textbf{Combine} & Merge results & Merge sorted halves \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Example: [38, 27, 43, 3, 9, 82, 10]}
    
    \begin{center}
    \begin{tikzpicture}[level/.style={sibling distance=60mm/#1, level distance=1.2cm}, scale=0.8, transform shape]
        \node[gtu block] {38, 27, 43, 3, 9, 82, 10}
            child {node[gtu block] {38, 27, 43, 3}
                child {node[gtu block] {38, 27}
                    child {node[gtu block] {38}}
                    child {node[gtu block] {27}}
                }
                child {node[gtu block] {43, 3}
                    child {node[gtu block] {43}}
                    child {node[gtu block] {3}}
                }
            }
            child {node[gtu block] {9, 82, 10}
                child {node[gtu block] {9, 82}
                    child {node[gtu block] {9}}
                    child {node[gtu block] {82}}
                }
                child {node[gtu block] {10}}
            };
    \end{tikzpicture}
    \captionof{figure}{Merge Sort Division}
    \end{center}
    
    \textbf{Merged Result:}
    \noindent\code{[3, 9, 10, 27, 38, 43, 82]}

    \textbf{Time Complexity: O(n log n)}

    \begin{mnemonicbox}
        "Merge Sort Methodically Merges Segments"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(a) OR}{3}{Write an algorithm for selection sort.}
\begin{solutionbox}
    \textbf{Selection Sort Algorithm:}
    \begin{lstlisting}[language=Python, caption=Selection Sort]
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
    \end{lstlisting}

    \textbf{Time Complexity: O(n\textsuperscript{2})}

    \begin{mnemonicbox}
        "Selection Sort Selects Smallest Successfully"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(b) OR}{4}{Explain double linked list with its advantages.}
\begin{solutionbox}
    \textbf{Double Linked List:}
    A linked list where each node contains data and two pointers - next and previous.

    \textbf{Advantages:}
    \begin{itemize}
        \item \textbf{Bidirectional Traversal}: Forward and backward movement
        \item \textbf{Easy Deletion}: Can delete without knowing previous node
        \item \textbf{Efficient Insertion}: Insert at any position easily
    \end{itemize}

    \begin{center}
    \begin{tikzpicture}[node distance=2.5cm, every node/.style={gtu block}]
        \node (A) {A};
        \node[right of=A] (B) {B};
        \node[right of=B] (C) {C};
        
        \path[->] 
            (A) edge [bend left] node {} (B)
            (B) edge [bend left] node {} (C)
            (C) edge [bend left] node {} (B)
            (B) edge [bend left] node {} (A);
    \end{tikzpicture}
    \captionof{figure}{Double Linked List}
    \end{center}

    \begin{mnemonicbox}
        "Double Links provide Dual Direction"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(c) OR}{7}{Explain insertion sort. Give trace of following numbers using insertion sort : 25, 15,30,9,99,20,26}
\begin{solutionbox}
    \textbf{Insertion Sort:}
    Builds sorted array one element at a time by inserting each element into its correct position.

    \textbf{Trace Evaluation:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Insertion Sort Trace}
        \centering
        \begin{tabulary}{\linewidth}{C C L L}
            \toprule
            \textbf{Pass} & \textbf{Current} & \textbf{Array State} & \textbf{Action} \\
            \midrule
            Initial & - & [25, 15, 30, 9, 99, 20, 26] & Start \\
            1 & 15 & [15, 25, 30, 9, 99, 20, 26] & Insert 15 \\
            2 & 30 & [15, 25, 30, 9, 99, 20, 26] & No change \\
            3 & 9 & [9, 15, 25, 30, 99, 20, 26] & Insert 9 \\
            4 & 99 & [9, 15, 25, 30, 99, 20, 26] & No change \\
            5 & 20 & [9, 15, 20, 25, 30, 99, 26] & Insert 20 \\
            6 & 26 & [9, 15, 20, 25, 26, 30, 99] & Insert 26 \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Final Sorted Array:} \code{[9, 15, 20, 25, 26, 30, 99]}

    \begin{mnemonicbox}
        "Insertion Inserts Into Increasing Order"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(a)}{3}{Explain application of binary tree.}
\begin{solutionbox}
    \textbf{Binary Tree Applications:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Applications}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Application} & \textbf{Use Case} & \textbf{Benefit} \\
            \midrule
            \textbf{Expression Trees} & Mathematical expressions & Easy evaluation \\
            \textbf{Binary Search Trees} & Searching/Sorting & O(log n) operations \\
            \textbf{Heap Trees} & Priority queues & Efficient min/max \\
            \textbf{File Systems} & Directory structure & Hierarchical organization \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{mnemonicbox}
        "Binary Trees Branch into Many Applications"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(b)}{4}{Write an algorithm for binary search using list.}
\begin{solutionbox}
    \textbf{Binary Search Algorithm:}
    \begin{lstlisting}[language=Python, caption=Binary Search]
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
    \end{lstlisting}

    \textbf{Prerequisite:} Array must be sorted.
    \textbf{Time Complexity: O(log n)}

    \begin{mnemonicbox}
        "Binary Search Bisects to Find Faster"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(c)}{7}{Define Tree. Enlist Types of Tree. Write an algorithm to insert node in binary search tree using python.}
\begin{solutionbox}
    \textbf{Tree:}
    A hierarchical data structure consisting of nodes connected by edges, with one root node and no cycles.

    \textbf{Types of Trees:}
    \begin{itemize}
        \item \textbf{Binary Tree}: Max 2 children per node.
        \item \textbf{Binary Search Tree}: Ordered binary tree (Left < Root < Right).
        \item \textbf{Complete Binary Tree}: All levels filled except last.
        \item \textbf{Full Binary Tree}: All nodes have 0 or 2 children.
        \item \textbf{AVL Tree}: Self-balancing BST.
    \end{itemize}

    \textbf{BST Insertion Algorithm:}
    \begin{lstlisting}[language=Python, caption=BST Insertion]
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def insert_bst(root, data):
    if root is None:
        return TreeNode(data)
    
    if data < root.data:
        root.left = insert_bst(root.left, data)
    elif data > root.data:
        root.right = insert_bst(root.right, data)
    
    return root
    \end{lstlisting}

    \begin{mnemonicbox}
        "Trees Grow with Structured Organization"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(a) OR}{3}{Write an algorithm for in-order traversal of tree.}
\begin{solutionbox}
    \textbf{In-order Traversal Algorithm:}
    \begin{lstlisting}[language=Python, caption=In-order Traversal]
def inorder_traversal(root):
    if root is not None:
        inorder_traversal(root.left)    # Left
        print(root.data)                # Root
        inorder_traversal(root.right)   # Right
    \end{lstlisting}

    \textbf{Traversal Order:} Left $\rightarrow$ Root $\rightarrow$ Right

    \begin{center}
    \begin{tikzpicture}[level/.style={sibling distance=30mm/#1}]
        \node[gtu block] {50}
            child {node[gtu block] {30}
                child {node[gtu block] {20}}
                child {node[gtu block] {40}}
            }
            child {node[gtu block] {70}
                child {node[gtu block] {60}}
                child {node[gtu block] {80}}
            };
    \end{tikzpicture}
    \captionof{figure}{Example Tree}
    \end{center}
    
    \textbf{In-order:} 20, 30, 40, 50, 60, 70, 80

    \begin{mnemonicbox}
        "In-order: Left, Root, Right"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(b) OR}{4}{Define search? Write an algorithm for Linear search using list.}
\begin{solutionbox}
    \textbf{Search:}
    The process of finding a specific element or checking if an element exists in a data structure.

    \textbf{Linear Search Algorithm:}
    \begin{lstlisting}[language=Python, caption=Linear Search]
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Return index if found
    return -1  # Return -1 if not found
    \end{lstlisting}

    \textbf{Time Complexity: O(n)}

    \begin{mnemonicbox}
        "Linear Search Looks through Lists Linearly"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(c) OR}{7}{Define: a) Path b). Leaf Node. Construct a binary search tree for following data items. 60, 40, 37,31,59,21,65,30}
\begin{solutionbox}
    \textbf{Definitions:}
    \begin{itemize}
        \item \textbf{Path}: Sequence of nodes from one node to another connected by edges.
        \item \textbf{Leaf Node}: Node with no children (no left or right child).
    \end{itemize}

    \textbf{BST Construction for: 60, 40, 37, 31, 59, 21, 65, 30}

    \begin{center}
    \begin{tikzpicture}[level distance=1.2cm, sibling distance=2.5cm, every node/.style={gtu block}]
        \node {60}
            child {node {40}
                child {node {37}
                    child {node {31}
                        child {node {21}
                            child[missing]
                            child {node {30}}
                        }
                        child[missing]
                    }
                    child[missing]
                }
                child {node {59}}
            }
            child {node {65}};
    \end{tikzpicture}
    \captionof{figure}{Final Binary Search Tree}
    \end{center}

    \textbf{Leaf Nodes:} 30, 59, 65

    \begin{mnemonicbox}
        "BST Building follows Binary Search Tree rules"
    \end{mnemonicbox}
\end{solutionbox}

\end{document}
