\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4331601 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Explain set data structure in python?}

\begin{solutionbox}

A \textbf{set} is an unordered collection of unique elements in Python.
Sets are mutable but contain only immutable elements.

\textbf{Key Properties:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Property & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Unique Elements} & No duplicate values allowed \\
\textbf{Unordered} & No indexing or slicing \\
\textbf{Mutable} & Can add/remove elements \\
\textbf{Iterable} & Can loop through elements \\
\end{longtable}
}

\textbf{Basic Operations:}

\begin{verbatim}
\# Create set
my\_set = \{1, 2, 3, 4\}
\# Add element
my\_set.add(5)
\# Remove element
my\_set.remove(2)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Sets are Unique Unordered Collections''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Define Tuple in python? Explain operations of tuple data
structure in python.}

\begin{solutionbox}

A \textbf{tuple} is an ordered collection of items that is immutable
(cannot be changed after creation).

\textbf{Tuple Definition:}

\begin{itemize}
\tightlist
\item
  \textbf{Ordered}: Elements have defined order
\item
  \textbf{Immutable}: Cannot modify after creation
\item
  \textbf{Allow duplicates}: Same values can appear multiple times
\item
  \textbf{Indexed}: Access elements using index
\end{itemize}

\textbf{Tuple Operations:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Example & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Creation} & \texttt{t\ =\ (1,\ 2,\ 3)} & Create tuple \\
\textbf{Indexing} & \texttt{t[0]} & Access first element \\
\textbf{Slicing} & \texttt{t[1:3]} & Get subset \\
\textbf{Length} & \texttt{len(t)} & Count elements \\
\textbf{Concatenation} & \texttt{t1\ +\ t2} & Join tuples \\
\end{longtable}
}

\begin{verbatim}
\# Example operations
tup = (10, 20, 30, 40)
print(tup[1])      \# Output: 20
print(tup[1:3])    \# Output: (20, 30)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Tuples are Immutable Ordered Collections''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Explain Types of constructors in python? Write a python program
to multiplication of two numbers using static method.}

\begin{solutionbox}

\textbf{Types of Constructors:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4595}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3514}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1892}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Constructor Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Usage
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default Constructor} & No parameters &
\texttt{\_\_init\_\_(self)} \\
\textbf{Parameterized Constructor} & Takes parameters &
\texttt{\_\_init\_\_(self,\ params)} \\
\textbf{Non-parameterized Constructor} & Only self parameter & Basic
initialization \\
\end{longtable}
}

\textbf{Static Method Program:}

\begin{verbatim}
class Calculator:
    def \_\_init\_\_(self):
        pass
    
    @staticmethod
    def multiply(num1, num2):
        return num1 * num2

\# Usage
result = Calculator.multiply(5, 3)
print(f"Multiplication: \{result\}")  \# Output: 15
\end{verbatim}

\textbf{Key Points:}

\begin{itemize}
\tightlist
\item
  \textbf{Static methods}: Don't need object instance
\item
  \textbf{@staticmethod decorator}: Defines static method
\item
  \textbf{No self parameter}: Independent of class instance
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Static methods Stand Separate from Self''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Define Data Encapsulation. List out different types of methods
in python. Write a python program to multilevel inheritances.}

\begin{solutionbox}

\textbf{Data Encapsulation:} Data encapsulation is the concept of
bundling data and methods within a class and restricting direct access
to some components.

\textbf{Types of Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method Type & Access Level & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Public} & Accessible everywhere & \texttt{method()} \\
\textbf{Protected} & Class and subclass & \texttt{\_method()} \\
\textbf{Private} & Only within class & \texttt{\_\_method()} \\
\textbf{Static} & Class level & \texttt{@staticmethod} \\
\textbf{Class} & Class and subclasses & \texttt{@classmethod} \\
\end{longtable}
}

\textbf{Multilevel Inheritance Program:}

\begin{verbatim}
class Animal:
    def \_\_init\_\_(self, name):
        self.name = name
    
    def speak(self):
        print(f"\{self.name\} makes sound")

class Mammal(Animal):
    def \_\_init\_\_(self, name, warm\_blooded):
        super().\_\_init\_\_(name)
        self.warm\_blooded = warm\_blooded

class Dog(Mammal):
    def \_\_init\_\_(self, name, breed):
        super().\_\_init\_\_(name, True)
        self.breed = breed
    
    def bark(self):
        print(f"\{self.name\} barks")

\# Usage
dog = Dog("Buddy", "Golden Retriever")
dog.speak()  \# From Animal class
dog.bark()   \# From Dog class
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Encapsulation Hides Internal Details''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Differentiate between simple queue and circular queue.}

\begin{solutionbox}

\textbf{Queue Comparison:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3590}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4103}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Simple Queue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Circular Queue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Structure} & Linear arrangement & Circular arrangement \\
\textbf{Memory Usage} & Wasteful (empty spaces) & Efficient (reuses
space) \\
\textbf{Rear Pointer} & Moves linearly & Wraps around \\
\textbf{Front Pointer} & Moves linearly & Wraps around \\
\textbf{Space Utilization} & Poor & Excellent \\
\end{longtable}
}

\textbf{Key Differences:}

\begin{itemize}
\tightlist
\item
  \textbf{Simple Queue}: Front and rear move in one direction only
\item
  \textbf{Circular Queue}: Rear connects back to front position
\item
  \textbf{Efficiency}: Circular queue eliminates memory waste
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Queues Complete the Circle''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Explain polymorphism in python with example.}

\begin{solutionbox}

\textbf{Polymorphism} means ``many forms'' - same method name behaves
differently in different classes.

\textbf{Types of Polymorphism:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Implementation
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Method Overriding} & Child class redefines parent method &
Inheritance \\
\textbf{Duck Typing} & Same method in different classes & Interface
similarity \\
\textbf{Operator Overloading} & Same operator different behavior & Magic
methods \\
\end{longtable}
}

\textbf{Example:}

\begin{verbatim}
class Animal:
    def make\_sound(self):
        pass

class Dog(Animal):
    def make\_sound(self):
        return "Woof!"

class Cat(Animal):
    def make\_sound(self):
        return "Meow!"

\# Polymorphic behavior
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.make\_sound())
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Polymorphism Provides Multiple Personalities''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(c) [7 marks]}\label{q2c}

**Define a).Infix b).postfix. Given equation to conversion from infix to
postfix using stack. A+(B*C/D)**

\begin{solutionbox}

\textbf{Definitions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Expression Type & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Infix} & Operator between operands & \texttt{A\ +\ B} \\
\textbf{Postfix} & Operator after operands & \texttt{A\ B\ +} \\
\end{longtable}
}

\textbf{Conversion Algorithm:}

\begin{enumerate}
\tightlist
\item
  Scan infix expression left to right
\item
  If operand, add to output
\item
  If operator, compare precedence with stack top
\item
  Higher precedence \rightarrow push to stack
\item
  Lower/equal precedence \rightarrow pop and add to output
\end{enumerate}

**Step-by-step Conversion: A+(B*C/D)**

\begin{verbatim}
Input: A+(B*C/D)

Step | Symbol | Stack | Output
{-{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}{-}}
1    | A      | []    | A
2    | +      | [+]   | A
3    | (      | [+,(] | A
4    | B      | [+,(] | AB
5    | *      | [+,(,*] | AB
6    | C      | [+,(,*] | ABC
7    | /      | [+,(,/] | ABC*
8    | D      | [+,(,/] | ABC*D
9    | )      | [+]   | ABC*D/
10   | End    | []    | ABC*D/+
\end{verbatim}

**Final Answer: ABC*D/+**

\end{solutionbox}
\begin{mnemonicbox}
``Stack Stores Operators Strategically''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{Explain disadvantages of Queue.}

\begin{solutionbox}

\textbf{Queue Disadvantages:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Disadvantage & Description & Impact \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Memory Waste} & Empty spaces not reused & Poor space
utilization \\
\textbf{Fixed Size} & Limited capacity & Overflow issues \\
\textbf{No Random Access} & Only front/rear access & Limited
flexibility \\
\end{longtable}
}

\textbf{Key Issues:}

\begin{itemize}
\tightlist
\item
  \textbf{Linear Queue}: Front spaces become unusable
\item
  \textbf{Insertion/Deletion}: Only at specific ends
\item
  \textbf{Search Operations}: Not efficient for searching
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Queues Quietly Queue with Quirks''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{Define Abstract class in python? Explain the declaration of
abstract method in python?}

\begin{solutionbox}

\textbf{Abstract Class:} A class that cannot be instantiated and
contains one or more abstract methods that must be implemented by
subclasses.

\textbf{Abstract Method Declaration:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3929}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Component
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ABC Module} & Provides abstract base class &
\texttt{from\ abc\ import\ ABC} \\
\textbf{@abstractmethod} & Decorator for abstract methods &
\texttt{@abstractmethod} \\
\textbf{Implementation} & Must override in subclass & Required \\
\end{longtable}
}

\textbf{Example:}

\begin{verbatim}
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def \_\_init\_\_(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width
    
    def perimeter(self):
        return 2 * (self.length + self.width)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Abstract classes Are Blueprints Only''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Write an algorithm for Infix to postfix expression. Evaluate
Postfix expression as: 5 6 2 + * 12 4 / -}

\begin{solutionbox}

\textbf{Infix to Postfix Algorithm:}

\begin{enumerate}
\tightlist
\item
  Initialize empty stack and output string
\item
  Scan infix expression from left to right
\item
  If operand \rightarrow add to output
\item
  If `(' \rightarrow push to stack
\item
  If `)' \rightarrow pop until `('
\item
  If operator \rightarrow pop higher/equal precedence operators
\item
  Push current operator to stack
\item
  Pop remaining operators
\end{enumerate}

\textbf{Postfix Evaluation: 5 6 2 + * 12 4 / -}

\begin{verbatim}
Expression: 5 6 2 + * 12 4 / {-}

Step | Token | Stack | Operation
{-{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
1    | 5     | [5]   | Push operand
2    | 6     | [5,6] | Push operand  
3    | 2     | [5,6,2] | Push operand
4    | +     | [5,8] | Pop 2,6  6+2=8
5    | *     | [40]  | Pop 8,5  5*8=40
6    | 12    | [40,12] | Push operand
7    | 4     | [40,12,4] | Push operand
8    | /     | [40,3] | Pop 4,12  12/4=3
9    | {-     | [37]  | Pop 3,40  40{-}3=37}
\end{verbatim}

\textbf{Final Result: 37}

\end{solutionbox}
\begin{mnemonicbox}
``Postfix Processing Pops Pairs Precisely''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Write an algorithm to traverse node in single linked list.}

\begin{solutionbox}

\textbf{Traversal Algorithm:}

\begin{verbatim}
def traverse\_linked\_list(head):
    current = head
    while current is not None:
        print(current.data)
        current = current.next
\end{verbatim}

\textbf{Algorithm Steps:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Action & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Start from head node & Initialize traversal \\
\textbf{2} & Check if current \neq NULL & Continue condition \\
\textbf{3} & Process current node & Perform operation \\
\textbf{4} & Move to next node & Advance pointer \\
\textbf{5} & Repeat until end & Complete traversal \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Traverse Through Till The Tail''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Write an algorithm for Dequeue operation in queue using List.}

\begin{solutionbox}

\textbf{Dequeue Algorithm:}

\begin{verbatim}
def dequeue(queue):
    if len(queue) == 0:
        print("Queue is empty")
        return None
    else:
        element = queue.pop(0)
        return element
\end{verbatim}

\textbf{Algorithm Steps:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Condition & Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Check empty & If queue is empty \\
\textbf{2} & Handle underflow & Display error message \\
\textbf{3} & Remove element & Delete front element \\
\textbf{4} & Return element & Return removed value \\
\textbf{5} & Update structure & Adjust queue pointers \\
\end{longtable}
}

\textbf{Time Complexity: O(n)} due to list shifting

\end{solutionbox}
\begin{mnemonicbox}
``Dequeue Deletes from Front Door''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Define double linked list. Enlist major operation of Linked
List. Write an algorithm to insert a node at beginning in singly linked
list.}

\begin{solutionbox}

\textbf{Double Linked List:} A linear data structure where each node
contains data and two pointers - one pointing to the next node and
another to the previous node.

\textbf{Major Linked List Operations:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Description & Time Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insertion} & Add new node & O(1) at beginning \\
\textbf{Deletion} & Remove node & O(1) if node known \\
\textbf{Traversal} & Visit all nodes & O(n) \\
\textbf{Search} & Find specific node & O(n) \\
\textbf{Update} & Modify node data & O(1) if node known \\
\end{longtable}
}

\textbf{Insert at Beginning Algorithm:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

def insert\_at\_beginning(head, data):
    new\_node = Node(data)
    new\_node.next = head
    head = new\_node
    return head
\end{verbatim}

\textbf{Algorithm Steps:}

\begin{enumerate}
\tightlist
\item
  Create new node with given data
\item
  Set new node's next to current head
\item
  Update head to point to new node
\item
  Return new head
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Insert at Beginning Builds Better Lists''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

\textbf{Explain the applications of single linked list.}

\begin{solutionbox}

\textbf{Single Linked List Applications:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3824}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2941}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3235}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use Case
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Advantage
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Memory} & Variable size data & Memory efficient \\
\textbf{Stack Implementation} & LIFO operations & Easy push/pop \\
\textbf{Queue Implementation} & FIFO operations & Dynamic sizing \\
\textbf{Music Playlist} & Sequential playback & Easy navigation \\
\textbf{Browser History} & Page navigation & Forward traversal \\
\textbf{Polynomial Representation} & Mathematical operations &
Coefficient storage \\
\end{longtable}
}

\textbf{Key Benefits:}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic Size}: Grows/shrinks during runtime
\item
  \textbf{Memory Efficiency}: Allocates as needed
\item
  \textbf{Insertion/Deletion}: Efficient at any position
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists Link Many Applications''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Write an algorithm for PUSH operation of stack using List.}

\begin{solutionbox}

\textbf{PUSH Algorithm:}

\begin{verbatim}
def push(stack, element):
    stack.append(element)
    print(f"Pushed \{element\} to stack")
\end{verbatim}

\textbf{Algorithm Steps:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Action & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Check capacity & Verify stack not full \\
\textbf{2} & Add element & Append to end of list \\
\textbf{3} & Update top & Top points to last element \\
\textbf{4} & Confirm operation & Display success message \\
\end{longtable}
}

\textbf{Detailed Algorithm:}

\begin{enumerate}
\tightlist
\item
  Accept stack and element to push
\item
  Check if stack has capacity (for fixed size)
\item
  Add element to end of list using append()
\item
  List automatically handles memory allocation
\item
  Return success status
\end{enumerate}

\textbf{Time Complexity: O(1)} - Constant time operation

\end{solutionbox}
\begin{mnemonicbox}
``PUSH Puts on Stack Summit''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{Explain advantages of a linked list. Write an algorithm to
delete node at last from single linked list.}

\begin{solutionbox}

\textbf{Linked List Advantages:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Advantage & Description & Benefit \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Size} & Size changes at runtime & Memory flexible \\
\textbf{Memory Efficient} & Allocates as needed & No waste \\
\textbf{Easy Insertion} & Add anywhere efficiently & O(1) operation \\
\textbf{Easy Deletion} & Remove efficiently & O(1) operation \\
\textbf{No Memory Shift} & Elements don't move & Fast operations \\
\end{longtable}
}

\textbf{Delete Last Node Algorithm:}

\begin{verbatim}
def delete\_last\_node(head):
    \# Empty list
    if head is None:
        return None
    
    \# Single node
    if head.next is None:
        return None
    
    \# Multiple nodes
    current = head
    while current.next.next is not None:
        current = current.next
    
    current.next = None
    return head
\end{verbatim}

\textbf{Algorithm Steps:}

\begin{enumerate}
\tightlist
\item
  Handle empty list case
\item
  Handle single node case
\item
  Traverse to second last node
\item
  Set second last node's next to NULL
\item
  Return updated head
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists Lead to Logical Advantages''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Write an algorithm of Bubble sort.}

\begin{solutionbox}

\textbf{Bubble Sort Algorithm:}

\begin{verbatim}
def bubble\_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n{-}i{-}1):
            if arr[j] {} arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
\end{verbatim}

\textbf{Algorithm Steps:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Action & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Outer loop i=0 to n-1 & Number of passes \\
\textbf{2} & Inner loop j=0 to n-i-2 & Compare adjacent elements \\
\textbf{3} & Compare arr[j] and arr[j+1] & Check ordering \\
\textbf{4} & Swap if out of order & Correct positioning \\
\textbf{5} & Repeat until sorted & Complete sorting \\
\end{longtable}
}

\textbf{Time Complexity: O(n^{2})}

\end{solutionbox}
\begin{mnemonicbox}
``Bubbles Rise to Surface Slowly''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Explain circular linked list with its advantages.}

\begin{solutionbox}

\textbf{Circular Linked List:} A linked list where the last node points
to the first node, forming a circular structure.

\textbf{Characteristics:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2903}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4194}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2903}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Benefit
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Circular Structure} & Last node \rightarrow First node & Continuous
traversal \\
\textbf{No NULL Pointers} & No end marker & Always connected \\
\textbf{Efficient Traversal} & Can start from any node & Flexible
access \\
\end{longtable}
}

\textbf{Advantages:}

\begin{itemize}
\tightlist
\item
  \textbf{Memory Efficient}: No NULL pointers
\item
  \textbf{Circular Traversal}: Can loop continuously
\item
  \textbf{Queue Implementation}: Efficient enqueue/dequeue
\item
  \textbf{Round Robin Scheduling}: CPU time sharing
\item
  \textbf{Music Player}: Continuous playlist looping
\end{itemize}

\begin{verbatim}
Circular Linked List Structure:

[A]  [B]  [C]  [D]
 ↑                 ↓
 
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Lists Create Continuous Connections''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Explain merge sort with suitable example.}

\begin{solutionbox}

\textbf{Merge Sort:} A divide-and-conquer algorithm that divides array
into halves, sorts them separately, and merges back.

\textbf{Algorithm Phases:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Phase & Action & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Divide} & Split array & Divide into two halves \\
\textbf{Conquer} & Sort subarrays & Recursively sort halves \\
\textbf{Combine} & Merge results & Merge sorted halves \\
\end{longtable}
}

\textbf{Example: [38, 27, 43, 3, 9, 82, 10]}

\begin{verbatim}
Merge Sort Process:

Level 0:  [38, 27, 43, 3, 9, 82, 10]
             ↓
Level 1:  [38, 27, 43, 3] | [9, 82, 10]
             ↓                  ↓
Level 2:  [38, 27] [43, 3] | [9, 82] [10]
             ↓       ↓         ↓      ↓
Level 3:  [38][27] [43][3] | [9][82] [10]
             ↓       ↓         ↓      ↓
Merge:    [27, 38] [3, 43] | [9, 82] [10]
             ↓                  ↓
          [3, 27, 38, 43] | [9, 10, 82]
             ↓
          [3, 9, 10, 27, 38, 43, 82]
\end{verbatim}

\textbf{Time Complexity: O(n log n)} \textbf{Space Complexity: O(n)}

\end{solutionbox}
\begin{mnemonicbox}
``Merge Sort Methodically Merges Segments''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{Write an algorithm for selection sort.}

\begin{solutionbox}

\textbf{Selection Sort Algorithm:}

\begin{verbatim}
def selection\_sort(arr):
    n = len(arr)
    for i in range(n):
        min\_idx = i
        for j in range(i+1, n):
            if arr[j] {} arr[min\_idx]:
                min\_idx = j
        arr[i], arr[min\_idx] = arr[min\_idx], arr[i]
    return arr
\end{verbatim}

\textbf{Algorithm Steps:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Action & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Find minimum element & Locate smallest \\
\textbf{2} & Swap with first position & Place in sorted position \\
\textbf{3} & Move to next position & Advance boundary \\
\textbf{4} & Repeat for remaining & Continue sorting \\
\textbf{5} & Complete when done & Finish algorithm \\
\end{longtable}
}

\textbf{Time Complexity: O(n^{2})}

\end{solutionbox}
\begin{mnemonicbox}
``Selection Sort Selects Smallest Successfully''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Explain double linked list with its advantages.}

\begin{solutionbox}

\textbf{Double Linked List:} A linked list where each node contains data
and two pointers - next and previous.

\textbf{Structure:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Component & Purpose & Direction \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Data} & Store information & - \\
\textbf{Next Pointer} & Points to next node & Forward \\
\textbf{Previous Pointer} & Points to previous node & Backward \\
\end{longtable}
}

\textbf{Advantages:}

\begin{itemize}
\tightlist
\item
  \textbf{Bidirectional Traversal}: Forward and backward movement
\item
  \textbf{Easy Deletion}: Can delete without knowing previous node
\item
  \textbf{Efficient Insertion}: Insert at any position easily
\item
  \textbf{Better Navigation}: Can move in both directions
\end{itemize}

\begin{verbatim}
Double Linked List Structure:

NULL  [prev|data|next] ⇄ [prev|data|next] ⇄ [prev|data|next]  NULL
\end{verbatim}

\textbf{Applications:}

\begin{itemize}
\tightlist
\item
  \textbf{Browser navigation} (back/forward buttons)
\item
  \textbf{Music player} (previous/next song)
\item
  \textbf{Undo/Redo operations}
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Double Links provide Dual Direction''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Explain insertion sort. Give trace of following numbers using
insertion sort : 25, 15,30,9,99,20,26}

\begin{solutionbox}

\textbf{Insertion Sort:} Builds sorted array one element at a time by
inserting each element into its correct position.

\textbf{Algorithm Concept:}

\begin{itemize}
\tightlist
\item
  \textbf{Sorted Portion}: Left side of current element
\item
  \textbf{Unsorted Portion}: Right side of current element
\item
  \textbf{Insert Strategy}: Place current element in correct position in
  sorted portion
\end{itemize}

\textbf{Trace of [25, 15, 30, 9, 99, 20, 26]:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1800}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2600}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2600}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1800}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Pass
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Current
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Array State
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Comparisons
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Action
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Initial} & - & [25, 15, 30, 9, 99, 20, 26] & - & Start \\
\textbf{1} & 15 & [15, 25, 30, 9, 99, 20, 26] & 15 \textless{} 25 &
Insert 15 before 25 \\
\textbf{2} & 30 & [15, 25, 30, 9, 99, 20, 26] & 30 \textgreater{} 25
& Keep 30 in place \\
\textbf{3} & 9 & [9, 15, 25, 30, 99, 20, 26] & 9 \textless{} all &
Insert at beginning \\
\textbf{4} & 99 & [9, 15, 25, 30, 99, 20, 26] & 99 \textgreater{} 30
& Keep 99 in place \\
\textbf{5} & 20 & [9, 15, 20, 25, 30, 99, 26] & Insert between 15,25
& Shift and insert \\
\textbf{6} & 26 & [9, 15, 20, 25, 26, 30, 99] & Insert between 25,30
& Final position \\
\end{longtable}
}

\textbf{Final Sorted Array: [9, 15, 20, 25, 26, 30, 99]}

\textbf{Time Complexity: O(n^{2})} worst case, \textbf{O(n)} best case

\end{solutionbox}
\begin{mnemonicbox}
``Insertion Inserts Into Increasing Order''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Explain application of binary tree.}

\begin{solutionbox}

\textbf{Binary Tree Applications:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Application & Use Case & Benefit \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Expression Trees} & Mathematical expressions & Easy
evaluation \\
\textbf{Binary Search Trees} & Searching/Sorting & O(log n)
operations \\
\textbf{Heap Trees} & Priority queues & Efficient min/max \\
\textbf{File Systems} & Directory structure & Hierarchical
organization \\
\textbf{Decision Trees} & AI/ML algorithms & Classification \\
\textbf{Huffman Coding} & Data compression & Optimal encoding \\
\end{longtable}
}

\textbf{Key Benefits:}

\begin{itemize}
\tightlist
\item
  \textbf{Hierarchical Structure}: Natural tree organization
\item
  \textbf{Efficient Operations}: Search, insert, delete
\item
  \textbf{Recursive Processing}: Easy to implement
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Trees Branch into Many Applications''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Write an algorithm for binary search using list.}

\begin{solutionbox}

\textbf{Binary Search Algorithm:}

\begin{verbatim}
def binary\_search(arr, target):
    left, right = 0, len(arr) {-} 1
    
    while left {=} right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] {} target:
            left = mid + 1
        else:
            right = mid {-} 1
    
    return {-}1  \# Element not found
\end{verbatim}

\textbf{Algorithm Steps:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Action & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Set left=0, right=n-1 & Initialize boundaries \\
\textbf{2} & Calculate mid & Find middle element \\
\textbf{3} & Compare target with mid & Determine direction \\
\textbf{4} & Update boundaries & Narrow search space \\
\textbf{5} & Repeat until found & Continue searching \\
\end{longtable}
}

\textbf{Prerequisite:} Array must be sorted \textbf{Time Complexity:
O(log n)}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Search Bisects to Find Faster''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Define Tree. Enlist Types of Tree. Write an algorithm to insert
node in binary search tree using python.}

\begin{solutionbox}

\textbf{Tree Definition:} A hierarchical data structure consisting of
nodes connected by edges, with one root node and no cycles.

\textbf{Types of Trees:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2619}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3095}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4286}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Tree Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Special Property
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Binary Tree} & Max 2 children per node & Left and right child \\
\textbf{Binary Search Tree} & Ordered binary tree & Left \textless{}
Root \textless{} Right \\
\textbf{Complete Binary Tree} & All levels filled except last &
Efficient heap \\
\textbf{Full Binary Tree} & All nodes have 0 or 2 children & No single
child \\
\textbf{AVL Tree} & Self-balancing BST & Height balanced \\
\textbf{Red-Black Tree} & Self-balancing BST & Color properties \\
\end{longtable}
}

\textbf{BST Insertion Algorithm:}

\begin{verbatim}
class TreeNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.left = None
        self.right = None

def insert\_bst(root, data):
    if root is None:
        return TreeNode(data)
    
    if data {} root.data:
        root.left = insert\_bst(root.left, data)
    elif data {} root.data:
        root.right = insert\_bst(root.right, data)
    
    return root
\end{verbatim}

\textbf{Algorithm Steps:}

\begin{enumerate}
\tightlist
\item
  If tree empty, create root node
\item
  If data \textless{} root.data, insert in left subtree
\item
  If data \textgreater{} root.data, insert in right subtree
\item
  If data = root.data, ignore (no duplicates)
\item
  Return updated root
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Trees Grow with Structured Organization''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{Write an algorithm for in-order traversal of tree.}

\begin{solutionbox}

\textbf{In-order Traversal Algorithm:}

\begin{verbatim}
def inorder\_traversal(root):
    if root is not None:
        inorder\_traversal(root.left)    \# Left
        print(root.data)                \# Root
        inorder\_traversal(root.right)   \# Right
\end{verbatim}

\textbf{Algorithm Steps:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Action & Order \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Traverse left subtree & Recursive call \\
\textbf{2} & Visit root node & Process data \\
\textbf{3} & Traverse right subtree & Recursive call \\
\end{longtable}
}

\textbf{Traversal Order: Left \rightarrow Root \rightarrow Right}

\textbf{Properties:}

\begin{itemize}
\tightlist
\item
  \textbf{BST Property}: In-order gives sorted sequence
\item
  \textbf{Time Complexity}: O(n)
\item
  \textbf{Space Complexity}: O(h) where h is height
\end{itemize}

\textbf{Example Tree Result:}

\begin{verbatim}
    Tree:     50
             /  {}
           30    70
          / {   / }
        20  40 60  80

In{-order: 20, 30, 40, 50, 60, 70, 80}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``In-order: Left, Root, Right''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Define search? Write an algorithm for Linear search using list.}

\begin{solutionbox}

\textbf{Search Definition:} The process of finding a specific element or
checking if an element exists in a data structure.

\textbf{Linear Search Algorithm:}

\begin{verbatim}
def linear\_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  \# Return index if found
    return {-}1  \# Return {-1 if not found}
\end{verbatim}

\textbf{Algorithm Characteristics:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Description & Value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Method} & Sequential checking & Element by element \\
\textbf{Time Complexity} & O(n) & Linear time \\
\textbf{Space Complexity} & O(1) & Constant space \\
\textbf{Data Requirement} & Any order & Unsorted data OK \\
\end{longtable}
}

\textbf{Algorithm Steps:}

\begin{enumerate}
\tightlist
\item
  Start from first element
\item
  Compare each element with target
\item
  If match found, return index
\item
  If end reached, return -1
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Linear Search Looks through Lists Linearly''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{Define: a) Path b). Leaf Node. Construct a binary search tree
for following data items. 60, 40, 37,31,59,21,65,30}

\begin{solutionbox}

\textbf{Definitions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3429}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Term
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Characteristics
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Path} & Sequence of nodes from one node to another & Connected
by edges \\
\textbf{Leaf Node} & Node with no children & No left or right child \\
\end{longtable}
}

\textbf{BST Construction for: 60, 40, 37, 31, 59, 21, 65, 30}

\textbf{Step-by-step Construction:}

\begin{verbatim}
Step 1: Insert 60 (Root)
        60

Step 2: Insert 40 (40 { 60, go left)}
        60
       /
      40

Step 3: Insert 37 (37 { 60, go left; 37  40, go left)}
        60
       /
      40
     /
    37

Step 4: Insert 31 (31 { 60, left; 31  40, left; 31  37, left)}
        60
       /
      40
     /
    37
   /
  31

Step 5: Insert 59 (59 { 60, left; 59  40, right)}
        60
       /
      40
     / {}
    37  59
   /
  31

Step 6: Insert 21 (21 { 60, left; 21  40, left; 21  37, left; 21  31, left)}
        60
       /
      40
     / {}
    37  59
   /
  31
 /
21

Step 7: Insert 65 (65 { 60, go right)}
        60
       / {}
      40  65
     / {}
    37  59
   /
  31
 /
21

Step 8: Insert 30 (30 { 60, left; 30  40, left; 30  37, left; 30  31, left; 30  21, right)}
        60
       / {}
      40  65
     / {}
    37  59
   /
  31
 / {}
21  30
\end{verbatim}

\textbf{Final BST Structure:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Level & Nodes & Type \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{0} & 60 & Root \\
\textbf{1} & 40, 65 & Internal \\
\textbf{2} & 37, 59 & Internal, Internal \\
\textbf{3} & 31 & Internal \\
\textbf{4} & 21 & Internal \\
\textbf{5} & 30 & Leaf \\
\end{longtable}
}

\textbf{Leaf Nodes:} 30, 59, 65

\end{solutionbox}
\begin{mnemonicbox}
``BST Building follows Binary Search Tree rules''

\end{mnemonicbox}

\end{document}
