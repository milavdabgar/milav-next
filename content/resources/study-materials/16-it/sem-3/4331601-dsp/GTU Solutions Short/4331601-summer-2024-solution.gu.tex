\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{ડેટા સ્ટ્રક્ચર વિથ પાયથન (4331601) - સમર 2024 સોલ્યુશન}
\date{June 06, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{Array અને list નો તફાવત જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Array vs List}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Array} & \textbf{List} \\
\hline
\textbf{નિશ્ચિત કદ} બનાવતી વખતે & \textbf{ગતિશીલ કદ} - વધી/ઘટી શકે \\
\hline
\textbf{સમાન પ્રકારનો} ડેટા & \textbf{મિશ્ર પ્રકારનો} ડેટા \\
\hline
\textbf{મેમરી કાર્યક્ષમ} - સતત ફાળવણી & \textbf{લવચીક} પણ વધારે મેમરી \\
\hline
\textbf{ઝડપી access} ગણતરી માટે & \textbf{બિલ્ટ-ઇન methods} operations માટે \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Arrays નિશ્ચિત મિત્રો, Lists લવચીક નેતાઓ
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Class અને object ના concept python program ની મદદથી સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Class} એ એક blueprint છે જે objects ના structure અને behavior વ્યાખ્યાયિત કરે છે. \keyword{Object} એ class નો instance છે.

\begin{lstlisting}[language=Python,caption={Class and Object Example}]
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def display(self):
        print(f"Name: {self.name}, Age: {self.age}")

# Objects બનાવવા
s1 = Student("રામ", 20)
s2 = Student("સીતા", 19)
s1.display()
\end{lstlisting}

\begin{itemize}
    \item \keyword{Class}: Template બનાવે છે
    \item \keyword{Object}: વાસ્તવિક instance બનાવે છે
    \item \keyword{Constructor}: Object initialize કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Class Blueprint બનાવે Object Instances
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Constructor ની વ્યાખ્યા આપો. વિવિધ પ્રકાર ના constructor python program સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Constructor} એ special method છે જે object creation time પર automatically call થાય છે. Python માં \code{\_\_init\_\_()} method constructor છે.

\begin{lstlisting}[language=Python,caption={Constructor Types}]
class Demo:
    # Default Constructor
    def __init__(self):
        self.value = 0
    
    # Parameterized Constructor
    def __init__(self, x, y=10):
        self.x = x
        self.y = y

# ઉપયોગ
d1 = Demo(5)      # x=5, y=10 (default)
d2 = Demo(3, 7)   # x=3, y=7
\end{lstlisting}

\textbf{Constructor ના પ્રકારો:}

\begin{center}
\captionof{table}{Types of Constructors}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉપયોગ} \\
\hline
\textbf{Default} & કોઈ parameters નહીં & Object initialization \\
\hline
\textbf{Parameterized} & Parameters સાથે & કસ્ટમ initialization \\
\hline
\textbf{Copy} & Object ની copy બનાવે & Object duplication \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Default Parameters Copy Objects
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Polymorphism ની વ્યાખ્યા આપો. Inheritance વડે Polymorphism નો python program લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Polymorphism} એ સમાન interface વાપરીને અલગ અલગ objects પર અલગ અલગ operations કરવાની ક્ષમતા છે.

\begin{lstlisting}[language=Python,caption={Polymorphism Example}]
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Woof!"

class Cat(Animal):
    def sound(self):
        return "Meow!"

# Polymorphic વર્તન
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.sound())
\end{lstlisting}

\begin{itemize}
    \item \keyword{Method Overriding}: Child class માં સમાન method name
    \item \keyword{Dynamic Binding}: Runtime પર method selection
    \item \keyword{Code Reusability}: સમાન interface, અલગ implementation
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
ઘણા Objects, એક Interface
\end{mnemonicbox}

\questionmarks{2(a)}{3}{Python અંતર્ગત data structure List, Tuple અને Dictionary સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{List vs Tuple vs Dictionary}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Data Structure} & \textbf{ગુણધર્મો} & \textbf{ઉદાહરણ} \\
\hline
\textbf{List} & Mutable, ordered, duplicates allowed & \code{[1, 2, 3, 2]} \\
\hline
\textbf{Tuple} & Immutable, ordered, duplicates allowed & \code{(1, 2, 3, 2)} \\
\hline
\textbf{Dictionary} & Mutable, key-value pairs, unique keys & \code{\{'a': 1, 'b': 2\}} \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Lists બદલાય, Tuples રહે, Dictionaries નકશો
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Stack ની એપ્લિકેશન જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Stack Applications:}

\begin{itemize}
    \item \keyword{Function Calls}: Call stack management
    \item \keyword{Expression Evaluation}: Infix to postfix conversion
    \item \keyword{Undo Operations}: Text editors, browsers
    \item \keyword{Parentheses Matching}: Syntax checking
\end{itemize}

\begin{center}
\begin{tikzpicture}
    \node[gtu block, minimum width=2cm] (top) at (0,2) {3};
    \node[right] at (top.east) {$\leftarrow$ Top};
    \node[gtu block, minimum width=2cm] (mid) at (0,1) {2};
    \node[gtu block, minimum width=2cm] (bot) at (0,0) {1};
    
    \draw[thick] (-1.2,-0.5) -- (1.2,-0.5); % Base
    \draw[thick] (-1.2,-0.5) -- (-1.2,2.5); % Left wall
    \draw[thick] (1.2,-0.5) -- (1.2,2.5);   % Right wall
\end{tikzpicture}
\captionof{figure}{Stack Structure}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Functions Evaluate કરે Undo Parentheses
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Stack ની વ્યાખ્યા આપો. PUSH અને POP operation ઉદાહરણ સાથે સમજાવો. Stack ના PUSH અને POP operation ના algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Stack} એ LIFO (Last In First Out) સિદ્ધાંત અનુસરતું linear data structure છે.

\textbf{PUSH Algorithm:}

\begin{enumerate}
    \item Check કરો કે stack ભરેલો છે કે નહીં
    \item જો ભરેલો હોય, print "Stack Overflow"
    \item અન્યથા, top increment કરો
    \item Top position પર element add કરો
\end{enumerate}

\textbf{POP Algorithm:}

\begin{enumerate}
    \item Check કરો કે stack ખાલી છે કે નહીં
    \item જો ખાલી હોય, print "Stack Underflow"
    \item અન્યથા, top થી element remove કરો
    \item Top decrement કરો
\end{enumerate}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=Python,caption={Stack Operations}]
stack = []
stack.append(10)  # PUSH
stack.append(20)  # PUSH
item = stack.pop()  # POP returns 20
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
છેલ્લો અંદર, પહેલો બહાર - થાળીઓ જેવું
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{નીચેની વ્યાખ્યા આપો: I. Time Complexity II. Space Complexity III. Best case}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Complexity Terms}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શબ્દ} & \textbf{વ્યાખ્યા} & \textbf{ઉદાહરણ} \\
\hline
\textbf{Time Complexity} & Algorithm execution time નું વિશ્લેષણ & $O(n)$, $O(\log n)$ \\
\hline
\textbf{Space Complexity} & Memory usage નું વિશ્લેષણ & $O(1)$, $O(n)$ \\
\hline
\textbf{Best Case} & ન્યૂનતમ time/space જરૂરિયાત & Sorted array search \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Time Space Best Performance
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{નીચે આપેલા infix expression ને postfix માં ફેરવો. A – (B / C + (D \% E * F) / G)* H}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Step-by-step conversion:}

\begin{itemize}
    \item Infix: $A - (B / C + (D \% E * F) / G) * H$
    \item Result: $A\ B\ C\ /\ D\ E\ \%\ F\ *\ G\ /\ +\ -\ H\ *$
\end{itemize}

\textbf{Stack operations:}
\begin{itemize}
    \item Operators: $-, (, /, +, (, \%, *, ), /, ), *$
    \item Final: \code{A B C / D E \% F * G / + - H *}
\end{itemize}

\textbf{Postfix પરિણામ: \code{A B C / D E \% F * G / + - H *}}
\end{solutionbox}

\begin{mnemonicbox}
Operands પહેલા, Operators પછી
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Circular queue ની વ્યાખ્યા આપો. Circular queue ના INSERT અને DELETE operations આકૃતિ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Circular Queue} એ queue નું સુધારેલું સ્વરૂપ છે જ્યાં છેલ્લી સ્થિતિ પ્રથમ સ્થિતિ સાથે જોડાયેલી હોય છે.

\begin{center}
\begin{tikzpicture}
    \foreach \i in {1,2,3,4} {
        \node[draw, circle, minimum size=1cm] (n\i) at ({90-90*\i}:1.5) {\ifnum\i=4 \else \i \fi};
    }
    \draw[->] (n1) -- (n2);
    \draw[->] (n2) -- (n3);
    \draw[->] (n3) -- (n4);
    \draw[->] (n4) -- (n1);
    
    \node at (0,0) {Queue};
    \node[above] at (n1.north) {front};
    \node[right] at (n3.east) {rear};
\end{tikzpicture}
\captionof{figure}{Circular Queue}
\end{center}

\textbf{INSERT Algorithm:}

\begin{enumerate}
    \item Check કરો કે queue ભરેલો છે કે નહીં
    \item rear = (rear + 1) \% size
    \item queue[rear] = element
    \item જો પ્રથમ element હોય, તો front = 0 સેટ કરો
\end{enumerate}

\textbf{DELETE Algorithm:}

\begin{enumerate}
    \item Check કરો કે queue ખાલી છે કે નહીં
    \item element = queue[front]
    \item front = (front + 1) \% size
    \item Element return કરો
\end{enumerate}

\begin{itemize}
    \item \keyword{ફાયદો}: Memory efficiency
    \item \keyword{ઉપયોગ}: CPU scheduling, buffering
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
ભરાઈ જાય તો પાછા ફરો
\end{mnemonicbox}

\questionmarks{3(a)}{3}{List નો ઉપયોગ કરી Stack નું Implementation સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

Stack operations Python List વડે:

\begin{lstlisting}[language=Python,caption={Stack Implementation using List}]
stack = []  # ખાલી stack
stack.append(10)  # PUSH
stack.append(20)  # PUSH
top = stack.pop()  # POP
\end{lstlisting}

\begin{itemize}
    \item \keyword{PUSH}: \code{append()} method
    \item \keyword{POP}: \code{pop()} method
    \item \keyword{TOP}: \code{stack[-1]} for peek
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Append ધકેલે, Pop ખેંચે
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Linked list ની વિવિધ એપ્લિકેશન વિશે ચર્ચા કરો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Linked List Applications:}

\begin{itemize}
    \item \keyword{Dynamic Memory}: Runtime પર size બદલાય
    \item \keyword{Insertion/Deletion}: કોઈપણ સ્થાને કાર્યક્ષમ
    \item \keyword{Implementation}: Stacks, queues, graphs
    \item \keyword{Undo Functionality}: Browser history, text editors
\end{itemize}

\begin{center}
\captionof{table}{Linked List Applications}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{ફાયદો} & \textbf{ઉપયોગ} \\
\hline
\textbf{Music Playlist} & સરળ add/remove & Media players \\
\hline
\textbf{Memory Management} & Dynamic allocation & Operating systems \\
\hline
\textbf{Polynomial Representation} & કાર્યક્ષમ storage & Mathematical operations \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
ગતિશીલ Implementation Undo Memory
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Doubly linked list સમજાવો. Doubly linked list માં શરૂઆત ની node ને delete કરવા માટેનો algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Doubly Linked List} માં દરેક node માં data, next pointer અને previous pointer હોય છે.

\begin{center}
\begin{tikzpicture}[gtu box]
    \node[draw, rectangle split, rectangle split parts=3, rectangle split horizontal] (n1) {prev \nodepart{second} data \nodepart{third} next};
    \node[below=0.2cm] at (n1.one south) {NULL};
    \draw[->] (n1.one south) -- (n1.one);
    
    \node[below=0.2cm] at (n1.three south) {next};
    \draw[->] (n1.three) -- (n1.three south);
\end{tikzpicture}
\captionof{figure}{Doubly Linked List Node}
\end{center}

\textbf{શરૂઆતથી Delete કરવાનો Algorithm:}

\begin{enumerate}
    \item જો list ખાલી હોય, તો return
    \item જો માત્ર એક node હોય:
    \begin{itemize}
        \item head = NULL
    \end{itemize}
    \item અન્યથા:
    \begin{itemize}
        \item temp = head
        \item head = head.next
        \item head.prev = NULL
        \item temp ને delete કરો
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Python,caption={Delete from Beginning}]
def delete_beginning(self):
    if self.head is None:
        return
    if self.head.next is None:
        self.head = None
    else:
        self.head = self.head.next
        self.head.prev = None
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
બે દિશા નેવિગેશન
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{નીચે આપેલા infix expression ને postfix માં ફેરવો: A+B/C*D-E/F-G}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Step-by-step conversion:}

\begin{itemize}
    \item Infix: $A+B/C*D-E/F-G$
    \item Postfix: $A\ B\ C\ /\ D\ *\ +\ E\ F\ /\ -\ G\ -$
    \item Operator precedence: $*, / > +, -$
    \item ડાબેથી જમણે associativity
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
ગુણા ભાગ પહેલા, સરવાળો બાદબાકી પછી
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Circular Linked List તેના ગેરફાયદા સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Circular Linked List} માં છેલ્લી node નો next pointer પ્રથમ node ને point કરે છે.

\begin{center}
\begin{tikzpicture}[gtu box]
    \node[gtu block] (n1) at (0,0) {1};
    \node[gtu block] (n2) at (2,0) {2};
    \node[gtu block] (n3) at (4,0) {3};
    
    \draw[gtu arrow] (n1) -- (n2);
    \draw[gtu arrow] (n2) -- (n3);
    \draw[gtu arrow] (n3.south) -- ++(0,-0.5) -| (n1.south);
\end{tikzpicture}
\captionof{figure}{Circular Linked List}
\end{center}

\textbf{ગેરફાયદાઓ:}

\begin{itemize}
    \item \keyword{અનંત લૂપ જોખમ}: ખોટા traversal
    \item \keyword{જટિલ Implementation}: વધારે સાવધાની જરૂરી
    \item \keyword{Memory Overhead}: વધારે pointer management
    \item \keyword{Debugging મુશ્કેલી}: Circular references
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
વર્તુળો મૂંઝવણ લાવી શકે
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{Doubly Linked List માં Insert operation ને perform કરવા માટેનો Python Program લખો. સ્વચ્છ આકૃતિ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Insert in Doubly Linked List}]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
    
    def insert_beginning(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[gtu box]
    \node[draw, rectangle split, rectangle split parts=3, rectangle split horizontal] (n1) at (0,0) {prev \nodepart{second} 10 \nodepart{third} next};
    \node[draw, rectangle split, rectangle split parts=3, rectangle split horizontal] (n0) at (-3,0) {prev \nodepart{second} 5 \nodepart{third} next};
    
    \draw[gtu arrow] (n0.three) -- (n1.one);
    \draw[gtu arrow] (n1.one) to[bend left] (n0.three);
    
    \node[below] at (n0.south) {New Head};
\end{tikzpicture}
\captionof{figure}{Inserting New Head}
\end{center}

\textbf{Insert Operations:}

\begin{itemize}
    \item \keyword{શરૂઆત}: Head pointer update કરો
    \item \keyword{અંત}: છેલ્લા node સુધી traverse કરો
    \item \keyword{મધ્ય}: prev/next pointers update કરો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
શરૂઆત અંત મધ્ય Insertions
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Merge sort નો algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Merge Sort Algorithm:}

\begin{enumerate}
    \item જો array size $\le$ 1 હોય, તો return
    \item Array ને બે ભાગમાં વહેંચો
    \item બંને ભાગોને recursively sort કરો
    \item Sorted ભાગોને merge કરો
\end{enumerate}

\textbf{Time Complexity}: $O(n \log n)$ \\
\textbf{Space Complexity}: $O(n)$
\end{solutionbox}

\begin{mnemonicbox}
વહેંચો જીતો મેળવો
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Singly Linked List અને Doubly Linked List નો તફાવત જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Singly vs Doubly Linked List}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Singly Linked List} & \textbf{Doubly Linked List} \\
\hline
\textbf{એક pointer} (next) & \textbf{બે pointers} (next, prev) \\
\hline
\textbf{આગળ traversal} માત્ર & \textbf{બંને દિશામાં traversal} \\
\hline
\textbf{ઓછી memory} વપરાશ & \textbf{વધારે memory} વપરાશ \\
\hline
\textbf{સરળ implementation} & \textbf{જટિલ implementation} \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[gtu box]
    \node (singly) at (0,1) {Singly: [data|next] $\rightarrow$ NULL};
    \node (doubly) at (0,0) {Doubly: NULL $\leftarrow$ [prev|data|next] $\leftrightarrow$ [prev|data|next] $\rightarrow$ NULL};
\end{tikzpicture}
\captionof{figure}{Linked List Types}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
સિંગલ આગળ, ડબલ બંને દિશા
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Selection sort નો algorithm લખો. આપેલા ડેટા ને selection sort ની મદદથી ચડતા ક્રમમાં ગોઠવી બતાવો. ડેટા: 13, 2, 6, 54, 18, 42, 11}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Selection Sort Algorithm:}

\begin{enumerate}
    \item i = 0 થી n-2 સુધી:
    \item array[i...n-1] માં minimum શોધો
    \item Minimum ને array[i] સાથે swap કરો
\end{enumerate}

\textbf{[13, 2, 6, 54, 18, 42, 11] માટે Trace:}

\begin{center}
\captionof{table}{Selection Sort Trace}
\begin{tabulary}{\linewidth}{|C|C|C|C|}
\hline
\textbf{Pass} & \textbf{Array State} & \textbf{Min મળ્યું} & \textbf{Swap} \\
\hline
0 & [13, 2, 6, 54, 18, 42, 11] & 2 & 13$\leftrightarrow$2 \\
\hline
1 & [2, 13, 6, 54, 18, 42, 11] & 6 & 13$\leftrightarrow$6 \\
\hline
2 & [2, 6, 13, 54, 18, 42, 11] & 11 & 13$\leftrightarrow$11 \\
\hline
3 & [2, 6, 11, 54, 18, 42, 13] & 13 & 54$\leftrightarrow$13 \\
\hline
4 & [2, 6, 11, 13, 18, 42, 54] & 18 & કોઈ swap નહીં \\
\hline
5 & [2, 6, 11, 13, 18, 42, 54] & 42 & કોઈ swap નહીં \\
\hline
\end{tabulary}
\end{center}

\textbf{અંતિમ પરિણામ: [2, 6, 11, 13, 18, 42, 54]}
\end{solutionbox}

\begin{mnemonicbox}
ન્યૂનતમ પસંદ કરો, સ્થાન બદલો
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{Insertion sort નો algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Insertion Sort Algorithm:}

\begin{enumerate}
    \item i = 1 થી n-1 સુધી:
    \item key = array[i]
    \item j = i-1
    \item જ્યાં સુધી j >= 0 અને array[j] > key:
    \item \quad array[j+1] = array[j]
    \item \quad j = j-1
    \item array[j+1] = key
\end{enumerate}

\textbf{Time Complexity}: $O(n^2)$ \\
\textbf{Best Case}: $O(n)$ sorted array માટે
\end{solutionbox}

\begin{mnemonicbox}
યોગ્ય સ્થાને દાખલ કરો
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Circular linked list માં અંત માં નવી node insert કરવા માટેનો algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Algorithm:}

\begin{enumerate}
    \item Data સાથે new\_node બનાવો
    \item જો list ખાલી હોય:
    \begin{itemize}
        \item head = new\_node
        \item new\_node.next = new\_node
    \end{itemize}
    \item અન્યથા:
    \begin{itemize}
        \item temp = head
        \item જ્યાં સુધી temp.next != head:
        \item \quad temp = temp.next
        \item temp.next = new\_node
        \item new\_node.next = head
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Python,caption={Insert at End Circular Linked List}]
def insert_end(self, data):
    new_node = Node(data)
    if self.head is None:
        self.head = new_node
        new_node.next = new_node
    else:
        temp = self.head
        while temp.next != self.head:
            temp = temp.next
        temp.next = new_node
        new_node.next = self.head
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
Head પર પાછા વર્તુળ
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{Bubble sort નો algorithm લખો. આપેલા ડેટા ને bubble sort ની મદદથી ચડતા ક્રમમાં ગોઠવી બતાવો. ડેટા: 37, 22, 64, 84, 58, 52, 11}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Bubble Sort Algorithm:}

\begin{enumerate}
    \item i = 0 થી n-2 સુધી:
    \item j = 0 થી n-2-i સુધી:
    \item જો array[j] > array[j+1]:
    \item \quad array[j] અને array[j+1] ને swap કરો
\end{enumerate}

\textbf{[37, 22, 64, 84, 58, 52, 11] માટે Trace:}

\begin{center}
\captionof{table}{Bubble Sort Trace}
\begin{tabulary}{\linewidth}{|C|L|L|}
\hline
\textbf{Pass} & \textbf{સરખામણી અને Swaps} & \textbf{પરિણામ} \\
\hline
1 & 37$\leftrightarrow$22, 64$\leftrightarrow$84, 84$\leftrightarrow$58, 84$\leftrightarrow$52, 84$\leftrightarrow$11 & [22, 37, 64, 58, 52, 11, 84] \\
\hline
2 & 37$\leftrightarrow$64, 64$\leftrightarrow$58, 64$\leftrightarrow$52, 64$\leftrightarrow$11 & [22, 37, 58, 52, 11, 64, 84] \\
\hline
3 & 37$\leftrightarrow$58, 58$\leftrightarrow$52, 58$\leftrightarrow$11 & [22, 37, 52, 11, 58, 64, 84] \\
\hline
4 & 37$\leftrightarrow$52, 52$\leftrightarrow$11 & [22, 37, 11, 52, 58, 64, 84] \\
\hline
5 & 37$\leftrightarrow$11 & [22, 11, 37, 52, 58, 64, 84] \\
\hline
6 & 22$\leftrightarrow$11 & [11, 22, 37, 52, 58, 64, 84] \\
\hline
\end{tabulary}
\end{center}

\textbf{અંતિમ પરિણામ: [11, 22, 37, 52, 58, 64, 84]}
\end{solutionbox}

\begin{mnemonicbox}
સૌથી મોટા બબલ ઉપર
\end{mnemonicbox}

\questionmarks{5(a)}{3}{Binary search tree અને તેની application સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Binary Search Tree (BST)} એ binary tree છે જ્યાં left subtree માં નાની values અને right subtree માં મોટી values હોય છે.

\textbf{ગુણધર્મો:}

\begin{itemize}
    \item \keyword{Left child} $<$ \keyword{Parent} $<$ \keyword{Right child}
    \item \keyword{Inorder traversal} sorted sequence આપે છે
    \item \keyword{Search time}: $O(\log n)$ average case
\end{itemize}

\textbf{Applications:}

\begin{center}
\captionof{table}{BST Applications}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{ફાયદો} & \textbf{ઉપયોગ} \\
\hline
\textbf{Database Indexing} & ઝડપી search & DBMS systems \\
\hline
\textbf{Expression Trees} & Evaluation & Compilers \\
\hline
\textbf{Huffman Coding} & Compression & Data compression \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Binary Search Trees ડેટા ગોઠવે
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Linear Search માટે Python Program લખો તથા ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Linear Search}]
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

# ઉદાહરણ
numbers = [10, 25, 30, 45, 60]
result = linear_search(numbers, 30)
print(f"Element found at index: {result}")  # Output: 2
\end{lstlisting}

\textbf{કામગીરી:}

\begin{itemize}
    \item \keyword{ક્રમિક તપાસ}: Element દર element
    \item \keyword{Time Complexity}: $O(n)$
    \item \keyword{Space Complexity}: $O(1)$
    \item \keyword{કામ કરે છે}: Unsorted arrays પર
\end{itemize}

\begin{center}
\captionof{table}{Linear Search Trace}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Step} & \textbf{Element} & \textbf{મળ્યું?} \\
\hline
1 & 10 & ના \\
\hline
2 & 25 & ના \\
\hline
3 & 30 & હા! \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
લીનિયર લાઇન દર લાઇન
\end{mnemonicbox}

\questionmarks{5(c)}{7}{આપેલી સાંખ્યઓ માટે Binary Search Tree બનાવો તથા તેના Preorder, Inorder અને Postorder traversals લખો: 45, 35, 12, 58, 5, 55, 58, 80, 35, 42}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{BST બાંધકામ (duplicates અવગણવામાં આવેલ):}

\begin{center}
\begin{tikzpicture}[
    level 1/.style={sibling distance=3cm},
    level 2/.style={sibling distance=1.5cm},
    level 3/.style={sibling distance=1cm}]
    
    \node[circle, draw] {45}
        child {node[circle, draw] {35}
            child {node[circle, draw] {12}
                child {node[circle, draw] {5}}
                child {node[circle, draw] {42}}
            }
            child[missing]
        }
        child {node[circle, draw] {58}
            child {node[circle, draw] {55}}
            child {node[circle, draw] {80}}
        };
\end{tikzpicture}
\captionof{figure}{Binary Search Tree}
\end{center}

\textbf{Insertion ક્રમ:} 45(root), 35(left), 12(35 ની left), 58(right), 5(12 ની left), 55(58 ની left), 80(58 ની right), 42(12 ની right)

\textbf{Traversals:}

\begin{center}
\captionof{table}{Traversals}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Traversal} & \textbf{ક્રમ} & \textbf{નિયમ} \\
\hline
\textbf{Preorder} & 45, 35, 12, 5, 42, 58, 55, 80 & Root-Left-Right \\
\hline
\textbf{Inorder} & 5, 12, 35, 42, 45, 55, 58, 80 & Left-Root-Right \\
\hline
\textbf{Postorder} & 5, 42, 12, 35, 55, 80, 58, 45 & Left-Right-Root \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Pre-Root પહેલા, In-Sorted, Post-Root છેલ્લે
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{નીચેની વ્યાખ્યા આપો: I. Binary tree II. level number III. Leaf-node}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Binary Tree Terms}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શબ્દ} & \textbf{વ્યાખ્યા} & \textbf{ઉદાહરણ} \\
\hline
\textbf{Binary tree} & દર node માં મહત્તમ 2 children વાળું tree & દરેક node માં $\le$ 2 children \\
\hline
\textbf{Level number} & Root થી અંતર (root = level 0) & Root=0, children=1, વગેરે \\
\hline
\textbf{Leaf-node} & કોઈ children ન હોય તેવી node & Terminal nodes \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[gtu box]
    \node[circle, draw] (a) at (0,0) {A};
    \node[circle, draw] (b) at (-1,-1) {B};
    \node[circle, draw] (c) at (1,-1) {C};
    \node[circle, draw] (d) at (-1.5,-2) {D};
    
    \draw (a) -- (b);
    \draw (a) -- (c);
    \draw (b) -- (d);
    
    \node[right] at (a.east) {$\leftarrow$ Root (L0)};
    \node[right] at (c.east) {$\leftarrow$ L1};
    \node[right] at (d.east) {$\leftarrow$ Leaf (L2)};
\end{tikzpicture}
\captionof{figure}{Binary Tree Levels}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Binary Levels લીડ કરે Leaves તરફ
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{Linear Search અને Binary search વચ્ચેનો તફાવત જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Linear vs Binary Search}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Linear Search} & \textbf{Binary Search} \\
\hline
\textbf{Unsorted arrays} પર કામ કરે & \textbf{Sorted array} જરૂરી \\
\hline
\textbf{ક્રમિક તપાસ} & \textbf{ભાગલા પાડીને જીતો} \\
\hline
\textbf{Time}: $O(n)$ & \textbf{Time}: $O(\log n)$ \\
\hline
\textbf{સરળ implementation} & \textbf{જટિલ implementation} \\
\hline
\textbf{કોઈ preprocessing} નહીં & \textbf{Sorting જરૂરી} \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[gtu box]
    \node[align=left] at (0,1) {Linear: દરેકની તપાસ};
    \node[align=left] at (0,0) {Binary: મધ્ય તપાસો, ભાગલા પાડો};
\end{tikzpicture}
\captionof{figure}{Search Comparison}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Linear લાઇન, Binary વિભાજન
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{Binary search tree માં node ને insertion અને deletion માટેનો algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Insertion Algorithm:}

\begin{enumerate}
    \item જો root NULL છે, તો નવી node ને root બનાવો
    \item જો data $<$ root.data, તો left subtree માં insert કરો
    \item જો data $>$ root.data, તો right subtree માં insert કરો
    \item જો data == root.data, તો insertion નહીં (duplicate)
\end{enumerate}

\textbf{Deletion Algorithm:}

\begin{enumerate}
    \item જો node leaf છે: સીધું delete કરો
    \item જો node માં એક child છે: child સાથે બદલો
    \item જો node માં બે children છે:
    \begin{itemize}
        \item Inorder successor શોધો
        \item Data ને successor ના data સાથે બદલો
        \item Successor ને delete કરો
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Python,caption={BST Operations}]
def insert(root, data):
    if root is None:
        return Node(data)
    if data < root.data:
        root.left = insert(root.left, data)
    elif data > root.data:
        root.right = insert(root.right, data)
    return root

def delete(root, data):
    if root is None:
        return root
    if data < root.data:
        root.left = delete(root.left, data)
    elif data > root.data:
        root.right = delete(root.right, data)
    else:
        # Delete કરવાની node મળી
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        # બે children સાથેની node
        temp = find_min(root.right)
        root.data = temp.data
        root.right = delete(root.right, temp.data)
    return root
\end{lstlisting}

\textbf{કેસો:}

\begin{itemize}
    \item \keyword{Leaf deletion}: સીધું removal
    \item \keyword{એક child}: Child સાથે replace
    \item \keyword{બે children}: Successor સાથે replace
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Insert સરખાવો, Delete બદલો
\end{mnemonicbox}

\end{document}
