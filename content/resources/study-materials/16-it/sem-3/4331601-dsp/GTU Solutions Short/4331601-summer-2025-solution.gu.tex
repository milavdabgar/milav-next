\documentclass{article}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Data Structure with Python (4331601) - Summer 2025 Solution}
\date{May 09, 2025}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{લીનીઅર અને નોન લીનીઅર ડેટા સ્ટ્રક્ચર નો તફાવત લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{લીનીઅર vs નોન લીનીઅર ડેટા સ્ટ્રક્ચર}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{લીનીઅર ડેટા સ્ટ્રક્ચર} & \textbf{નોન લીનીઅર ડેટા સ્ટ્રક્ચર} \\
\hline
એલિમેન્ટ્સ ક્રમિક રીતે સ્ટોર કરાય છે & એલિમેન્ટ્સ હાયરાર્કિકલ રીતે સ્ટોર કરાય છે \\
\hline
સિંગલ લેવલ ગોઠવણી & મલ્ટિ લેવલ ગોઠવણી \\
\hline
સરળ ટ્રાવર્સલ & જટિલ ટ્રાવર્સલ \\
\hline
ઉદાહરણ: Array, Stack, Queue & ઉદાહરણ: Tree, Graph \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
લીનીઅર પાણીની જેમ વહે, નોન-લીનીઅર નેટવર્ક જેવું નેવિગેટ કરે
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Object Oriented programming ના વિવિધ concepts સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{OOP કોન્સેપ્ટ્સ કોષ્ટક:}

\begin{center}
\captionof{table}{OOP કોન્સેપ્ટ્સ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કોન્સેપ્ટ} & \textbf{વર્ણન} \\
\hline
\textbf{Encapsulation} & ડેટા અને મેથડ્સ એકસાથે બાંધવું \\
\hline
\textbf{Inheritance} & પેરેન્ટ ક્લાસથી પ્રોપર્ટીઝ મેળવવી \\
\hline
\textbf{Polymorphism} & એક નામ, અનેક સ્વરૂપો \\
\hline
\textbf{Abstraction} & ઇમ્પ્લિમેન્ટેશન વિગતો છુપાવવી \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Encapsulation}: ડેટા હાઇડિંગ અને બન્ડલિંગ
    \item \keyword{Inheritance}: પેરેન્ટ-ચાઇલ્ડ સંબંધ દ્વારા કોડ પુનઃઉપયોગ
    \item \keyword{Polymorphism}: મેથડ ઓવરરાઇડિંગ અને ઓવરલોડિંગ
    \item \keyword{Abstraction}: ઇમ્પ્લિમેન્ટેશન વગરનું ઇન્ટરફેસ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
દરેક હોશિયાર પ્રોગ્રામર Abstracts કરે છે
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Polymorphism ની વ્યાખ્યા આપો. Inheritance વડે Polymorphism નો python program લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Polymorphism} એટલે "અનેક સ્વરૂપો" - એજ મેથડ નામ અલગ અલગ ક્લાસોમાં અલગ વર્તન દર્શાવે.

\textbf{કોડ:}

\begin{lstlisting}[language=Python,caption={Polymorphism ઉદાહરણ}]
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"

class Cat(Animal):
    def sound(self):
        return "Meow"

# Polymorphism ની ક્રિયા
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.sound())
\end{lstlisting}

\begin{itemize}
    \item \keyword{Polymorphism}: સેમ ઇન્ટરફેસ, અલગ ઇમ્પ્લિમેન્ટેશન
    \item \keyword{Runtime binding}: ઑબ્જેક્ટ ટાઇપ પર આધારિત મેથડ કૉલ
    \item \keyword{કોડ લવચીકતા}: નવી ક્લાસો સાથે સરળતાથી વિસ્તાર
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Polymorphism પરફેક્ટ પ્રોગ્રામિંગ પ્રદાન કરે
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Abstraction ની વ્યાખ્યા આપો. Abstract class નો concept સમજવા માટેનો python program લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Abstraction} ઇમ્પ્લિમેન્ટેશન વિગતો છુપાવે છે અને ફક્ત જરૂરી ફીચર્સ બતાવે છે.

\textbf{કોડ:}

\begin{lstlisting}[language=Python,caption={Abstraction ઉદાહરણ}]
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width

# ઉપયોગ
rect = Rectangle(5, 3)
print(f"Area: {rect.area()}")
\end{lstlisting}

\begin{itemize}
    \item \keyword{Abstract class}: સીધી રીતે instantiate કરી શકાતી નથી
    \item \keyword{Abstract method}: ચાઇલ્ડ ક્લાસોમાં ઇમ્પ્લિમેન્ટ કરવું આવશ્યક
    \item \keyword{ઇન્ટરફેસ ડેફિનિશન}: સબક્લાસ માટે ટેમ્પ્લેટ પ્રદાન કરે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Abstraction વાસ્તવિક ઇમ્પ્લિમેન્ટેશન ટાળે
\end{mnemonicbox}

\questionmarks{2(a)}{3}{નીચેની વ્યાખ્યા આપો: I. Best case II. Worst case III. Average case}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Time Complexity Cases}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કેસ} & \textbf{વ્યાખ્યા} \\
\hline
\textbf{Best case} & અલ્ગોરિધમ માટે લઘુત્તમ સમય જરૂરી \\
\hline
\textbf{Worst case} & અલ્ગોરિધમ માટે મહત્તમ સમય જરૂરી \\
\hline
\textbf{Average case} & રેન્ડમ ઇનપુટ માટે અપેક્ષિત સમય \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Best-Worst-Average = પરફોર્મન્સ એનાલિસિસ
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Infix, postfix અને prefix એક્સપ્રેશન સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Expression Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{એક્સપ્રેશન} & \textbf{ઑપરેટર પોઝિશન} & \textbf{ઉદાહરણ} \\
\hline
\textbf{Infix} & ઑપરેન્ડ્સ વચ્ચે & A + B \\
\hline
\textbf{Prefix} & ઑપરેન્ડ્સ પહેલાં & + A B \\
\hline
\textbf{Postfix} & ઑપરેન્ડ્સ પછી & A B + \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Infix}: પ્રાકૃતિક ગાણિતિક સંકેત
    \item \keyword{Prefix}: Polish notation
    \item \keyword{Postfix}: Reverse Polish notation
    \item \keyword{Stack ઉપયોગ}: Postfix કૌંસ દૂર કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
In-Pre-Post = ઑપરેટરની સ્થિતિ
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Circular queue ની વ્યાખ્યા આપો. Circular queue ના INSERT અને DELETE operations આકૃતિ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Circular Queue}: લીનીઅર ડેટા સ્ટ્રક્ચર જેમાં છેલ્લી સ્થિતિ પ્રથમ સ્થિતિ સાથે જોડાય છે.

\textbf{આકૃતિ:}

\begin{center}
\begin{tikzpicture}
    \foreach \i in {0,1,2,3} {
        \node[draw, circle, minimum size=1cm] (n\i) at ({90-90*\i}:1.5) {\i};
    }
    \draw[->] (n0) -- (n1);
    \draw[->] (n1) -- (n2);
    \draw[->] (n2) -- (n3);
    \draw[->] (n3) -- (n0);
    
    \node at (0,0) {Queue};
    \node[above] at (n0.north) {front};
    \node[right] at (n3.east) {rear};
\end{tikzpicture}
\captionof{figure}{Circular Queue}
\end{center}

\textbf{INSERT ઑપરેશન:}

\begin{enumerate}
    \item ચકાસો કે queue ભરાઈ ગઈ છે કે નહીં
    \item જો ભરાઈ નથી, rear વધારો
    \item જો rear size કરતાં વધે, rear = 0 કરો
    \item rear પોઝિશને એલિમેન્ટ insert કરો
\end{enumerate}

\textbf{DELETE ઑપરેશન:}

\begin{enumerate}
    \item ચકાસો કે queue ખાલી છે કે નહીં
    \item જો ખાલી નથી, front માંથી એલિમેન્ટ કાઢો
    \item front વધારો
    \item જો front size કરતાં વધે, front = 0 કરો
\end{enumerate}

\begin{itemize}
    \item \keyword{ગોળ પ્રકૃતિ}: કાર્યક્ષમ મેમરી ઉપયોગ
    \item \keyword{કોઈ શિફ્ટિંગ નહીં}: એલિમેન્ટ્સ જગ્યામાં રહે
    \item \keyword{Front-rear pointers}: queue બાઉન્ડરીઝ ટ્રેક કરે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Circular સ્પેસ બચાવે છે
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{ઉદાહરણ સાથે વિવિધ Data Structure જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Data Structure Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{ડેટા સ્ટ્રક્ચર} & \textbf{ઉદાહરણ} \\
\hline
\textbf{લીનીઅર} & Array & [1,2,3,4] \\
\hline
\textbf{લીનીઅર} & Stack & Function calls \\
\hline
\textbf{લીનીઅર} & Queue & Printer queue \\
\hline
\textbf{નોન-લીનીઅર} & Tree & File system \\
\hline
\textbf{નોન-લીનીઅર} & Graph & Social network \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Arrays-Stacks-Queues = લીનીઅર, Trees-Graphs = નોન-લીનીઅર
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{Circular queue એ simple queue કરતાં કેવી રીતે અલગ છે તે જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Simple vs Circular Queue}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Simple Queue} & \textbf{Circular Queue} \\
\hline
લીનીઅર ગોઠવણી & ગોળ ગોઠવણી \\
\hline
મેમરી બગાડ & કાર્યક્ષમ મેમરી ઉપયોગ \\
\hline
ફિક્સ્ડ front અને rear & Wraparound pointers \\
\hline
False overflow & True overflow detection \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{મેમરી કાર્યક્ષમતા}: Circular ડિલીટ કરેલી જગ્યાઓ ફરી વાપરે
    \item \keyword{Pointer મેનેજમેન્ટ}: Wraparound માટે મોડ્યુલો અંકગણિત
    \item \keyword{પરફોર્મન્સ}: બહેતર સ્પેસ ઉપયોગ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Circular મેમરી સમસ્યાઓ જીતે છે
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Stack ની વ્યાખ્યા આપો. PUSH અને POP operation ઉદાહરણ સાથે સમજાવો. Stack ના PUSH અને POP operation ના algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Stack}: LIFO (Last In First Out) ડેટા સ્ટ્રક્ચર.

\textbf{PUSH Algorithm:}

\begin{enumerate}
    \item ચકાસો કે stack ભરાઈ ગઈ છે કે નહીં
    \item જો ભરાઈ નથી, top વધારો
    \item top પોઝિશને એલિમેન્ટ insert કરો
    \item top pointer અપડેટ કરો
\end{enumerate}

\textbf{POP Algorithm:}

\begin{enumerate}
    \item ચકાસો કે stack ખાલી છે કે નહીં
    \item જો ખાલી નથી, top એલિમેન્ટ સ્ટોર કરો
    \item top pointer ઘટાડો
    \item સ્ટોર કરેલું એલિમેન્ટ return કરો
\end{enumerate}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=Python,caption={Stack ઉદાહરણ}]
Stack: [10, 20, 30] <- top
PUSH 40: [10, 20, 30, 40] <- top
POP: returns 40, stack: [10, 20, 30] <- top
\end{lstlisting}

\begin{itemize}
    \item \keyword{LIFO સિદ્ધાંત}: છેલ્લું ઉમેરેલું એલિમેન્ટ પ્રથમ કાઢવામાં આવે
    \item \keyword{Top pointer}: વર્તમાન stack પોઝિશન ટ્રેક કરે
    \item \keyword{Overflow/Underflow}: ઑપરેશન પહેલાં ચકાસણી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Stack છેલ્લા-અંદર-પ્રથમ-બહાર સ્ટોર કરે
\end{mnemonicbox}

\questionmarks{3(a)}{3}{નીચે આપેલા infix expression ને postfix માં ફેરવો: ( ( ( A - B ) * C ) + ( ( D - E ) / F ) )}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{પગલાબદ્ધ રૂપાંતર:}

\begin{center}
\captionof{table}{Infix to Postfix Conversion}
\begin{tabulary}{\linewidth}{|C|L|L|L|}
\hline
\textbf{પગલું} & \textbf{Scanned} & \textbf{Stack} & \textbf{Postfix} \\
\hline
1 & ( & ( & \\
\hline
2 & ( & (( & \\
\hline
3 & ( & ((( & \\
\hline
4 & A & ((( & A \\
\hline
5 & - & (((- & A \\
\hline
6 & B & (((- & AB \\
\hline
7 & ) & (( & AB- \\
\hline
8 & * & ((* & AB- \\
\hline
9 & C & ((* & AB-C \\
\hline
10 & ) & ( & AB-C* \\
\hline
11 & + & (+ & AB-C* \\
\hline
12 & ( & (+( & AB-C* \\
\hline
13 & ( & (+(( & AB-C* \\
\hline
14 & D & (+(( & AB-C*D \\
\hline
15 & - & (+((- & AB-C*D \\
\hline
16 & E & (+((- & AB-C*DE \\
\hline
17 & ) & (+ & AB-C*DE- \\
\hline
18 & / & (+(/ & AB-C*DE- \\
\hline
19 & F & (+(/ & AB-C*DE-F \\
\hline
20 & ) & (+ & AB-C*DE-F/ \\
\hline
21 & ) & & AB-C*DE-F/+ \\
\hline
\end{tabulary}
\end{center}

\textbf{અંતિમ જવાબ: AB-C*DE-F/+}
\end{solutionbox}

\begin{mnemonicbox}
Postfix ઑપરેટર્સ ઑપરેન્ડ્સ પછી મૂકે
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Doubly linked list વિશે ટૂંકનોંધ લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Doubly Linked List}: દ્વિદિશીય લિંક્સ સાથેની લીનીઅર ડેટા સ્ટ્રક્ચર.

\textbf{સ્ટ્રક્ચર:}

\begin{center}
\begin{tikzpicture}[gtu box]
    \node (null1) at (-2,0) {NULL};
    \node[draw, rectangle split, rectangle split parts=3, rectangle split horizontal] (n1) at (0,0) {prev \nodepart{second} data \nodepart{third} next};
    \node[draw, rectangle split, rectangle split parts=3, rectangle split horizontal] (n2) at (3,0) {prev \nodepart{second} data \nodepart{third} next};
    \node[draw, rectangle split, rectangle split parts=3, rectangle split horizontal] (n3) at (6,0) {prev \nodepart{second} data \nodepart{third} next};
    \node (null2) at (8,0) {NULL};

    \draw[->] (null1) -- (n1);
    \draw[->] (n1.three) -- (n2.one);
    \draw[->] (n2.one) -- (n1.three);
    \draw[->] (n2.three) -- (n3.one);
    \draw[->] (n3.one) -- (n2.three);
    \draw[->] (n3.three) -- (null2);
\end{tikzpicture}
\captionof{figure}{Doubly Linked List}
\end{center}

\textbf{ફાયદાઓ:}

\begin{itemize}
    \item \keyword{દ્વિદિશીય traversal}: આગળ અને પાછળ navigation
    \item \keyword{કાર્યક્ષમ deletion}: પાછલા node ના reference ની જરૂર નહીં
    \item \keyword{બહેતર insertion}: આપેલા node પહેલાં સરળતાથી insert કરી શકાય
\end{itemize}

\textbf{ગેરફાયદાઓ:}

\begin{itemize}
    \item \keyword{વધારાની મેમરી}: વધારાના pointer storage
    \item \keyword{જટિલ operations}: વધુ pointer manipulations
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Doubly દ્વિદિશીય ફાયદાઓ આપે
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Singly linked list માં પ્રથમ અને અંતિમ node કાઢવા માટેનો Python Program લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{કોડ:}

\begin{lstlisting}[language=Python,caption={Singly Linked List Deletion}]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def delete_first(self):
        if self.head is None:
            return "List is empty"
        self.head = self.head.next
        return "First node deleted"
    
    def delete_last(self):
        if self.head is None:
            return "List is empty"
        if self.head.next is None:
            self.head = None
            return "Last node deleted"
        
        current = self.head
        while current.next.next:
            current = current.next
        current.next = None
        return "Last node deleted"
    
    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        return elements

# ઉપયોગ
ll = LinkedList()
# nodes ઉમેરો અને deletion ટેસ્ટ કરો
\end{lstlisting}

\begin{itemize}
    \item \keyword{પ્રથમ ડિલીટ}: head pointer અપડેટ કરો
    \item \keyword{છેલ્લું ડિલીટ}: બીજા છેલ્લા node સુધી traverse કરો
    \item \keyword{Edge cases}: ખાલી list અને સિંગલ node
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Delete pointer અપડેટ દ્વારા આપે
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{Queue ની વિવિધ એપ્લિકેશન જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Queue એપ્લિકેશન્સ:}

\begin{center}
\captionof{table}{Queue Applications}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{ઉપયોગ} \\
\hline
\textbf{CPU Scheduling} & Process management \\
\hline
\textbf{Print Queue} & Document printing \\
\hline
\textbf{BFS Algorithm} & Graph traversal \\
\hline
\textbf{Buffer} & Data streaming \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{FIFO પ્રકૃતિ}: પ્રથમ આવ્યો પ્રથમ સેવા
    \item \keyword{Real-time systems}: ઓર્ડરમાં requests handle કરે
    \item \keyword{Resource sharing}: વાજબી ફાળવણી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Queues ક્રમબદ્ધ operations શાંતિથી handle કરે
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Singly linked list પર આપણે કરી શકીએ તેવા વિવિધ ઑપરેશન્સ સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Singly Linked List ઑપરેશન્સ:}

\begin{center}
\captionof{table}{Singly Linked List Operations}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઑપરેશન} & \textbf{વર્ણન} \\
\hline
\textbf{Insertion} & શરૂઆત/અંત/મધ્યમાં node ઉમેરવું \\
\hline
\textbf{Deletion} & કોઈપણ પોઝિશનથી node કાઢવું \\
\hline
\textbf{Traversal} & બધા nodes ને ક્રમિક રીતે visit કરવા \\
\hline
\textbf{Search} & list માં ચોક્કસ ડેટા શોધવું \\
\hline
\textbf{Count} & કુલ nodes ની ગિનતી કરવી \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{ડાયનામિક સાઇઝ}: runtime દરમિયાન વધે/ઘટે
    \item \keyword{મેમરી કાર્યક્ષમતા}: જરૂર મુજબ allocate કરે
    \item \keyword{Sequential access}: કોઈ random access નથી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Insert-Delete-Traverse-Search-Count
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{Doubly linked list માં અંતે નવી node insert કરવા માટેનો algorithm લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{અંતે insertion માટે Algorithm:}

\begin{enumerate}
    \item આપેલા ડેટા સાથે નવું node બનાવો
    \item નવા node નું next = NULL કરો
    \item જો list ખાલી છે:
    \begin{itemize}
        \item head = નવું node કરો
        \item નવા node નું prev = NULL કરો
    \end{itemize}
    \item નહીં તો:
    \begin{itemize}
        \item છેલ્લા node સુધી traverse કરો
        \item છેલ્લા node નું next = નવું node કરો
        \item નવા node નું prev = છેલ્લું node કરો
    \end{itemize}
    \item success return કરો
\end{enumerate}

\textbf{કોડ:}

\begin{lstlisting}[language=Python,caption={Insert at End Doubly Linked List}]
def insert_at_end(self, data):
    new_node = Node(data)
    if self.head is None:
        self.head = new_node
        return
    
    current = self.head
    while current.next:
        current = current.next
    
    current.next = new_node
    new_node.prev = current
\end{lstlisting}

\begin{itemize}
    \item \keyword{દ્વિદિશીય લિંકિંગ}: next અને prev બંને pointers અપડેટ કરો
    \item \keyword{અંત insertion}: છેલ્લું node શોધવા traverse કરો
    \item \keyword{દ્વિદિશીય કનેક્શન}: list integrity જાળવો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
દ્વિદિશીય લિંક્સ સાથે હોશિયારીથી Insert કરો
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Linear search માટેનો Python Program લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{કોડ:}

\begin{lstlisting}[language=Python,caption={Linear Search}]
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

# ઉદાહરણ ઉપયોગ
data = [10, 20, 30, 40, 50]
result = linear_search(data, 30)
print(f"Element found at index: {result}")
\end{lstlisting}

\begin{itemize}
    \item \keyword{Sequential search}: દરેક element એક પછી એક ચકાસો
    \item \keyword{Time complexity}: O(n)
    \item \keyword{સાદું implementation}: સમજવામાં આસાન
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Linear દરેક element દ્વારા જુએ છે
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Circular linked list વિશે ટૂંકનોંધ લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Circular Linked List}: છેલ્લું node પ્રથમ node તરફ પાછું point કરે છે અને ગોળ બનાવે છે.

\textbf{આકૃતિ:}

\begin{center}
\begin{tikzpicture}[gtu box]
    \node[draw, rectangle split, rectangle split parts=2, rectangle split horizontal] (n1) at (0,0) {data \nodepart{second} next};
    \node[draw, rectangle split, rectangle split parts=2, rectangle split horizontal] (n2) at (3,0) {data \nodepart{second} next};
    \node[draw, rectangle split, rectangle split parts=2, rectangle split horizontal] (n3) at (6,0) {data \nodepart{second} next};

    \draw[->] (n1.second) -- (n2);
    \draw[->] (n2.second) -- (n3);
    \draw[->] (n3.second) -- ++(0,-0.7) -| (n1);
\end{tikzpicture}
\captionof{figure}{Circular Linked List}
\end{center}

\textbf{લક્ષણો:}

\begin{itemize}
    \item \keyword{કોઈ NULL pointers નથી}: છેલ્લું node પ્રથમ સાથે જોડાય
    \item \keyword{સતત traversal}: અનંત traversal શક્ય
    \item \keyword{મેમરી કાર્યક્ષમતા}: બહેતર cache performance
    \item \keyword{એપ્લિકેશન્સ}: Round-robin scheduling, multiplayer games
\end{itemize}

\textbf{ફાયદાઓ:}

\begin{itemize}
    \item \keyword{કાર્યક્ષમ insertion}: કોઈપણ પોઝિશને
    \item \keyword{કોઈ બગડેલા pointers નથી}: બધા nodes જોડાયેલા
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Circular બધું loop માં જોડે છે
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Quick sort algorithm ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Quick Sort}: Pivot element વાપરીને divide અને conquer sorting algorithm.

\textbf{Algorithm:}

\begin{enumerate}
    \item Pivot element પસંદ કરો
    \item Pivot આસપાસ array partition કરો
    \item બાઈ subarray ને recursively sort કરો
    \item જમણી subarray ને recursively sort કરો
\end{enumerate}

\textbf{ઉદાહરણ: [64, 34, 25, 12, 22, 11, 90] સોર્ટ કરો}

\textbf{પગલું 1:} Pivot = 64

\begin{center}
\code{[34, 25, 12, 22, 11] 64 [90]}
\end{center}

\textbf{પગલું 2:} બાઈ partition [34, 25, 12, 22, 11] સોર્ટ કરો (Pivot = 34)

\begin{center}
\code{[25, 12, 22, 11] 34 []}
\end{center}

\textbf{અંતિમ sorted:} [11, 12, 22, 25, 34, 64, 90]

\begin{itemize}
    \item \keyword{Divide અને conquer}: સમસ્યાને નાના ભાગોમાં વહેંચો
    \item \keyword{In-place sorting}: ન્યૂનતમ વધારાની મેમરી
    \item \keyword{Average complexity}: O(n log n)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Quick Partitions પછી જીતે છે
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{Binary search algorithm ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Binary Search}: Divide અને conquer વાપરીને sorted arrays માટે search algorithm.

\textbf{Algorithm:}

\begin{enumerate}
    \item left = 0, right = array length - 1 સેટ કરો
    \item જ્યાં સુધી left <= right:
    \begin{itemize}
        \item mid = (left + right) / 2 calculate કરો
        \item જો target = array[mid], mid return કરો
        \item જો target $<$ array[mid], right = mid - 1
        \item જો target $>$ array[mid], left = mid + 1
    \end{itemize}
    \item ન મળે તો -1 return કરો
\end{enumerate}

\textbf{ઉદાહરણ: [11, 12, 22, 25, 34, 64, 90] માં 22 શોધો}

\begin{center}
\captionof{table}{Binary Search Trace}
\begin{tabulary}{\linewidth}{|C|C|C|C|C|L|}
\hline
\textbf{પગલું} & \textbf{Left} & \textbf{Right} & \textbf{Mid} & \textbf{Value} & \textbf{Action} \\
\hline
1 & 0 & 6 & 3 & 25 & 22 $<$ 25, right = 2 \\
\hline
2 & 0 & 2 & 1 & 12 & 22 $>$ 12, left = 2 \\
\hline
3 & 2 & 2 & 2 & 22 & મળ્યું! \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Binary ઝડપથી શોધવા બે ભાગ કરે છે
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Linked list ની વિવિધ એપ્લિકેશન જણાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Linked List એપ્લિકેશન્સ:}

\begin{center}
\captionof{table}{Linked List Applications}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{ઉપયોગ} \\
\hline
\textbf{Dynamic Arrays} & Resizable ડેટા storage \\
\hline
\textbf{Stack/Queue Implementation} & LIFO/FIFO structures \\
\hline
\textbf{Graph Representation} & Adjacency lists \\
\hline
\textbf{Memory Management} & Free memory blocks \\
\hline
\textbf{Music Playlist} & Next/previous song navigation \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{ડાયનામિક મેમરી}: જરૂર મુજબ allocate કરો
    \item \keyword{કાર્યક્ષમ insertion/deletion}: કોઈ shifting જરૂરી નથી
    \item \keyword{લવચીક structure}: બદલાતી જરૂરિયાતોને અનુકૂળ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Linked Lists ડાયનામિક એપ્લિકેશન્સમાં રહે છે
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{ઉદાહરણ સાથે Insertion sort માટેનો python program લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{કોડ:}

\begin{lstlisting}[language=Python,caption={Insertion Sort}]
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr

# ઉદાહરણ
data = [64, 34, 25, 12, 22, 11, 90]
sorted_data = insertion_sort(data)
print(f"Sorted array: {sorted_data}")
\end{lstlisting}

\textbf{પગલાબદ્ધ ઉદાહરણ:}

\begin{itemize}
    \item Initial: [64, 34, 25, 12, 22, 11, 90]
    \item Pass 1:  [34, 64, 25, 12, 22, 11, 90]
    \item Pass 2:  [25, 34, 64, 12, 22, 11, 90]
    \item Pass 3:  [12, 25, 34, 64, 22, 11, 90]
    \item Pass 4:  [12, 22, 25, 34, 64, 11, 90]
    \item Pass 5:  [11, 12, 22, 25, 34, 64, 90]
    \item Pass 6:  [11, 12, 22, 25, 34, 64, 90]
\end{itemize}

\begin{itemize}
    \item \keyword{કાર્ડ sorting analogy}: playing cards ગોઠવવા જેવું
    \item \keyword{Stable sort}: સમાન elements નો relative order જાળવે
    \item \keyword{Online algorithm}: ડેટા મળતા જ list sort કરી શકે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Insertion યોગ્ય જગ્યામાં Insert કરે છે
\end{mnemonicbox}

\questionmarks{5(a)}{3}{નીચેની વ્યાખ્યા આપો: I. Complete Binary tree II. In-degree III. Out-degree.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Binary Tree Terms}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{શબ્દ} & \textbf{વ્યાખ્યા} \\
\hline
\textbf{Complete Binary Tree} & છેલ્લા level સિવાય બધા levels ડાબેથી ભરાયેલા \\
\hline
\textbf{In-degree} & Node માં આવતા edges ની સંખ્યા \\
\hline
\textbf{Out-degree} & Node માંથી જતા edges ની સંખ્યા \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Complete-In-Out = Tree terminology
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Bubble sort algorithm ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Bubble Sort}: અડીખમ elements ની તુલના કરો અને ખોટા ક્રમમાં હોય તો swap કરો.

\textbf{Algorithm:}

\begin{enumerate}
    \item દરેક pass માટે (0 થી n-1):
    \item દરેક element માટે (0 થી n-pass-1):
    \item જો arr[j] $>$ arr[j+1]:
    \item arr[j] અને arr[j+1] swap કરો
\end{enumerate}

\textbf{ઉદાહરણ: [64, 34, 25, 12]}

\begin{center}
\captionof{table}{Bubble Sort Trace}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Pass} & \textbf{Comparisons} & \textbf{Result} \\
\hline
1 & 64$>$34(swap), 64$>$25(swap), 64$>$12(swap) & [34,25,12,64] \\
\hline
2 & 34$>$25(swap), 34$>$12(swap) & [25,12,34,64] \\
\hline
3 & 25$>$12(swap) & [12,25,34,64] \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Bubble up}: સૌથી મોટું element અંતે bubble થાય
    \item \keyword{Multiple passes}: દરેક pass એક element સાચી જગ્યામાં મૂકે
    \item \keyword{સાદું implementation}: સમજવામાં આસાન
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Bubble સૌથી મોટાને પાછળ લાવે છે
\end{mnemonicbox}

\questionmarks{5(c)}{7}{આપેલી સંખ્યાઓ માટે Binary Search Tree બનાવો તથા તેના Preorder, Inorder અને Postorder traversals લખો: 15, 35, 12, 48, 5, 25, 58, 8}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{BST Construction:}

\begin{center}
\begin{tikzpicture}[
    level 1/.style={sibling distance=3cm},
    level 2/.style={sibling distance=1.5cm},
    level 3/.style={sibling distance=1cm}]
    
    \node[circle, draw] {15}
        child {node[circle, draw] {12}
            child {node[circle, draw] {5}
                child[missing]
                child {node[circle, draw] {8}}
            }
            child[missing]
        }
        child {node[circle, draw] {35}
            child {node[circle, draw] {25}}
            child {node[circle, draw] {48}
                child[missing]
                child {node[circle, draw] {58}}
            }
        };
\end{tikzpicture}
\captionof{figure}{Binary Search Tree}
\end{center}

\textbf{Traversal Sequences:}

\begin{center}
\captionof{table}{Traversals}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Traversal} & \textbf{Sequence} \\
\hline
\textbf{Preorder} & 15, 12, 5, 8, 35, 25, 48, 58 \\
\hline
\textbf{Inorder} & 5, 8, 12, 15, 25, 35, 48, 58 \\
\hline
\textbf{Postorder} & 8, 5, 12, 25, 58, 48, 35, 15 \\
\hline
\end{tabulary}
\end{center}

\textbf{Traversal નિયમો:}

\begin{itemize}
    \item \keyword{Preorder}: Root $\rightarrow$ Left $\rightarrow$ Right
    \item \keyword{Inorder}: Left $\rightarrow$ Root $\rightarrow$ Right (sorted order આપે)
    \item \keyword{Postorder}: Left $\rightarrow$ Right $\rightarrow$ Root
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Pre-In-Post = Root ની સ્થિતિ
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{Binary tree ની વ્યાખ્યા આપો. Binary tree માં node searching વિશે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\keyword{Binary Tree}: Hierarchical ડેટા structure જેમાં દરેક node ને મહત્તમ બે children હોય.

\textbf{Search Algorithm:}

\begin{enumerate}
    \item Root થી શરુઆત કરો
    \item જો target = current node, found return કરો
    \item જો target $<$ current node, ડાબે જાઓ
    \item જો target $>$ current node, જમણે જાઓ
    \item મળે કે NULL સુધી પહોંચે ત્યાં સુધી repeat કરો
\end{enumerate}

\begin{itemize}
    \item \keyword{Hierarchical structure}: Parent-child સંબંધ
    \item \keyword{Binary property}: node દીઠ મહત્તમ બે children
    \item \keyword{Search કાર્યક્ષમતા}: Balanced trees માટે O(log n)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Binary બે પાથમાં branch કરે છે
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{આપેલા ડેટા ને bubble sort ની મદદથી ચડતા ક્રમમાં ગોઠવી બતાવો. ડેટા: 44, 72, 94, 28, 18, 442, 41}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Bubble Sort Trace:}

\begin{center}
\captionof{table}{Bubble Sort Trace}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Pass} & \textbf{Array State} & \textbf{Swaps} \\
\hline
Initial & [44, 72, 94, 28, 18, 442, 41] & - \\
\hline
Pass 1 & [44, 72, 28, 18, 94, 41, 442] & 94$>$28, 94$>$18, 442$>$41 \\
\hline
Pass 2 & [44, 28, 18, 72, 41, 94, 442] & 72$>$28, 72$>$18, 94$>$41 \\
\hline
Pass 3 & [28, 18, 44, 41, 72, 94, 442] & 44$>$28, 44$>$18, 72$>$41 \\
\hline
Pass 4 & [18, 28, 41, 44, 72, 94, 442] & 28$>$18, 44$>$41 \\
\hline
Pass 5 & [18, 28, 41, 44, 72, 94, 442] & કોઈ swaps નથી \\
\hline
\end{tabulary}
\end{center}

\textbf{અંતિમ sorted array:} [18, 28, 41, 44, 72, 94, 442]
\end{solutionbox}

\begin{mnemonicbox}
Bubble sort દરેક pass સૌથી મોટાને અંતે bubbles કરે
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{Trees ની વિવિધ એપ્લિકેશન જણાવો. General tree ને Binary Search Tree માં રૂપાંતર કરવા માટેની technique ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Tree એપ્લિકેશન્સ:}

\begin{center}
\captionof{table}{Tree Applications}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{ઉપયોગ} \\
\hline
\textbf{File System} & Directory hierarchy \\
\hline
\textbf{Expression Trees} & ગાણિતિક expressions \\
\hline
\textbf{Decision Trees} & AI અને machine learning \\
\hline
\textbf{Heap} & Priority queues \\
\hline
\end{tabulary}
\end{center}

\textbf{General Tree થી BST રૂપાંતર:}

\textbf{Technique: First Child - Next Sibling Representation}

\textbf{મૂળ General Tree:}

\begin{center}
\begin{tikzpicture}
    \node[circle, draw] {A}
        child {node[circle, draw] {B}
            child {node[circle, draw] {E}}
        }
        child {node[circle, draw] {C}
            child {node[circle, draw] {F}}
        }
        child {node[circle, draw] {D}
            child {node[circle, draw] {G}}
        };
\end{tikzpicture}
\captionof{figure}{General Tree}
\end{center}

\textbf{Binary Tree માં રૂપાંતર:}

\begin{center}
\begin{tikzpicture}
    \node[circle, draw] {A}
        child {node[circle, draw] {B}
            child {node[circle, draw] {E}}
            child {node[circle, draw] {C}
                child {node[circle, draw] {F}}
                child {node[circle, draw] {D}
                    child {node[circle, draw] {G}}
                }
            }
        }
        child[missing];
\end{tikzpicture}
\captionof{figure}{Converted Binary Tree}
\end{center}

\textbf{પગલાં:}

\begin{enumerate}
    \item \keyword{First child}: Binary tree માં left child બને
    \item \keyword{Next sibling}: Binary tree માં right child બને
    \item \keyword{Recursive application}: બધા nodes પર લાગુ કરો
\end{enumerate}

\begin{itemize}
    \item \keyword{વ્યવસ્થિત રૂપાંતર}: Tree structure જાળવે
    \item \keyword{Binary representation}: node દીઠ ફક્ત બે pointers વાપરે
    \item \keyword{Space કાર્યક્ષમતા}: માનક binary tree operations લાગુ પડે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
First-child ડાબે, Next-sibling જમણે
\end{mnemonicbox}

\end{document}
