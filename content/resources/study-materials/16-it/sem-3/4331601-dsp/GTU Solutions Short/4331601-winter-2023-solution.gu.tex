\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{Data Structure with Python (4331601) - Winter 2023 Solution}
\date{January 11, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{Time Complexity માટે best case, worst case અને average case વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Time Complexity Cases}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{કેસનો પ્રકાર} & \textbf{વ્યાખ્યા} & \textbf{ઉદાહરણ} \\
\hline
\textbf{Best Case} & એલ્ગોરિધમ execution માટે લઘુત્તમ સમય & Linear search માં એલિમેન્ટ પહેલી પોઝિશન પર મળે \\
\hline
\textbf{Worst Case} & એલ્ગોરિધમ execution માટે મહત્તમ સમય & Linear search માં એલિમેન્ટ છેલ્લી પોઝિશન પર મળે \\
\hline
\textbf{Average Case} & સામાન્ય input scenarios માટે અપેક્ષિત સમય & Linear search માં એલિમેન્ટ મધ્યમાં મળે \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Best Case}: આદર્શ input conditions સાથે એલ્ગોરિધમ optimal પ્રદર્શન આપે
    \item \keyword{Worst Case}: પ્રતિકૂળ input સાથે એલ્ગોરિધમ મહત્તમ સમય લે
    \item \keyword{Average Case}: બધા શક્ય inputs માં execution time ની ગાણિતિક અપેક્ષા
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
BWA - Best, Worst, Average
\end{mnemonicbox}

\questionmarks{1(b)}{4}{OOP માં Class અને Object શું છે? યોગ્ય ઉદાહરણ આપો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Class vs Object}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{Class} & \textbf{Object} \\
\hline
\textbf{વ્યાખ્યા} & Objects બનાવવા માટે blueprint/template & Class નું instance \\
\hline
\textbf{મેમરી} & કોઈ મેમરી allocate નથી થતી & બનાવવામાં આવે ત્યારે મેમરી allocate થાય \\
\hline
\textbf{ઉદાહરણ} & Car (template) & my\_car = Car() \\
\hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Class and Object Example}]
# Class definition
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def display(self):
        print(f"Name: {self.name}, Age: {self.age}")

# Object creation
student1 = Student("John", 20)
student1.display()
\end{lstlisting}

\begin{itemize}
    \item \keyword{Class}: Attributes અને methods વ્યાખ્યાયિત કરતું template
    \item \keyword{Object}: વાસ્તવિક values સાથેનું instance
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Class = Cookie Cutter, Object = વાસ્તવિક Cookie
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Simple nested loop અને numpy module નો ઉપયોગ કરીને બે matrix multiplication માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Matrix Multiplication}]
# Method 1: Simple Nested Loop નો ઉપયોગ
def matrix_multiply_nested(A, B):
    rows_A, cols_A = len(A), len(A[0])
    rows_B, cols_B = len(B), len(B[0])
    
    # Result matrix initialize કરો
    result = [[0 for _ in range(cols_B)] for _ in range(rows_A)]
    
    # Matrix multiplication
    for i in range(rows_A):
        for j in range(cols_B):
            for k in range(cols_A):
                result[i][j] += A[i][k] * B[k][j]
    
    return result

# Method 2: NumPy નો ઉપયોગ
import numpy as np

def matrix_multiply_numpy(A, B):
    A_np = np.array(A)
    B_np = np.array(B)
    return np.dot(A_np, B_np)

# ઉદાહરણ
A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]

print("Nested Loop Result:", matrix_multiply_nested(A, B))
print("NumPy Result:", matrix_multiply_numpy(A, B))
\end{lstlisting}

\begin{itemize}
    \item \keyword{Nested Loop}: Row, column અને multiplication માટે ત્રણ loops
    \item \keyword{NumPy}: કાર્યક્ષમ multiplication માટે built-in dot() function
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Row $\times$ Column = Result
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Array ના basic operations માટે એક પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Array Operations}]
import array

# Array બનાવો
arr = array.array('i', [1, 2, 3, 4, 5])

def array_operations():
    print("મૂળ array:", arr)
    
    # Element insert કરો
    arr.insert(2, 10)
    print("insert(2, 10) પછી:", arr)
    
    # Element append કરો
    arr.append(6)
    print("append(6) પછી:", arr)
    
    # Element remove કરો
    arr.remove(10)
    print("remove(10) પછી:", arr)
    
    # Element pop કરો
    popped = arr.pop()
    print(f"Pop કરેલું element: {popped}, Array: {arr}")
    
    # Element શોધો
    index = arr.index(3)
    print(f"3 નું index: {index}")
    
    # Occurrences ગણો
    count = arr.count(2)
    print(f"2 નું count: {count}")

array_operations()
\end{lstlisting}

\begin{center}
\captionof{table}{Array Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Method} & \textbf{વર્ણન} \\
\hline
\textbf{Insert} & insert(index, value) & ચોક્કસ position પર element ઉમેરવું \\
\hline
\textbf{Append} & append(value) & છેડે element ઉમેરવું \\
\hline
\textbf{Remove} & remove(value) & પહેલું occurrence દૂર કરવું \\
\hline
\textbf{Pop} & pop() & છેલ્લું element દૂર કરીને return કરવું \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
IARP - Insert, Append, Remove, Pop
\end{mnemonicbox}

\questionmarks{2(a)}{3}{Big 'O' Notation સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Big O Complexity}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Notation} & \textbf{નામ} & \textbf{ઉદાહરણ} \\
\hline
\textbf{O(1)} & Constant & Array access \\
\hline
\textbf{O(n)} & Linear & Linear search \\
\hline
\textbf{O(n\textsuperscript{2})} & Quadratic & Bubble sort \\
\hline
\textbf{O(log n)} & Logarithmic & Binary search \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Big O}: એલ્ગોરિધમની time complexity ની upper bound વર્ણવે છે
    \item \keyword{હેતુ}: વિવિધ એલ્ગોરિધમની કાર્યક્ષમતાની તુલના કરવી
    \item \keyword{ધ્યાન}: Worst-case scenario analysis પર
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Big O = વૃદ્ધિના Big Order
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Class method અને static method વચ્ચે તફાવત લખી સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Method Types Comparison}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{Class Method} & \textbf{Static Method} \\
\hline
\textbf{Decorator} & @classmethod & @staticmethod \\
\hline
\textbf{પહેલું Parameter} & cls (class reference) & કોઈ ખાસ parameter નહીં \\
\hline
\textbf{Access} & Class variables ને access કરી શકે & Class/instance variables ને access કરી શકતું નથી \\
\hline
\textbf{ઉપયોગ} & Alternative constructors & Utility functions \\
\hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Class vs Static Method}]
class MyClass:
    class_var = "હું class variable છું"
    
    @classmethod
    def class_method(cls):
        return f"Class method accessing: {cls.class_var}"
    
    @staticmethod
    def static_method():
        return "Static method - કોઈ class access નથી"

# ઉપયોગ
print(MyClass.class_method())
print(MyClass.static_method())
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
Class method માં CLS છે, Static method STandalone છે
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Public અને private type derivation નો ઉપયોગ કરીને single level inheritance માટે class બનાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Single Level Inheritance}]
# Base class
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand          # Public attribute
        self._model = model         # Protected attribute
        self.__year = 2023          # Private attribute
    
    def start_engine(self):
        return f"{self.brand} engine શરૂ થયું"
    
    def _display_model(self):       # Protected method
        return f"Model: {self._model}"
    
    def __private_method(self):     # Private method
        return f"Year: {self.__year}"

# Derived class (Single level inheritance)
class Car(Vehicle):
    def __init__(self, brand, model, doors):
        super().__init__(brand, model)
        self.doors = doors
    
    def car_info(self):
        # Public અને protected members ને access કરી શકે
        return f"Car: {self.brand}, {self._display_model()}, Doors: {self.doors}"
    
    def demonstrate_access(self):
        print("Public access:", self.brand)
        print("Protected access:", self._model)
        # print("Private access:", self.__year)  # આ error આપશે

# ઉપયોગ
my_car = Car("Toyota", "Camry", 4)
print(my_car.car_info())
print(my_car.start_engine())
my_car.demonstrate_access()
\end{lstlisting}

\begin{itemize}
    \item \keyword{Public}: બધે accessible (brand)
    \item \keyword{Protected}: Class અને subclasses માં accessible (\_model)
    \item \keyword{Private}: માત્ર સમાન class માં accessible (\_\_year)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Public = બધા, Protected = કુટુંબ, Private = વ્યક્તિગત
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{Constructor ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Constructor Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{Method} & \textbf{હેતુ} \\
\hline
\textbf{Default} & \code{\_\_init\_\_(self)} & Default values સાથે initialize \\
\hline
\textbf{Parameterized} & \code{\_\_init\_\_(self, params)} & Custom values સાથે initialize \\
\hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Constructor Example}]
class Student:
    def __init__(self, name="અજ્ઞાત", age=18):  # Constructor
        self.name = name
        self.age = age
        print(f"Student {name} બનાવ્યો")
    
    def display(self):
        print(f"નામ: {self.name}, ઉંમર: {self.age}")

# Object creation automatically constructor ને call કરે છે
s1 = Student("Alice", 20)
s2 = Student()  # Default values ઉપયોગ કરે
\end{lstlisting}

\begin{itemize}
    \item \keyword{Constructor}: Object બનાવવામાં આવે ત્યારે call થતી special method
    \item \keyword{હેતુ}: Object attributes ને initialize કરવા
    \item \keyword{Automatic}: Object creation દરમિયાન automatically call થાય
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Constructor = Object નું જન્મ પ્રમાણપત્ર
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{Polymorphism દર્શાવવા માટે એક પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Polymorphism Example}]
# Base class
class Animal:
    def make_sound(self):
        pass

# Derived classes
class Dog(Animal):
    def make_sound(self):
        return "ભોંભોં!"

class Cat(Animal):
    def make_sound(self):
        return "મિયાઉં!"

class Cow(Animal):
    def make_sound(self):
        return "હંભા!"

# Polymorphism demonstration
def animal_sound(animal):
    return animal.make_sound()

# Objects બનાવવા
animals = [Dog(), Cat(), Cow()]

# સમાન method call, અલગ behavior
for animal in animals:
    print(f"{animal.__class__.__name__}: {animal_sound(animal)}")
\end{lstlisting}

\begin{center}
\captionof{table}{Polymorphism ના ફાયદા}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ફાયદો} & \textbf{વર્ણન} \\
\hline
\textbf{લવચીકતા} & સમાન interface, અલગ implementations \\
\hline
\textbf{જાળવણી} & નવા types ઉમેરવા સહેલા \\
\hline
\textbf{Code Reuse} & વિવિધ objects માટે સામાન્ય interface \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Poly = ઘણા, Morph = સ્વરૂપો
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Multiple અને hierarchical inheritance નો ઉપયોગ કરી પાયથોન પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Inheritance Types}]
# Multiple Inheritance
class Teacher:
    def __init__(self, subject):
        self.subject = subject
    
    def teach(self):
        return f"{self.subject} શીખવાડવું"

class Researcher:
    def __init__(self, field):
        self.field = field
    
    def research(self):
        return f"{self.field} માં સંશોધન કરવું"

# Multiple inheritance
class Professor(Teacher, Researcher):
    def __init__(self, name, subject, field):
        self.name = name
        Teacher.__init__(self, subject)
        Researcher.__init__(self, field)
    
    def profile(self):
        return f"પ્રોફેસર {self.name}: {self.teach()} અને {self.research()}"

# Hierarchical Inheritance
class Vehicle:
    def __init__(self, brand):
        self.brand = brand
    
    def start(self):
        return f"{self.brand} શરૂ થયું"

class Car(Vehicle):
    def drive(self):
        return f"{self.brand} કાર ચાલે છે"

class Bike(Vehicle):
    def ride(self):
        return f"{self.brand} બાઇક ચાલે છે"

# ઉપયોગ
prof = Professor("સ્મિથ", "પાયથોન", "AI")
print(prof.profile())

car = Car("Honda")
bike = Bike("Yamaha")
print(car.drive())
print(bike.ride())
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[level 1/.style={sibling distance=2cm}, level 2/.style={sibling distance=1cm}]
    % Multiple Inheritance
    \node at (-3,0) {Multiple Inheritance};
    \node (T) at (-3.5,-1) {Teacher};
    \node (R) at (-2.5,-1) {Researcher};
    \node (P) at (-3,-2.5) {Professor};
    \draw (T) -- (P);
    \draw (R) -- (P);

    % Hierarchical Inheritance
    \node at (2,0) {Hierarchical Inheritance};
    \node (V) at (2,-1) {Vehicle};
    \node (C) at (1,-2.5) {Car};
    \node (B) at (3,-2.5) {Bike};
    \draw (V) -- (C);
    \draw (V) -- (B);
\end{tikzpicture}
\captionof{figure}{Inheritance Types}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Multiple = ઘણા માતા-પિતા, Hierarchical = વૃક્ષ માળખું
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Stack પર Push અને Pop operations સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Stack Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{વર્ણન} & \textbf{Time Complexity} \\
\hline
\textbf{Push} & ટોચ પર element ઉમેરવું & O(1) \\
\hline
\textbf{Pop} & ટોચેથી element દૂર કરવું & O(1) \\
\hline
\textbf{Peek/Top} & ટોચનું element જોવું & O(1) \\
\hline
\textbf{isEmpty} & Stack ખાલી છે કે નહીં તપાસવું & O(1) \\
\hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Stack Push-Pop}]
stack = []

# Push operation
stack.append(10)  # 10 Push કરો
stack.append(20)  # 20 Push કરો
print("Push પછી:", stack)  # [10, 20]

# Pop operation
item = stack.pop()  # 20 Pop કરો
print(f"Pop કર્યું: {item}, Stack: {stack}")  # [10]
\end{lstlisting}

\begin{itemize}
    \item \keyword{LIFO}: Last In, First Out સિદ્ધાંત
    \item \keyword{ટોચ}: Operations માટે માત્ર accessible element
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Stack = થાળીઓનો ઢગલો - છેલ્લી થાળી અંદર, પહેલી થાળી બહાર
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Queue ના Enqueue અને Dequeue operations સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Queue Operations}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Operation} & \textbf{વર્ણન} & \textbf{સ્થાન} & \textbf{Time Complexity} \\
\hline
\textbf{Enqueue} & Element ઉમેરવું & પાછળ & O(1) \\
\hline
\textbf{Dequeue} & Element દૂર કરવું & આગળ & O(1) \\
\hline
\textbf{Front} & આગળનું element જોવું & આગળ & O(1) \\
\hline
\textbf{Rear} & પાછળનું element જોવું & પાછળ & O(1) \\
\hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Queue Enqueue-Dequeue}]
from collections import deque

queue = deque()

# Enqueue operation
queue.append(10)  # 10 Enqueue કરો
queue.append(20)  # 20 Enqueue કરો
print("Enqueue પછી:", list(queue))  # [10, 20]

# Dequeue operation
item = queue.popleft()  # 10 Dequeue કરો
print(f"Dequeue કર્યું: {item}, Queue: {list(queue)}")  # [20]
\end{lstlisting}

\begin{itemize}
    \item \keyword{FIFO}: First In, First Out સિદ્ધાંત
    \item \keyword{બે છેડા}: આગળ removal માટે, પાછળ insertion માટે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Queue = દુકાનમાં લાઇન - પહેલો વ્યક્તિ અંદર, પહેલો વ્યક્તિ બહાર
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Stack ની વિવિધ applications સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Stack Applications}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Application} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\
\hline
\textbf{Expression Evaluation} & Infix ને postfix માં રૂપાંતર & (a+b)*c $\rightarrow$ ab+c* \\
\hline
\textbf{Function Calls} & Function call sequence manage કરવું & Recursion handling \\
\hline
\textbf{Undo Operations} & તાજેતરની ક્રિયાઓ ઉલટાવવી & Text editor undo \\
\hline
\textbf{Browser History} & Pages દ્વારા પાછળ navigate કરવું & Back button \\
\hline
\textbf{Parentheses Matching} & Balanced brackets ચકાસવા & \{[()]\} validation \\
\hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Parentheses Matching}]
# ઉદાહરણ: Parentheses matching
def is_balanced(expression):
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}
    
    for char in expression:
        if char in pairs:  # Opening bracket
            stack.append(char)
        elif char in pairs.values():  # Closing bracket
            if not stack:
                return False
            if pairs[stack.pop()] != char:
                return False
    
    return len(stack) == 0

# ટેસ્ટ
print(is_balanced("({[]})"))  # True
print(is_balanced("({[}])"))  # False
\end{lstlisting}

\begin{itemize}
    \item \keyword{Memory Management}: Programming માં function call stack
    \item \keyword{Backtracking}: Maze solving, game algorithms
    \item \keyword{Compiler Design}: Syntax analysis અને parsing
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Stack Applications = UFPB (Undo, Function, Parentheses, Browser)
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{Single Queue ની મર્યાદાઓની યાદી બનાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Single Queue Limitations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{મર્યાદા} & \textbf{વર્ણન} & \textbf{સમસ્યા} \\
\hline
\textbf{Memory Wastage} & આગળની જગ્યા અનુપયોગી બને છે & અકાર્યક્ષમ memory ઉપયોગ \\
\hline
\textbf{Fixed Size} & Dynamically resize કરી શકાતું નથી & જગ્યાની મર્યાદા \\
\hline
\textbf{False Overflow} & આગળની જગ્યા ખાલી હોવા છતાં queue ભરેલી લાગે & અકાળે capacity limit \\
\hline
\textbf{No Reuse} & Dequeue કરેલી positions ફરીથી વાપરી શકાતી નથી & Linear space utilization \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}
    \coordinate (A) at (0,0);
    \foreach \i/\val in {0/X, 1/X, 2/3, 3/4, 4/5, 5/, 6/, 7/} {
        \draw (\i,0) rectangle ++(1,1);
        \node at (\i+0.5, 0.5) {\val};
    }
    \node at (0.5, -0.3) {$\uparrow$};
    \node at (0.5, -0.6) {Front};
    \node at (2.5, -0.3) {$\uparrow$};
    \node at (4.5, -0.3) {$\uparrow$};
    \node at (4.5, -0.6) {Rear};
    
    \node[align=center] at (1, -1) {બગાડેલી જગ્યા\\(ફરીથી વાપરી શકાતી નથી)};
\end{tikzpicture}
\captionof{figure}{Single Queue Problem}
\end{center}

\begin{itemize}
    \item \keyword{Linear Implementation}: Dequeue કરેલી જગ્યા utilize કરી શકાતી નથી
    \item \keyword{Static Array}: Fixed size allocation
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Single Queue = એક બાજુનો રસ્તો (પાછા ફરી શકાતા નથી)
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Circular અને simple queues નો તફાવત લખી સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Queue Types Comparison}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{Simple Queue} & \textbf{Circular Queue} \\
\hline
\textbf{Memory Usage} & Linear, wasteful & Circular, efficient \\
\hline
\textbf{Space Reuse} & Dequeue કરેલી જગ્યા ફરીથી વાપરાતી નથી & બધી positions ફરીથી વાપરે છે \\
\hline
\textbf{Overflow} & False overflow શક્ય & માત્ર true overflow \\
\hline
\textbf{Implementation} & Front અને rear pointers & Modulo સાથે front અને rear \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}
    % Simple Queue
    \node at (2, 2) {Simple Queue};
    \draw (0,1) rectangle (4,1.5);
    \foreach \x in {1,2,3} \draw (\x,1) -- (\x,1.5);
    \node at (0.5,1.25) {X}; \node at (1.5,1.25) {X};
    \node at (2.5,1.25) {3}; \node at (3.5,1.25) {4};
    \node[below] at (0.5,1) {F}; \node[below] at (3.5,1) {R};

    % Circular Queue
    \node at (7, 2) {Circular Queue};
    \foreach \i in {0,1,2,3} {
        \node[draw, circle, minimum size=0.8cm] (c\i) at ({6+1.5*cos(90-90*\i)}, {1+1.5*sin(90-90*\i)}) {};
    }
    \node at (c0) {5}; \node at (c1) {6}; \node at (c2) {3}; \node at (c3) {4};
    \draw[->] (c0) -- (c1); \draw[->] (c1) -- (c2); \draw[->] (c2) -- (c3); \draw[->] (c3) -- (c0);
    \node[above] at (c2.north) {Front};
    \node[above] at (c1.north) {Rear};
\end{tikzpicture}
\captionof{figure}{Simple vs Circular Queue}
\end{center}

\begin{lstlisting}[language=Python,caption={Circular Queue Implementation}]
class CircularQueue:
    def __init__(self, size):
        self.size = size
        self.queue = [None] * size
        self.front = -1
        self.rear = -1
    
    def enqueue(self, item):
        if (self.rear + 1) % self.size == self.front:
            print("Queue ભરાઈ ગયું")
            return
        if self.front == -1:
            self.front = 0
        self.rear = (self.rear + 1) % self.size
        self.queue[self.rear] = item
    
    def dequeue(self):
        if self.front == -1:
            print("Queue ખાલી છે")
            return None
        item = self.queue[self.front]
        if self.front == self.rear:
            self.front = self.rear = -1
        else:
            self.front = (self.front + 1) % self.size
        return item
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
Circular = Ring Road (સતત), Simple = મૃત અંતનો રસ્તો
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{નીચેની infix expression ને postfix માં રૂપાંતર કરો: (a * b) * (c \^{} (d + e) - f)}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Operator Precedence}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operator} & \textbf{Precedence} & \textbf{Associativity} \\
\hline
\textbf{\^{}} & 3 & Right to Left \\
\hline
\textbf{*, /} & 2 & Left to Right \\
\hline
\textbf{+, -} & 1 & Left to Right \\
\hline
\end{tabulary}
\end{center}

\textbf{Step-by-step conversion:}

\begin{enumerate}
    \item (a * b) $\rightarrow$ ab*
    \item (d + e) $\rightarrow$ de+
    \item c \^{} (de+) $\rightarrow$ c de+ \^{}
    \item (c de+ \^{}) – f $\rightarrow$ c de+ \^{} f -
    \item (ab*) * (c de+ \^{} f -) $\rightarrow$ ab* c de+ \^{} f - *
\end{enumerate}

\textbf{અંતિમ જવાબ: ab*cde+\^{}f-*}

\begin{lstlisting}[language=Python,caption={Infix to Postfix}]
def infix_to_postfix(expression):
    precedence = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    stack = []
    output = []
    
    for char in expression:
        if char.isalnum():
            output.append(char)
        elif char == '(':
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()  # '(' દૂર કરો
        elif char in precedence:
            while (stack and stack[-1] != '(' and 
                   stack[-1] in precedence and
                   precedence[stack[-1]] >= precedence[char]):
                output.append(stack.pop())
            stack.append(char)
    
    while stack:
        output.append(stack.pop())
    
    return ''.join(output)

# ટેસ્ટ
result = infix_to_postfix("(a*b)*(c^(d+e)-f)")
print("Postfix:", result)  # ab*cde+^f-*
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
Precedence માટે PEMDAS, Operators માટે Stack
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Linked List ના પ્રકારો સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Linked List Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વર્ણન} & \textbf{મુખ્ય વિશેષતા} \\
\hline
\textbf{Singly Linked} & Next node નો એક pointer & માત્ર આગળ traversal \\
\hline
\textbf{Doubly Linked} & Next અને previous નાં pointers & બંને દિશામાં traversal \\
\hline
\textbf{Circular Linked} & છેલ્લો node પહેલાને point કરે & કોઈ NULL pointer નથી \\
\hline
\textbf{Doubly Circular} & Doubly + Circular features & બંને દિશા + circular \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}
    % Singly
    \node at (0,3) {Singly:};
    \foreach \i in {0,1,2} \draw (\i*1.5, 3) rectangle ++(1,0.5) node[midway] {D};
    \draw[->] (1,3.25) -- (1.5,3.25); \draw[->] (2.5,3.25) -- (3,3.25); \draw[->] (4,3.25) -- (4.5,3.25) node[right] {NULL};
    
    % Doubly
    \node at (0,2) {Doubly:};
    \foreach \i in {0,1,2} \draw (\i*1.5, 2) rectangle ++(1,0.5) node[midway] {D};
    \draw[<->] (1,2.25) -- (1.5,2.25); \draw[<->] (2.5,2.25) -- (3,2.25);
    \node at (-0.5,2.25) {NULL}; \draw[<-] (0,2.25) -- (-0.2,2.25);
    \draw[->] (4,2.25) -- (4.5,2.25) node[right] {NULL};

    % Circular
    \node at (0,1) {Circular:};
    \foreach \i in {0,1,2} \draw (\i*1.5, 1) rectangle ++(1,0.5) node[midway] {D};
    \draw[->] (1,1.25) -- (1.5,1.25); \draw[->] (2.5,1.25) -- (3,1.25);
    \draw[->] (4,1.25) -- (4.2,1.25) -- (4.2,0.8) -- (0.5,0.8) -- (0.5,1);
\end{tikzpicture}
\captionof{figure}{Linked List Types}
\end{center}

\begin{itemize}
    \item \keyword{Memory}: દરેક node માં data અને pointer(s) હોય છે
    \item \keyword{Dynamic}: Runtime દરમિયાન size બદલાઈ શકે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
SDCD - Singly, Doubly, Circular, Doubly-Circular
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Circular linked list અને singly linked list નો તફાવત લખી સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Singly vs Circular Linked List}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{Singly Linked List} & \textbf{Circular Linked List} \\
\hline
\textbf{છેલ્લો Node} & NULL ને point કરે & પહેલા node ને point કરે \\
\hline
\textbf{Traversal} & NULL પર અંત આવે & સતત loop \\
\hline
\textbf{Memory} & છેલ્લો node NULL store કરે & કોઈ NULL pointer નથી \\
\hline
\textbf{Detection} & NULL માટે check કરો & શરૂઆતના node માટે check કરો \\
\hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Singly vs Circular Traversal}]
# Singly Linked List Node
class SinglyNode:
    def __init__(self, data):
        self.data = data
        self.next = None

# Circular Linked List Node
class CircularNode:
    def __init__(self, data):
        self.data = data
        self.next = None

def traverse_singly(head):
    current = head
    while current:  # NULL પર અટકે
        print(current.data)
        current = current.next

def traverse_circular(head):
    if not head:
        return
    current = head
    while True:
        print(current.data)
        current = current.next
        if current == head:  # શરૂઆતમાં પાછા
            break
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
Singly = મૃત અંત, Circular = Race Track
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Singly linked list માં નીચેની કામગીરી કરવા માટે એક પ્રોગ્રામનો અમલ કરો: a. Singly linked list ની શરૂઆતમાં node દાખલ કરો. b. Singly linked list ના અંતે node દાખલ કરો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Singly Linked List Insertion}]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None
    
    def insert_at_beginning(self, data):
        """શરૂઆતમાં node insert કરો"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        print(f"{data} શરૂઆતમાં insert કર્યું")
    
    def insert_at_end(self, data):
        """અંતે node insert કરો"""
        new_node = Node(data)
        
        if not self.head:  # ખાલી list
            self.head = new_node
            print(f"{data} અંતે insert કર્યું (પહેલો node)")
            return
        
        # છેલ્લા node સુધી traverse કરો
        current = self.head
        while current.next:
            current = current.next
        
        current.next = new_node
        print(f"{data} અંતે insert કર્યું")
    
    def display(self):
        """Linked list દર્શાવો"""
        if not self.head:
            print("List ખાલી છે")
            return
        
        current = self.head
        elements = []
        while current:
            elements.append(str(current.data))
            current = current.next
        
        print(" -> ".join(elements) + " -> NULL")

# ઉપયોગનું ઉદાહરણ
sll = SinglyLinkedList()

# શરૂઆતમાં insert કરો
sll.insert_at_beginning(10)
sll.insert_at_beginning(20)
sll.display()  # 20 -> 10 -> NULL

# અંતે insert કરો
sll.insert_at_end(30)
sll.insert_at_end(40)
sll.display()  # 20 -> 10 -> 30 -> 40 -> NULL
\end{lstlisting}

\begin{center}
\captionof{table}{Insertion Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Time Complexity} & \textbf{પગલાં} \\
\hline
\textbf{શરૂઆત} & O(1) & 1. Node બનાવો 2. Head ને point કરો 3. Head update કરો \\
\hline
\textbf{અંત} & O(n) & 1. Node બનાવો 2. અંત સુધી traverse કરો 3. છેલ્લો node link કરો \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
શરૂઆત = ઝડપથી (O(1)), અંત = પ્રવાસ (O(n))
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{Doubly linked list સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Doubly Linked List Features}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{વિશેષતા} & \textbf{વર્ણન} \\
\hline
\textbf{બે Pointers} & દરેક node માં prev અને next \\
\hline
\textbf{Bidirectional} & આગળ અને પાછળ બંને તરફ traverse કરી શકાય \\
\hline
\textbf{Memory} & prev pointer માટે વધારાની જગ્યા \\
\hline
\textbf{લવચીકતા} & ગમે ત્યાં insertion/deletion સહેલું \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}
    \node (null1) at (-1.5,0) {NULL};
    \foreach \i/\val in {0/A, 1/B, 2/C} {
        \draw (\i*2,0) rectangle ++(1.5,0.7) node[midway] {\val};
        \node[font=\tiny] at (\i*2+0.25, 0.15) {prev};
        \node[font=\tiny] at (\i*2+1.25, 0.15) {next};
    }
    \node (null2) at (6,0.35) {NULL};
    
    \draw[<-] (0,0.35) -- (null1);
    \draw[<->] (1.5,0.35) -- (2,0.35);
    \draw[<->] (3.5,0.35) -- (4,0.35);
    \draw[->] (5.5,0.35) -- (null2);
\end{tikzpicture}
\captionof{figure}{Doubly Linked List Structure}
\end{center}

\begin{itemize}
    \item \keyword{ફાયદા}: Bidirectional traversal, સહેલું deletion
    \item \keyword{નુકસાન}: prev pointer માટે વધારાની મેમરી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Doubly = બે બાજુનો રસ્તો
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Linked List ની applications નું વર્ણન કરો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Linked List Applications}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Application} & \textbf{Use Case} & \textbf{ફાયદો} \\
\hline
\textbf{Dynamic Arrays} & જ્યારે size બદલાતું રહે & કાર્યક્ષમ memory usage \\
\hline
\textbf{Stack/Queue} & LIFO/FIFO operations & Dynamic size \\
\hline
\textbf{Graphs} & Adjacency list representation & Space efficient \\
\hline
\textbf{Music Playlist} & પાછલા/આગલા ગીતો & સહેલું navigation \\
\hline
\textbf{Browser History} & Back/Forward navigation & Dynamic history \\
\hline
\textbf{Undo Operations} & Text editors & કાર્યક્ષમ undo/redo \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
Linked Lists = Dynamic, લવચીક, જોડાયેલ
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{Merge Sort algorithm નો પ્રોગ્રામ લખી સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Merge Sort Implementation}]
def merge_sort(arr):
    """Merge Sort implementation"""
    if len(arr) <= 1:
        return arr
    
    # Array ને બે ભાગમાં વહેંચો
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    # બંને ભાગો recursively sort કરો
    left_sorted = merge_sort(left_half)
    right_sorted = merge_sort(right_half)
    
    # Sorted ભાગોને merge કરો
    return merge(left_sorted, right_sorted)

def merge(left, right):
    """બે sorted arrays ને merge કરો"""
    result = []
    i = j = 0
    
    # Elements compare કરીને merge કરો
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # બાકીના elements ઉમેરો
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# ઉદાહરણ
def demonstrate_merge_sort():
    arr = [64, 34, 25, 12, 22, 11, 90]
    print("મૂળ array:", arr)
    
    sorted_arr = merge_sort(arr)
    print("Sorted array:", sorted_arr)

demonstrate_merge_sort()
\end{lstlisting}

\begin{center}
\captionof{table}{Merge Sort Analysis}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પાસું} & \textbf{મૂલ્ય} \\
\hline
\textbf{Time Complexity} & O(n log n) \\
\hline
\textbf{Space Complexity} & O(n) \\
\hline
\textbf{Stability} & Stable \\
\hline
\textbf{પ્રકાર} & Divide and Conquer \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{વિભાજન}: Array ને બે ભાગમાં વહેંચો
    \item \keyword{જીત}: બંને ભાગો recursively sort કરો
    \item \keyword{જોડાણ}: Sorted ભાગોને merge કરો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Merge Sort = વહેંચો, ગોઠવો, જોડો
\end{mnemonicbox}

\questionmarks{5(a)}{3}{Binary tree ની applications નું વર્ણન કરો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Binary Tree Applications}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Application} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\
\hline
\textbf{Expression Trees} & ગાણિતિક expression representation & (a+b)*c \\
\hline
\textbf{Decision Trees} & AI/ML માં decision making & Classification algorithms \\
\hline
\textbf{File Systems} & Directory structure organization & Folder hierarchy \\
\hline
\textbf{Database Indexing} & કાર્યક્ષમ searching માટે B-trees & Database indices \\
\hline
\textbf{Huffman Coding} & Data compression technique & File compression \\
\hline
\textbf{Heap Operations} & Priority queues implementation & Task scheduling \\
\hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{વંશવેલો Data}: Tree-like structures ને કુદરતી રીતે represent કરે
    \item \keyword{કાર્યક્ષમ Search}: Binary search trees O(log n) operations આપે
    \item \keyword{Memory Management}: Compiler design માં syntax trees માટે વપરાય
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Binary Trees = EDFDHH (Expression, Decision, File, Database, Huffman, Heap)
\end{mnemonicbox}

\questionmarks{5(b)}{4}{ઉદાહરણ સાથે binary tree ની Indegree અને Outdegree સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Degree Definitions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શબ્દ} & \textbf{વ્યાખ્યા} & \textbf{Binary Tree Value} \\
\hline
\textbf{Indegree} & Node માં આવતા edges ની સંખ્યા & 0 (root) અથવા 1 (બાકી) \\
\hline
\textbf{Outdegree} & Node માંથી જતા edges ની સંખ્યા & 0, 1, અથવા 2 \\
\hline
\textbf{Degree} & Node સાથે જોડાયેલા કુલ edges & Indegree + Outdegree \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[level 1/.style={sibling distance=3cm}, level 2/.style={sibling distance=1.5cm}]
    \node[circle, draw] {A}
        child {node[circle, draw] {B}
            child {node[circle, draw] {D}}
            child[missing]
        }
        child {node[circle, draw] {C}
            child {node[circle, draw] {E}}
            child[missing]
        };
\end{tikzpicture}
\captionof{figure}{Binary Tree ઉદાહરણ}
\end{center}

\begin{center}
\captionof{table}{ઉદાહરણ Analysis}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Node} & \textbf{Indegree} & \textbf{Outdegree} & \textbf{Node Type} \\
\hline
A & 0 & 2 & Root \\
\hline
B & 1 & 1 & Internal \\
\hline
C & 1 & 1 & Internal \\
\hline
D & 1 & 0 & Leaf \\
\hline
E & 1 & 0 & Leaf \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
In = અંદર આવતા, Out = બહાર જતા
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Binary search tree બનાવવા માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{lstlisting}[language=Python,caption={Binary Search Tree Construction}]
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        """BST માં node insert કરો"""
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self._insert_recursive(self.root, data)
    
    def _insert_recursive(self, node, data):
        if data < node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self._insert_recursive(node.left, data)
        elif data > node.data:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self._insert_recursive(node.right, data)
    
    def search(self, data):
        """BST માં node શોધો"""
        return self._search_recursive(self.root, data)
    
    def _search_recursive(self, node, data):
        if node is None or node.data == data:
            return node
        
        if data < node.data:
            return self._search_recursive(node.left, data)
        else:
            return self._search_recursive(node.right, data)
    
    def inorder_traversal(self):
        """Inorder traversal (ડાબે, રૂટ, જમણે)"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.data)
            self._inorder_recursive(node.right, result)

# ઉદાહરણ
bst = BinarySearchTree()
values = [50, 30, 70, 20, 40, 60, 80]

print("મૂલ્યો insert કરી રહ્યા છીએ:", values)
for value in values:
    bst.insert(value)

print("\nInorder traversal:", bst.inorder_traversal())
\end{lstlisting}

\begin{center}
\captionof{table}{BST Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Time Complexity} & \textbf{વર્ણન} \\
\hline
\textbf{Insert} & O(log n) average, O(n) worst & નવો node ઉમેરો \\
\hline
\textbf{Search} & O(log n) average, O(n) worst & ચોક્કસ node શોધો \\
\hline
\textbf{Delete} & O(log n) average, O(n) worst & Node દૂર કરો \\
\hline
\textbf{Traversal} & O(n) & બધા nodes ની મુલાકાત \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
BST નિયમ = ડાબે < રૂટ < જમણે
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{Binary tree માં level, degree અને leaf node વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Binary Tree શબ્દો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શબ્દ} & \textbf{વ્યાખ્યા} & \textbf{ઉદાહરણ} \\
\hline
\textbf{Level} & Root થી અંતર (root = level 0) & Root=0, Children=1, વગેરે \\
\hline
\textbf{Degree} & Node ના children ની સંખ્યા & 0, 1, અથવા 2 \\
\hline
\textbf{Leaf Node} & કોઈ children વગરનો node (degree = 0) & Terminal nodes \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[level 1/.style={sibling distance=2cm}, level 2/.style={sibling distance=1cm}]
    \node[circle, draw] {A}
        child {node[circle, draw] {B}
            child {node[circle, draw] {D}}
            child {node[circle, draw] {E}}
        }
        child {node[circle, draw] {C}
            child {node[circle, draw] {F}}
            child[missing]
        };
\end{tikzpicture}
\captionof{figure}{Levels સાથે Binary Tree}
\end{center}

\begin{itemize}
    \item \keyword{Height}: Tree માં મહત્તમ level
    \item \keyword{Depth}: એક node માટે level જેટલું જ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
Level = માળનો નંબર, Degree = બાળકોની ગણતરી, Leaf = કોઈ બાળક નથી
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{ઉદાહરણ સાથે complete binary tree સમજાવો.}

\begin{solutionbox}
\textbf{જવાબ}:

\begin{center}
\captionof{table}{Binary Tree પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વર્ણન} & \textbf{ગુણધર્મ} \\
\hline
\textbf{Complete} & છેલ્લા સિવાય બધા levels ભરેલા, ડાબેથી ભરાય & કાર્યક્ષમ array representation \\
\hline
\textbf{Full} & દરેક node પાસે 0 અથવા 2 children & એક child વાળા nodes નથી \\
\hline
\textbf{Perfect} & બધા levels સંપૂર્ણ ભરેલા & 2\textsuperscript{h} - 1 nodes \\
\hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[scale=0.8]
    \node at (0,3) {Complete};
    \node[circle,draw] at (0,2) {A}
        child {node[circle,draw] {B} child {node[circle,draw] {D}} child {node[circle,draw] {E}}}
        child {node[circle,draw] {C} child {node[circle,draw] {F}} child[missing]};

    \node at (5,3) {Complete નથી};
    \node[circle,draw] at (5,2) {A}
        child {node[circle,draw] {B} child[missing] child {node[circle,draw] {E}}}
        child {node[circle,draw] {C} child {node[circle,draw] {F}} child[missing]};
\end{tikzpicture}
\captionof{figure}{Complete vs Non-Complete Binary Tree}
\end{center}

\begin{lstlisting}[language=Python,caption={Complete Binary Tree Structure}]
class CompleteBinaryTree:
    def __init__(self):
        self.tree = []
    
    def insert(self, data):
        """Complete binary tree રીતે insert કરો"""
        self.tree.append(data)
    
    def get_parent_index(self, i):
        return (i - 1) // 2
    
    def get_left_child_index(self, i):
        return 2 * i + 1
    
    def get_right_child_index(self, i):
        return 2 * i + 2
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
Complete = છેલ્લા સિવાય બધા માળ ભરેલા, ડાબેથી જમણે ભરાય
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{નીચેના નંબરોના ક્રમ માટે binary search tree (BST) બનાવો: 50, 70, 60, 20, 90, 10, 40, 100}

\begin{solutionbox}
\textbf{જવાબ}:

\textbf{Step-by-step BST Construction:}

\begin{enumerate}
    \item Insert 50: Root
    \item Insert 70: $70 > 50 \rightarrow$ જમણે
    \item Insert 60: $60 > 50 \rightarrow$ જમણે, $60 < 70 \rightarrow$ ડાબે
    \item Insert 20: $20 < 50 \rightarrow$ ડાબે
    \item Insert 90: $90 > 50 \rightarrow$ જમણે, $90 > 70 \rightarrow$ જમણે
    \item Insert 10: $10 < 50 \rightarrow$ ડાબે, $10 < 20 \rightarrow$ ડાબે
    \item Insert 40: $40 < 50 \rightarrow$ ડાબે, $40 > 20 \rightarrow$ જમણે
    \item Insert 100: $100 > 50 \rightarrow$ જમણે... $100 > 90 \rightarrow$ જમણે
\end{enumerate}

\begin{center}
\begin{tikzpicture}[level 1/.style={sibling distance=4cm}, level 2/.style={sibling distance=2cm}, level 3/.style={sibling distance=1cm}]
    \node[circle, draw] {50}
        child {node[circle, draw] {20}
            child {node[circle, draw] {10}}
            child {node[circle, draw] {40}}
        }
        child {node[circle, draw] {70}
            child {node[circle, draw] {60}}
            child {node[circle, draw] {90}
                child[missing]
                child {node[circle, draw] {100}}
            }
        };
\end{tikzpicture}
\captionof{figure}{અંતિમ BST માળખું}
\end{center}

\begin{lstlisting}[language=Python,caption={BST Construction}]
# BST બનાવો
bst = BST()
sequence = [50, 70, 60, 20, 90, 10, 40, 100]

for num in sequence:
    bst.insert(num)
\end{lstlisting}

\begin{center}
\captionof{table}{Traversal પરિણામો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Traversal} & \textbf{પરિણામ} \\
\hline
\textbf{Inorder} & 10, 20, 40, 50, 60, 70, 90, 100 \\
\hline
\textbf{Preorder} & 50, 20, 10, 40, 70, 60, 90, 100 \\
\hline
\textbf{Postorder} & 10, 40, 20, 60, 100, 90, 70, 50 \\
\hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
BST Construction = તુલના કરો, દિશા પસંદ કરો, Insert કરો
\end{mnemonicbox}

\end{document}
