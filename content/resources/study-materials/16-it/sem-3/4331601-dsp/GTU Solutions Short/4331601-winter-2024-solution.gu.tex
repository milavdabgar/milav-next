\documentclass{article}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{c:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{ડેટા સ્ટ્રક્ચર વિથ પાયથોન (4331601) - શિયાળો 2024 સોલ્યુશન}
\date{December 03, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{પાયથોનમાં સેટ ડેટા સ્ટ્રક્ચર સમજાવો?}
\begin{solutionbox}
    \keyword{Set} એ પાયથોનમાં અનન્ય એલિમેન્ટ્સનો અક્રમ સંગ્રહ છે. સેટ્સ mutable છે પરંતુ તેમાં ફક્ત immutable એલિમેન્ટ્સ જ હોય છે.

    \textbf{મુખ્ય લક્ષણો:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Set Properties}
        \centering
        \begin{tabulary}{\linewidth}{LC}
            \toprule
            \textbf{લક્ષણ} & \textbf{વર્ણન} \\
            \midrule
            \textbf{અનન્ય એલિમેન્ટ્સ} & કોઈ ડુપ્લિકેટ વેલ્યુઝ મંજૂર નથી \\
            \textbf{અક્રમ} & કોઈ ઇન્ડેક્સિંગ અથવા સ્લાઇસિંગ નથી \\
            \textbf{Mutable} & એલિમેન્ટ્સ ઉમેરી/દૂર કરી શકાય છે \\
            \textbf{Iterable} & એલિમેન્ટ્સમાં લૂપ ચલાવી શકાય છે \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{મૂળભૂત ઓપરેશન્સ:}
    \begin{lstlisting}[language=Python, caption=Set Operations]
# Create set
my_set = {1, 2, 3, 4}
# Add element
my_set.add(5)
# Remove element
my_set.remove(2)
    \end{lstlisting}

    \begin{mnemonicbox}
        "Sets are Unique Unordered Collections"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(b)}{4}{પાયથોનમાં Tuple ની વ્યાખ્યા આપો? પાયથોનમાં Tuple data structure ના operations સમજાવો.}
\begin{solutionbox}
    \keyword{Tuple} એ આઇટમ્સનો ક્રમિત સંગ્રહ છે જે immutable છે (બનાવ્યા પછી બદલી શકાતું નથી).

    \textbf{Tuple વ્યાખ્યા:}
    \begin{itemize}
        \item \textbf{ક્રમિત}: એલિમેન્ટ્સનો નિશ્ચિત ક્રમ
        \item \textbf{Immutable}: બનાવ્યા પછી બદલી શકાતું નથી
        \item \textbf{ડુપ્લિકેટ્સ મંજૂર}: સમાન વેલ્યુઝ આવી શકે છે
        \item \textbf{ઇન્ડેક્સ્ડ}: ઇન્ડેક્સ વાપરીને એક્સેસ કરી શકાય છે
    \end{itemize}

    \textbf{Tuple ઓપરેશન્સ:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Tuple Operations}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{ઓપરેશન} & \textbf{ઉદાહરણ} & \textbf{વર્ણન} \\
            \midrule
            \textbf{બનાવવું} & \code{t = (1, 2, 3)} & Tuple બનાવો \\
            \textbf{ઇન્ડેક્સિંગ} & \code{t[0]} & પ્રથમ એલિમેન્ટ એક્સેસ કરો \\
            \textbf{સ્લાઇસિંગ} & \code{t[1:3]} & સબસેટ મેળવો \\
            \textbf{લેન્થ} & \code{len(t)} & એલિમેન્ટ્સ ગણો \\
            \textbf{જોડાણ} & \code{t1 + t2} & Tuples જોડો \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{lstlisting}[language=Python, caption=Tuple Examples]
# Example operations
tup = (10, 20, 30, 40)
print(tup[1])      # Output: 20
print(tup[1:3])    # Output: (20, 30)
    \end{lstlisting}

    \begin{mnemonicbox}
        "Tuples are Immutable Ordered Collections"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(c)}{7}{પાયથોનમાં કન્સ્ટ્રક્ટરના પ્રકારો સમજાવો? Static methodનો ઉપયોગ કરીને બે સંખ્યાઓના ગુણાકાર માટે પાયથોન પ્રોગ્રામ લખો.}
\begin{solutionbox}
    \textbf{કન્સ્ટ્રક્ટરના પ્રકારો:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Constructor Types}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{કન્સ્ટ્રક્ટર પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉપયોગ} \\
            \midrule
            \textbf{Default Constructor} & કોઈ પેરામીટર નથી & \code{\_\_init\_\_(self)} \\
            \textbf{Parameterized Constructor} & પેરામીટર લે છે & \code{\_\_init\_\_(self, params)} \\
            \textbf{Non-parameterized Constructor} & ફક્ત self પેરામીટર & મૂળભૂત પ્રારંભિકરણ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Static Method પ્રોગ્રામ:}
    \begin{lstlisting}[language=Python, caption=Static Method for Multiplication]
class Calculator:
    def __init__(self):
        pass
    
    @staticmethod
    def multiply(num1, num2):
        return num1 * num2

# Usage
result = Calculator.multiply(5, 3)
print(f"Multiplication: {result}")  # Output: 15
    \end{lstlisting}

    \textbf{મુખ્ય મુદ્દાઓ:}
    \begin{itemize}
        \item \textbf{Static methods}: ઑબ્જેક્ટ ઇન્સ્ટન્સની જરૂર નથી
        \item \textbf{\@staticmethod decorator}: Static method દર્શાવે છે
        \item \textbf{કોઈ self પેરામીટર નથી}: ક્લાસ ઇન્સ્ટન્સથી સ્વતંત્ર
    \end{itemize}

    \begin{mnemonicbox}
        "Static methods Stand Separate from Self"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(c) અથવા}{7}{Data Encapsulation ની વ્યાખ્યા આપો? પાયથોનમાં વિવિધ પ્રકારની methods ની યાદી આપો. Multilevel inheritance માટે પાયથોન પ્રોગ્રામ લખો.}
\begin{solutionbox}
    \textbf{Data Encapsulation:}
    ડેટા એન્કેપ્સુલેશન એ ડેટા અને methods ને ક્લાસની અંદર બાંધવાની અને કેટલાક ઘટકોની સીધી પહોંચ મર્યાદિત કરવાની વિભાવના છે.

    \textbf{Methods ના પ્રકારો:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Method Types}
        \centering
        \begin{tabulary}{\linewidth}{LCc}
            \toprule
            \textbf{Method પ્રકાર} & \textbf{પહોંચ સ્તર} & \textbf{ઉદાહરણ} \\
            \midrule
            \textbf{Public} & બધે પહોંચી શકાય છે & \code{method()} \\
            \textbf{Protected} & ક્લાસ અને સબક્લાસ & \code{\_method()} \\
            \textbf{Private} & ફક્ત ક્લાસની અંદર & \code{\_\_method()} \\
            \textbf{Static} & ક્લાસ લેવલ & \code{\@staticmethod} \\
            \textbf{Class} & ક્લાસ અને સબક્લાસીઝ & \code{\@classmethod} \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{Multilevel Inheritance પ્રોગ્રામ:}
    \begin{lstlisting}[language=Python, caption=Multilevel Inheritance]
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(f"{self.name} makes sound")

class Mammal(Animal):
    def __init__(self, name, warm_blooded):
        super().__init__(name)
        self.warm_blooded = warm_blooded

class Dog(Mammal):
    def __init__(self, name, breed):
        super().__init__(name, True)
        self.breed = breed
    
    def bark(self):
        print(f"{self.name} barks")

# Usage
dog = Dog("Buddy", "Golden Retriever")
dog.speak()  # From Animal class
dog.bark()   # From Dog class
    \end{lstlisting}

    \begin{mnemonicbox}
        "Encapsulation Hides Internal Details"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(a)}{3}{Simple Queue અને Circular Queue વચ્ચેનો તફાવત આપો.}
\begin{solutionbox}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Simple vs Circular Queue}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{લક્ષણ} & \textbf{Simple Queue} & \textbf{Circular Queue} \\
            \midrule
            \textbf{સ્ટ્રક્ચર} & રેખીય ગોઠવણી & વર્તુળાકાર ગોઠવણી \\
            \textbf{મેમરી ઉપયોગ} & બગાડજનક (ખાલી જગ્યાઓ) & કાર્યક્ષમ (જગ્યા પુનઃઉપયોગ) \\
            \textbf{Rear Pointer} & રેખીય રીતે આગળ વધે છે & ફરીથી આગળ વળે છે \\
            \textbf{Front Pointer} & રેખીય રીતે આગળ વધે છે & ફરીથી આગળ વળે છે \\
            \textbf{જગ્યા ઉપયોગ} & નબળો & ઉત્તમ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{મુખ્ય તફાવતો:}
    \begin{itemize}
        \item \textbf{Simple Queue}: Front અને rear ફક્ત એક દિશામાં જાય છે
        \item \textbf{Circular Queue}: Rear ફરીથી front સ્થાને જોડાય છે
        \item \textbf{કાર્યક્ષમતા}: Circular queue મેમરી વેસ્ટેજ ટાળે છે
    \end{itemize}

    \begin{mnemonicbox}
        "Circular Queues Complete the Circle"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(b)}{4}{પાયથોનમાં પોલીમોર્ફિઝમ ઉદાહરણ સાથે સમજાવો.}
\begin{solutionbox}
    \keyword{Polymorphism} એટલે "અનેક સ્વરૂપો" - સમાન method નામ અલગ અલગ ક્લાસમાં અલગ રીતે વર્તે છે.

    \textbf{પોલીમોર્ફિઝમના પ્રકારો:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Polymorphism Types}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{પ્રકાર} & \textbf{વર્ણન} & \textbf{અમલીકરણ} \\
            \midrule
            \textbf{Method Overriding} & ચાઇલ્ડ ક્લાસ પેરેન્ટ method ફરીથી વ્યાખ્યાયિત કરે છે & Inheritance \\
            \textbf{Duck Typing} & અલગ ક્લાસમાં સમાન method & Interface સમાનતા \\
            \textbf{Operator Overloading} & સમાન ઓપરેટર અલગ વર્તન & Magic methods \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{lstlisting}[language=Python, caption=Polymorphism Example]
class Animal:
    def make_sound(self):
        pass

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

# Polymorphic behavior
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.make_sound())
    \end{lstlisting}

    \begin{mnemonicbox}
        "Polymorphism Provides Multiple Personalities"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(c)}{7}{વ્યાખ્યા આપો. a). Infix b).Postfix સ્ટેકનો ઉપયોગ કરીને આપેલ Infix expression ને Postfix expression માં ફેરવો. A+(B*C/D)}
\begin{solutionbox}
    \textbf{વ્યાખ્યાઓ:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Expression Types}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{Expression પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\
            \midrule
            \textbf{Infix} & ઓપરેટર ઓપરેન્ડ્સ વચ્ચે & \code{A + B} \\
            \textbf{Postfix} & ઓપરેટર ઓપરેન્ડ્સ પછી & \code{A B +} \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{રૂપાંતરણ એલ્ગોરિધમ:}
    \begin{enumerate}
        \item Infix expression ને ડાબેથી જમણે સ્કેન કરો.
        \item જો operand છે, આઉટપુટમાં ઉમેરો.
        \item જો operator છે, સ્ટેક ટોપ સાથે precedence સરખાવો.
        \item વધુ precedence $\rightarrow$ સ્ટેકમાં push કરો.
        \item ઓછી/સમાન precedence $\rightarrow$ pop કરીને આઉટપુટમાં ઉમેરો.
    \end{enumerate}

    \textbf{પગલાં પ્રમાણે રૂપાંતરણ: A+(B*C/D)}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Infix to Postfix Trace}
        \centering
        \begin{tabulary}{\linewidth}{C C L L}
            \toprule
            \textbf{પગલું} & \textbf{સિમ્બલ} & \textbf{સ્ટેક} & \textbf{આઉટપુટ} \\
            \midrule
            1 & A & [ ] & A \\
            2 & + & [+] & A \\
            3 & ( & [+, (] & A \\
            4 & B & [+, (] & AB \\
            5 & * & [+, (, *] & AB \\
            6 & C & [+, (, *] & ABC \\
            7 & / & [+, (, /] & ABC* \\
            8 & D & [+, (, /] & ABC*D \\
            9 & ) & [+] & ABC*D/ \\
            10 & અંત & [ ] & ABC*D/+ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{અંતિમ જવાબ:} \code{ABC*D/+}

    \begin{mnemonicbox}
        "Stack Stores Operators Strategically"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(a) અથવા}{3}{Queue ના ગેરફાયદા સમજાવો.}
\begin{solutionbox}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Queue Disadvantages}
        \centering
        \begin{tabulary}{\linewidth}{LLL}
            \toprule
            \textbf{ગેરફાયદો} & \textbf{વર્ણન} & \textbf{અસર} \\
            \midrule
            \textbf{મેમરી વેસ્ટેજ} & ખાલી જગ્યાઓ પુનઃઉપયોગ નથી & નબળો જગ્યા ઉપયોગ \\
            \textbf{નિયત કદ} & મર્યાદિત ક્ષમતા & Overflow સમસ્યાઓ \\
            \textbf{રેન્ડમ એક્સેસ નથી} & ફક્ત front/rear એક્સેસ & મર્યાદિત લવચીકતા \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{મુખ્ય સમસ્યાઓ:}
    \begin{itemize}
        \item \textbf{રેખીય Queue}: આગળની જગ્યાઓ અનુપયોગી બને છે
        \item \textbf{Insertion/Deletion}: ફક્ત ચોક્કસ છેડાઓથી
        \item \textbf{શોધ ઓપરેશન્સ}: શોધવા માટે કાર્યક્ષમ નથી
    \end{itemize}

    \begin{mnemonicbox}
        "Queues Quietly Queue with Quirks"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(b) અથવા}{4}{પાયથોનમાં Abstract class ની વ્યાખ્યા આપો? પાયથોનમાં abstract method નું declaration સમજાવો?}
\begin{solutionbox}
    \textbf{Abstract Class:}
    એક ક્લાસ જેનું instantiation કરી શકાતું નથી અને જેમાં એક અથવા વધુ abstract methods હોય છે જે સબક્લાસીઝ દ્વારા અમલ કરવા જોઈએ.

    \textbf{Abstract Method Declaration:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Abstract Methods}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{ઘટક} & \textbf{હેતુ} & \textbf{સિન્ટેક્સ} \\
            \midrule
            \textbf{ABC Module} & Abstract base class પ્રદાન કરે છે & \code{from abc import ABC} \\
            \textbf{@abstractmethod} & Abstract methods માટે decorator & \code{@abstractmethod} \\
            \textbf{અમલીકરણ} & સબક્લાસમાં ફરજિયાત override & આવશ્યક \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{lstlisting}[language=Python, caption=Abstract Class Example]
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width
    
    def perimeter(self):
        return 2 * (self.length + self.width)
    \end{lstlisting}

    \begin{mnemonicbox}
        "Abstract classes Are Blueprints Only"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(c) અથવા}{7}{Infix to postfix માટેનો અલ્ગોરિધમ લખો. નીચેની પોસ્ટફિક્સ એક્સપ્રેશન મૂલ્યાંકન કરો. 5 6 2 + * 12 4 / -}
\begin{solutionbox}
    \textbf{Infix to Postfix અલ્ગોરિધમ:}
    \begin{enumerate}
        \item ખાલી સ્ટેક અને આઉટપુટ સ્ટ્રિંગ પ્રારંભ કરો.
        \item ડાબેથી જમણે infix expression સ્કેન કરો.
        \item જો operand છે $\rightarrow$ આઉટપુટમાં ઉમેરો.
        \item જો '(' છે $\rightarrow$ સ્ટેકમાં push કરો.
        \item જો ')' છે $\rightarrow$ '(' સુધી pop કરો.
        \item જો operator છે $\rightarrow$ વધુ/સમાન precedence operators pop કરો.
        \item વર્તમાન operator સ્ટેકમાં push કરો.
        \item બાકીના operators pop કરો.
    \end{enumerate}

    \textbf{Postfix મૂલ્યાંકન: 5 6 2 + * 12 4 / -}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Postfix Evaluation Trace}
        \centering
        \begin{tabulary}{\linewidth}{C C L L}
            \toprule
            \textbf{પગલું} & \textbf{ટોકન} & \textbf{સ્ટેક} & \textbf{ઓપરેશન} \\
            \midrule
            1 & 5 & [5] & Operand push કરો \\
            2 & 6 & [5, 6] & Operand push કરો \\
            3 & 2 & [5, 6, 2] & Operand push કરો \\
            4 & + & [5, 8] & Pop 2, 6 $\rightarrow$ $6+2=8$ \\
            5 & * & [40] & Pop 8, 5 $\rightarrow$ $5*8=40$ \\
            6 & 12 & [40, 12] & Operand push કરો \\
            7 & 4 & [40, 12, 4] & Operand push કરો \\
            8 & / & [40, 3] & Pop 4, 12 $\rightarrow$ $12/4=3$ \\
            9 & - & [37] & Pop 3, 40 $\rightarrow$ $40-3=37$ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{અંતિમ પરિણામ: 37}

    \begin{mnemonicbox}
        "Postfix Processing Pops Pairs Precisely"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(a)}{3}{સિંગલ લિંક લિસ્ટમાં નોડને traverse કરવા માટે અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Traversal અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Linked List Traversal]
def traverse_linked_list(head):
    current = head
    while current is not None:
        print(current.data)
        current = current.next
    \end{lstlisting}

    \textbf{અલ્ગોરિધમ પગલાં:}
    \begin{enumerate}
        \item Head નોડથી શરૂ કરો.
        \item ચકાસો કે current $\neq$ NULL.
        \item વર્તમાન નોડ પ્રોસેસ કરો.
        \item આગલા નોડ પર જાઓ.
        \item અંત સુધી પુનરાવર્તન કરો.
    \end{enumerate}

    \begin{mnemonicbox}
        "Traverse Through Till The Tail"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(b)}{4}{લિસ્ટનો ઉપયોગ કરીને Queueના Dequeue ઓપરેશન માટેનો અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Dequeue અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Dequeue Operation]
def dequeue(queue):
    if len(queue) == 0:
        print("Queue is empty")
        return None
    else:
        element = queue.pop(0)
        return element
    \end{lstlisting}

    \textbf{અલ્ગોરિધમ પગલાં:}
    \begin{enumerate}
        \item ખાલી ચકાસો: જો queue ખાલી છે.
        \item Underflow હેન્ડલ કરો: એરર મેસેજ દર્શાવો.
        \item એલિમેન્ટ દૂર કરો: આગળનું એલિમેન્ટ ડિલીટ કરો.
        \item એલિમેન્ટ પરત કરો: દૂર કરેલી વેલ્યુ પરત કરો.
        \item સ્ટ્રક્ચર અપડેટ કરો: Queue pointers એડજસ્ટ કરો.
    \end{enumerate}

    \textbf{Time Complexity:} $O(n)$ લિસ્ટ shifting ને કારણે

    \begin{mnemonicbox}
        "Dequeue Deletes from Front Door"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(c)}{7}{Double linked list ની વ્યાખ્યા આપો. લિંક લિસ્ટના મુખ્ય ઓપરેશનની નોંધણી કરો. Single Linked list મા શરૂઆતમાં નોડ દાખલ કરવા માટેનો અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Double Linked List:}
    એક રેખીય ડેટા સ્ટ્રક્ચર જ્યાં દરેક નોડમાં ડેટા અને બે pointers હોય છે - એક આગલા નોડ તરફ અને બીજો પાછલા નોડ તરફ.

    \textbf{લિંક લિસ્ટના મુખ્ય ઓપરેશન્સ:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Linked List Operations}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{ઓપરેશન} & \textbf{વર્ણન} & \textbf{Time Complexity} \\
            \midrule
            \textbf{Insertion} & નવો નોડ ઉમેરો & $O(1)$ શરૂઆતમાં \\
            \textbf{Deletion} & નોડ દૂર કરો & $O(1)$ જો નોડ ખબર છે \\
            \textbf{Traversal} & બધા નોડ્સની મુલાકાત લો & $O(n)$ \\
            \textbf{Search} & ચોક્કસ નોડ શોધો & $O(n)$ \\
            \textbf{Update} & નોડ ડેટા બદલો & $O(1)$ જો નોડ ખબર છે \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{શરૂઆતમાં Insert અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Insert at Beginning]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def insert_at_beginning(head, data):
    new_node = Node(data)
    new_node.next = head
    head = new_node
    return head
    \end{lstlisting}

    \textbf{અલ્ગોરિધમ પગલાં:}
    \begin{enumerate}
        \item આપેલ ડેટા સાથે નવો નોડ બનાવો.
        \item નવા નોડનો next વર્તમાન head પર સેટ કરો.
        \item Head ને નવા નોડ તરફ અપડેટ કરો.
        \item નવો head પરત કરો.
    \end{enumerate}

    \begin{mnemonicbox}
        "Insert at Beginning Builds Better Lists"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(a) અથવા}{3}{Single Linked List ની એપ્લિકેશન સમજાવો.}
\begin{solutionbox}
    \textbf{Single Linked List એપ્લિકેશન્સ:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Applications}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{એપ્લિકેશન} & \textbf{ઉપયોગ કેસ} & \textbf{ફાયદો} \\
            \midrule
            \textbf{Dynamic Memory} & વેરિયેબલ સાઇઝ ડેટા & મેમરી કાર્યક્ષમ \\
            \textbf{Stack Implementation} & LIFO ઓપરેશન્સ & સરળ push/pop \\
            \textbf{Queue Implementation} & FIFO ઓપરેશન્સ & Dynamic sizing \\
            \textbf{Music Playlist} & સિક્વેન્શિયલ પ્લેબેક & સરળ નેવિગેશન \\
            \textbf{Browser History} & પેજ નેવિગેશન & ફોરવર્ડ traversal \\
            \textbf{Polynomial Representation} & ગાણિતિક ઓપરેશન્સ & Coefficient સ્ટોરેજ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{મુખ્ય ફાયદાઓ:}
    \begin{itemize}
        \item \textbf{Dynamic Size}: રનટાઇમ દરમિયાન વધે/ઘટે છે
        \item \textbf{મેમરી કાર્યક્ષમતા}: જરૂર પ્રમાણે allocate કરે છે
        \item \textbf{Insertion/Deletion}: કોઈપણ સ્થાને કાર્યક્ષમ
    \end{itemize}

    \begin{mnemonicbox}
        "Linked Lists Link Many Applications"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(b) અથવા}{4}{લિસ્ટનો ઉપયોગ કરીને સ્ટેકના PUSH ઓપરેશન માટે અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{PUSH અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Stack Push]
def push(stack, element):
    stack.append(element)
    print(f"Pushed {element} to stack")
    \end{lstlisting}

    \textbf{અલ્ગોરિધમ પગલાં:}
    \begin{enumerate}
        \item \textbf{ક્ષમતા ચકાસો}: સ્ટેક ભરાયો નથી તે ચકાસો (fixed size માટે).
        \item \textbf{એલિમેન્ટ ઉમેરો}: લિસ્ટના અંતે append કરો.
        \item \textbf{ટોપ અપડેટ કરો}: ટોપ છેલ્લા એલિમેન્ટ તરફ પોઇન્ટ કરે છે.
        \item \textbf{ઓપરેશન કન્ફર્મ કરો}: સફળતાનો મેસેજ દર્શાવો.
    \end{enumerate}

    \textbf{Time Complexity: O(1)}

    \begin{mnemonicbox}
        "PUSH Puts on Stack Summit"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(c) અથવા}{7}{Linked list ના ફાયદા સમજાવો. Single linked list માંથી last નોડ કાઢી નાખવા માટે અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Linked List ફાયદાઓ:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Advantages}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{ફાયદો} & \textbf{વર્ણન} & \textbf{લાભ} \\
            \midrule
            \textbf{Dynamic Size} & રનટાઇમે સાઇઝ બદલાય છે & મેમરી લવચીક \\
            \textbf{મેમરી કાર્યક્ષમ} & જરૂર પ્રમાણે allocate કરે છે & કોઈ વેસ્ટેજ નથી \\
            \textbf{સરળ Insertion} & ગમે ત્યાં કાર્યક્ષમ રીતે ઉમેરો & O(1) ઓપરેશન \\
            \textbf{સરળ Deletion} & કાર્યક્ષમ રીતે દૂર કરો & O(1) ઓપરેશન \\
            \textbf{મેમરી Shift નથી} & એલિમેન્ટ્સ ખસતા નથી & ઝડપી ઓપરેશન્સ \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{છેલ્લો નોડ ડિલીટ કરવાનો અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Delete Last Node]
def delete_last_node(head):
    # Empty list
    if head is None:
        return None
    
    # Single node
    if head.next is None:
        return None
    
    # Multiple nodes
    current = head
    while current.next.next is not None:
        current = current.next
    
    current.next = None
    return head
    \end{lstlisting}

    \begin{mnemonicbox}
        "Linked Lists Lead to Logical Advantages"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(a)}{3}{બબલ સૉર્ટમાટેના અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Bubble Sort અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Bubble Sort]
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
    \end{lstlisting}

    \textbf{Time Complexity: O(n\textsuperscript{2})}

    \begin{mnemonicbox}
        "Bubbles Rise to Surface Slowly"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(b)}{4}{Circular linked list ને તેના ફાયદાઓ સાથે સમજાવો.}
\begin{solutionbox}
    \textbf{Circular Linked List:}
    એક લિંક લિસ્ટ જ્યાં છેલ્લો નોડ પ્રથમ નોડ તરફ પોઇન્ટ કરે છે, વર્તુળાકાર સ્ટ્રક્ચર બનાવે છે.

    \textbf{ફાયદાઓ:}
    \begin{itemize}
        \item \textbf{મેમરી કાર્યક્ષમ}: કોઈ NULL pointers નથી
        \item \textbf{વર્તુળાકાર Traversal}: સતત લૂપ કરી શકાય છે
        \item \textbf{Queue Implementation}: કાર્યક્ષમ enqueue/dequeue
        \item \textbf{Round Robin Scheduling}: CPU time sharing
    \end{itemize}

    \begin{center}
    \begin{tikzpicture}[node distance=1.5cm]
        \node[gtu block] (A) {A};
        \node[gtu block, right=of A] (B) {B};
        \node[gtu block, right=of B] (C) {C};
        \node[gtu block, right=of C] (D) {D};
        
        \draw[gtu arrow] (A) -- (B);
        \draw[gtu arrow] (B) -- (C);
        \draw[gtu arrow] (C) -- (D);
        \draw[gtu arrow] (D.south) -- ++(0,-0.5) -| (A.south);
    \end{tikzpicture}
    \captionof{figure}{Circular Linked List}
    \end{center}

    \begin{mnemonicbox}
        "Circular Lists Create Continuous Connections"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(c)}{7}{યોગ્ય ઉદાહરણ સાથે મર્જ સૉર્ટ સમજાવો.}
\begin{solutionbox}
    \keyword{Merge Sort} એક divide-and-conquer અલ્ગોરિધમ જે array ને ભાગોમાં વહેંચે છે, તેમને અલગ અલગ સૉર્ટ કરે છે, અને પછી ભેગા કરે છે.

    \textbf{અલ્ગોરિધમ તબક્કાઓ:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Merge Sort Phases}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{તબક્કો} & \textbf{ક્રિયા} & \textbf{વર્ણન} \\
            \midrule
            \textbf{Divide} & Array વહેંચો & બે ભાગોમાં વહેંચો \\
            \textbf{Conquer} & Subarrays સૉર્ટ કરો & ભાગોને recursively સૉર્ટ કરો \\
            \textbf{Combine} & પરિણામો મર્જ કરો & સૉર્ટેડ ભાગો મર્જ કરો \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{ઉદાહરણ: [38, 27, 43, 3, 9, 82, 10]}
    
    \begin{center}
    \begin{tikzpicture}[level/.style={sibling distance=60mm/#1, level distance=1.2cm}, scale=0.8, transform shape]
        \node[gtu block] {38, 27, 43, 3, 9, 82, 10}
            child {node[gtu block] {38, 27, 43, 3}
                child {node[gtu block] {38, 27}
                    child {node[gtu block] {38}}
                    child {node[gtu block] {27}}
                }
                child {node[gtu block] {43, 3}
                    child {node[gtu block] {43}}
                    child {node[gtu block] {3}}
                }
            }
            child {node[gtu block] {9, 82, 10}
                child {node[gtu block] {9, 82}
                    child {node[gtu block] {9}}
                    child {node[gtu block] {82}}
                }
                child {node[gtu block] {10}}
            };
    \end{tikzpicture}
    \captionof{figure}{Merge Sort Division}
    \end{center}
    
    \textbf{મર્જ પરિણામ:}
    \noindent\code{[3, 9, 10, 27, 38, 43, 82]}

    \textbf{Time Complexity: O(n log n)}

    \begin{mnemonicbox}
        "Merge Sort Methodically Merges Segments"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(a) અથવા}{3}{Selection sort માટેના અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Selection Sort અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Selection Sort]
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
    \end{lstlisting}

    \textbf{Time Complexity: O(n\textsuperscript{2})}

    \begin{mnemonicbox}
        "Selection Sort Selects Smallest Successfully"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(b) અથવા}{4}{Double linked list ને તેના ફાયદાઓ સાથે સમજાવો.}
\begin{solutionbox}
    \textbf{Double Linked List:}
    એક લિંક લિસ્ટ જ્યાં દરેક નોડમાં ડેટા અને બે pointers હોય છે - next અને previous.

    \textbf{ફાયદાઓ:}
    \begin{itemize}
        \item \textbf{બાયડાયરેક્શનલ Traversal}: આગળ અને પાછળ બંને દિશામાં ચાલી શકાય છે
        \item \textbf{સરળ Deletion}: પાછલો નોડ જાણ્યા વગર ડિલીટ કરી શકાય છે
        \item \textbf{કાર્યક્ષમ Insertion}: કોઈપણ સ્થાને સરળતાથી insert કરી શકાય છે
    \end{itemize}

    \begin{center}
    \begin{tikzpicture}[node distance=2.5cm, every node/.style={gtu block}]
        \node (A) {A};
        \node[right of=A] (B) {B};
        \node[right of=B] (C) {C};
        
        \path[->] 
            (A) edge [bend left] node {} (B)
            (B) edge [bend left] node {} (C)
            (C) edge [bend left] node {} (B)
            (B) edge [bend left] node {} (A);
    \end{tikzpicture}
    \captionof{figure}{Double Linked List}
    \end{center}

    \begin{mnemonicbox}
        "Double Links provide Dual Direction"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(c) અથવા}{7}{Insertion સૉર્ટ સમજાવો. Insertion સૉર્ટનો ઉપયોગ કરીને નીચેના નંબરોનો ટ્રેસ આપો: 25, 15,30,9,99,20,26}
\begin{solutionbox}
    \textbf{Insertion Sort:}
    એક સમયે એક એલિમેન્ટ દ્વારા સૉર્ટેડ array બનાવે છે દરેક એલિમેન્ટને તેની યોગ્ય પોઝિશનમાં insert કરીને.

    \textbf{ટ્રેસ મૂલ્યાંકન:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Insertion Sort Trace}
        \centering
        \begin{tabulary}{\linewidth}{C C L L}
            \toprule
            \textbf{પાસ} & \textbf{વર્તમાન} & \textbf{Array સ્થિતિ} & \textbf{ક્રિયા} \\
            \midrule
            પ્રારંભિક & - & [25, 15, 30, 9, 99, 20, 26] & શરૂ \\
            1 & 15 & [15, 25, 30, 9, 99, 20, 26] & Insert 15 \\
            2 & 30 & [15, 25, 30, 9, 99, 20, 26] & No change \\
            3 & 9 & [9, 15, 25, 30, 99, 20, 26] & Insert 9 \\
            4 & 99 & [9, 15, 25, 30, 99, 20, 26] & No change \\
            5 & 20 & [9, 15, 20, 25, 30, 99, 26] & Insert 20 \\
            6 & 26 & [9, 15, 20, 25, 26, 30, 99] & Insert 26 \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \textbf{અંતિમ સૉર્ટેડ Array:} \code{[9, 15, 20, 25, 26, 30, 99]}

    \begin{mnemonicbox}
        "Insertion Inserts Into Increasing Order"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(a)}{3}{બાઈનરી ટ્રીની એપ્લિકેશન સમજાવો.}
\begin{solutionbox}
    \textbf{Binary Tree એપ્લિકેશન્સ:}
    \par\noindent\begin{minipage}{\linewidth}
        \captionof{table}{Applications}
        \centering
        \begin{tabulary}{\linewidth}{LCL}
            \toprule
            \textbf{એપ્લિકેશન} & \textbf{ઉપયોગ કેસ} & \textbf{ફાયદો} \\
            \midrule
            \textbf{Expression Trees} & ગાણિતિક expressions & સરળ evaluation \\
            \textbf{Binary Search Trees} & Searching/Sorting & O(log n) operations \\
            \textbf{Heap Trees} & Priority queues & કાર્યક્ષમ min/max \\
            \textbf{File Systems} & Directory structure & હાયરાર્કિકલ ઓર્ગેનાઇઝેશન \\
            \bottomrule
        \end{tabulary}
    \end{minipage}

    \begin{mnemonicbox}
        "Binary Trees Branch into Many Applications"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(b)}{4}{લિસ્ટનો ઉપયોગ કરીને Binary search માટેનો અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Binary Search અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Binary Search]
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1
    \end{lstlisting}

    \textbf{પૂર્વશરત:} Array સૉર્ટેડ હોવું જોઈએ.
    \textbf{Time Complexity: O(log n)}

    \begin{mnemonicbox}
        "Binary Search Bisects to Find Faster"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(c)}{7}{Tree ની વ્યાખ્યા આપો. Tree ની યાદી બનાવો. પાયથોનનો ઉપયોગ કરીને બાઈનરી સર્ચ ટ્રીમાં નોડ દાખલ કરવા માટે અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Tree:}
    એક હાયરાર્કિકલ ડેટા સ્ટ્રક્ચર જેમાં edges દ્વારા જોડાયેલા nodes હોય છે, એક root node સાથે અને કોઈ cycles ન હોય.

    \textbf{Tree ના પ્રકારો:}
    \begin{itemize}
        \item \textbf{Binary Tree}: નોડ દીઠ વધુમાં વધુ 2 બાળકો.
        \item \textbf{Binary Search Tree}: ક્રમિત binary tree (ડાબું < Root < જમણું).
        \item \textbf{Complete Binary Tree}: છેલ્લા સિવાય બધા લેવલ ભરેલા.
        \item \textbf{Full Binary Tree}: બધા nodes ને 0 અથવા 2 બાળકો.
        \item \textbf{AVL Tree}: સ્વ-સંતુલિત BST.
    \end{itemize}

    \textbf{BST Insertion અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=BST Insertion]
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def insert_bst(root, data):
    if root is None:
        return TreeNode(data)
    
    if data < root.data:
        root.left = insert_bst(root.left, data)
    elif data > root.data:
        root.right = insert_bst(root.right, data)
    
    return root
    \end{lstlisting}

    \begin{mnemonicbox}
        "Trees Grow with Structured Organization"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(a) અથવા}{3}{ટ્રીના ઇન-ઓર્ડર ટ્રાવર્સલનો અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{In-order Traversal અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=In-order Traversal]
def inorder_traversal(root):
    if root is not None:
        inorder_traversal(root.left)    # Left
        print(root.data)                # Root
        inorder_traversal(root.right)   # Right
    \end{lstlisting}

    \textbf{Traversal ક્રમ:} ડાબું $\rightarrow$ Root $\rightarrow$ જમણું

    \begin{center}
    \begin{tikzpicture}[level/.style={sibling distance=30mm/#1}]
        \node[gtu block] {50}
            child {node[gtu block] {30}
                child {node[gtu block] {20}}
                child {node[gtu block] {40}}
            }
            child {node[gtu block] {70}
                child {node[gtu block] {60}}
                child {node[gtu block] {80}}
            };
    \end{tikzpicture}
    \captionof{figure}{Example Tree}
    \end{center}
    
    \textbf{In-order:} 20, 30, 40, 50, 60, 70, 80

    \begin{mnemonicbox}
        "In-order: Left, Root, Right"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(b) અથવા}{4}{Search ની વ્યાખ્યા આપો? લિસ્ટનો ઉપયોગ કરીને Linear search માટેનો અલ્ગોરિધમ લખો.}
\begin{solutionbox}
    \textbf{Search:}
    ડેટા સ્ટ્રક્ચરમાં ચોક્કસ એલિમેન્ટ શોધવાની અથવા એલિમેન્ટ અસ્તિત્વમાં છે કે નહીં તે ચકાસવાની પ્રક્રિયા.

    \textbf{Linear Search અલ્ગોરિધમ:}
    \begin{lstlisting}[language=Python, caption=Linear Search]
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Return index if found
    return -1  # Return -1 if not found
    \end{lstlisting}

    \textbf{Time Complexity: O(n)}

    \begin{mnemonicbox}
        "Linear Search Looks through Lists Linearly"
    \end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(c) અથવા}{7}{વ્યાખ્યા આપો: a) પાથ b). લીફ નોડ. નીચે આપેલ માહિતી ઉપરથી binary search tree બનાવો. 60, 40, 37,31,59,21,65,30}
\begin{solutionbox}
    \textbf{વ્યાખ્યાઓ:}
    \begin{itemize}
        \item \textbf{Path}: એક નોડથી બીજા નોડ સુધીના nodes ની શ્રેણી.
        \item \textbf{Leaf Node}: કોઈ બાળકો ન હોય તેવો નોડ (કોઈ ડાબું કે જમણું બાળક નથી).
    \end{itemize}

    \textbf{BST બનાવટ માટે: 60, 40, 37, 31, 59, 21, 65, 30}

    \begin{center}
    \begin{tikzpicture}[level distance=1.2cm, sibling distance=2.5cm, every node/.style={gtu block}]
        \node {60}
            child {node {40}
                child {node {37}
                    child {node {31}
                        child {node {21}
                            child[missing]
                            child {node {30}}
                        }
                        child[missing]
                    }
                    child[missing]
                }
                child {node {59}}
            }
            child {node {65}};
    \end{tikzpicture}
    \captionof{figure}{Final Binary Search Tree}
    \end{center}

    \textbf{Leaf Nodes:} 30, 59, 65

    \begin{mnemonicbox}
        "BST Building follows Binary Search Tree rules"
    \end{mnemonicbox}
\end{solutionbox}

\end{document}
