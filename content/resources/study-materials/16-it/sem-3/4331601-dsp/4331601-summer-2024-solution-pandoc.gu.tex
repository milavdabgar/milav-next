\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331601 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{Array અને list નો તફાવત જણાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Array & List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{નિશ્ચિત કદ} બનાવતી વખતે & \textbf{ગતિશીલ કદ} - વધી/ઘટી શકે \\
\textbf{સમાન પ્રકારનો} ડેટા & \textbf{મિશ્ર પ્રકારનો} ડેટા \\
\textbf{મેમરી કાર્યક્ષમ} - સતત ફાળવણી & \textbf{લવચીક} પણ વધારે મેમરી \\
\textbf{ઝડપી access} ગણતરી માટે & \textbf{બિલ્ટ-ઇન methods} operations
માટે \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Arrays નિશ્ચિત મિત્રો, Lists લવચીક નેતાઓ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{Class અને object ના concept python program ની મદદથી સમજાવો.}

\begin{solutionbox}

\textbf{Class} એ એક blueprint છે જે objects ના structure અને behavior
વ્યાખ્યાયિત કરે છે. \textbf{Object} એ class નો instance છે.

\begin{verbatim}
class Student:
    def \_\_init\_\_(self, name, age):
        self.name = name
        self.age = age
    
    def display(self):
        print(f"Name: \{self.name\}, Age: \{self.age\}")

\# Objects બનાવવા
s1 = Student("રામ", 20)
s2 = Student("સીતા", 19)
s1.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Class}: Template બનાવે છે
\item
  \textbf{Object}: વાસ્તવિક instance બનાવે છે
\item
  \textbf{Constructor}: Object initialize કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Class Blueprint બનાવે Object Instances''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{Constructor ની વ્યાખ્યા આપો. વિવિધ પ્રકાર ના constructor python
program સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Constructor} એ special method છે જે object creation time પર
automatically call થાય છે. Python માં \texttt{\_\_init\_\_()} method
constructor છે.

\begin{verbatim}
class Demo:
    \# Default Constructor
    def \_\_init\_\_(self):
        self.value = 0
    
    \# Parameterized Constructor
    def \_\_init\_\_(self, x, y=10):
        self.x = x
        self.y = y

\# ઉપયોગ
d1 = Demo(5)      \#

x=5,

y=10 (default)

d2 = Demo(3, 7)   \#

x=3,

y=7

\end{verbatim}

\textbf{Constructor ના પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default} & કોઈ parameters નહીં & Object initialization \\
\textbf{Parameterized} & Parameters સાથે & કસ્ટમ initialization \\
\textbf{Copy} & Object ની copy બનાવે & Object duplication \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Default Parameters Copy Objects''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) OR [7
ગુણ]}\label{q1c}

\textbf{Polymorphism ની વ્યાખ્યા આપો. Inheritance વડે Polymorphism નો
python program લખો.}

\begin{solutionbox}

\textbf{Polymorphism} એ સમાન interface વાપરીને અલગ અલગ objects પર અલગ અલગ
operations કરવાની ક્ષમતા છે.

\begin{verbatim}
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Woof!"

class Cat(Animal):
    def sound(self):
        return "Meow!"

\# Polymorphic વર્તન
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.sound())
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Method Overriding}: Child class માં સમાન method name
\item
  \textbf{Dynamic Binding}: Runtime પર method selection
\item
  \textbf{Code Reusability}: સમાન interface, અલગ implementation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ઘણા Objects, એક Interface''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{Python અંતર્ગત data structure List, Tuple અને Dictionary સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4324}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3243}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2432}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Data Structure
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ગુણધર્મો
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{List} & Mutable, ordered, duplicates allowed &
\texttt{[1,\ 2,\ 3,\ 2]} \\
\textbf{Tuple} & Immutable, ordered, duplicates allowed &
\texttt{(1,\ 2,\ 3,\ 2)} \\
\textbf{Dictionary} & Mutable, key-value pairs, unique keys &
\texttt{\{\textquotesingle{}a\textquotesingle{}:\ 1,\ \textquotesingle{}b\textquotesingle{}:\ 2\}} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Lists બદલાય, Tuples રહે, Dictionaries નકશો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{Stack ની એપ્લિકેશન જણાવો.}

\begin{solutionbox}

\textbf{Stack Applications:}

\begin{itemize}
\tightlist
\item
  \textbf{Function Calls}: Call stack management
\item
  \textbf{Expression Evaluation}: Infix to postfix conversion
\item
  \textbf{Undo Operations}: Text editors, browsers
\item
  \textbf{Parentheses Matching}: Syntax checking
\end{itemize}

\begin{verbatim}
     +{-{-}{-}+}
     | 3 | {{-} Top}
     +{-{-}{-}+}
     | 2 |
     +{-{-}{-}+}
     | 1 |
     +{-{-}{-}+}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Functions Evaluate કરે Undo Parentheses''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{Stack ની વ્યાખ્યા આપો. PUSH અને POP operation ઉદાહરણ સાથે સમજાવો.
Stack ના PUSH અને POP operation ના algorithm લખો.}

\begin{solutionbox}

\textbf{Stack} એ LIFO (Last In First Out) સિદ્ધાંત અનુસરતું linear data
structure છે.

\textbf{PUSH Algorithm:}

\begin{verbatim}
1. Check કરો કે stack ભરેલો છે કે નહીં
2. જો ભરેલો હોય, print "Stack Overflow"
3. અન્યથા, top increment કરો
4. Top position પર element add કરો
\end{verbatim}

\textbf{POP Algorithm:}

\begin{verbatim}
1. Check કરો કે stack ખાલી છે કે નહીં
2. જો ખાલી હોય, print "Stack Underflow"
3. અન્યથા, top થી element remove કરો
4. Top decrement કરો
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
stack = []
stack.append(10)  \# PUSH
stack.append(20)  \# PUSH
item = stack.pop()  \# POP returns 20
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``છેલ્લો અંદર, પહેલો બહાર - થાળીઓ જેવું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) OR [3
ગુણ]}\label{q2a}

\textbf{નીચેની વ્યાખ્યા આપો: I. Time Complexity II. Space Complexity III.
Best case}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શબ્દ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Time Complexity} & Algorithm execution time નું વિશ્લેષણ & O(n),
O(log n) \\
\textbf{Space Complexity} & Memory usage નું વિશ્લેષણ & O(1), O(n) \\
\textbf{Best Case} & ન્યૂનતમ time/space જરૂરિયાત & Sorted array search \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Time Space Best Performance''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) OR [4
ગુણ]}\label{q2b}

\textbf{નીચે આપેલા infix expression ને postfix માં ફેરવો. A -- (B / C + (D \%
E * F) / G)* H}

\begin{solutionbox}

\textbf{Step-by-step conversion:}

\begin{verbatim}
Infix: A – (B / C + (D % E * F) / G) * H

1. A B C / D E % F * G / + - H *

Stack operations:
- Operators: -, (, /, +, (, %, *, ), /, ), *
- Final: A B C / D E % F * G / + - H *
\end{verbatim}

\textbf{Postfix પરિણામ:
\texttt{A\ B\ C\ /\ D\ E\ \%\ F\ *\ G\ /\ +\ -\ H\ *}}

\end{solutionbox}
\begin{mnemonicbox}
``Operands પહેલા, Operators પછી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) OR [7
ગુણ]}\label{q2c}

\textbf{Circular queue ની વ્યાખ્યા આપો. Circular queue ના INSERT અને DELETE
operations આકૃતિ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Circular Queue} એ queue નું સુધારેલું સ્વરૂપ છે જ્યાં છેલ્લી સ્થિતિ પ્રથમ સ્થિતિ
સાથે જોડાયેલી હોય છે.

\begin{verbatim}
     +{-{-}{-}+{-}{-}{-}+{-}{-}{-}+{-}{-}{-}+}
     | 1 | 2 | 3 |   |
     +{-{-}{-}+{-}{-}{-}+{-}{-}{-}+{-}{-}{-}+}
       \^{           \^{}}
     front        rear
\end{verbatim}

\textbf{INSERT Algorithm:}

\begin{verbatim}
1. Check કરો કે queue ભરેલો છે કે નહીં
2. rear = (rear + 1) % size
3. queue[rear] = element
4. જો પ્રથમ element હોય, તો front = 0 સેટ કરો
\end{verbatim}

\textbf{DELETE Algorithm:}

\begin{verbatim}
1. Check કરો કે queue ખાલી છે કે નહીં
2. element = queue[front]
3. front = (front + 1) % size
4. Element return કરો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફાયદો}: Memory efficiency
\item
  \textbf{ઉપયોગ}: CPU scheduling, buffering
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ભરાઈ જાય તો પાછા ફરો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{List નો ઉપયોગ કરી Stack નું Implementation સમજાવો.}

\begin{solutionbox}

Stack operations Python List વડે:

\begin{verbatim}
stack = []  \# ખાલી stack
stack.append(10)  \# PUSH
stack.append(20)  \# PUSH
top = stack.pop()  \# POP
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{PUSH}: \texttt{append()} method
\item
  \textbf{POP}: \texttt{pop()} method
\item
  \textbf{TOP}: \texttt{stack[-1]} for peek
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Append ધકેલે, Pop ખેંચે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{Linked list ની વિવિધ એપ્લિકેશન વિશે ચર્ચા કરો.}

\begin{solutionbox}

\textbf{Linked List Applications:}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic Memory}: Runtime પર size બદલાય
\item
  \textbf{Insertion/Deletion}: કોઈપણ સ્થાને કાર્યક્ષમ
\item
  \textbf{Implementation}: Stacks, queues, graphs
\item
  \textbf{Undo Functionality}: Browser history, text editors
\end{itemize}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3824}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3235}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2941}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
એપ્લિકેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ફાયદો
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Music Playlist} & સરળ add/remove & Media players \\
\textbf{Memory Management} & Dynamic allocation & Operating systems \\
\textbf{Polynomial Representation} & કાર્યક્ષમ storage & Mathematical
operations \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ગતિશીલ Implementation Undo Memory''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{Doubly linked list સમજાવો. Doubly linked list માં શરૂઆત ની node ને
delete કરવા માટેનો algorithm લખો.}

\begin{solutionbox}

\textbf{Doubly Linked List} માં દરેક node માં data, next pointer અને
previous pointer હોય છે.

\begin{verbatim}
    +{-{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+}
    | prev | data | next |
    +{-{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+{-}{-}{-}{-}{-}{-}+}
         \^{         \^{}}
       NULL     points to next
\end{verbatim}

\textbf{શરૂઆતથી Delete કરવાનો Algorithm:}

\begin{verbatim}
1. જો list ખાલી હોય, તો return
2. જો માત્ર એક node હોય:
   - head = NULL
3. અન્યથા:
   - temp = head
   - head = head.next
   - head.prev = NULL
   - temp ને delete કરો
\end{verbatim}

\begin{verbatim}
def delete\_beginning(self):
    if self.head is None:
        return
    if self.head.next is None:
        self.head = None
    else:
        self.head = self.head.next
        self.head.prev = None
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``બે દિશા નેવિગેશન''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) OR [3
ગુણ]}\label{q3a}

**નીચે આપેલા infix expression ને postfix માં ફેરવો: A+B/C*D-E/F-G**

\begin{solutionbox}

\textbf{Step-by-step conversion:}

\begin{verbatim}
Infix: A+B/C*D-E/F-G

Postfix: A B C / D * + E F / - G -

Operator precedence: *, / > +, -
ડાબેથી જમણે associativity
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ગુણા ભાગ પહેલા, સરવાળો બાદબાકી પછી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) OR [4
ગુણ]}\label{q3b}

\textbf{Circular Linked List તેના ગેરફાયદા સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Circular Linked List} માં છેલ્લી node નો next pointer પ્રથમ node ને
point કરે છે.

\begin{verbatim}
    +{-{-}{-}+    +{-}{-}{-}+    +{-}{-}{-}+}
    | 1 |{-{-}{-}| 2 |{-}{-}{-}| 3 |}
    +{-{-}{-}+    +{-}{-}{-}+    +{-}{-}{-}+}
      \^{                 |}
      +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\textbf{ગેરફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{અનંત લૂપ જોખમ}: ખોટા traversal
\item
  \textbf{જટિલ Implementation}: વધારે સાવધાની જરૂરી
\item
  \textbf{Memory Overhead}: વધારે pointer management
\item
  \textbf{Debugging મુશ્કેલી}: Circular references
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``વર્તુળો મૂંઝવણ લાવી શકે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) OR [7
ગુણ]}\label{q3c}

\textbf{Doubly Linked List માં Insert operation ને perform કરવા માટેનો
Python Program લખો. સ્વચ્છ આકૃતિ સાથે સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def insert\_beginning(self, data):
        new\_node = Node(data)
        if self.head is None:
            self.head = new\_node
        else:
            new\_node.next = self.head
            self.head.prev = new\_node
            self.head = new\_node
\end{verbatim}

\begin{verbatim}
પહેલા:  NULL {{-} [10] {-} [20] {-} NULL}

પછી:   NULL {{-} [5] {-} [10] {-} [20] {-} NULL}
                 \^{}
               new head
\end{verbatim}

\textbf{Insert Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{શરૂઆત}: Head pointer update કરો
\item
  \textbf{અંત}: છેલ્લા node સુધી traverse કરો
\item
  \textbf{મધ્ય}: prev/next pointers update કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``શરૂઆત અંત મધ્ય Insertions''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{Merge sort નો algorithm લખો.}

\begin{solutionbox}

\textbf{Merge Sort Algorithm:}

\begin{verbatim}
1. જો array size <= 1 હોય, તો return
2. Array ને બે ભાગમાં વહેંચો
3. બંને ભાગોને recursively sort કરો
4. Sorted ભાગોને merge કરો
\end{verbatim}

\textbf{Time Complexity}: O(n log n) \textbf{Space Complexity}: O(n)

\end{solutionbox}
\begin{mnemonicbox}
``વહેંચો જીતો મેળવો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{Singly Linked List અને Doubly Linked List નો તફાવત જણાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Singly Linked List & Doubly Linked List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{એક pointer} (next) & \textbf{બે pointers} (next, prev) \\
\textbf{આગળ traversal} માત્ર & \textbf{બંને દિશામાં traversal} \\
\textbf{ઓછી memory} વપરાશ & \textbf{વધારે memory} વપરાશ \\
\textbf{સરળ implementation} & \textbf{જટિલ implementation} \\
\end{longtable}
}

\begin{verbatim}
Singly:  [data|next] {- [data|next] {-} NULL}

Doubly:  NULL {{-} [prev|data|next] {-} [prev|data|next] {-} NULL}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``સિંગલ આગળ, ડબલ બંને દિશા''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{Selection sort નો algorithm લખો. આપેલા ડેટા ને selection sort ની
મદદથી ચડતા ક્રમમાં ગોઠવી બતાવો. ડેટા: 13, 2, 6, 54, 18, 42, 11}

\begin{solutionbox}

\textbf{Selection Sort Algorithm:}

\begin{verbatim}
1. i = 0 થી n-2 સુધી:
   2. array[i...n-1] માં minimum શોધો
   3. Minimum ને array[i] સાથે swap કરો
\end{verbatim}

\textbf{[13, 2, 6, 54, 18, 42, 11] માટે Trace:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Pass & Array State & Min મળ્યું & Swap \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & [13, 2, 6, 54, 18, 42, 11] & 2 & 13\leftrightarrow2 \\
1 & [2, 13, 6, 54, 18, 42, 11] & 6 & 13\leftrightarrow6 \\
2 & [2, 6, 13, 54, 18, 42, 11] & 11 & 13\leftrightarrow11 \\
3 & [2, 6, 11, 54, 18, 42, 13] & 13 & 54\leftrightarrow13 \\
4 & [2, 6, 11, 13, 18, 42, 54] & 18 & કોઈ swap નહીં \\
5 & [2, 6, 11, 13, 18, 42, 54] & 42 & કોઈ swap નહીં \\
\end{longtable}
}

\textbf{અંતિમ પરિણામ: [2, 6, 11, 13, 18, 42, 54]}

\end{solutionbox}
\begin{mnemonicbox}
``ન્યૂનતમ પસંદ કરો, સ્થાન બદલો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) OR [3
ગુણ]}\label{q4a}

\textbf{Insertion sort નો algorithm લખો.}

\begin{solutionbox}

\textbf{Insertion Sort Algorithm:}

\begin{verbatim}
1. i = 1 થી n-1 સુધી:
   2. key = array[i]
   3. j = i-1
   4. જ્યાં સુધી j >= 0 અને array[j] > key:
      5. array[j+1] = array[j]
      6. j = j-1
   7. array[j+1] = key
\end{verbatim}

\textbf{Time Complexity}: O(n^{2}) \textbf{Best Case}: O(n) sorted array
માટે

\end{solutionbox}
\begin{mnemonicbox}
``યોગ્ય સ્થાને દાખલ કરો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) OR [4
ગુણ]}\label{q4b}

\textbf{Circular linked list માં અંત માં નવી node insert કરવા માટેનો
algorithm લખો.}

\begin{solutionbox}

\textbf{Algorithm:}

\begin{verbatim}
1. Data સાથે new_node બનાવો
2. જો list ખાલી હોય:
   - head = new_node
   - new_node.next = new_node
3. અન્યથા:
   - temp = head
   - જ્યાં સુધી temp.next != head:
     - temp = temp.next
   - temp.next = new_node
   - new_node.next = head
\end{verbatim}

\begin{verbatim}
def insert\_end(self, data):
    new\_node = Node(data)
    if self.head is None:
        self.head = new\_node
        new\_node.next = new\_node
    else:
        temp = self.head
        while temp.next != self.head:
            temp = temp.next
        temp.next = new\_node
        new\_node.next = self.head
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Head પર પાછા વર્તુળ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) OR [7
ગુણ]}\label{q4c}

\textbf{Bubble sort નો algorithm લખો. આપેલા ડેટા ને bubble sort ની મદદથી
ચડતા ક્રમમાં ગોઠવી બતાવો. ડેટા: 37, 22, 64, 84, 58, 52, 11}

\begin{solutionbox}

\textbf{Bubble Sort Algorithm:}

\begin{verbatim}
1. i = 0 થી n-2 સુધી:
   2. j = 0 થી n-2-i સુધી:
      3. જો array[j] > array[j+1]:
         4. array[j] અને array[j+1] ને swap કરો
\end{verbatim}

\textbf{[37, 22, 64, 84, 58, 52, 11] માટે Trace:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Pass & સરખામણી અને Swaps & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 37\leftrightarrow22, 64\leftrightarrow84, 84\leftrightarrow58, 84\leftrightarrow52, 84\leftrightarrow11 & [22, 37, 64, 58, 52, 11,
84] \\
2 & 37\leftrightarrow64, 64\leftrightarrow58, 64\leftrightarrow52, 64\leftrightarrow11 & [22, 37, 58, 52, 11, 64, 84] \\
3 & 37\leftrightarrow58, 58\leftrightarrow52, 58\leftrightarrow11 & [22, 37, 52, 11, 58, 64, 84] \\
4 & 37\leftrightarrow52, 52\leftrightarrow11 & [22, 37, 11, 52, 58, 64, 84] \\
5 & 37\leftrightarrow11 & [22, 11, 37, 52, 58, 64, 84] \\
6 & 22\leftrightarrow11 & [11, 22, 37, 52, 58, 64, 84] \\
\end{longtable}
}

\textbf{અંતિમ પરિણામ: [11, 22, 37, 52, 58, 64, 84]}

\end{solutionbox}
\begin{mnemonicbox}
``સૌથી મોટા બબલ ઉપર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{Binary search tree અને તેની application સમજાવો.}

\begin{solutionbox}

\textbf{Binary Search Tree (BST)} એ binary tree છે જ્યાં left subtree માં
નાની values અને right subtree માં મોટી values હોય છે.

\textbf{ગુણધર્મો:}

\begin{itemize}
\tightlist
\item
  \textbf{Left child} \textless{} \textbf{Parent} \textless{}
  \textbf{Right child}
\item
  \textbf{Inorder traversal} sorted sequence આપે છે
\item
  \textbf{Search time}: O(log n) average case
\end{itemize}

\textbf{Applications:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
એપ્લિકેશન & ફાયદો & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Database Indexing} & ઝડપી search & DBMS systems \\
\textbf{Expression Trees} & Evaluation & Compilers \\
\textbf{Huffman Coding} & Compression & Data compression \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Search Trees ડેટા ગોઠવે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{Linear Search માટે Python Program લખો તથા ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
def linear\_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return {-}1

\# ઉદાહરણ
numbers = [10, 25, 30, 45, 60]
result = linear\_search(numbers, 30)
print(f"Element found at index: \{result\}")  \# Output: 2
\end{verbatim}

\textbf{કામગીરી:}

\begin{itemize}
\tightlist
\item
  \textbf{ક્રમિક તપાસ}: Element દર element
\item
  \textbf{Time Complexity}: O(n)
\item
  \textbf{Space Complexity}: O(1)
\item
  \textbf{કામ કરે છે}: Unsorted arrays પર
\end{itemize}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Element & મળ્યું? \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 10 & ના \\
2 & 25 & ના \\
3 & 30 & હા! \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``લીનિયર લાઇન દર લાઇન''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{આપેલી સાંખ્યઓ માટે Binary Search Tree બનાવો તથા તેના Preorder,
Inorder અને Postorder traversals લખો: 45, 35, 12, 58, 5, 55, 58, 80, 35,
42}

\begin{solutionbox}

\textbf{BST બાંધકામ (duplicates અવગણવામાં આવેલ):}

\begin{verbatim}
         45
        /  {}
      35    58
     / {   / }
   12  42 55 80
   /
  5
\end{verbatim}

\textbf{Insertion ક્રમ:} 45(root), 35(left), 12(35 ની left), 58(right),
5(12 ની left), 55(58 ની left), 80(58 ની right), 42(12 ની right)

\textbf{Traversals:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Traversal & ક્રમ & નિયમ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Preorder} & 45, 35, 12, 5, 42, 58, 55, 80 & Root-Left-Right \\
\textbf{Inorder} & 5, 12, 35, 42, 45, 55, 58, 80 & Left-Root-Right \\
\textbf{Postorder} & 5, 42, 12, 35, 55, 80, 58, 45 & Left-Right-Root \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Pre-Root પહેલા, In-Sorted, Post-Root છેલ્લે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) OR [3
ગુણ]}\label{q5a}

\textbf{નીચેની વ્યાખ્યા આપો: I. Binary tree II. level number III.
Leaf-node}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શબ્દ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Binary tree} & દર node માં મહત્તમ 2 children વાળું tree & દરેક node
માં \leq 2 children \\
\textbf{Level number} & Root થી અંતર (root = level 0) & Root=0,
children=1, વગેરે \\
\textbf{Leaf-node} & કોઈ children ન હોય તેવી node & Terminal nodes \\
\end{longtable}
}

\begin{verbatim}
      A     {{-} Level 0 (Root)}
     / {}
    B   C   {{-} Level 1}
   /
  D         {{-} Level 2 (Leaf)}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Levels લીડ કરે Leaves તરફ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) OR [4
ગુણ]}\label{q5b}

\textbf{Linear Search અને Binary search વચ્ચેનો તફાવત જણાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Linear Search & Binary Search \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Unsorted arrays} પર કામ કરે & \textbf{Sorted array} જરૂરી \\
\textbf{ક્રમિક તપાસ} & \textbf{ભાગલા પાડીને જીતો} \\
\textbf{Time}: O(n) & \textbf{Time}: O(log n) \\
\textbf{સરળ implementation} & \textbf{જટિલ implementation} \\
\textbf{કોઈ preprocessing} નહીં & \textbf{Sorting જરૂરી} \\
\end{longtable}
}

\begin{verbatim}
Linear:  [1][2][3][4][5] {- દરેકની તપાસ}
Binary:  [1][2][3][4][5] {- મધ્ય તપાસો, ભાગલા પાડો}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Linear લાઇન, Binary વિભાજન''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) OR [7
ગુણ]}\label{q5c}

\textbf{Binary search tree માં node ને insertion અને deletion માટેનો
algorithm લખો.}

\begin{solutionbox}

\textbf{Insertion Algorithm:}

\begin{verbatim}
1. જો root NULL છે, તો નવી node ને root બનાવો
2. જો data < root.data, તો left subtree માં insert કરો
3. જો data > root.data, તો right subtree માં insert કરો
4. જો data == root.data, તો insertion નહીં (duplicate)
\end{verbatim}

\textbf{Deletion Algorithm:}

\begin{verbatim}
1. જો node leaf છે: સીધું delete કરો
2. જો node માં એક child છે: child સાથે બદલો
3. જો node માં બે children છે:
   - Inorder successor શોધો
   - Data ને successor ના data સાથે બદલો
   - Successor ને delete કરો
\end{verbatim}

\begin{verbatim}
def insert(root, data):
    if root is None:
        return Node(data)
    if data {} root.data:
        root.left = insert(root.left, data)
    elif data {} root.data:
        root.right = insert(root.right, data)
    return root

def delete(root, data):
    if root is None:
        return root
    if data {} root.data:
        root.left = delete(root.left, data)
    elif data {} root.data:
        root.right = delete(root.right, data)
    else:
        \# Delete કરવાની node મળી
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        \# બે children સાથેની node
        temp = find\_min(root.right)
        root.data = temp.data
        root.right = delete(root.right, temp.data)
    return root
\end{verbatim}

\textbf{કેસો:}

\begin{itemize}
\tightlist
\item
  \textbf{Leaf deletion}: સીધું removal
\item
  \textbf{એક child}: Child સાથે replace
\item
  \textbf{બે children}: Successor સાથે replace
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Insert સરખાવો, Delete બદલો''

\end{mnemonicbox}

\end{document}
