\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331601 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{Time Complexity માટે best case, worst case અને average case
વ્યાખ્યાયિત કરો.}

\begin{solutionbox}

\textbf{ટેબલ: Time Complexity Cases}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4062}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2812}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3125}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કેસનો પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Best Case} & એલ્ગોરિધમ execution માટે લઘુત્તમ સમય & Linear search માં
એલિમેન્ટ પહેલી પોઝિશન પર મળે \\
\textbf{Worst Case} & એલ્ગોરિધમ execution માટે મહત્તમ સમય & Linear search
માં એલિમેન્ટ છેલ્લી પોઝિશન પર મળે \\
\textbf{Average Case} & સામાન્ય input scenarios માટે અપેક્ષિત સમય & Linear
search માં એલિમેન્ટ મધ્યમાં મળે \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Best Case}: આદર્શ input conditions સાથે એલ્ગોરિધમ optimal પ્રદર્શન
  આપે
\item
  \textbf{Worst Case}: પ્રતિકૂળ input સાથે એલ્ગોરિધમ મહત્તમ સમય લે
\item
  \textbf{Average Case}: બધા શક્ય inputs માં execution time ની ગાણિતિક
  અપેક્ષા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BWA - Best, Worst, Average''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{OOP માં Class અને Object શું છે? યોગ્ય ઉદાહરણ આપો.}

\begin{solutionbox}

\textbf{ટેબલ: Class vs Object}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3182}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3182}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3636}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Class
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Object
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{વ્યાખ્યા} & Objects બનાવવા માટે blueprint/template & Class નું
instance \\
\textbf{મેમરી} & કોઈ મેમરી allocate નથી થતી & બનાવવામાં આવે ત્યારે મેમરી
allocate થાય \\
\textbf{ઉદાહરણ} & Car (template) & my\_car = Car() \\
\end{longtable}
}

\begin{verbatim}
\# Class definition
class Student:
    def \_\_init\_\_(self, name, age):
        self.name = name
        self.age = age
    
    def display(self):
        print(f"Name: \{self.name\}, Age: \{self.age\}")

\# Object creation
student1 = Student("John", 20)
student1.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Class}: Attributes અને methods વ્યાખ્યાયિત કરતું template
\item
  \textbf{Object}: વાસ્તવિક values સાથેનું instance
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Class = Cookie Cutter, Object = વાસ્તવિક Cookie''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{Simple nested loop અને numpy module નો ઉપયોગ કરીને બે matrix
multiplication માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\# Method 1: Simple Nested Loop નો ઉપયોગ
def matrix\_multiply\_nested(A, B):
    rows\_A, cols\_A = len(A), len(A[0])
    rows\_B, cols\_B = len(B), len(B[0])
    
    \# Result matrix initialize કરો
    result = [[0 for \_ in range(cols\_B)] for \_ in range(rows\_A)]
    
    \# Matrix multiplication
    for i in range(rows\_A):
        for j in range(cols\_B):
            for k in range(cols\_A):
                result[i][j] += A[i][k] * B[k][j]
    
    return result

\# Method 2: NumPy નો ઉપયોગ
import numpy as np

def matrix\_multiply\_numpy(A, B):
    A\_np = np.array(A)
    B\_np = np.array(B)
    return np.dot(A\_np, B\_np)

\# ઉદાહરણ
A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]

print("Nested Loop Result:", matrix\_multiply\_nested(A, B))
print("NumPy Result:", matrix\_multiply\_numpy(A, B))
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Nested Loop}: Row, column અને multiplication માટે ત્રણ loops
\item
  \textbf{NumPy}: કાર્યક્ષમ multiplication માટે built-in dot() function
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Row \times Column = Result''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) OR [7
ગુણ]}\label{q1c}

\textbf{Array ના basic operations માટે એક પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
import array

\# Array બનાવો
arr = array.array({i}, [1, 2, 3, 4, 5])

def array\_operations():
    print("મૂળ array:", arr)
    
    \# Element insert કરો
    arr.insert(2, 10)
    print("insert(2, 10) પછી:", arr)
    
    \# Element append કરો
    arr.append(6)
    print("append(6) પછી:", arr)
    
    \# Element remove કરો
    arr.remove(10)
    print("remove(10) પછી:", arr)
    
    \# Element pop કરો
    popped = arr.pop()
    print(f"Pop કરેલું element: \{popped\}, Array: \{arr\}")
    
    \# Element શોધો
    index = arr.index(3)
    print(f"3 નું index: \{index\}")
    
    \# Occurrences ગણો
    count = arr.count(2)
    print(f"2 નું count: \{count\}")

array\_operations()
\end{verbatim}

\textbf{ટેબલ: Array Operations}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Method & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insert} & insert(index, value) & ચોક્કસ position પર element
ઉમેરવું \\
\textbf{Append} & append(value) & છેડે element ઉમેરવું \\
\textbf{Remove} & remove(value) & પહેલું occurrence દૂર કરવું \\
\textbf{Pop} & pop() & છેલ્લું element દૂર કરીને return કરવું \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``IARP - Insert, Append, Remove, Pop''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{Big `O' Notation સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Big O Complexity}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Notation & નામ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{O(1)} & Constant & Array access \\
\textbf{O(n)} & Linear & Linear search \\
\textbf{O(n^{2})} & Quadratic & Bubble sort \\
\textbf{O(log n)} & Logarithmic & Binary search \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Big O}: એલ્ગોરિધમની time complexity ની upper bound વર્ણવે છે
\item
  \textbf{હેતુ}: વિવિધ એલ્ગોરિધમની કાર્યક્ષમતાની તુલના કરવી
\item
  \textbf{ધ્યાન}: Worst-case scenario analysis પર
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Big O = વૃદ્ધિના Big Order''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{Class method અને static method વચ્ચે તફાવત લખી સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Method Types Comparison}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1944}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4167}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Class Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Static Method
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Decorator} & @classmethod & @staticmethod \\
\textbf{પહેલું Parameter} & cls (class reference) & કોઈ ખાસ parameter
નહીં \\
\textbf{Access} & Class variables ને access કરી શકે & Class/instance
variables ને access કરી શકતું નથી \\
\textbf{ઉપયોગ} & Alternative constructors & Utility functions \\
\end{longtable}
}

\begin{verbatim}
class MyClass:
    class\_var = "હું class variable છું"
    
    @classmethod
    def class\_method(cls):
        return f"Class method accessing: \{cls.class\_var\}"
    
    @staticmethod
    def static\_method():
        return "Static method {- કોઈ class access નથી"}

\# ઉપયોગ
print(MyClass.class\_method())
print(MyClass.static\_method())
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Class method માં CLS છે, Static method STandalone
છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{Public અને private type derivation નો ઉપયોગ કરીને single level
inheritance માટે class બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# Base class
class Vehicle:
    def \_\_init\_\_(self, brand, model):
        self.brand = brand          \# Public attribute
        self.\_model = model         \# Protected attribute
        self.\_\_year = 2023          \# Private attribute
    
    def start\_engine(self):
        return f"\{self.brand\} engine શરૂ થયું"
    
    def \_display\_model(self):       \# Protected method
        return f"Model: \{self.\_model\}"
    
    def \_\_private\_method(self):     \# Private method
        return f"Year: \{self.\_\_year\}"

\# Derived class (Single level inheritance)
class Car(Vehicle):
    def \_\_init\_\_(self, brand, model, doors):
        super().\_\_init\_\_(brand, model)
        self.doors = doors
    
    def car\_info(self):
        \# Public અને protected members ને access કરી શકે
        return f"Car: \{self.brand\}, \{self.\_display\_model()\}, Doors: \{self.doors\}"
    
    def demonstrate\_access(self):
        print("Public access:", self.brand)
        print("Protected access:", self.\_model)
        \# print("Private access:", self.\_\_year)  \# આ error આપશે

\# ઉપયોગ
my\_car = Car("Toyota", "Camry", 4)
print(my\_car.car\_info())
print(my\_car.start\_engine())
my\_car.demonstrate\_access()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Public}: બધે accessible (brand)
\item
  \textbf{Protected}: Class અને subclasses માં accessible (\_model)
\item
  \textbf{Private}: માત્ર સમાન class માં accessible (\_\_year)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Public = બધા, Protected = કુટુંબ, Private = વ્યક્તિગત''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) OR [3
ગુણ]}\label{q2a}

\textbf{Constructor ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Constructor Types}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default} & \texttt{\_\_init\_\_(self)} & Default values સાથે
initialize \\
\textbf{Parameterized} & \texttt{\_\_init\_\_(self,\ params)} & Custom
values સાથે initialize \\
\end{longtable}
}

\begin{verbatim}
class Student:
    def \_\_init\_\_(self, name="અજ્ઞાત", age=18):  \# Constructor
        self.name = name
        self.age = age
        print(f"Student \{name\} બનાવ્યો")
    
    def display(self):
        print(f"નામ: \{self.name\}, ઉંમર: \{self.age\}")

\# Object creation automatically constructor ને call કરે છે
s1 = Student("Alice", 20)
s2 = Student()  \# Default values ઉપયોગ કરે
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Constructor}: Object બનાવવામાં આવે ત્યારે call થતી special method
\item
  \textbf{હેતુ}: Object attributes ને initialize કરવા
\item
  \textbf{Automatic}: Object creation દરમિયાન automatically call થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Constructor = Object નું જન્મ પ્રમાણપત્ર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) OR [4
ગુણ]}\label{q2b}

\textbf{Polymorphism દર્શાવવા માટે એક પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\# Base class
class Animal:
    def make\_sound(self):
        pass

\# Derived classes
class Dog(Animal):
    def make\_sound(self):
        return "ભોંભોં!"

class Cat(Animal):
    def make\_sound(self):
        return "મિયાઉં!"

class Cow(Animal):
    def make\_sound(self):
        return "હંભા!"

\# Polymorphism demonstration
def animal\_sound(animal):
    return animal.make\_sound()

\# Objects બનાવવા
animals = [Dog(), Cat(), Cow()]

\# સમાન method call, અલગ behavior
for animal in animals:
    print(f"\{animal.\_\_class\_\_.\_\_name\_\_\}: \{animal\_sound(animal)\}")
\end{verbatim}

\textbf{ટેબલ: Polymorphism ના ફાયદા}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફાયદો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{લવચીકતા} & સમાન interface, અલગ implementations \\
\textbf{જાળવણી} & નવા types ઉમેરવા સહેલા \\
\textbf{Code Reuse} & વિવિધ objects માટે સામાન્ય interface \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Poly = ઘણા, Morph = સ્વરૂપો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) OR [7
ગુણ]}\label{q2c}

\textbf{Multiple અને hierarchical inheritance નો ઉપયોગ કરી પાયથોન પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\begin{verbatim}
\# Multiple Inheritance
class Teacher:
    def \_\_init\_\_(self, subject):
        self.subject = subject
    
    def teach(self):
        return f"\{self.subject\} શીખવાડવું"

class Researcher:
    def \_\_init\_\_(self, field):
        self.field = field
    
    def research(self):
        return f"\{self.field\} માં સંશોધન કરવું"

\# Multiple inheritance
class Professor(Teacher, Researcher):
    def \_\_init\_\_(self, name, subject, field):
        self.name = name
        Teacher.\_\_init\_\_(self, subject)
        Researcher.\_\_init\_\_(self, field)
    
    def profile(self):
        return f"પ્રોફેસર \{self.name\}: \{self.teach()\} અને \{self.research()\}"

\# Hierarchical Inheritance
class Vehicle:
    def \_\_init\_\_(self, brand):
        self.brand = brand
    
    def start(self):
        return f"\{self.brand\} શરૂ થયું"

class Car(Vehicle):
    def drive(self):
        return f"\{self.brand\} કાર ચાલે છે"

class Bike(Vehicle):
    def ride(self):
        return f"\{self.brand\} બાઇક ચાલે છે"

\# ઉપયોગ
prof = Professor("સ્મિથ", "પાયથોન", "AI")
print(prof.profile())

car = Car("Honda")
bike = Bike("Yamaha")
print(car.drive())
print(bike.ride())
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
Multiple Inheritance:    Hierarchical Inheritance:
   Teacher  Researcher         Vehicle
      {        /                /    }
       {      /               Car    Bike}
      Professor
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Multiple = ઘણા માતા-પિતા, Hierarchical = વૃક્ષ
માળખું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{Stack પર Push અને Pop operations સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Stack Operations}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & વર્ણન & Time Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Push} & ટોચ પર element ઉમેરવું & O(1) \\
\textbf{Pop} & ટોચેથી element દૂર કરવું & O(1) \\
\textbf{Peek/Top} & ટોચનું element જોવું & O(1) \\
\textbf{isEmpty} & Stack ખાલી છે કે નહીં તપાસવું & O(1) \\
\end{longtable}
}

\begin{verbatim}
stack = []

\# Push operation
stack.append(10)  \# 10 Push કરો
stack.append(20)  \# 20 Push કરો
print("Push પછી:", stack)  \# [10, 20]

\# Pop operation
item = stack.pop()  \# 20 Pop કરો
print(f"Pop કર્યું: \{item\}, Stack: \{stack\}")  \# [10]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{LIFO}: Last In, First Out સિદ્ધાંત
\item
  \textbf{ટોચ}: Operations માટે માત્ર accessible element
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Stack = થાળીઓનો ઢગલો - છેલ્લી થાળી અંદર, પહેલી થાળી
બહાર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{Queue ના Enqueue અને Dequeue operations સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Queue Operations}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operation & વર્ણન & સ્થાન & Time Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Enqueue} & Element ઉમેરવું & પાછળ & O(1) \\
\textbf{Dequeue} & Element દૂર કરવું & આગળ & O(1) \\
\textbf{Front} & આગળનું element જોવું & આગળ & O(1) \\
\textbf{Rear} & પાછળનું element જોવું & પાછળ & O(1) \\
\end{longtable}
}

\begin{verbatim}
from collections import deque

queue = deque()

\# Enqueue operation
queue.append(10)  \# 10 Enqueue કરો
queue.append(20)  \# 20 Enqueue કરો
print("Enqueue પછી:", list(queue))  \# [10, 20]

\# Dequeue operation
item = queue.popleft()  \# 10 Dequeue કરો
print(f"Dequeue કર્યું: \{item\}, Queue: \{list(queue)\}")  \# [20]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{FIFO}: First In, First Out સિદ્ધાંત
\item
  \textbf{બે છેડા}: આગળ removal માટે, પાછળ insertion માટે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Queue = દુકાનમાં લાઇન - પહેલો વ્યક્તિ અંદર, પહેલો વ્યક્તિ
બહાર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{Stack ની વિવિધ applications સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Stack Applications}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4194}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2581}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3226}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Expression Evaluation} & Infix ને postfix માં રૂપાંતર & (a+b)\emph{c
\rightarrow ab+c} \\
\textbf{Function Calls} & Function call sequence manage કરવું & Recursion
handling \\
\textbf{Undo Operations} & તાજેતરની ક્રિયાઓ ઉલટાવવી & Text editor undo \\
\textbf{Browser History} & Pages દ્વારા પાછળ navigate કરવું & Back
button \\
\textbf{Parentheses Matching} & Balanced brackets ચકાસવા & \{[()]\}
validation \\
\end{longtable}
}

\begin{verbatim}
\# ઉદાહરણ: Parentheses matching
def is\_balanced(expression):
    stack = []
    pairs = \{{(}: {)}, {[}: {]}, {\{}: {\}}\}
    
    for char in expression:
        if char in pairs:  \# Opening bracket
            stack.append(char)
        elif char in pairs.values():  \# Closing bracket
            if not stack:
                return False
            if pairs[stack.pop()] != char:
                return False
    
    return len(stack) == 0

\# ટેસ્ટ
print(is\_balanced("(\{[]\)"}))  \# True
print(is\_balanced("(\{[\])"}))  \# False
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Memory Management}: Programming માં function call stack
\item
  \textbf{Backtracking}: Maze solving, game algorithms
\item
  \textbf{Compiler Design}: Syntax analysis અને parsing
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Stack Applications = UFPB (Undo, Function,
Parentheses, Browser)''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) OR [3
ગુણ]}\label{q3a}

\textbf{Single Queue ની મર્યાદાઓની યાદી બનાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Single Queue Limitations}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3462}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3077}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3462}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મર્યાદા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સમસ્યા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Memory Wastage} & આગળની જગ્યા અનુપયોગી બને છે & અકાર્યક્ષમ memory
ઉપયોગ \\
\textbf{Fixed Size} & Dynamically resize કરી શકાતું નથી & જગ્યાની મર્યાદા \\
\textbf{False Overflow} & આગળની જગ્યા ખાલી હોવા છતાં queue ભરેલી લાગે & અકાળે
capacity limit \\
\textbf{No Reuse} & Dequeue કરેલી positions ફરીથી વાપરી શકાતી નથી &
Linear space utilization \\
\end{longtable}
}

\begin{verbatim}
Single Queue Problem:
Front               Rear
  ↓                  ↓
[X][X][3][4][5][ ][ ][ ]
 ↑  ↑
બગાડેલી જગ્યા (ફરીથી વાપરી શકાતી નથી)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Linear Implementation}: Dequeue કરેલી જગ્યા utilize કરી શકાતી
  નથી
\item
  \textbf{Static Array}: Fixed size allocation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Single Queue = એક બાજુનો રસ્તો (પાછા ફરી શકાતા
નથી)''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) OR [4
ગુણ]}\label{q3b}

\textbf{Circular અને simple queues નો તફાવત લખી સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Queue Types Comparison}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1892}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3784}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4324}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Simple Queue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Circular Queue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Memory Usage} & Linear, wasteful & Circular, efficient \\
\textbf{Space Reuse} & Dequeue કરેલી જગ્યા ફરીથી વાપરાતી નથી & બધી
positions ફરીથી વાપરે છે \\
\textbf{Overflow} & False overflow શક્ય & માત્ર true overflow \\
\textbf{Implementation} & Front અને rear pointers & Modulo સાથે front અને
rear \\
\end{longtable}
}

\begin{verbatim}
Simple Queue:          Circular Queue:
[X][X][3][4][ ][ ]    [5][6][3][4]
Front    Rear        ↑Rear Front
(બગાડેલી જગ્યા)         (જગ્યા ફરીથી વાપરાય)
\end{verbatim}

\begin{verbatim}
\# Circular Queue Implementation
class CircularQueue:
    def \_\_init\_\_(self, size):
        self.size = size
        self.queue = [None] * size
        self.front = {-}1
        self.rear = {-}1
    
    def enqueue(self, item):
        if (self.rear + 1) \% self.size == self.front:
            print("Queue ભરાઈ ગયું")
            return
        if self.front == {-}1:
            self.front = 0
        self.rear = (self.rear + 1) \% self.size
        self.queue[self.rear] = item
    
    def dequeue(self):
        if self.front == {-}1:
            print("Queue ખાલી છે")
            return None
        item = self.queue[self.front]
        if self.front == self.rear:
            self.front = self.rear = {-}1
        else:
            self.front = (self.front + 1) \% self.size
        return item
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Circular = Ring Road (સતત), Simple = મૃત અંતનો
રસ્તો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) OR [7
ગુણ]}\label{q3c}

\textbf{નીચેની infix expression ને postfix માં રૂપાંતર કરો: (a * b) * (c \^{}
(d + e) -- f)}

\begin{solutionbox}

\textbf{ટેબલ: Operator Precedence}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operator & Precedence & Associativity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\^{}} & 3 & Right to Left \\
\textbf{*, /} & 2 & Left to Right \\
\textbf{+, -} & 1 & Left to Right \\
\end{longtable}
}

\textbf{Step-by-step conversion:}

\begin{verbatim}
Expression: (a * b) * (c ^ (d + e) – f)

Step 1: (a * b) \rightarrow ab*
Step 2: (d + e) \rightarrow de+
Step 3: c ^ (de+) \rightarrow c de+ ^
Step 4: (c de+ ^) – f \rightarrow c de+ ^ f -
Step 5: (ab*) * (c de+ ^ f -) \rightarrow ab* c de+ ^ f - *

અંતિમ જવાબ: ab*cde+^f-*
\end{verbatim}

\textbf{Algorithm:}

\begin{enumerate}
\tightlist
\item
  \textbf{Operand}: Output માં ઉમેરો
\item
  \textbf{`('}: Stack માં push કરો
\item
  \textbf{`)'}: `(' આવે ત્યાં સુધી pop કરો
\item
  \textbf{Operator}: Higher/equal precedence pop કરો, પછી push કરો
\item
  \textbf{અંત}: બાકીના બધા operators pop કરો
\end{enumerate}

\begin{verbatim}
def infix\_to\_postfix(expression):
    precedence = \{{+}: 1, {{-}}: 1, {*}: 2, {/}: 2, {\^{}}: 3\}
    stack = []
    output = []
    
    for char in expression:
        if char.isalnum():
            output.append(char)
        elif char == {(}:
            stack.append(char)
        elif char == {)}:
            while stack and stack[{-}1] != {(}:
                output.append(stack.pop())
            stack.pop()  \# {( દૂર કરો}
        elif char in precedence:
            while (stack and stack[{-}1] != {(} and 
                   stack[{-}1] in precedence and
                   precedence[stack[{-}1]] {=} precedence[char]):
                output.append(stack.pop())
            stack.append(char)
    
    while stack:
        output.append(stack.pop())
    
    return {}.join(output)

\# ટેસ્ટ
result = infix\_to\_postfix("(a*b)*(c\^{(d+e){-}f)"})
print("Postfix:", result)  \# ab*cde+\^{f{-}*}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Precedence માટે PEMDAS, Operators માટે Stack''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{Linked List ના પ્રકારો સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Linked List Types}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2258}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2581}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5161}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
મુખ્ય વિશેષતા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Singly Linked} & Next node નો એક pointer & માત્ર આગળ traversal \\
\textbf{Doubly Linked} & Next અને previous નાં pointers & બંને દિશામાં
traversal \\
\textbf{Circular Linked} & છેલ્લો node પહેલાને point કરે & કોઈ NULL pointer
નથી \\
\textbf{Doubly Circular} & Doubly + Circular features & બંને દિશા +
circular \\
\end{longtable}
}

\begin{verbatim}
Singly:     [A][B][C]

Doubly:     NULL[A]⇄[B]⇄[C]

Circular:   [A][B][C]
             ↑\_\_\_\_\_\_\_\_\_|

Doubly Circular: [A]⇄[B]⇄[C]
                  ↑\_\_\_\_\_\_\_\_\_|
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Memory}: દરેક node માં data અને pointer(s) હોય છે
\item
  \textbf{Dynamic}: Runtime દરમિયાન size બદલાઈ શકે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SDCD - Singly, Doubly, Circular, Doubly-Circular''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{Circular linked list અને singly linked list નો તફાવત લખી સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Singly vs Circular Linked List}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પાસું & Singly Linked List & Circular Linked List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{છેલ્લો Node} & NULL ને point કરે & પહેલા node ને point કરે \\
\textbf{Traversal} & NULL પર અંત આવે & સતત loop \\
\textbf{Memory} & છેલ્લો node NULL store કરે & કોઈ NULL pointer નથી \\
\textbf{Detection} & NULL માટે check કરો & શરૂઆતના node માટે check કરો \\
\end{longtable}
}

\begin{verbatim}
\# Singly Linked List Node
class SinglyNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

\# Circular Linked List Node
class CircularNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

def traverse\_singly(head):
    current = head
    while current:  \# NULL પર અટકે
        print(current.data)
        current = current.next

def traverse\_circular(head):
    if not head:
        return
    current = head
    while True:
        print(current.data)
        current = current.next
        if current == head:  \# શરૂઆતમાં પાછા
            break
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
Singly:    [1][2][3]

Circular:  [1][2][3]
            ↑\_\_\_\_\_\_\_|
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Singly = મૃત અંત, Circular = Race Track''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{Singly linked list માં નીચેની કામગીરી કરવા માટે એક પ્રોગ્રામનો અમલ
કરો:} \textbf{a. Singly linked list ની શરૂઆતમાં node દાખલ કરો.} \textbf{b.
Singly linked list ના અંતે node દાખલ કરો.}

\begin{solutionbox}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def insert\_at\_beginning(self, data):
        """શરૂઆતમાં node insert કરો"""
        new\_node = Node(data)
        new\_node.next = self.head
        self.head = new\_node
        print(f"\{data\} શરૂઆતમાં insert કર્યું")
    
    def insert\_at\_end(self, data):
        """અંતે node insert કરો"""
        new\_node = Node(data)
        
        if not self.head:  \# ખાલી list
            self.head = new\_node
            print(f"\{data\} અંતે insert કર્યું (પહેલો node)")
            return
        
        \# છેલ્લા node સુધી traverse કરો
        current = self.head
        while current.next:
            current = current.next
        
        current.next = new\_node
        print(f"\{data\} અંતે insert કર્યું")
    
    def display(self):
        """Linked list દર્શાવો"""
        if not self.head:
            print("List ખાલી છે")
            return
        
        current = self.head
        elements = []
        while current:
            elements.append(str(current.data))
            current = current.next
        
        print("  ".join(elements) + "  NULL")

\# ઉપયોગનું ઉદાહરણ
sll = SinglyLinkedList()

\# શરૂઆતમાં insert કરો
sll.insert\_at\_beginning(10)
sll.insert\_at\_beginning(20)
sll.display()  \# 20  10  NULL

\# અંતે insert કરો
sll.insert\_at\_end(30)
sll.insert\_at\_end(40)
sll.display()  \# 20  10  30  40  NULL
\end{verbatim}

\textbf{ટેબલ: Insertion Operations}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Time Complexity
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પગલાં
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{શરૂઆત} & O(1) & 1. Node બનાવો 2. Head ને point કરો 3. Head update
કરો \\
\textbf{અંત} & O(n) & 1. Node બનાવો 2. અંત સુધી traverse કરો 3. છેલ્લો node
link કરો \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``શરૂઆત = ઝડપથી (O(1)), અંત = પ્રવાસ (O(n))''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) OR [3
ગુણ]}\label{q4a}

\textbf{Doubly linked list સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Doubly Linked List Features}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બે Pointers} & દરેક node માં prev અને next \\
\textbf{Bidirectional} & આગળ અને પાછળ બંને તરફ traverse કરી શકાય \\
\textbf{Memory} & prev pointer માટે વધારાની જગ્યા \\
\textbf{લવચીકતા} & ગમે ત્યાં insertion/deletion સહેલું \\
\end{longtable}
}

\begin{verbatim}
class DoublyNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None
        self.prev = None

\# માળખાનું visualization
\# NULL  [prev|data|next] ⇄ [prev|data|next]  NULL
\end{verbatim}

\begin{verbatim}
Doubly Linked List માળખું:
NULL[A]⇄[B]⇄[C]
     prev next
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફાયદા}: Bidirectional traversal, સહેલું deletion
\item
  \textbf{નુકસાન}: prev pointer માટે વધારાની મેમરી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Doubly = બે બાજુનો રસ્તો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) OR [4
ગુણ]}\label{q4b}

\textbf{Linked List ની applications નું વર્ણન કરો.}

\begin{solutionbox}

\textbf{ટેબલ: Linked List Applications}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Application & Use Case & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Arrays} & જ્યારે size બદલાતું રહે & કાર્યક્ષમ memory usage \\
\textbf{Stack/Queue} & LIFO/FIFO operations & Dynamic size \\
\textbf{Graphs} & Adjacency list representation & Space efficient \\
\textbf{Music Playlist} & પાછલા/આગલા ગીતો & સહેલું navigation \\
\textbf{Browser History} & Back/Forward navigation & Dynamic history \\
\textbf{Undo Operations} & Text editors & કાર્યક્ષમ undo/redo \\
\end{longtable}
}

\begin{verbatim}
\# ઉદાહરણ: Doubly Linked List વાપરીને Browser History
class Page:
    def \_\_init\_\_(self, url):
        self.url = url
        self.prev = None
        self.next = None

class BrowserHistory:
    def \_\_init\_\_(self):
        self.current = None
    
    def visit(self, url):
        page = Page(url)
        if self.current:
            self.current.next = page
            page.prev = self.current
        self.current = page
    
    def back(self):
        if self.current and self.current.prev:
            self.current = self.current.prev
            return self.current.url
        return "કોઈ પાછલું page નથી"
    
    def forward(self):
        if self.current and self.current.next:
            self.current = self.current.next
            return self.current.url
        return "કોઈ આગલું page નથી"
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists = Dynamic, લવચીક, જોડાયેલ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) OR [7
ગુણ]}\label{q4c}

\textbf{Merge Sort algorithm નો પ્રોગ્રામ લખી સમજાવો.}

\begin{solutionbox}

\begin{verbatim}
def merge\_sort(arr):
    """Merge Sort implementation"""
    if len(arr) {=} 1:
        return arr
    
    \# Array ને બે ભાગમાં વહેંચો
    mid = len(arr) // 2
    left\_half = arr[:mid]
    right\_half = arr[mid:]
    
    \# બંને ભાગો recursively sort કરો
    left\_sorted = merge\_sort(left\_half)
    right\_sorted = merge\_sort(right\_half)
    
    \# Sorted ભાગોને merge કરો
    return merge(left\_sorted, right\_sorted)

def merge(left, right):
    """બે sorted arrays ને merge કરો"""
    result = []
    i = j = 0
    
    \# Elements compare કરીને merge કરો
    while i {} len(left) and j {} len(right):
        if left[i] {=} right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    \# બાકીના elements ઉમેરો
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

\# ઉદાહરણ
def demonstrate\_merge\_sort():
    arr = [64, 34, 25, 12, 22, 11, 90]
    print("મૂળ array:", arr)
    
    sorted\_arr = merge\_sort(arr)
    print("Sorted array:", sorted\_arr)

demonstrate\_merge\_sort()
\end{verbatim}

\textbf{ટેબલ: Merge Sort Analysis}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પાસું & મૂલ્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Time Complexity} & O(n log n) \\
\textbf{Space Complexity} & O(n) \\
\textbf{Stability} & Stable \\
\textbf{પ્રકાર} & Divide and Conquer \\
\end{longtable}
}

\textbf{Algorithm પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{વિભાજન}: Array ને બે ભાગમાં વહેંચો
\item
  \textbf{જીત}: બંને ભાગો recursively sort કરો
\item
  \textbf{જોડાણ}: Sorted ભાગોને merge કરો
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Merge Sort = વહેંચો, ગોઠવો, જોડો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{Binary tree ની applications નું વર્ણન કરો.}

\begin{solutionbox}

\textbf{ટેબલ: Binary Tree Applications}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4194}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2581}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3226}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Expression Trees} & ગાણિતિક expression representation &
(a+b)*c \\
\textbf{Decision Trees} & AI/ML માં decision making & Classification
algorithms \\
\textbf{File Systems} & Directory structure organization & Folder
hierarchy \\
\textbf{Database Indexing} & કાર્યક્ષમ searching માટે B-trees & Database
indices \\
\textbf{Huffman Coding} & Data compression technique & File
compression \\
\textbf{Heap Operations} & Priority queues implementation & Task
scheduling \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{વંશવેલો Data}: Tree-like structures ને કુદરતી રીતે represent કરે
\item
  \textbf{કાર્યક્ષમ Search}: Binary search trees O(log n) operations આપે
\item
  \textbf{Memory Management}: Compiler design માં syntax trees માટે વપરાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Trees = EDFDHH (Expression, Decision, File,
Database, Huffman, Heap)''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{ઉદાહરણ સાથે binary tree ની Indegree અને Outdegree સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Degree Definitions}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
શબ્દ & વ્યાખ્યા & Binary Tree Value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Indegree} & Node માં આવતા edges ની સંખ્યા & 0 (root) અથવા 1
(બાકી) \\
\textbf{Outdegree} & Node માંથી જતા edges ની સંખ્યા & 0, 1, અથવા 2 \\
\textbf{Degree} & Node સાથે જોડાયેલા કુલ edges & Indegree + Outdegree \\
\end{longtable}
}

\begin{verbatim}
Binary Tree ઉદાહરણ:
        A (indegree=0, outdegree=2)
       / {}
      B   C (indegree=1, outdegree=1)
     /   /
    D   E (indegree=1, outdegree=0)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Root Node}: હંમેશા indegree = 0
\item
  \textbf{Leaf Nodes}: હંમેશા outdegree = 0
\item
  \textbf{Internal Nodes}: outdegree = 1 અથવા 2
\end{itemize}

\textbf{ટેબલ: ઉદાહરણ Analysis}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Node & Indegree & Outdegree & Node Type \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & 0 & 2 & Root \\
B & 1 & 1 & Internal \\
C & 1 & 1 & Internal \\
D & 1 & 0 & Leaf \\
E & 1 & 0 & Leaf \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``In = અંદર આવતા, Out = બહાર જતા''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{Binary search tree બનાવવા માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
class TreeNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    def \_\_init\_\_(self):
        self.root = None
    
    def insert(self, data):
        """BST માં node insert કરો"""
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self.\_insert\_recursive(self.root, data)
    
    def \_insert\_recursive(self, node, data):
        if data {} node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self.\_insert\_recursive(node.left, data)
        elif data {} node.data:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self.\_insert\_recursive(node.right, data)
    
    def search(self, data):
        """BST માં node શોધો"""
        return self.\_search\_recursive(self.root, data)
    
    def \_search\_recursive(self, node, data):
        if node is None or node.data == data:
            return node
        
        if data {} node.data:
            return self.\_search\_recursive(node.left, data)
        else:
            return self.\_search\_recursive(node.right, data)
    
    def inorder\_traversal(self):
        """Inorder traversal (ડાબે, રૂટ, જમણે)"""
        result = []
        self.\_inorder\_recursive(self.root, result)
        return result
    
    def \_inorder\_recursive(self, node, result):
        if node:
            self.\_inorder\_recursive(node.left, result)
            result.append(node.data)
            self.\_inorder\_recursive(node.right, result)
    
    def display\_tree(self):
        """સાદું tree display"""
        if self.root:
            self.\_display\_recursive(self.root, 0)
    
    def \_display\_recursive(self, node, level):
        if node:
            self.\_display\_recursive(node.right, level + 1)
            print("  " * level + str(node.data))
            self.\_display\_recursive(node.left, level + 1)

\# ઉદાહરણ
bst = BinarySearchTree()
values = [50, 30, 70, 20, 40, 60, 80]

print("મૂલ્યો insert કરી રહ્યા છીએ:", values)
for value in values:
    bst.insert(value)

print("{n}Tree structure:")
bst.display\_tree()

print("{n}Inorder traversal:", bst.inorder\_traversal())

\# Search ઉદાહરણો
print(f"{n}40 શોધો: \{{મળ્યું} if bst.search(40) else {મળ્યું નહીં}\}")
print(f"90 શોધો: \{{મળ્યું} if bst.search(90) else {મળ્યું નહીં}\}")
\end{verbatim}

\textbf{ટેબલ: BST Operations}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Time Complexity & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insert} & O(log n) average, O(n) worst & નવો node ઉમેરો \\
\textbf{Search} & O(log n) average, O(n) worst & ચોક્કસ node શોધો \\
\textbf{Delete} & O(log n) average, O(n) worst & Node દૂર કરો \\
\textbf{Traversal} & O(n) & બધા nodes ની મુલાકાત \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``BST નિયમ = ડાબે \textless{} રૂટ \textless{} જમણે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) OR [3
ગુણ]}\label{q5a}

\textbf{Binary tree માં level, degree અને leaf node વ્યાખ્યાયિત કરો.}

\begin{solutionbox}

\textbf{ટેબલ: Binary Tree શબ્દો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2400}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3600}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શબ્દ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Level} & Root થી અંતર (root = level 0) & Root=0, Children=1,
વગેરે \\
\textbf{Degree} & Node ના children ની સંખ્યા & 0, 1, અથવા 2 \\
\textbf{Leaf Node} & કોઈ children વગરનો node (degree = 0) & Terminal
nodes \\
\end{longtable}
}

\begin{verbatim}
Levels સાથે Binary Tree:
Level 0:        A
               / {}
Level 1:      B   C
             /   / {}
Level 2:    D   E   F
\end{verbatim}

\textbf{ટેબલ: ઉદાહરણ Analysis}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Node & Level & Degree & પ્રકાર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & 0 & 2 & Root \\
B & 1 & 1 & Internal \\
C & 1 & 2 & Internal \\
D & 2 & 0 & Leaf \\
E & 2 & 0 & Leaf \\
F & 2 & 0 & Leaf \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Height}: Tree માં મહત્તમ level
\item
  \textbf{Depth}: એક node માટે level જેટલું જ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Level = માળનો નંબર, Degree = બાળકોની ગણતરી, Leaf =
કોઈ બાળક નથી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) OR [4
ગુણ]}\label{q5b}

\textbf{ઉદાહરણ સાથે complete binary tree સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Binary Tree પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2917}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3750}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ગુણધર્મ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Complete} & છેલ્લા સિવાય બધા levels ભરેલા, ડાબેથી ભરાય & કાર્યક્ષમ
array representation \\
\textbf{Full} & દરેક node પાસે 0 અથવા 2 children & એક child વાળા nodes
નથી \\
\textbf{Perfect} & બધા levels સંપૂર્ણ ભરેલા & 2\^{}h - 1 nodes \\
\end{longtable}
}

\begin{verbatim}
Complete Binary Tree:
        A
       / {}
      B   C
     / { /}
    D  E F

Complete નથી:
        A
       / {}
      B   C
       { / }
        E F G
\end{verbatim}

\begin{verbatim}
class CompleteBinaryTree:
    def \_\_init\_\_(self):
        self.tree = []
    
    def insert(self, data):
        """Complete binary tree રીતે insert કરો"""
        self.tree.append(data)
    
    def get\_parent\_index(self, i):
        return (i {-} 1) // 2
    
    def get\_left\_child\_index(self, i):
        return 2 * i + 1
    
    def get\_right\_child\_index(self, i):
        return 2 * i + 2
    
    def display\_level\_order(self):
        """Tree ને level દ્વારા દર્શાવો"""
        if not self.tree:
            return
        
        level = 0
        while (2 ** level) {=} len(self.tree):
            start = 2 ** level {-} 1
            end = min(2 ** (level + 1) {-} 1, len(self.tree))
            print(f"Level \{level\}: \{self.tree[start:end]\}")
            level += 1

\# ઉદાહરણ
cbt = CompleteBinaryTree()
for i in [1, 2, 3, 4, 5, 6]:
    cbt.insert(i)

cbt.display\_level\_order()
\end{verbatim}

\textbf{ગુણધર્મો:}

\begin{itemize}
\tightlist
\item
  \textbf{Array Representation}: Parent i પર, children 2i+1 અને 2i+2 પર
\item
  \textbf{Heap Property}: Heap data structure નો આધાર બને
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Complete = છેલ્લા સિવાય બધા માળ ભરેલા, ડાબેથી જમણે
ભરાય''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) OR [7
ગુણ]}\label{q5c}

\textbf{નીચેના નંબરોના ક્રમ માટે binary search tree (BST) બનાવો: 50, 70, 60,
20, 90, 10, 40, 100}

\begin{solutionbox}

\textbf{Step-by-step BST Construction:}

\begin{verbatim}
Insert 50: (Root)
    50

Insert 70: (70 > 50, જમણે જાઓ)
    50
     \
      70

Insert 60: (60 > 50, જમણે જાઓ; 60 < 70, ડાબે જાઓ)
    50
     \
      70
     /
    60

Insert 20: (20 < 50, ડાબે જાઓ)
    50
   /  \
  20   70
       /
      60

Insert 90: (90 > 50, જમણે; 90 > 70, જમણે)
    50
   /  \
  20   70
       / \
      60  90

Insert 10: (10 < 50, ડાબે; 10 < 20, ડાબે)
    50
   /  \
  20   70
 /    / \
10   60  90

Insert 40: (40 < 50, ડાબે; 40 > 20, જમણે)
    50
   /  \
  20   70
 / \   / \
10  40 60 90

Insert 100: (100 > 50, જમણે; 100 > 70, જમણે; 100 > 90, જમણે)
    50
   /  \
  20   70
 / \   / \
10  40 60 90
             \
              100
\end{verbatim}

\textbf{અંતિમ BST માળખું:}

\begin{verbatim}
        50
       /  {}
      20   70
     / {   / }
    10  40 60 90
              {}
               100
\end{verbatim}

\begin{verbatim}
\# Construction માટે implementation code
class BST:
    def \_\_init\_\_(self):
        self.root = None
    
    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
            print(f"\{data\} ને root તરીકે insert કર્યું")
        else:
            self.\_insert(self.root, data)
    
    def \_insert(self, node, data):
        if data {} node.data:
            if node.left is None:
                node.left = TreeNode(data)
                print(f"\{data\} ને \{node.data\} ના ડાબે insert કર્યું")
            else:
                self.\_insert(node.left, data)
        else:
            if node.right is None:
                node.right = TreeNode(data)
                print(f"\{data\} ને \{node.data\} ના જમણે insert કર્યું")
            else:
                self.\_insert(node.right, data)

\# BST બનાવો
bst = BST()
sequence = [50, 70, 60, 20, 90, 10, 40, 100]

for num in sequence:
    bst.insert(num)
\end{verbatim}

\textbf{ટેબલ: Traversal પરિણામો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Traversal & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Inorder} & 10, 20, 40, 50, 60, 70, 90, 100 \\
\textbf{Preorder} & 50, 20, 10, 40, 70, 60, 90, 100 \\
\textbf{Postorder} & 10, 40, 20, 60, 100, 90, 70, 50 \\
\end{longtable}
}

\textbf{ચકાસાયેલા ગુણધર્મો:}

\begin{itemize}
\tightlist
\item
  \textbf{BST Property}: ડાબું subtree \textless{} Root \textless{} જમણું
  subtree
\item
  \textbf{Inorder}: Sorted sequence આપે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BST Construction = તુલના કરો, દિશા પસંદ કરો, Insert
કરો''

\end{mnemonicbox}

\end{document}
