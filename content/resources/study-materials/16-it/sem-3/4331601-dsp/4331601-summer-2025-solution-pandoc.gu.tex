\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331601 -- Summer 2025}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{લીનીઅર અને નોન લીનીઅર ડેટા સ્ટ્રક્ચર નો તફાવત લખો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{લીનીઅર ડેટા સ્ટ્રક્ચર} & \textbf{નોન લીનીઅર ડેટા સ્ટ્રક્ચર} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
એલિમેન્ટ્સ ક્રમિક રીતે સ્ટોર કરાય છે & એલિમેન્ટ્સ હાયરાર્કિકલ રીતે સ્ટોર કરાય છે \\
સિંગલ લેવલ ગોઠવણી & મલ્ટિ લેવલ ગોઠવણી \\
સરળ ટ્રાવર્સલ & જટિલ ટ્રાવર્સલ \\
ઉદાહરણ: Array, Stack, Queue & ઉદાહરણ: Tree, Graph \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``લીનીઅર પાણીની જેમ વહે, નોન-લીનીઅર નેટવર્ક જેવું નેવિગેટ
કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{Object Oriented programming ના વિવિધ concepts સમજાવો.}

\begin{solutionbox}

\textbf{OOP કોન્સેપ્ટ્સ કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{કોન્સેપ્ટ} & \textbf{વર્ણન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Encapsulation} & ડેટા અને મેથડ્સ એકસાથે બાંધવું \\
\textbf{Inheritance} & પેરેન્ટ ક્લાસથી પ્રોપર્ટીઝ મેળવવી \\
\textbf{Polymorphism} & એક નામ, અનેક સ્વરૂપો \\
\textbf{Abstraction} & ઇમ્પ્લિમેન્ટેશન વિગતો છુપાવવી \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Encapsulation}: ડેટા હાઇડિંગ અને બન્ડલિંગ
\item
  \textbf{Inheritance}: પેરેન્ટ-ચાઇલ્ડ સંબંધ દ્વારા કોડ પુનઃઉપયોગ
\item
  \textbf{Polymorphism}: મેથડ ઓવરરાઇડિંગ અને ઓવરલોડિંગ
\item
  \textbf{Abstraction}: ઇમ્પ્લિમેન્ટેશન વગરનું ઇન્ટરફેસ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``દરેક હોશિયાર પ્રોગ્રામર Abstracts કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{Polymorphism ની વ્યાખ્યા આપો. Inheritance વડે Polymorphism નો
python program લખો.}

\begin{solutionbox}

\textbf{Polymorphism} એટલે ``અનેક સ્વરૂપો'' - એજ મેથડ નામ અલગ અલગ ક્લાસોમાં અલગ
વર્તન દર્શાવે.

\textbf{કોડ:}

\begin{verbatim}
class Animal:
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"

class Cat(Animal):
    def sound(self):
        return "Meow"

\# Polymorphism ની ક્રિયા
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.sound())
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Polymorphism}: સેમ ઇન્ટરફેસ, અલગ ઇમ્પ્લિમેન્ટેશન
\item
  \textbf{Runtime binding}: ઑબ્જેક્ટ ટાઇપ પર આધારિત મેથડ કૉલ
\item
  \textbf{કોડ લવચીકતા}: નવી ક્લાસો સાથે સરળતાથી વિસ્તાર
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Polymorphism પરફેક્ટ પ્રોગ્રામિંગ પ્રદાન કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) OR [7
ગુણ]}\label{q1c}

\textbf{Abstraction ની વ્યાખ્યા આપો. Abstract class નો concept સમજવા માટેનો
python program લખો.}

\begin{solutionbox}

\textbf{Abstraction} ઇમ્પ્લિમેન્ટેશન વિગતો છુપાવે છે અને ફક્ત જરૂરી ફીચર્સ બતાવે છે.

\textbf{કોડ:}

\begin{verbatim}
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def \_\_init\_\_(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width

\# ઉપયોગ
rect = Rectangle(5, 3)
print(f"Area: \{rect.area()\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Abstract class}: સીધી રીતે instantiate કરી શકાતી નથી
\item
  \textbf{Abstract method}: ચાઇલ્ડ ક્લાસોમાં ઇમ્પ્લિમેન્ટ કરવું આવશ્યક
\item
  \textbf{ઇન્ટરફેસ ડેફિનિશન}: સબક્લાસ માટે ટેમ્પ્લેટ પ્રદાન કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Abstraction વાસ્તવિક ઇમ્પ્લિમેન્ટેશન ટાળે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{નીચેની વ્યાખ્યા આપો: I. Best case II. Worst case III. Average case}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{કેસ} & \textbf{વ્યાખ્યા} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Best case} & અલ્ગોરિધમ માટે લઘુત્તમ સમય જરૂરી \\
\textbf{Worst case} & અલ્ગોરિધમ માટે મહત્તમ સમય જરૂરી \\
\textbf{Average case} & રેન્ડમ ઇનપુટ માટે અપેક્ષિત સમય \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Best-Worst-Average = પરફોર્મન્સ એનાલિસિસ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{Infix, postfix અને prefix એક્સપ્રેશન સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{એક્સપ્રેશન} & \textbf{ઑપરેટર પોઝિશન} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Infix} & ઑપરેન્ડ્સ વચ્ચે & A + B \\
\textbf{Prefix} & ઑપરેન્ડ્સ પહેલાં & + A B \\
\textbf{Postfix} & ઑપરેન્ડ્સ પછી & A B + \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Infix}: પ્રાકૃતિક ગાણિતિક સંકેત
\item
  \textbf{Prefix}: Polish notation
\item
  \textbf{Postfix}: Reverse Polish notation
\item
  \textbf{Stack ઉપયોગ}: Postfix કૌંસ દૂર કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``In-Pre-Post = ઑપરેટરની સ્થિતિ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{Circular queue ની વ્યાખ્યા આપો. Circular queue ના INSERT અને DELETE
operations આકૃતિ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Circular Queue}: લીનીઅર ડેટા સ્ટ્રક્ચર જેમાં છેલ્લી સ્થિતિ પ્રથમ સ્થિતિ સાથે
જોડાય છે.

\textbf{આકૃતિ:}

\begin{verbatim}
     [0] [1] [2] [3]
      ↑           ↑
   front        rear
\end{verbatim}

\textbf{INSERT ઑપરેશન:}

\begin{verbatim}
1. ચકાસો કે queue ભરાઈ ગઈ છે કે નહીં
2. જો ભરાઈ નથી, rear વધારો
3. જો rear size કરતાં વધે, rear = 0 કરો
4. rear પોઝિશને એલિમેન્ટ insert કરો
\end{verbatim}

\textbf{DELETE ઑપરેશન:}

\begin{verbatim}
1. ચકાસો કે queue ખાલી છે કે નહીં
2. જો ખાલી નથી, front માંથી એલિમેન્ટ કાઢો
3. front વધારો
4. જો front size કરતાં વધે, front = 0 કરો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ગોળ પ્રકૃતિ}: કાર્યક્ષમ મેમરી ઉપયોગ
\item
  \textbf{કોઈ શિફ્ટિંગ નહીં}: એલિમેન્ટ્સ જગ્યામાં રહે
\item
  \textbf{Front-rear pointers}: queue બાઉન્ડરીઝ ટ્રેક કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular સ્પેસ બચાવે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) OR [3
ગુણ]}\label{q2a}

\textbf{ઉદાહરણ સાથે વિવિધ Data Structure જણાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{પ્રકાર} & \textbf{ડેટા સ્ટ્રક્ચર} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{લીનીઅર} & Array & [1,2,3,4] \\
\textbf{લીનીઅર} & Stack & Function calls \\
\textbf{લીનીઅર} & Queue & Printer queue \\
\textbf{નોન-લીનીઅર} & Tree & File system \\
\textbf{નોન-લીનીઅર} & Graph & Social network \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Arrays-Stacks-Queues = લીનીઅર, Trees-Graphs =
નોન-લીનીઅર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) OR [4
ગુણ]}\label{q2b}

\textbf{Circular queue એ simple queue કરતાં કેવી રીતે અલગ છે તે જણાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Simple Queue} & \textbf{Circular Queue} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લીનીઅર ગોઠવણી & ગોળ ગોઠવણી \\
મેમરી બગાડ & કાર્યક્ષમ મેમરી ઉપયોગ \\
ફિક્સ્ડ front અને rear & Wraparound pointers \\
False overflow & True overflow detection \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{મેમરી કાર્યક્ષમતા}: Circular ડિલીટ કરેલી જગ્યાઓ ફરી વાપરે
\item
  \textbf{Pointer મેનેજમેન્ટ}: Wraparound માટે મોડ્યુલો અંકગણિત
\item
  \textbf{પરફોર્મન્સ}: બહેતર સ્પેસ ઉપયોગ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular મેમરી સમસ્યાઓ જીતે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) OR [7
ગુણ]}\label{q2c}

\textbf{Stack ની વ્યાખ્યા આપો. PUSH અને POP operation ઉદાહરણ સાથે સમજાવો.
Stack ના PUSH અને POP operation ના algorithm લખો.}

\begin{solutionbox}

\textbf{Stack}: LIFO (Last In First Out) ડેટા સ્ટ્રક્ચર.

\textbf{PUSH Algorithm:}

\begin{verbatim}
1. ચકાસો કે stack ભરાઈ ગઈ છે કે નહીં
2. જો ભરાઈ નથી, top વધારો
3. top પોઝિશને એલિમેન્ટ insert કરો
4. top pointer અપડેટ કરો
\end{verbatim}

\textbf{POP Algorithm:}

\begin{verbatim}
1. ચકાસો કે stack ખાલી છે કે નહીં
2. જો ખાલી નથી, top એલિમેન્ટ સ્ટોર કરો
3. top pointer ઘટાડો
4. સ્ટોર કરેલું એલિમેન્ટ return કરો
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
Stack: [10, 20, 30] \leftarrow top
PUSH 40: [10, 20, 30, 40] \leftarrow top
POP: returns 40, stack: [10, 20, 30] \leftarrow top
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{LIFO સિદ્ધાંત}: છેલ્લું ઉમેરેલું એલિમેન્ટ પ્રથમ કાઢવામાં આવે
\item
  \textbf{Top pointer}: વર્તમાન stack પોઝિશન ટ્રેક કરે
\item
  \textbf{Overflow/Underflow}: ઑપરેશન પહેલાં ચકાસણી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Stack છેલ્લા-અંદર-પ્રથમ-બહાર સ્ટોર કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{નીચે આપેલા infix expression ને postfix માં ફેરવો: ( ( ( A - B ) * C )
+ ( ( D - E ) / F ) )}

\begin{solutionbox}

\textbf{પગલાબદ્ધ રૂપાંતર:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\textbf{પગલું} & \textbf{Scanned} & \textbf{Stack} & \textbf{Postfix} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & ( & ( & \\
2 & ( & (( & \\
3 & ( & ((( & \\
4 & A & ((( & A \\
5 & - & (((- & A \\
6 & B & (((- & AB \\
7 & ) & (( & AB- \\
8 & * & ((* & AB- \\
9 & C & ((* & AB-C \\
10 & ) & ( & AB-C* \\
11 & + & (+ & AB-C* \\
12 & ( & (+( & AB-C* \\
13 & ( & (+(( & AB-C* \\
14 & D & (+(( & AB-C*D \\
15 & - & (+((- & AB-C*D \\
16 & E & (+((- & AB-C*DE \\
17 & ) & (+ & AB-C*DE- \\
18 & / & (+(/ & AB-C*DE- \\
19 & F & (+(/ & AB-C*DE-F \\
20 & ) & (+ & AB-C*DE-F/ \\
21 & ) & & AB-C*DE-F/+ \\
\end{longtable}
}

**અંતિમ જવાબ: AB-C*DE-F/+**

\end{solutionbox}
\begin{mnemonicbox}
``Postfix ઑપરેટર્સ ઑપરેન્ડ્સ પછી મૂકે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{Doubly linked list વિશે ટૂંકનોંધ લખો.}

\begin{solutionbox}

\textbf{Doubly Linked List}: દ્વિદિશીય લિંક્સ સાથેની લીનીઅર ડેટા સ્ટ્રક્ચર.

\textbf{સ્ટ્રક્ચર:}

\begin{verbatim}
NULL  [prev|data|next]  [prev|data|next]  [prev|data|next]  NULL
\end{verbatim}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{દ્વિદિશીય traversal}: આગળ અને પાછળ navigation
\item
  \textbf{કાર્યક્ષમ deletion}: પાછલા node ના reference ની જરૂર નહીં
\item
  \textbf{બહેતર insertion}: આપેલા node પહેલાં સરળતાથી insert કરી શકાય
\end{itemize}

\textbf{ગેરફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{વધારાની મેમરી}: વધારાના pointer storage
\item
  \textbf{જટિલ operations}: વધુ pointer manipulations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Doubly દ્વિદિશીય ફાયદાઓ આપે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{Singly linked list માં પ્રથમ અને અંતિમ node કાઢવા માટેનો Python
Program લખો.}

\begin{solutionbox}

\textbf{કોડ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def delete\_first(self):
        if self.head is None:
            return "List is empty"
        self.head = self.head.next
        return "First node deleted"
    
    def delete\_last(self):
        if self.head is None:
            return "List is empty"
        if self.head.next is None:
            self.head = None
            return "Last node deleted"
        
        current = self.head
        while current.next.next:
            current = current.next
        current.next = None
        return "Last node deleted"
    
    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        return elements

\# ઉપયોગ
ll = LinkedList()
\# nodes ઉમેરો અને deletion ટેસ્ટ કરો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રથમ ડિલીટ}: head pointer અપડેટ કરો
\item
  \textbf{છેલ્લું ડિલીટ}: બીજા છેલ્લા node સુધી traverse કરો
\item
  \textbf{Edge cases}: ખાલી list અને સિંગલ node
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Delete pointer અપડેટ દ્વારા આપે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) OR [3
ગુણ]}\label{q3a}

\textbf{Queue ની વિવિધ એપ્લિકેશન જણાવો.}

\begin{solutionbox}

\textbf{Queue એપ્લિકેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{એપ્લિકેશન} & \textbf{ઉપયોગ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{CPU Scheduling} & Process management \\
\textbf{Print Queue} & Document printing \\
\textbf{BFS Algorithm} & Graph traversal \\
\textbf{Buffer} & Data streaming \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{FIFO પ્રકૃતિ}: પ્રથમ આવ્યો પ્રથમ સેવા
\item
  \textbf{Real-time systems}: ઓર્ડરમાં requests handle કરે
\item
  \textbf{Resource sharing}: વાજબી ફાળવણી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Queues ક્રમબદ્ધ operations શાંતિથી handle કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) OR [4
ગુણ]}\label{q3b}

\textbf{Singly linked list પર આપણે કરી શકીએ તેવા વિવિધ ઑપરેશન્સ સમજાવો.}

\begin{solutionbox}

\textbf{Singly Linked List ઑપરેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{ઑપરેશન} & \textbf{વર્ણન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insertion} & શરૂઆત/અંત/મધ્યમાં node ઉમેરવું \\
\textbf{Deletion} & કોઈપણ પોઝિશનથી node કાઢવું \\
\textbf{Traversal} & બધા nodes ને ક્રમિક રીતે visit કરવા \\
\textbf{Search} & list માં ચોક્કસ ડેટા શોધવું \\
\textbf{Count} & કુલ nodes ની ગિનતી કરવી \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{ડાયનામિક સાઇઝ}: runtime દરમિયાન વધે/ઘટે
\item
  \textbf{મેમરી કાર્યક્ષમતા}: જરૂર મુજબ allocate કરે
\item
  \textbf{Sequential access}: કોઈ random access નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Insert-Delete-Traverse-Search-Count''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) OR [7
ગુણ]}\label{q3c}

\textbf{Doubly linked list માં અંતે નવી node insert કરવા માટેનો algorithm
લખો.}

\begin{solutionbox}

\textbf{અંતે insertion માટે Algorithm:}

\begin{verbatim}
1. આપેલા ડેટા સાથે નવું node બનાવો
2. નવા node નું next = NULL કરો
3. જો list ખાલી છે:
   - head = નવું node કરો
   - નવા node નું prev = NULL કરો
4. નહીં તો:
   - છેલ્લા node સુધી traverse કરો
   - છેલ્લા node નું next = નવું node કરો
   - નવા node નું prev = છેલ્લું node કરો
5. success return કરો
\end{verbatim}

\textbf{કોડ:}

\begin{verbatim}
def insert\_at\_end(self, data):
    new\_node = Node(data)
    if self.head is None:
        self.head = new\_node
        return
    
    current = self.head
    while current.next:
        current = current.next
    
    current.next = new\_node
    new\_node.prev = current
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{દ્વિદિશીય લિંકિંગ}: next અને prev બંને pointers અપડેટ કરો
\item
  \textbf{અંત insertion}: છેલ્લું node શોધવા traverse કરો
\item
  \textbf{દ્વિદિશીય કનેક્શન}: list integrity જાળવો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``દ્વિદિશીય લિંક્સ સાથે હોશિયારીથી Insert કરો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{Linear search માટેનો Python Program લખો.}

\begin{solutionbox}

\textbf{કોડ:}

\begin{verbatim}
def linear\_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return {-}1

\# ઉદાહરણ ઉપયોગ
data = [10, 20, 30, 40, 50]
result = linear\_search(data, 30)
print(f"Element found at index: \{result\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Sequential search}: દરેક element એક પછી એક ચકાસો
\item
  \textbf{Time complexity}: O(n)
\item
  \textbf{સાદું implementation}: સમજવામાં આસાન
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Linear દરેક element દ્વારા જુએ છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{Circular linked list વિશે ટૂંકનોંધ લખો.}

\begin{solutionbox}

\textbf{Circular Linked List}: છેલ્લું node પ્રથમ node તરફ પાછું point કરે છે અને
ગોળ બનાવે છે.

\textbf{આકૃતિ:}

\begin{verbatim}
[data|next]  [data|next]  [data|next]
     ↑                           ↓
     
\end{verbatim}

\textbf{લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{કોઈ NULL pointers નથી}: છેલ્લું node પ્રથમ સાથે જોડાય
\item
  \textbf{સતત traversal}: અનંત traversal શક્ય
\item
  \textbf{મેમરી કાર્યક્ષમતા}: બહેતર cache performance
\item
  \textbf{એપ્લિકેશન્સ}: Round-robin scheduling, multiplayer games
\end{itemize}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{કાર્યક્ષમ insertion}: કોઈપણ પોઝિશને
\item
  \textbf{કોઈ બગડેલા pointers નથી}: બધા nodes જોડાયેલા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular બધું loop માં જોડે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{Quick sort algorithm ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Quick Sort}: Pivot element વાપરીને divide અને conquer sorting
algorithm.

\textbf{Algorithm:}

\begin{verbatim}
1. Pivot element પસંદ કરો
2. Pivot આસપાસ array partition કરો
3. બાઈ subarray ને recursively sort કરો
4. જમણી subarray ને recursively sort કરો
\end{verbatim}

\textbf{ઉદાહરણ: [64, 34, 25, 12, 22, 11, 90] સોર્ટ કરો}

\textbf{પગલું 1:} Pivot = 64

\begin{verbatim}
[34, 25, 12, 22, 11] 64 [90]
\end{verbatim}

\textbf{પગલું 2:} બાઈ partition [34, 25, 12, 22, 11] સોર્ટ કરો Pivot =
34

\begin{verbatim}
[25, 12, 22, 11] 34 []
\end{verbatim}

\textbf{અંતિમ sorted:} [11, 12, 22, 25, 34, 64, 90]

\begin{itemize}
\tightlist
\item
  \textbf{Divide અને conquer}: સમસ્યાને નાના ભાગોમાં વહેંચો
\item
  \textbf{In-place sorting}: ન્યૂનતમ વધારાની મેમરી
\item
  \textbf{Average complexity}: O(n log n)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Quick Partitions પછી જીતે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) OR [3
ગુણ]}\label{q4a}

\textbf{Binary search algorithm ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Binary Search}: Divide અને conquer વાપરીને sorted arrays માટે
search algorithm.

\textbf{Algorithm:}

\begin{verbatim}
1. left = 0, right = array length - 1 સેટ કરો
2. જ્યાં સુધી left <= right:
   - mid = (left + right) / 2 calculate કરો
   - જો target = array[mid], mid return કરો
   - જો target < array[mid], right = mid - 1
   - જો target > array[mid], left = mid + 1
3. ન મળે તો -1 return કરો
\end{verbatim}

\textbf{ઉદાહરણ: [11, 12, 22, 25, 34, 64, 90] માં 22 શોધો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llllll@{}}
\toprule\noalign{}
\textbf{પગલું} & \textbf{Left} & \textbf{Right} & \textbf{Mid} &
\textbf{Value} & \textbf{Action} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 0 & 6 & 3 & 25 & 22 \textless{} 25, right = 2 \\
2 & 0 & 2 & 1 & 12 & 22 \textgreater{} 12, left = 2 \\
3 & 2 & 2 & 2 & 22 & મળ્યું! \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Binary ઝડપથી શોધવા બે ભાગ કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) OR [4
ગુણ]}\label{q4b}

\textbf{Linked list ની વિવિધ એપ્લિકેશન જણાવો.}

\begin{solutionbox}

\textbf{Linked List એપ્લિકેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{એપ્લિકેશન} & \textbf{ઉપયોગ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Arrays} & Resizable ડેટા storage \\
\textbf{Stack/Queue Implementation} & LIFO/FIFO structures \\
\textbf{Graph Representation} & Adjacency lists \\
\textbf{Memory Management} & Free memory blocks \\
\textbf{Music Playlist} & Next/previous song navigation \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{ડાયનામિક મેમરી}: જરૂર મુજબ allocate કરો
\item
  \textbf{કાર્યક્ષમ insertion/deletion}: કોઈ shifting જરૂરી નથી
\item
  \textbf{લવચીક structure}: બદલાતી જરૂરિયાતોને અનુકૂળ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists ડાયનામિક એપ્લિકેશન્સમાં રહે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) OR [7
ગુણ]}\label{q4c}

\textbf{ઉદાહરણ સાથે Insertion sort માટેનો python program લખો.}

\begin{solutionbox}

\textbf{કોડ:}

\begin{verbatim}
def insertion\_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i {-} 1
        
        while j {=} 0 and arr[j] {} key:
            arr[j + 1] = arr[j]
            j {-=} 1
        
        arr[j + 1] = key
    
    return arr

\# ઉદાહરણ
data = [64, 34, 25, 12, 22, 11, 90]
sorted\_data = insertion\_sort(data)
print(f"Sorted array: \{sorted\_data\}")
\end{verbatim}

\textbf{પગલાબદ્ધ ઉદાહરણ:}

\begin{verbatim}
Initial: [64, 34, 25, 12, 22, 11, 90]
Pass 1:  [34, 64, 25, 12, 22, 11, 90]
Pass 2:  [25, 34, 64, 12, 22, 11, 90]
Pass 3:  [12, 25, 34, 64, 22, 11, 90]
Pass 4:  [12, 22, 25, 34, 64, 11, 90]
Pass 5:  [11, 12, 22, 25, 34, 64, 90]
Pass 6:  [11, 12, 22, 25, 34, 64, 90]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કાર્ડ sorting analogy}: playing cards ગોઠવવા જેવું
\item
  \textbf{Stable sort}: સમાન elements નો relative order જાળવે
\item
  \textbf{Online algorithm}: ડેટા મળતા જ list sort કરી શકે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Insertion યોગ્ય જગ્યામાં Insert કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{નીચેની વ્યાખ્યા આપો: I. Complete Binary tree II. In-degree III.
Out-degree.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{શબ્દ} & \textbf{વ્યાખ્યા} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Complete Binary Tree} & છેલ્લા level સિવાય બધા levels ડાબેથી
ભરાયેલા \\
\textbf{In-degree} & Node માં આવતા edges ની સંખ્યા \\
\textbf{Out-degree} & Node માંથી જતા edges ની સંખ્યા \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Complete-In-Out = Tree terminology''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{Bubble sort algorithm ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Bubble Sort}: અડીખમ elements ની તુલના કરો અને ખોટા ક્રમમાં હોય તો
swap કરો.

\textbf{Algorithm:}

\begin{verbatim}
1. દરેક pass માટે (0 થી n-1):
   2. દરેક element માટે (0 થી n-pass-1):
      3. જો arr[j] > arr[j+1]:
         4. arr[j] અને arr[j+1] swap કરો
\end{verbatim}

\textbf{ઉદાહરણ: [64, 34, 25, 12]}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Pass} & \textbf{Comparisons} & \textbf{Result} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 64\textgreater34(swap), 64\textgreater25(swap),
64\textgreater12(swap) & [34,25,12,64] \\
2 & 34\textgreater25(swap), 34\textgreater12(swap) &
[25,12,34,64] \\
3 & 25\textgreater12(swap) & [12,25,34,64] \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Bubble up}: સૌથી મોટું element અંતે bubble થાય
\item
  \textbf{Multiple passes}: દરેક pass એક element સાચી જગ્યામાં મૂકે
\item
  \textbf{સાદું implementation}: સમજવામાં આસાન
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Bubble સૌથી મોટાને પાછળ લાવે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{આપેલી સંખ્યાઓ માટે Binary Search Tree બનાવો તથા તેના Preorder,
Inorder અને Postorder traversals લખો: 15, 35, 12, 48, 5, 25, 58, 8}

\begin{solutionbox}

\textbf{BST Construction:}

\begin{verbatim}
        15
       /  {}
      12   35
     /    /  {}
    5    25   48
     {          }
      8          58
\end{verbatim}

\textbf{Traversal Sequences:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Traversal} & \textbf{Sequence} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Preorder} & 15, 12, 5, 8, 35, 25, 48, 58 \\
\textbf{Inorder} & 5, 8, 12, 15, 25, 35, 48, 58 \\
\textbf{Postorder} & 8, 5, 12, 25, 58, 48, 35, 15 \\
\end{longtable}
}

\textbf{Traversal નિયમો:}

\begin{itemize}
\tightlist
\item
  \textbf{Preorder}: Root \rightarrow Left \rightarrow Right
\item
  \textbf{Inorder}: Left \rightarrow Root \rightarrow Right (sorted order આપે)
\item
  \textbf{Postorder}: Left \rightarrow Right \rightarrow Root
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Pre-In-Post = Root ની સ્થિતિ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) OR [3
ગુણ]}\label{q5a}

\textbf{Binary tree ની વ્યાખ્યા આપો. Binary tree માં node searching વિશે
સમજાવો.}

\begin{solutionbox}

\textbf{Binary Tree}: Hierarchical ડેટા structure જેમાં દરેક node ને મહત્તમ બે
children હોય.

\textbf{Search Algorithm:}

\begin{verbatim}
1. Root થી શરુઆત કરો
2. જો target = current node, found return કરો
3. જો target < current node, ડાબે જાઓ
4. જો target > current node, જમણે જાઓ
5. મળે કે NULL સુધી પહોંચે ત્યાં સુધી repeat કરો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Hierarchical structure}: Parent-child સંબંધ
\item
  \textbf{Binary property}: node દીઠ મહત્તમ બે children
\item
  \textbf{Search કાર્યક્ષમતા}: Balanced trees માટે O(log n)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Binary બે પાથમાં branch કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) OR [4
ગુણ]}\label{q5b}

\textbf{આપેલા ડેટા ને bubble sort ની મદદથી ચડતા ક્રમમાં ગોઠવી બતાવો. ડેટા: 44,
72, 94, 28, 18, 442, 41}

\begin{solutionbox}

\textbf{Bubble Sort Trace:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Pass} & \textbf{Array State} & \textbf{Swaps} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Initial & [44, 72, 94, 28, 18, 442, 41] & - \\
Pass 1 & [44, 72, 28, 18, 94, 41, 442] & 94\textgreater28,
94\textgreater18, 442\textgreater41 \\
Pass 2 & [44, 28, 18, 72, 41, 94, 442] & 72\textgreater28,
72\textgreater18, 94\textgreater41 \\
Pass 3 & [28, 18, 44, 41, 72, 94, 442] & 44\textgreater28,
44\textgreater18, 72\textgreater41 \\
Pass 4 & [18, 28, 41, 44, 72, 94, 442] & 28\textgreater18,
44\textgreater41 \\
Pass 5 & [18, 28, 41, 44, 72, 94, 442] & કોઈ swaps નથી \\
\end{longtable}
}

\textbf{અંતિમ sorted array:} [18, 28, 41, 44, 72, 94, 442]

\end{solutionbox}
\begin{mnemonicbox}
``Bubble sort દરેક pass સૌથી મોટાને અંતે bubbles કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) OR [7
ગુણ]}\label{q5c}

\textbf{Trees ની વિવિધ એપ્લિકેશન જણાવો. General tree ને Binary Search Tree
માં રૂપાંતર કરવા માટેની technique ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Tree એપ્લિકેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{એપ્લિકેશન} & \textbf{ઉપયોગ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{File System} & Directory hierarchy \\
\textbf{Expression Trees} & ગાણિતિક expressions \\
\textbf{Decision Trees} & AI અને machine learning \\
\textbf{Heap} & Priority queues \\
\end{longtable}
}

\textbf{General Tree થી BST રૂપાંતર:}

\textbf{Technique: First Child - Next Sibling Representation}

\textbf{મૂળ General Tree:}

\begin{verbatim}
    A
   /|\
  B C D
 /| |
E F G
\end{verbatim}

\textbf{Binary Tree માં રૂપાંતર:}

\begin{verbatim}
    A
   /
  B
   {}
    C
   / {}
  E   D
   {}
    F
     {}
      G
\end{verbatim}

\textbf{પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{First child}: Binary tree માં left child બને
\item
  \textbf{Next sibling}: Binary tree માં right child બને
\item
  \textbf{Recursive application}: બધા nodes પર લાગુ કરો
\end{enumerate}

\begin{itemize}
\tightlist
\item
  \textbf{વ્યવસ્થિત રૂપાંતર}: Tree structure જાળવે
\item
  \textbf{Binary representation}: node દીઠ ફક્ત બે pointers વાપરે
\item
  \textbf{Space કાર્યક્ષમતા}: મानક binary tree operations લાગુ પડે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``First-child ડાબે, Next-sibling જમણે''

\end{mnemonicbox}

\end{document}
