\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331601 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{પાયથોનમાં સેટ ડેટા સ્ટ્રક્ચર સમજાવો?}

\begin{solutionbox}

\textbf{સેટ} એ પાયથોનમાં અનન્ય એલિમેન્ટ્સનો અક્રમ સંગ્રહ છે. સેટ્સ mutable છે પરંતુ તેમાં
ફક્ત immutable એલિમેન્ટ્સ જ હોય છે.

\textbf{મુખ્ય લક્ષણો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
લક્ષણ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{અનન્ય એલિમેન્ટ્સ} & કોઈ ડુપ્લિકેટ વેલ્યુઝ મંજૂર નથી \\
\textbf{અક્રમ} & કોઈ ઇન્ડેક્સિંગ અથવા સ્લાઇસિંગ નથી \\
\textbf{Mutable} & એલિમેન્ટ્સ ઉમેરી/દૂર કરી શકાય છે \\
\textbf{Iterable} & એલિમેન્ટ્સમાં લૂપ ચલાવી શકાય છે \\
\end{longtable}
}

\textbf{મૂળભૂત ઓપરેશન્સ:}

\begin{verbatim}
\# સેટ બનાવો
my\_set = \{1, 2, 3, 4\}
\# એલિમેન્ટ ઉમેરો
my\_set.add(5)
\# એલિમેન્ટ દૂર કરો
my\_set.remove(2)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``સેટ્સ એ અનન્ય અક્રમ સંગ્રહો છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{પાયથોનમાં Tuple ની વ્યાખ્યા આપો? પાયથોનમાં Tuple data structure ના
operations સમજાવો.}

\begin{solutionbox}

\textbf{Tuple} એ આઇટમ્સનો ક્રમિત સંગ્રહ છે જે immutable છે (બનાવ્યા પછી બદલી
શકાતું નથી).

\textbf{Tuple વ્યાખ્યા:}

\begin{itemize}
\tightlist
\item
  \textbf{ક્રમિત}: એલિમેન્ટ્સનો નિશ્ચિત ક્રમ
\item
  \textbf{Immutable}: બનાવ્યા પછી બદલી શકાતું નથી
\item
  \textbf{ડુપ્લિકેટ્સ મંજૂર}: સમાન વેલ્યુઝ આવી શકે છે
\item
  \textbf{ઇન્ડેક્સ્ડ}: ઇન્ડેક્સ વાપરીને એક્સેસ કરી શકાય છે
\end{itemize}

\textbf{Tuple ઓપરેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઓપરેશન & ઉદાહરણ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બનાવવું} & \texttt{t\ =\ (1,\ 2,\ 3)} & Tuple બનાવો \\
\textbf{ઇન્ડેક્સિંગ} & \texttt{t[0]} & પ્રથમ એલિમેન્ટ એક્સેસ કરો \\
\textbf{સ્લાઇસિંગ} & \texttt{t[1:3]} & સબસેટ મેળવો \\
\textbf{લેન્થ} & \texttt{len(t)} & એલિમેન્ટ્સ ગણો \\
\textbf{જોડાણ} & \texttt{t1\ +\ t2} & Tuples જોડો \\
\end{longtable}
}

\begin{verbatim}
\# ઉદાહરણ ઓપરેશન્સ
tup = (10, 20, 30, 40)
print(tup[1])      \# આઉટપુટ: 20
print(tup[1:3])    \# આઉટપુટ: (20, 30)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Tuples એ Immutable ક્રમિત સંગ્રહો છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{પાયથોનમાં કન્સ્ટ્રક્ટરના પ્રકારો સમજાવો? Static methodનો ઉપયોગ કરીને બે
સંખ્યાઓના ગુણાકાર માટે પાયથોન પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{કન્સ્ટ્રક્ટરના પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5455}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2424}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2121}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કન્સ્ટ્રક્ટર પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Default Constructor} & કોઈ પેરામીટર નથી &
\texttt{\_\_init\_\_(self)} \\
\textbf{Parameterized Constructor} & પેરામીટર લે છે &
\texttt{\_\_init\_\_(self,\ params)} \\
\textbf{Non-parameterized Constructor} & ફક્ત self પેરામીટર & મૂળભૂત
પ્રારંભિકરણ \\
\end{longtable}
}

\textbf{Static Method પ્રોગ્રામ:}

\begin{verbatim}
class Calculator:
    def \_\_init\_\_(self):
        pass
    
    @staticmethod
    def multiply(num1, num2):
        return num1 * num2

\# ઉપયોગ
result = Calculator.multiply(5, 3)
print(f"ગુણાકાર: \{result\}")  \# આઉટપુટ: 15
\end{verbatim}

\textbf{મુખ્ય મુદ્દાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Static methods}: ઑબ્જેક્ટ ઇન્સ્ટન્સની જરૂર નથી
\item
  \textbf{@staticmethod decorator}: Static method દર્શાવે છે
\item
  \textbf{કોઈ self પેરામીટર નથી}: ક્લાસ ઇન્સ્ટન્સથી સ્વતંત્ર
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Static methods સેલ્ફથી અલગ રહે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(c) અથવા [7
ગુણ]}\label{q1c}

\textbf{Data Encapsulation ની વ્યાખ્યા આપો? પાયથોનમાં વિવિધ પ્રકારની methods
ની યાદી આપો. Multilevel inheritance માટે પાયથોન પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{Data Encapsulation:} ડેટા એન્કેપ્સુલેશન એ ડેટા અને methods ને ક્લાસની અંદર
બાંધવાની અને કેટલાક ઘટકોની સીધી પહોંચ મર્યાદિત કરવાની વિભાવના છે.

\textbf{Methods ના પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method પ્રકાર & પહોંચ સ્તર & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Public} & બધે પહોંચી શકાય છે & \texttt{method()} \\
\textbf{Protected} & ક્લાસ અને સબક્લાસ & \texttt{\_method()} \\
\textbf{Private} & ફક્ત ક્લાસની અંદર & \texttt{\_\_method()} \\
\textbf{Static} & ક્લાસ લેવલ & \texttt{@staticmethod} \\
\textbf{Class} & ક્લાસ અને સબક્લાસીઝ & \texttt{@classmethod} \\
\end{longtable}
}

\textbf{Multilevel Inheritance પ્રોગ્રામ:}

\begin{verbatim}
class Animal:
    def \_\_init\_\_(self, name):
        self.name = name
    
    def speak(self):
        print(f"\{self.name\} અવાજ કરે છે")

class Mammal(Animal):
    def \_\_init\_\_(self, name, warm\_blooded):
        super().\_\_init\_\_(name)
        self.warm\_blooded = warm\_blooded

class Dog(Mammal):
    def \_\_init\_\_(self, name, breed):
        super().\_\_init\_\_(name, True)
        self.breed = breed
    
    def bark(self):
        print(f"\{self.name\} ભસે છે")

\# ઉપયોગ
dog = Dog("બડી", "ગોલ્ડન રિટ્રીવર")
dog.speak()  \# Animal ક્લાસથી
dog.bark()   \# Dog ક્લાસથી
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``એન્કેપ્સુલેશન આંતરિક વિગતો છુપાવે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{Simple Queue અને Circular Queue વચ્ચેનો તફાવત આપો.}

\begin{solutionbox}

\textbf{Queue સરખામણી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & Simple Queue & Circular Queue \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સ્ટ્રક્ચર} & રેખીય ગોઠવણી & વર્તુળાકાર ગોઠવણી \\
\textbf{મેમરી ઉપયોગ} & બગાડજનક (ખાલી જગ્યાઓ) & કાર્યક્ષમ (જગ્યા પુનઃઉપયોગ) \\
\textbf{Rear Pointer} & રેખીય રીતે આગળ વધે છે & ફરીથી આગળ વળે છે \\
\textbf{Front Pointer} & રેખીય રીતે આગળ વધે છે & ફરીથી આગળ વળે છે \\
\textbf{જગ્યા ઉપયોગ} & નબળો & ઉત્તમ \\
\end{longtable}
}

\textbf{મુખ્ય તફાવતો:}

\begin{itemize}
\tightlist
\item
  \textbf{Simple Queue}: Front અને rear ફક્ત એક દિશામાં જાય છે
\item
  \textbf{Circular Queue}: Rear ફરીથી front સ્થાને જોડાય છે
\item
  \textbf{કાર્યક્ષમતા}: Circular queue મેમરી વેસ્ટેજ ટાળે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Queues વર્તુળ પૂર્ણ કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{પાયથોનમાં પોલીમોર્ફિઝમ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{પોલીમોર્ફિઝમ} એટલે ``અનેક સ્વરૂપો'' - સમાન method નામ અલગ અલગ ક્લાસમાં
અલગ રીતે વર્તે છે.

\textbf{પોલીમોર્ફિઝમના પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4167}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
અમલીકરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Method Overriding} & ચાઇલ્ડ ક્લાસ પેરેન્ટ method ફરીથી વ્યાખ્યાયિત કરે છે
& Inheritance \\
\textbf{Duck Typing} & અલગ ક્લાસમાં સમાન method & Interface સમાનતા \\
\textbf{Operator Overloading} & સમાન ઓપરેટર અલગ વર્તન & Magic methods \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
class Animal:
    def make\_sound(self):
        pass

class Dog(Animal):
    def make\_sound(self):
        return "ભૌં ભૌં!"

class Cat(Animal):
    def make\_sound(self):
        return "મ્યાઉં!"

\# પોલીમોર્ફિક વર્તન
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.make\_sound())
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``પોલીમોર્ફિઝમ અનેક વ્યક્તિત્વ પ્રદાન કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

**વ્યાખ્યા આપો. a). Infix b).Postfix સ્ટેકનો ઉપયોગ કરીને આપેલ Infix expression
ને Postfix expression માં ફેરવો. A+(B*C/D)**

\begin{solutionbox}

\textbf{વ્યાખ્યાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Expression પ્રકાર & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Infix} & ઓપરેટર ઓપરેન્ડ્સ વચ્ચે & \texttt{A\ +\ B} \\
\textbf{Postfix} & ઓપરેટર ઓપરેન્ડ્સ પછી & \texttt{A\ B\ +} \\
\end{longtable}
}

\textbf{રૂપાંતરણ એલ્ગોરિધમ:}

\begin{enumerate}
\tightlist
\item
  Infix expression ને ડાબેથી જમણે સ્કેન કરો
\item
  જો operand છે, આઉટપુટમાં ઉમેરો
\item
  જો operator છે, સ્ટેક ટોપ સાથે precedence સરખાવો
\item
  વધુ precedence \rightarrow સ્ટેકમાં push કરો
\item
  ઓછી/સમાન precedence \rightarrow pop કરીને આઉટપુટમાં ઉમેરો
\end{enumerate}

**પગલાં પ્રમાણે રૂપાંતરણ: A+(B*C/D)**

\begin{verbatim}
ઇનપુટ: A+(B*C/D)

પગલું | સિમ્બલ | સ્ટેક | આઉટપુટ
{-{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}{-}}
1     | A      | []    | A
2     | +      | [+]   | A
3     | (      | [+,(] | A
4     | B      | [+,(] | AB
5     | *      | [+,(,*] | AB
6     | C      | [+,(,*] | ABC
7     | /      | [+,(,/] | ABC*
8     | D      | [+,(,/] | ABC*D
9     | )      | [+]   | ABC*D/
10    | અંત    | []    | ABC*D/+
\end{verbatim}

**અંતિમ જવાબ: ABC*D/+**

\end{solutionbox}
\begin{mnemonicbox}
``સ્ટેક ઓપરેટર્સને વ્યૂહાત્મક રીતે સંગ્રહિત કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(a) અથવા [3
ગુણ]}\label{q2a}

\textbf{Queue ના ગેરફાયદા સમજાવો.}

\begin{solutionbox}

\textbf{Queue ગેરફાયદાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ગેરફાયદો & વર્ણન & અસર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{મેમરી વેસ્ટેજ} & ખાલી જગ્યાઓ પુનઃઉપયોગ નથી & નબળો જગ્યા ઉપયોગ \\
\textbf{નિયત કદ} & મર્યાદિત ક્ષમતા & Overflow સમસ્યાઓ \\
\textbf{રેન્ડમ એક્સેસ નથી} & ફક્ત front/rear એક્સેસ & મર્યાદિત લવચીકતા \\
\end{longtable}
}

\textbf{મુખ્ય સમસ્યાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{રેખીય Queue}: આગળની જગ્યાઓ અનુપયોગી બને છે
\item
  \textbf{Insertion/Deletion}: ફક્ત ચોક્કસ છેડાઓથી
\item
  \textbf{શોધ ઓપરેશન્સ}: શોધવા માટે કાર્યક્ષમ નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Queues શાંતિથી ક્વિર્ક્સ સાથે કતાર લગાવે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(b) અથવા [4
ગુણ]}\label{q2b}

\textbf{પાયથોનમાં Abstract class ની વ્યાખ્યા આપો? પાયથોનમાં abstract method
નું declaration સમજાવો?}

\begin{solutionbox}

\textbf{Abstract Class:} એક ક્લાસ જેનું instantiation કરી શકાતું નથી અને જેમાં એક
અથવા વધુ abstract methods હોય છે જે સબક્લાસીઝ દ્વારા અમલ કરવા જોઈએ.

\textbf{Abstract Method Declaration:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઘટક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ABC Module} & Abstract base class પ્રદાન કરે છે &
\texttt{from\ abc\ import\ ABC} \\
\textbf{@abstractmethod} & Abstract methods માટે decorator &
\texttt{@abstractmethod} \\
\textbf{અમલીકરણ} & સબક્લાસમાં ફરજિયાત override & આવશ્યક \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def \_\_init\_\_(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width
    
    def perimeter(self):
        return 2 * (self.length + self.width)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Abstract classes ફક્ત બ્લૂપ્રિન્ટ છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(c) અથવા [7
ગુણ]}\label{q2c}

\textbf{Infix to postfix માટેનો અલ્ગોરિધમ લખો. નીચેની પોસ્ટફિક્સ એક્સપ્રેશન
મૂલ્યાંકન કરો. 5 6 2 + * 12 4 / -}

\begin{solutionbox}

\textbf{Infix to Postfix અલ્ગોરિધમ:}

\begin{enumerate}
\tightlist
\item
  ખાલી સ્ટેક અને આઉટપુટ સ્ટ્રિંગ પ્રારંભ કરો
\item
  ડાબેથી જમણે infix expression સ્કેન કરો
\item
  જો operand છે \rightarrow આઉટપુટમાં ઉમેરો
\item
  જો `(' છે \rightarrow સ્ટેકમાં push કરો
\item
  જો `)' છે \rightarrow `(' સુધી pop કરો
\item
  જો operator છે \rightarrow વધુ/સમાન precedence operators pop કરો
\item
  વર્તમાન operator સ્ટેકમાં push કરો
\item
  બાકીના operators pop કરો
\end{enumerate}

\textbf{Postfix મૂલ્યાંકન: 5 6 2 + * 12 4 / -}

\begin{verbatim}
એક્સપ્રેશન: 5 6 2 + * 12 4 / {-}

પગલું | ટોકન | સ્ટેક | ઓપરેશન
{-{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}
1     | 5     | [5]   | Operand push કરો
2     | 6     | [5,6] | Operand push કરો
3     | 2     | [5,6,2] | Operand push કરો
4     | +     | [5,8] | Pop 2,6  6+2=8
5     | *     | [40]  | Pop 8,5  5*8=40
6     | 12    | [40,12] | Operand push કરો
7     | 4     | [40,12,4] | Operand push કરો
8     | /     | [40,3] | Pop 4,12  12/4=3
9     | {-     | [37]  | Pop 3,40  40{-}3=37}
\end{verbatim}

\textbf{અંતિમ પરિણામ: 37}

\end{solutionbox}
\begin{mnemonicbox}
``Postfix પ્રોસેસિંગ યુગ્મો ચોક્કસ રીતે Pop કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{સિંગલ લિંક લિસ્ટમાં નોડને traverse કરવા માટે અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Traversal અલ્ગોરિધમ:}

\begin{verbatim}
def traverse\_linked\_list(head):
    current = head
    while current is not None:
        print(current.data)
        current = current.next
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & Head નોડથી શરૂ કરો & Traversal પ્રારંભ કરો \\
\textbf{2} & ચકાસો કે current \neq NULL & ચાલુ રાખવાની શરત \\
\textbf{3} & વર્તમાન નોડ પ્રોસેસ કરો & ઓપરેશન કરો \\
\textbf{4} & આગલા નોડ પર જાઓ & Pointer આગળ વધારો \\
\textbf{5} & અંત સુધી પુનરાવર્તન કરો & સંપૂર્ણ traversal \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Traverse ટેઇલ સુધી પહોંચે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{લિસ્ટનો ઉપયોગ કરીને Queueના Dequeue ઓપરેશન માટેનો અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Dequeue અલ્ગોરિધમ:}

\begin{verbatim}
def dequeue(queue):
    if len(queue) == 0:
        print("Queue ખાલી છે")
        return None
    else:
        element = queue.pop(0)
        return element
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & શરત & ક્રિયા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & ખાલી ચકાસો & જો queue ખાલી છે \\
\textbf{2} & Underflow હેન્ડલ કરો & એરર મેસેજ દર્શાવો \\
\textbf{3} & એલિમેન્ટ દૂર કરો & આગળનું એલિમેન્ટ ડિલીટ કરો \\
\textbf{4} & એલિમેન્ટ પરત કરો & દૂર કરેલી વેલ્યુ પરત કરો \\
\textbf{5} & સ્ટ્રક્ચર અપડેટ કરો & Queue pointers એડજસ્ટ કરો \\
\end{longtable}
}

\textbf{Time Complexity: O(n)} લિસ્ટ shifting ને કારણે

\end{solutionbox}
\begin{mnemonicbox}
``Dequeue આગળના દરવાજેથી ડિલીટ કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{Double linked list ની વ્યાખ્યા આપો. લિંક લિસ્ટના મુખ્ય ઓપરેશનની નોંધણી
કરો. Single Linked list મા શરૂઆતમાં નોડ દાખલ કરવા માટેનો અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Double Linked List:} એક રેખીય ડેટા સ્ટ્રક્ચર જ્યાં દરેક નોડમાં ડેટા અને બે
pointers હોય છે - એક આગલા નોડ તરફ અને બીજો પાછલા નોડ તરફ.

\textbf{લિંક લિસ્ટના મુખ્ય ઓપરેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઓપરેશન & વર્ણન & Time Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Insertion} & નવો નોડ ઉમેરો & O(1) શરૂઆતમાં \\
\textbf{Deletion} & નોડ દૂર કરો & O(1) જો નોડ ખબર છે \\
\textbf{Traversal} & બધા નોડ્સની મુલાકાત લો & O(n) \\
\textbf{Search} & ચોક્કસ નોડ શોધો & O(n) \\
\textbf{Update} & નોડ ડેટા બદલો & O(1) જો નોડ ખબર છે \\
\end{longtable}
}

\textbf{શરૂઆતમાં Insert અલ્ગોરિધમ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

def insert\_at\_beginning(head, data):
    new\_node = Node(data)
    new\_node.next = head
    head = new\_node
    return head
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

\begin{enumerate}
\tightlist
\item
  આપેલ ડેટા સાથે નવો નોડ બનાવો
\item
  નવા નોડનો next વર્તમાન head પર સેટ કરો
\item
  Head ને નવા નોડ તરફ અપડેટ કરો
\item
  નવો head પરત કરો
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``શરૂઆતમાં Insert બેહતર લિસ્ટ બનાવે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(a) અથવા [3
ગુણ]}\label{q3a}

\textbf{Single Linked List ની એપ્લિકેશન સમજાવો.}

\begin{solutionbox}

\textbf{Single Linked List એપ્લિકેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
એપ્લિકેશન & ઉપયોગ કેસ & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Memory} & વેરિયેબલ સાઇઝ ડેટા & મેમરી કાર્યક્ષમ \\
\textbf{Stack Implementation} & LIFO ઓપરેશન્સ & સરળ push/pop \\
\textbf{Queue Implementation} & FIFO ઓપરેશન્સ & Dynamic sizing \\
\textbf{Music Playlist} & સિક્વેન્શિયલ પ્લેબેક & સરળ નેવિગેશન \\
\textbf{Browser History} & પેજ નેવિગેશન & ફોરવર્ડ traversal \\
\textbf{Polynomial Representation} & ગાણિતિક ઓપરેશન્સ & Coefficient
સ્ટોરેજ \\
\end{longtable}
}

\textbf{મુખ્ય ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic Size}: રનટાઇમ દરમિયાન વધે/ઘટે છે
\item
  \textbf{મેમરી કાર્યક્ષમતા}: જરૂર પ્રમાણે allocate કરે છે
\item
  \textbf{Insertion/Deletion}: કોઈપણ સ્થાને કાર્યક્ષમ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists અનેક એપ્લિકેશન્સને લિંક કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(b) અથવા [4
ગુણ]}\label{q3b}

\textbf{લિસ્ટનો ઉપયોગ કરીને સ્ટેકના PUSH ઓપરેશન માટે અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{PUSH અલ્ગોરિધમ:}

\begin{verbatim}
def push(stack, element):
    stack.append(element)
    print(f"સ્ટેકમાં \{element\} push કર્યું")
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & ક્ષમતા ચકાસો & સ્ટેક ભરાયો નથી તે ચકાસો \\
\textbf{2} & એલિમેન્ટ ઉમેરો & લિસ્ટના અંતે append કરો \\
\textbf{3} & ટોપ અપડેટ કરો & ટોપ છેલ્લા એલિમેન્ટ તરફ પોઇન્ટ કરે છે \\
\textbf{4} & ઓપરેશન કન્ફર્મ કરો & સફળતાનો મેસેજ દર્શાવો \\
\end{longtable}
}

\textbf{વિગતવાર અલ્ગોરિધમ:}

\begin{enumerate}
\tightlist
\item
  સ્ટેક અને push કરવાનું એલિમેન્ટ સ્વીકારો
\item
  સ્ટેકની ક્ષમતા ચકાસો (fixed size માટે)
\item
  append() વાપરીને લિસ્ટના અંતે એલિમેન્ટ ઉમેરો
\item
  લિસ્ટ આપોઆપ મેમરી allocation હેન્ડલ કરે છે
\item
  સફળતાની સ્થિતિ પરત કરો
\end{enumerate}

\textbf{Time Complexity: O(1)} - Constant time ઓપરેશન

\end{solutionbox}
\begin{mnemonicbox}
``PUSH સ્ટેક શિખર પર મૂકે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(c) અથવા [7
ગુણ]}\label{q3c}

\textbf{Linked list ના ફાયદા સમજાવો. Single linked list માંથી last નોડ
કાઢી નાખવા માટે અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Linked List ફાયદાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફાયદો & વર્ણન & લાભ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic Size} & રનટાઇમે સાઇઝ બદલાય છે & મેમરી લવચીક \\
\textbf{મેમરી કાર્યક્ષમ} & જરૂર પ્રમાણે allocate કરે છે & કોઈ વેસ્ટેજ નથી \\
\textbf{સરળ Insertion} & ગમે ત્યાં કાર્યક્ષમ રીતે ઉમેરો & O(1) ઓપરેશન \\
\textbf{સરળ Deletion} & કાર્યક્ષમ રીતે દૂર કરો & O(1) ઓપરેશન \\
\textbf{મેમરી Shift નથી} & એલિમેન્ટ્સ ખસતા નથી & ઝડપી ઓપરેશન્સ \\
\end{longtable}
}

\textbf{છેલ્લો નોડ ડિલીટ કરવાનો અલ્ગોરિધમ:}

\begin{verbatim}
def delete\_last\_node(head):
    \# ખાલી લિસ્ટ
    if head is None:
        return None
    
    \# એક જ નોડ
    if head.next is None:
        return None
    
    \# અનેક નોડ્સ
    current = head
    while current.next.next is not None:
        current = current.next
    
    current.next = None
    return head
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

\begin{enumerate}
\tightlist
\item
  ખાલી લિસ્ટ કેસ હેન્ડલ કરો
\item
  એક નોડ કેસ હેન્ડલ કરો
\item
  છેલ્લાથી બીજા નોડ સુધી traverse કરો
\item
  છેલ્લાથી બીજા નોડનો next NULL પર સેટ કરો
\item
  અપડેટેડ head પરત કરો
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Linked Lists તાર્કિક ફાયદાઓ તરફ દોરી જાય છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{બબલ સૉર્ટમાટેના અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Bubble Sort અલ્ગોરિધમ:}

\begin{verbatim}
def bubble\_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n{-}i{-}1):
            if arr[j] {} arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & બાહ્ય લૂપ i=0 થી n-1 & પાસની સંખ્યા \\
\textbf{2} & આંતરિક લૂપ j=0 થી n-i-2 & નજીકના એલિમેન્ટ્સ સરખાવો \\
\textbf{3} & arr[j] અને arr[j+1] સરખાવો & ક્રમ ચકાસો \\
\textbf{4} & ક્રમ ખોટો હોય તો અદલાબદલી કરો & યોગ્ય સ્થિતિ \\
\textbf{5} & સૉર્ટ થાય સુધી પુનરાવર્તન કરો & સંપૂર્ણ સૉર્ટિંગ \\
\end{longtable}
}

\textbf{Time Complexity: O(n^{2})}

\end{solutionbox}
\begin{mnemonicbox}
``બબલ્સ ધીમે ધીમે સપાટી પર આવે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{Circular linked list ને તેના ફાયદાઓ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Circular Linked List:} એક લિંક લિસ્ટ જ્યાં છેલ્લો નોડ પ્રથમ નોડ તરફ
પોઇન્ટ કરે છે, વર્તુળાકાર સ્ટ્રક્ચર બનાવે છે.

\textbf{લક્ષણો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & વર્ણન & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{વર્તુળાકાર સ્ટ્રક્ચર} & છેલ્લો નોડ \rightarrow પ્રથમ નોડ & સતત traversal \\
\textbf{કોઈ NULL Pointers નથી} & કોઈ અંત માર્કર નથી & હંમેશા જોડાયેલ \\
\textbf{કાર્યક્ષમ Traversal} & કોઈપણ નોડથી શરૂ કરી શકાય છે & લવચીક એક્સેસ \\
\end{longtable}
}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{મેમરી કાર્યક્ષમ}: કોઈ NULL pointers નથી
\item
  \textbf{વર્તુળાકાર Traversal}: સતત લૂપ કરી શકાય છે
\item
  \textbf{Queue Implementation}: કાર્યક્ષમ enqueue/dequeue
\item
  \textbf{Round Robin Scheduling}: CPU time sharing
\item
  \textbf{Music Player}: સતત playlist looping
\end{itemize}

\begin{verbatim}
Circular Linked List સ્ટ્રક્ચર:

[A]  [B]  [C]  [D]
 ↑                 ↓
 
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Lists સતત કનેક્શન્સ બનાવે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{યોગ્ય ઉદાહરણ સાથે મર્જ સૉર્ટ સમજાવો.}

\begin{solutionbox}

\textbf{Merge Sort:} એક divide-and-conquer અલ્ગોરિધમ જે array ને ભાગોમાં વહેંચે
છે, તેમને અલગ અલગ સૉર્ટ કરે છે, અને પછી ભેગા કરે છે.

\textbf{અલ્ગોરિધમ તબક્કાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
તબક્કો & ક્રિયા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Divide} & Array વહેંચો & બે ભાગોમાં વહેંચો \\
\textbf{Conquer} & Subarrays સૉર્ટ કરો & ભાગોને recursively સૉર્ટ કરો \\
\textbf{Combine} & પરિણામો મર્જ કરો & સૉર્ટેડ ભાગો મર્જ કરો \\
\end{longtable}
}

\textbf{ઉદાહરણ: [38, 27, 43, 3, 9, 82, 10]}

\begin{verbatim}
Merge Sort પ્રક્રિયા:

લેવલ 0:  [38, 27, 43, 3, 9, 82, 10]
             ↓
લેવલ 1:  [38, 27, 43, 3] | [9, 82, 10]
             ↓                  ↓
લેવલ 2:  [38, 27] [43, 3] | [9, 82] [10]
             ↓       ↓         ↓      ↓
લેવલ 3:  [38][27] [43][3] | [9][82] [10]
             ↓       ↓         ↓      ↓
મર્જ:     [27, 38] [3, 43] | [9, 82] [10]
             ↓                  ↓
          [3, 27, 38, 43] | [9, 10, 82]
             ↓
          [3, 9, 10, 27, 38, 43, 82]
\end{verbatim}

\textbf{Time Complexity: O(n log n)} \textbf{Space Complexity: O(n)}

\end{solutionbox}
\begin{mnemonicbox}
``Merge Sort વ્યવસ્થિત રીતે સેગમેન્ટ્સને મર્જ કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(a) અથવા [3
ગુણ]}\label{q4a}

\textbf{Selection sort માટેના અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Selection Sort અલ્ગોરિધમ:}

\begin{verbatim}
def selection\_sort(arr):
    n = len(arr)
    for i in range(n):
        min\_idx = i
        for j in range(i+1, n):
            if arr[j] {} arr[min\_idx]:
                min\_idx = j
        arr[i], arr[min\_idx] = arr[min\_idx], arr[i]
    return arr
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & મિનિમમ એલિમેન્ટ શોધો & સૌથી નાનું લોકેટ કરો \\
\textbf{2} & પ્રથમ સ્થાને અદલાબદલી કરો & સૉર્ટેડ સ્થાને મૂકો \\
\textbf{3} & આગલી પોઝિશન પર જાઓ & બાઉન્ડ્રી આગળ વધારો \\
\textbf{4} & બાકીના માટે પુનરાવર્તન કરો & સૉર્ટિંગ ચાલુ રાખો \\
\textbf{5} & પૂર્ણ થયા પર સમાપ્ત કરો & અલ્ગોરિધમ ફિનિશ કરો \\
\end{longtable}
}

\textbf{Time Complexity: O(n^{2})}

\end{solutionbox}
\begin{mnemonicbox}
``Selection Sort સફળતાપૂર્વક સૌથી નાનું સિલેક્ટ કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(b) અથવા [4
ગુણ]}\label{q4b}

\textbf{Double linked list ને તેના ફાયદાઓ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Double Linked List:} એક લિંક લિસ્ટ જ્યાં દરેક નોડમાં ડેટા અને બે pointers
હોય છે - next અને previous.

\textbf{સ્ટ્રક્ચર:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & હેતુ & દિશા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ડેટા} & માહિતી સ્ટોર કરો & - \\
\textbf{Next Pointer} & આગલા નોડ તરફ પોઇન્ટ કરે છે & આગળ \\
\textbf{Previous Pointer} & પાછલા નોડ તરફ પોઇન્ટ કરે છે & પાછળ \\
\end{longtable}
}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{બાયડાયરેક્શનલ Traversal}: આગળ અને પાછળ બંને દિશામાં ચાલી શકાય છે
\item
  \textbf{સરળ Deletion}: પાછલો નોડ જાણ્યા વગર ડિલીટ કરી શકાય છે
\item
  \textbf{કાર્યક્ષમ Insertion}: કોઈપણ સ્થાને સરળતાથી insert કરી શકાય છે
\item
  \textbf{બહેતર Navigation}: બંને દિશામાં ચાલી શકાય છે
\end{itemize}

\begin{verbatim}
Double Linked List સ્ટ્રક્ચર:

NULL  [prev|data|next] ⇄ [prev|data|next] ⇄ [prev|data|next]  NULL
\end{verbatim}

\textbf{એપ્લિકેશન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{Browser navigation} (back/forward બટન્સ)
\item
  \textbf{Music player} (previous/next ગીત)
\item
  \textbf{Undo/Redo operations}
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Double Links બેવડી દિશા પ્રદાન કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(c) અથવા [7
ગુણ]}\label{q4c}

\textbf{Insertion સૉર્ટ સમજાવો. Insertion સૉર્ટનો ઉપયોગ કરીને નીચેના નંબરોનો
ટ્રેસ આપો: 25, 15,30,9,99,20,26}

\begin{solutionbox}

\textbf{Insertion Sort:} એક સમયે એક એલિમેન્ટ દ્વારા સૉર્ટેડ array બનાવે છે દરેક
એલિમેન્ટને તેની યોગ્ય પોઝિશનમાં insert કરીને.

\textbf{અલ્ગોરિધમ કન્સેપ્ટ:}

\begin{itemize}
\tightlist
\item
  \textbf{સૉર્ટેડ ભાગ}: વર્તમાન એલિમેન્ટની ડાબી બાજુ
\item
  \textbf{અનસૉર્ટેડ ભાગ}: વર્તમાન એલિમેન્ટની જમણી બાજુ
\item
  \textbf{Insert સ્ટ્રેટેજી}: વર્તમાન એલિમેન્ટને સૉર્ટેડ ભાગમાં યોગ્ય સ્થાને મૂકો
\end{itemize}

\textbf{[25, 15, 30, 9, 99, 20, 26] નો ટ્રેસ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1087}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1957}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2826}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2609}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1522}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્તમાન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Array સ્થિતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સરખામણીઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ક્રિયા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{પ્રારંભિક} & - & [25, 15, 30, 9, 99, 20, 26] & - & શરૂ \\
\textbf{1} & 15 & [15, 25, 30, 9, 99, 20, 26] & 15 \textless{} 25 &
15 ને 25 પહેલાં insert કરો \\
\textbf{2} & 30 & [15, 25, 30, 9, 99, 20, 26] & 30 \textgreater{} 25
& 30 ને જગ્યાએ રાખો \\
\textbf{3} & 9 & [9, 15, 25, 30, 99, 20, 26] & 9 \textless{} બધા &
શરૂઆતમાં insert કરો \\
\textbf{4} & 99 & [9, 15, 25, 30, 99, 20, 26] & 99 \textgreater{} 30
& 99 ને જગ્યાએ રાખો \\
\textbf{5} & 20 & [9, 15, 20, 25, 30, 99, 26] & 15 અને 25 વચ્ચે insert
& શિફ્ટ કરીને insert કરો \\
\textbf{6} & 26 & [9, 15, 20, 25, 26, 30, 99] & 25 અને 30 વચ્ચે insert
& અંતિમ સ્થિતિ \\
\end{longtable}
}

\textbf{અંતિમ સૉર્ટેડ Array: [9, 15, 20, 25, 26, 30, 99]}

\textbf{Time Complexity: O(n^{2})} worst case, \textbf{O(n)} best case

\end{solutionbox}
\begin{mnemonicbox}
``Insertion વધતા ક્રમમાં Insert કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{બાઈનરી ટ્રીની એપ્લિકેશન સમજાવો.}

\begin{solutionbox}

\textbf{Binary Tree એપ્લિકેશન્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
એપ્લિકેશન & ઉપયોગ કેસ & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Expression Trees} & ગાણિતિક expressions & સરળ evaluation \\
\textbf{Binary Search Trees} & Searching/Sorting & O(log n)
operations \\
\textbf{Heap Trees} & Priority queues & કાર્યક્ષમ min/max \\
\textbf{File Systems} & Directory structure & હાયરાર્કિકલ ઓર્ગેનાઇઝેશન \\
\textbf{Decision Trees} & AI/ML algorithms & Classification \\
\textbf{Huffman Coding} & Data compression & Optimal encoding \\
\end{longtable}
}

\textbf{મુખ્ય ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{હાયરાર્કિકલ સ્ટ્રક્ચર}: કુદરતી tree ઓર્ગેનાઇઝેશન
\item
  \textbf{કાર્યક્ષમ ઓપરેશન્સ}: Search, insert, delete
\item
  \textbf{Recursive Processing}: અમલ કરવામાં સરળ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Trees અનેક એપ્લિકેશન્સમાં શાખા કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{લિસ્ટનો ઉપયોગ કરીને Binary search માટેનો અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Binary Search અલ્ગોરિધમ:}

\begin{verbatim}
def binary\_search(arr, target):
    left, right = 0, len(arr) {-} 1
    
    while left {=} right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] {} target:
            left = mid + 1
        else:
            right = mid {-} 1
    
    return {-}1  \# એલિમેન્ટ મળ્યું નથી
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & left=0, right=n-1 સેટ કરો & બાઉન્ડ્રીઝ પ્રારંભ કરો \\
\textbf{2} & Mid કેલ્ક્યુલેટ કરો & મધ્ય એલિમેન્ટ શોધો \\
\textbf{3} & Target ને mid સાથે સરખાવો & દિશા નક્કી કરો \\
\textbf{4} & બાઉન્ડ્રીઝ અપડેટ કરો & શોધ જગ્યા સાંકડી કરો \\
\textbf{5} & મળે સુધી પુનરાવર્તન કરો & શોધ ચાલુ રાખો \\
\end{longtable}
}

\textbf{પૂર્વશરત:} Array સૉર્ટેડ હોવું જોઈએ \textbf{Time Complexity: O(log n)}

\end{solutionbox}
\begin{mnemonicbox}
``Binary Search ઝડપથી શોધવા માટે બાઇસેક્ટ કરે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{Tree ની વ્યાખ્યા આપો. Tree ની યાદી બનાવો. પાયથોનનો ઉપયોગ કરીને
બાઈનરી સર્ચ ટ્રીમાં નોડ દાખલ કરવા માટે અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Tree વ્યાખ્યા:} એક હાયરાર્કિકલ ડેટા સ્ટ્રક્ચર જેમાં edges દ્વારા જોડાયેલા
nodes હોય છે, એક root node સાથે અને કોઈ cycles ન હોય.

\textbf{Tree ના પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Tree પ્રકાર & વર્ણન & વિશેષ ગુણધર્મ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Binary Tree} & નોડ દીઠ વધુમાં વધુ 2 બાળકો & ડાબું અને જમણું બાળક \\
\textbf{Binary Search Tree} & ક્રમિત binary tree & ડાબું \textless{} Root
\textless{} જમણું \\
\textbf{Complete Binary Tree} & છેલ્લા સિવાય બધા લેવલ ભરેલા & કાર્યક્ષમ
heap \\
\textbf{Full Binary Tree} & બધા nodes ને 0 અથવા 2 બાળકો & કોઈ એક બાળક
નથી \\
\textbf{AVL Tree} & સ્વ-સંતુલિત BST & Height balanced \\
\textbf{Red-Black Tree} & સ્વ-સંતુલિત BST & રંગ ગુણધર્મો \\
\end{longtable}
}

\textbf{BST Insertion અલ્ગોરિધમ:}

\begin{verbatim}
class TreeNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.left = None
        self.right = None

def insert\_bst(root, data):
    if root is None:
        return TreeNode(data)
    
    if data {} root.data:
        root.left = insert\_bst(root.left, data)
    elif data {} root.data:
        root.right = insert\_bst(root.right, data)
    
    return root
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

\begin{enumerate}
\tightlist
\item
  જો tree ખાલી છે, root node બનાવો
\item
  જો data \textless{} root.data, ડાબા subtree માં insert કરો
\item
  જો data \textgreater{} root.data, જમણા subtree માં insert કરો
\item
  જો data = root.data, ignore કરો (duplicates નથી)
\item
  અપડેટેડ root પરત કરો
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Trees સંરચિત ઓર્ગેનાઇઝેશન સાથે વધે છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(a) અથવા [3
ગુણ]}\label{q5a}

\textbf{ટ્રીના ઇન-ઓર્ડર ટ્રાવર્સલનો અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{In-order Traversal અલ્ગોરિધમ:}

\begin{verbatim}
def inorder\_traversal(root):
    if root is not None:
        inorder\_traversal(root.left)    \# ડાબું
        print(root.data)                \# Root
        inorder\_traversal(root.right)   \# જમણું
\end{verbatim}

\textbf{અલ્ગોરિધમ પગલાં:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & ક્રમ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & ડાબા subtree ને traverse કરો & Recursive call \\
\textbf{2} & Root node ની મુલાકાત લો & ડેટા પ્રોસેસ કરો \\
\textbf{3} & જમણા subtree ને traverse કરો & Recursive call \\
\end{longtable}
}

\textbf{Traversal ક્રમ: ડાબું \rightarrow Root \rightarrow જમણું}

\textbf{ગુણધર્મો:}

\begin{itemize}
\tightlist
\item
  \textbf{BST ગુણધર્મ}: In-order સૉર્ટેડ sequence આપે છે
\item
  \textbf{Time Complexity}: O(n)
\item
  \textbf{Space Complexity}: O(h) જ્યાં h એ height છે
\end{itemize}

\textbf{ઉદાહરણ Tree પરિણામ:}

\begin{verbatim}
    Tree:     50
             /  {}
           30    70
          / {   / }
        20  40 60  80

In{-order: 20, 30, 40, 50, 60, 70, 80}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``In-order: ડાબું, Root, જમણું''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(b) અથવા [4
ગુણ]}\label{q5b}

\textbf{Search ની વ્યાખ્યા આપો? લિસ્ટનો ઉપયોગ કરીને Linear search માટેનો
અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\textbf{Search વ્યાખ્યા:} ડેટા સ્ટ્રક્ચરમાં ચોક્કસ એલિમેન્ટ શોધવાની અથવા એલિમેન્ટ
અસ્તિત્વમાં છે કે નહીં તે ચકાસવાની પ્રક્રિયા.

\textbf{Linear Search અલ્ગોરિધમ:}

\begin{verbatim}
def linear\_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  \# મળ્યું તો index પરત કરો
    return {-}1  \# ન મળ્યું તો {-1 પરત કરો}
\end{verbatim}

\textbf{અલ્ગોરિધમ લક્ષણો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & વર્ણન & મૂલ્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{પદ્ધતિ} & ક્રમિક ચકાસણી & એલિમેન્ટ દર એલિમેન્ટ \\
\textbf{Time Complexity} & O(n) & રેખીય સમય \\
\textbf{Space Complexity} & O(1) & Constant space \\
\textbf{ડેટા આવશ્યકતા} & કોઈપણ ક્રમ & અનસૉર્ટેડ ડેટા ચાલે છે \\
\end{longtable}
}

\textbf{અલ્ગોરિધમ પગલાં:}

\begin{enumerate}
\tightlist
\item
  પ્રથમ એલિમેન્ટથી શરૂ કરો
\item
  દરેક એલિમેન્ટને target સાથે સરખાવો
\item
  જો મેચ મળે, index પરત કરો
\item
  જો અંત પહોંચે, -1 પરત કરો
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Linear Search રેખીય રીતે લિસ્ટ્સમાં જુએ છે''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(c) અથવા [7
ગુણ]}\label{q5c}

\textbf{વ્યાખ્યા આપો: a) પાથ b). લીફ નોડ. નીચે આપેલ માહિતી ઉપરથી binary
search tree બનાવો. 60, 40, 37,31,59,21,65,30}

\begin{solutionbox}

\textbf{વ્યાખ્યાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3750}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શબ્દ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
લક્ષણો
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Path} & એક નોડથી બીજા નોડ સુધીના nodes ની શ્રેણી & edges દ્વારા
જોડાયેલ \\
\textbf{Leaf Node} & કોઈ બાળકો ન હોય તેવો નોડ & કોઈ ડાબું કે જમણું બાળક નથી \\
\end{longtable}
}

\textbf{BST બનાવટ માટે: 60, 40, 37, 31, 59, 21, 65, 30}

\textbf{પગલાં પ્રમાણે બનાવટ:}

\begin{verbatim}
પગલું 1: 60 Insert કરો (Root)
        60

પગલું 2: 40 Insert કરો (40 { 60, ડાબે જાઓ)}
        60
       /
      40

પગલું 3: 37 Insert કરો (37 { 60, ડાબે; 37  40, ડાબે)}
        60
       /
      40
     /
    37

પગલું 4: 31 Insert કરો (31 { 60, ડાબે; 31  40, ડાબે; 31  37, ડાબે)}
        60
       /
      40
     /
    37
   /
  31

પગલું 5: 59 Insert કરો (59 { 60, ડાબે; 59  40, જમણે)}
        60
       /
      40
     / {}
    37  59
   /
  31

પગલું 6: 21 Insert કરો (21 { 60, ડાબે; 21  40, ડાબે; 21  37, ડાબે; 21  31, ડાબે)}
        60
       /
      40
     / {}
    37  59
   /
  31
 /
21

પગલું 7: 65 Insert કરો (65 { 60, જમણે જાઓ)}
        60
       / {}
      40  65
     / {}
    37  59
   /
  31
 /
21

પગલું 8: 30 Insert કરો (30 { 60, ડાબે; 30  40, ડાબે; 30  37, ડાબે; 30  31, ડાબે; 30  21, જમણે)}
        60
       / {}
      40  65
     / {}
    37  59
   /
  31
 / {}
21  30
\end{verbatim}

\textbf{અંતિમ BST સ્ટ્રક્ચર:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લેવલ & Nodes & પ્રકાર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{0} & 60 & Root \\
\textbf{1} & 40, 65 & Internal \\
\textbf{2} & 37, 59 & Internal, Internal \\
\textbf{3} & 31 & Internal \\
\textbf{4} & 21 & Internal \\
\textbf{5} & 30 & Leaf \\
\end{longtable}
}

\textbf{Leaf Nodes:} 30, 59, 65

\end{solutionbox}
\begin{mnemonicbox}
``BST બિલ્ડિંગ Binary Search Tree નિયમોને અનુસરે છે''

\end{mnemonicbox}

\end{document}
