\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{સોફ્ટવેર ડેવલપમેન્ટના મૂળભૂત સિદ્ધાંતો (4331604) - ઉનાળો 2024 સોલ્યુશન}
\date{June 14, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{સોફ્ટવેર એન્જિનિયરિંગ layered approach સમજાવો.}

\begin{solutionbox}
સોફ્ટવેર એન્જિનિયરિંગ એક layered approach અપનાવે છે જેમાં ચાર મુખ્ય layers હોય છે જે ગુણવત્તાયુક્ત સોફ્ટવેર પ્રોડક્ટ બનાવવા માટે સાથે કામ કરે છે.

\begin{center}
\captionof{table}{સોફ્ટવેર એન્જિનિયરિંગ Layered Approach}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Layer} & \textbf{વર્ણન} & \textbf{હેતુ} \\ \hline
\textbf{Quality Focus} & સતત સુધારા પર ભાર મૂકતું foundation layer & ખામી-મુક્ત પ્રોડક્ટ્સ બનાવવા \\ \hline
\textbf{Process} & પ્રવૃત્તિઓ અને કાર્યોનું framework & વ્યવસ્થિત વિકાસ પ્રક્રિયા પૂરી પાડવી \\ \hline
\textbf{Methods} & વિશ્લેષણ, ડિઝાઇન, કોડિંગ, ટેસ્ટિંગ માટે તકનીકી પ્રક્રિયાઓ & ``કેવી રીતે કરવું'' તે માર્ગદર્શન આપવું \\ \hline
\textbf{Tools} & Process અને methods માટે automated support & કાર્યક્ષમતા અને સુસંગતતા પૂરી પાડવી \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Quality Focus}: ગ્રાહક સંતોષ સુનિશ્ચિત કરતું foundation બનાવે છે
    \item \keyword{Process Layer}: કાર્યપ્રવાહ અને પ્રોજેક્ટ મેનેજમેન્ટ પ્રવૃત્તિઓ વ્યાખ્યાયિત કરે છે
    \item \keyword{Methods Layer}: દરેક વિકાસ તબક્કા માટે તકનીકી અભિગમ પૂરો પાડે છે
    \item \keyword{Tools Layer}: ઓટોમેશન અને integration ને સપોર્ટ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Quality Processes Make Tools: યાદ રાખવા માટે નીચેથી ઉપર સુધીના ચાર layers.}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Iterative Waterfall model સમજાવો.}

\begin{solutionbox}
Iterative Waterfall Model એ waterfall ની structured approach અને સુધારા અને ભૂલ સુધારણા માટે feedback loops ને જોડે છે.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, every node/.style={gtu state, align=center}]
    \node (Req) {Requirements\\Analysis};
    \node [right=of Req] (Sys) {System\\Design};
    \node [right=of Sys] (Imp) {Implementation};
    \node [below=of Imp] (Int) {Integration \&\\Testing};
    \node [left=of Int] (Dep) {Deployment};
    \node [left=of Dep] (Mai) {Maintenance};

    \path [gtu arrow] (Req) -- (Sys);
    \path [gtu arrow] (Sys) -- (Imp);
    \path [gtu arrow] (Imp) -- (Int);
    \path [gtu arrow] (Int) -- (Dep);
    \path [gtu arrow] (Dep) -- (Mai);

    % Feedback loops
    \path [gtu arrow, dashed, bend left] (Sys) to node [above, font=\footnotesize] {Feedback} (Req);
    \path [gtu arrow, dashed, bend left] (Imp) to node [above, font=\footnotesize] {Feedback} (Sys);
    \path [gtu arrow, dashed, bend left] (Int) to node [right, font=\footnotesize] {Feedback} (Imp);
    \path [gtu arrow, dashed, bend left] (Dep) to node [below, font=\footnotesize] {Feedback} (Int);
    \path [gtu arrow, dashed, bend left] (Mai) to node [below, font=\footnotesize] {Feedback} (Dep);
\end{tikzpicture}
\captionof{figure}{Iterative Waterfall Model}
\end{center}

\textbf{મુખ્ય લક્ષણો:}
\begin{itemize}
    \item \keyword{ક્રમિક તબક્કાઓ}: દરેક તબક્કો પૂર્ણ થયા પછી આગળનો શરૂ થાય છે
    \item \keyword{Feedback loops}: અગાઉના તબક્કાઓમાં પાછા જવાની મંજૂરી આપે છે
    \item \keyword{Documentation driven}: દરેક તબક્કામાં documentation પર ભારે ભાર
    \item \keyword{ભૂલ સુધારણા}: પછીના તબક્કાઓમાં ઓળખાયેલી સમસ્યાઓ સુધારી શકાય છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Water Falls Back Up: ઉપરની તરફ feedback ક્ષમતા સાથે sequential flow.}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Agile મોડેલ અને Agile Principles સમજાવો.}

\begin{solutionbox}
Agile એ iterative સોફ્ટવેર ડેવલપમેન્ટ methodology છે જે સહયોગ, ગ્રાહક feedback, અને કાર્યશીલ સોફ્ટવેરની ઝડપી delivery પર ભાર મૂકે છે.

\begin{center}
\captionof{table}{Agile Values વિ Traditional Approach}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Agile Values} & \textbf{Traditional Approach} \\ \hline
વ્યક્તિઓ અને આંતરક્રિયાઓ & પ્રક્રિયાઓ અને ટૂલ્સ \\ \hline
કાર્યશીલ સોફ્ટવેર & વ્યાપક documentation \\ \hline
ગ્રાહક સહયોગ & કરાર વાટાઘાટ \\ \hline
પરિવર્તનનો પ્રતિસાદ & યોજનાને અનુસરવી \\ \hline
\end{tabulary}
\end{center}

\textbf{મુખ્ય Agile સિદ્ધાંતો:}
\begin{itemize}
    \item \keyword{ગ્રાહક સંતોષ}: મૂલ્યવાન સોફ્ટવેર વહેલી અને સતત delivery
    \item \keyword{પરિવર્તનનું સ્વાગત}: વિકાસ દરમિયાન મોડેથી આવતા બદલાવો પણ સ્વીકારવા
    \item \keyword{વારંવાર delivery}: કાર્યશીલ સોફ્ટવેર વારંવાર deliver કરવું (મહિનાને બદલે અઠવાડિયાઓમાં)
    \item \keyword{સહયોગ}: વ્યાપારિક લોકો અને developers દરરોજ સાથે કામ કરે
    \item \keyword{પ્રેરિત વ્યક્તિઓ}: પ્રેરિત લોકોની આસપાસ પ્રોજેક્ટ્સ બનાવવા
    \item \keyword{આમને-સામનો વાતચીત}: સંદેશાવ્યવહારની સૌથી અસરકારક પદ્ધતિ
    \item \keyword{કાર્યશીલ સોફ્ટવેર}: પ્રગતિનું પ્રાથમિક માપદંડ
    \item \keyword{ટકાઉ વિકાસ}: અનિશ્ચિત સમય સુધી સતત ગતિ જાળવવી
    \item \keyword{તકનીકી ઉત્કૃષ્ટતા}: સારી ડિઝાઇન પર સતત ધ્યાન
    \item \keyword{સરળતા}: ન કરેલા કામને વધુ મહત્ત્વ આપવાની કળા
    \item \keyword{સ્વ-સંગઠિત ટીમો}: સ્વ-સંગઠિત ટીમોમાંથી શ્રેષ્ઠ requirements બહાર આવે છે
    \item \keyword{નિયમિત પ્રતિબિંબ}: ટીમ વર્તનને પ્રતિબિંબિત કરે અને ગોઠવે છે
\end{itemize}

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto, every node/.style={gtu state, align=center, font=\small}]
    \node (Plan) {Planning};
    \node [right=of Plan] (Des) {Design};
    \node [right=of Des] (Code) {Coding};
    \node [below=of Code] (Test) {Testing};
    \node [left=of Test] (Rev) {Review};
    \node [left=of Rev] (Rel) {Release};

    \path [gtu arrow] (Plan) -- (Des);
    \path [gtu arrow] (Des) -- (Code);
    \path [gtu arrow] (Code) -- (Test);
    \path [gtu arrow] (Test) -- (Rev);
    \path [gtu arrow] (Rev) -- (Plan);
    \path [gtu arrow] (Rev) -- (Rel);
\end{tikzpicture}
\captionof{figure}{Agile Development Cycle}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Customer Change Frequently Collaborates: મુખ્ય agile સિદ્ધાંતો પર ધ્યાન.}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Scrum પર ટૂંક નોંધ લખો.}

\begin{solutionbox}
Scrum એ ટીમ સહયોગ અને iterative પ્રગતિ પર ભાર મૂકીને સોફ્ટવેર ડેવલપમેન્ટ મેનેજ કરવા માટેનું agile framework છે.

\begin{center}
\captionof{table}{Scrum Roles અને જવાબદારીઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Role} & \textbf{જવાબદારીઓ} & \textbf{મુખ્ય પ્રવૃત્તિઓ} \\ \hline
\textbf{Product Owner} & પ્રોડક્ટ features અને priorities વ્યાખ્યાયિત કરે & Product backlog મેનેજ કરે \\ \hline
\textbf{Scrum Master} & પ્રક્રિયાને સુવિધા આપે અને અવરોધો દૂર કરે & Ceremonies આયોજિત કરે \\ \hline
\textbf{Development Team} & કાર્યશીલ સોફ્ટવેર બનાવે & સ્વ-સંગઠિત અને cross-functional \\ \hline
\end{tabulary}
\end{center}

\textbf{Scrum Events:}
\begin{itemize}
    \item \keyword{Sprint}: 1-4 અઠવાડિયાનું iteration જે સંભવિત shippable product બનાવે
    \item \keyword{Sprint Planning}: આગામી sprint માટે ટીમ કામની યોજના બનાવે
    \item \keyword{Daily Scrum}: 15 મિનિટની દૈનિક synchronization બેઠક
    \item \keyword{Sprint Review}: stakeholders ને પૂર્ણ થયેલું કામ દર્શાવવું
    \item \keyword{Sprint Retrospective}: પ્રક્રિયા સુધારણા પર ટીમનું પ્રતિબિંબ
\end{itemize}

\textbf{Scrum Artifacts:}
\begin{itemize}
    \item \keyword{Product Backlog}: features ની પ્રાથમિકતા આધારિત યાદી
    \item \keyword{Sprint Backlog}: વર્તમાન sprint માટે પસંદ કરેલી items
    \item \keyword{Increment}: Sprint ના અંતે કાર્યશીલ પ્રોડક્ટ
\end{itemize}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, every node/.style={gtu block, align=center, font=\small}]
    \node (Backlogs) {Product\\Backlog};
    \node [right=of Backlogs] (Plan) {Sprint\\Planning};
    \node [right=of Plan] (SprintBack) {Sprint\\Backlog};
    \node [below=of SprintBack] (Daily) {Daily\\Scrum};
    \node [left=of Daily] (Review) {Sprint\\Review};
    \node [left=of Review] (Retro) {Sprint\\Retrospective};
    \node [below=of Review] (Inc) {Product\\Increment};

    \path [gtu arrow] (Backlogs) -- (Plan);
    \path [gtu arrow] (Plan) -- (SprintBack);
    \path [gtu arrow] (SprintBack) -- (Daily);
    \path [gtu arrow] (Daily) -- (Review);
    \path [gtu arrow] (Review) -- (Retro);
    \path [gtu arrow] (Retro) |- (Plan);
    \path [gtu arrow] (Review) -- (Inc);
\end{tikzpicture}
\captionof{figure}{Scrum Process Flow}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Product Sprints Daily Reviews: મુખ્ય scrum elements નો ક્રમ.}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{જો તમે એક word processing software બનાવી રહ્યા હોઈ તો તમે ક્યા process model નો ઉપયોગ કરશો? તમારો જવાબ સમજાવો.}

\begin{solutionbox}
Word processing software ડેવલપમેન્ટ માટે હું \keyword{Incremental Model} ને સૌથી યોગ્ય process model તરીકે પસંદ કરીશ.

\textbf{બચાવ:}
\begin{itemize}
    \item \keyword{જટિલ functionality}: Word processors માં અસંખ્ય features છે (editing, formatting, spell-check) જે incrementally વિકસિત કરી શકાય
    \item \keyword{User feedback}: પ્રારંભિક increments user testing અને feedback incorporation ની મંજૂરી આપે છે
    \item \keyword{જોખમ મેનેજમેન્ટ}: મુખ્ય features પહેલા deliver, advanced features પછીથી ઉમેરવા
    \item \keyword{બજાર લાભ}: બેઝિક વર્ઝન વહેલું રિલીઝ કરીને બજારમાં હાજરી મેળવી શકાય
\end{itemize}

\textbf{ડેવલપમેન્ટ Increments:}
\begin{enumerate}
    \item \textbf{Increment 1}: મૂળભૂત text editing અને file operations
    \item \textbf{Increment 2}: Formatting અને font management
    \item \textbf{Increment 3}: Advanced features (spell-check, templates)
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Word Processing Increments User Feedback: જટિલ સોફ્ટવેર માટે incremental approach યોગ્ય.}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{સારા SRS ની લાક્ષણિકતાઓ સમજાવો.}

\begin{solutionbox}
સારા Software Requirements Specification (SRS) દસ્તાવેજમાં સફળ સોફ્ટવેર ડેવલપમેન્ટ સુનિશ્ચિત કરવા માટે ચોક્કસ લાક્ષણિકતાઓ હોવી જરૂરી છે.

\begin{center}
\captionof{table}{સારા SRS ની લાક્ષણિકતાઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લાક્ષણિકતા} & \textbf{વર્ણન} & \textbf{મહત્વ} \\ \hline
\textbf{સંપૂર્ણ} & બધી જરૂરી requirements ધરાવે & Scope creep અટકાવે છે \\ \hline
\textbf{સુસંગત} & કોઈ વિરોધાભાસી requirements નહીં & Implementation confusion ટાળે છે \\ \hline
\textbf{અસ્પષ્ટતા રહિત} & સ્પષ્ટ અને ચોક્કસ ભાષા & એક જ અર્થઘટન શક્ય \\ \hline
\textbf{ચકાસી શકાય તેવું} & Requirements ટેસ્ટ કરી શકાય & Validation શક્ય બનાવે \\ \hline
\textbf{સુધારી શકાય તેવું} & બદલવા અને જાળવવામાં સરળ & Requirement evolution ને સપોર્ટ કરે \\ \hline
\textbf{ટ્રેસેબલ} & Requirements સ્રોતો સાથે જોડાયેલ & Impact analysis શક્ય બનાવે \\ \hline
\end{tabulary}
\end{center}

\textbf{વધારાની લાક્ષણિકતાઓ:}
\begin{itemize}
    \item \keyword{શક્ય}: તકનીકી અને આર્થિક રીતે સાધ્ય
    \item \keyword{જરૂરી}: દરેક requirement નો હેતુ હોય
    \item \keyword{પ્રાથમિકતા આપેલ}: Requirements મહત્વ પ્રમાણે ક્રમાંકિત
    \item \keyword{ટેસ્ટ કરી શકાય તેવું}: ચકાસણી માટે ચોક્કસ માપદંડો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Complete Consistent Unambiguous Verifiable: મુખ્ય SRS ગુણવત્તા લક્ષણો.}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{ATM software માટે functional અને non-functional requirements સમજાવો.}

\begin{solutionbox}
ATM software requirements ને functional (સિસ્ટમ શું કરે છે) અને non-functional (સિસ્ટમ કેવી રીતે perform કરે છે) requirements માં વર્ગીકૃત કરવામાં આવે છે.

\begin{center}
\captionof{table}{ATM Functional Requirements}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Function} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{પ્રમાણીકરણ} & યુઝર લોગિન અને ચકાસણી & PIN validation, card reading \\ \hline
\textbf{એકાઉન્ટ ઓપરેશન્સ} & મૂળભૂત બેંકિંગ વ્યવહારો & બેલેન્સ પૂછપરછ, રોકડ ઉપાડ \\ \hline
\textbf{Transaction Processing} & પૈસા ટ્રાન્સફર અને જમા & એકાઉન્ટ-ટુ-એકાઉન્ટ ટ્રાન્સફર \\ \hline
\textbf{Receipt Generation} & વ્યવહાર documentation & Transaction receipts પ્રિન્ટ કરવી \\ \hline
\textbf{Session Management} & યુઝર session નિયંત્રણ & Timeout, logout functionality \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\captionof{table}{ATM Non-Functional Requirements}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શ્રેણી} & \textbf{Requirement} & \textbf{સ્પેસિફિકેશન} \\ \hline
\textbf{Performance} & Response time & પ્રતિ transaction મહત્તમ 3 સેકન્ડ \\ \hline
\textbf{Security} & ડેટા સુરક્ષા & બધા ડેટા માટે 256-bit encryption \\ \hline
\textbf{Reliability} & સિસ્ટમ ઉપલબ્ધતા & 99.9\% uptime requirement \\ \hline
\textbf{Usability} & યુઝર interface & બધી ઉંમરના લોકો માટે સરળ interface \\ \hline
\textbf{Scalability} & લોડ હેન્ડલિંગ & 1000 concurrent users ને સપોર્ટ \\ \hline
\end{tabulary}
\end{center}

\textbf{Functional Requirements વિગતો:}
\begin{itemize}
    \item \keyword{રોકડ ઉપાડ}: સફળ પ્રમાણીકરણ પછી રોકડ આપવી
    \item \keyword{બેલેન્સ પૂછપરછ}: વર્તમાન એકાઉન્ટ બેલેન્સ દર્શાવવું
    \item \keyword{PIN બદલવી}: યુઝર્સને તેમની PIN અપડેટ કરવાની મંજૂરી
    \item \keyword{મિની સ્ટેટમેન્ટ}: છેલ્લા 10 transactions પૂરા પાડવા
\end{itemize}

\textbf{Non-Functional Requirements વિગતો:}
\begin{itemize}
    \item \keyword{સુરક્ષા}: Multi-factor authentication, transaction logging
    \item \keyword{Performance}: ઝડપી transaction processing, ન્યૂનતમ રાહ જોવાનો સમય
    \item \keyword{ઉપલબ્ધતા}: ન્યૂનતમ downtime સાથે 24/7 ઓપરેશન
    \item \keyword{જાળવણીક્ષમતા}: સરળ software updates અને hardware maintenance
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Functions Work, Quality Matters: Functional વિ non-functional ભેદ.}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{આકૃતિ સાથે Incremental Model સમજાવો.}

\begin{solutionbox}
Incremental Model એ સોફ્ટવેરને increments તરીકે ઓળખાતા નાના, મેનેજ કરી શકાય તેવા ભાગોમાં વિકસિત કરે છે, જેમાં દરેક increment હાલની સિસ્ટમમાં નવી functionality ઉમેરે છે.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, every node/.style={gtu block, font=\small}]
    \node (Req) {Requirements};
    
    \node [right=2cm of Req] (Inc1) {Increment 1};
    \node [below=of Inc1] (Inc2) {Increment 2};
    \node [below=of Inc2] (Inc3) {Increment 3};

    \path [gtu arrow] (Req) -- (Inc1);
    \path [gtu arrow] (Req) |- (Inc2);
    \path [gtu arrow] (Req) |- (Inc3);

    % Details for Inc 1
    \node [right=1cm of Inc1, gtu state] (Rel1) {Release 1};
    \path [gtu arrow] (Inc1) -- node[above, font=\tiny]{Design, Code, Test} (Rel1);
    
    % Details for Inc 2
    \node [right=1cm of Inc2, gtu state] (Rel2) {Release 2};
    \path [gtu arrow] (Inc2) -- node[above, font=\tiny]{Design, Code, Test} (Rel2);
    
    % Details for Inc 3
    \node [right=1cm of Inc3, gtu state] (Rel3) {Final Release};
    \path [gtu arrow] (Inc3) -- node[above, font=\tiny]{Design, Code, Test} (Rel3);

\end{tikzpicture}
\captionof{figure}{Incremental Model}
\end{center}

\textbf{મુખ્ય લક્ષણો:}
\begin{itemize}
    \item \keyword{સમાંતર વિકાસ}: અનેક increments એક સાથે વિકસિત
    \item \keyword{પ્રારંભિક delivery}: પ્રથમ increment પછી કાર્યશીલ સોફ્ટવેર ઉપલબ્ધ
    \item \keyword{જોખમ ઘટાડો}: મુખ્ય functionality પહેલા deliver
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Increments Build Upon Previous: દરેક increment હાલની functionality પર ઉમેરે છે.}
\end{mnemonicbox}


\questionmarks{2(b OR)}{4}{Functional અને non-functional requirements નો તફાવત સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Functional વિ Non-Functional Requirements}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{Functional Requirements} & \textbf{Non-Functional Requirements} \\ \hline
\textbf{વ્યાખ્યા} & સિસ્ટમ શું કરે છે & સિસ્ટમ કેવી રીતે perform કરે છે \\ \hline
\textbf{ફોકસ} & સિસ્ટમ વર્તન અને features & સિસ્ટમ ગુણવત્તા લક્ષણો \\ \hline
\textbf{ટેસ્ટિંગ} & Black-box testing & Performance અને stress testing \\ \hline
\textbf{Documentation} & Use cases, user stories & Quality metrics, constraints \\ \hline
\textbf{ઉદાહરણો} & Login, search, calculate & Speed, security, usability \\ \hline
\textbf{ચકાસણી} & Functional testing & Non-functional testing \\ \hline
\textbf{બદલાવની અસર} & Feature modification & Performance tuning \\ \hline
\textbf{યુઝર દૃશ્યતા} & યુઝર્સને સીધી દેખાય છે & પરોક્ષ રીતે અનુભવાય છે \\ \hline
\end{tabulary}
\end{center}

\textbf{Functional Requirements લાક્ષણિકતાઓ:}
\begin{itemize}
    \item \keyword{વર્તન-કેન્દ્રિત}: સિસ્ટમ ક્રિયાઓ અને પ્રતિસાદો વ્યાખ્યાયિત કરે
    \item \keyword{Feature-વિશિષ્ટ}: દરેક requirement ચોક્કસ ક્ષમતા વર્ણવે છે
    \item \keyword{યુઝર-સંચાલિત}: યુઝર જરૂરિયાતો અને બિઝનેસ પ્રક્રિયાઓ પર આધારિત
\end{itemize}

\textbf{Non-Functional Requirements લાક્ષણિકતાઓ:}
\begin{itemize}
    \item \keyword{ગુણવત્તા-કેન્દ્રિત}: Performance અને ગુણવત્તા ધોરણો વ્યાખ્યાયિત કરે
    \item \keyword{સિસ્ટમ-વ્યાપી}: ચોક્કસ features ને બદલે સમગ્ર સિસ્ટમ પર લાગુ પડે
    \item \keyword{અવરોધ-સંચાલિત}: સિસ્ટમ ઓપરેશન માટે મર્યાદાઓ અને બાઉન્ડરીઝ સેટ કરે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Functions Do, Quality Shows: Functional requirements ક્રિયાઓ વ્યાખ્યાયિત કરે, non-functional ગુણવત્તા વ્યાખ્યાયિત કરે.}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Requirements Analysis પર ટૂંક નોંધ લખો.}

\begin{solutionbox}
Requirements Analysis એ યુઝર જરૂરિયાતોનો અભ્યાસ કરવાની અને સોફ્ટવેર સિસ્ટમે શું સિદ્ધ કરવું જોઈએ તે સમજવા માટે સિસ્ટમ requirements વ્યાખ્યાયિત કરવાની પ્રક્રિયા છે.

\begin{center}
\captionof{table}{Requirements Analysis Process}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{તબક્કો} & \textbf{પ્રવૃત્તિઓ} & \textbf{Deliverables} \\ \hline
\textbf{Elicitation} & Stakeholders પાસેથી requirements ભેગી કરવી & Requirement lists, interviews \\ \hline
\textbf{Analysis} & Requirements નો અભ્યાસ અને સમજ & Requirement models, prototypes \\ \hline
\textbf{Specification} & Requirements ને ઔપચારિક રીતે document કરવી & SRS document, use cases \\ \hline
\textbf{Validation} & Requirements ની શુદ્ધતા ચકાસવી & Validated requirements \\ \hline
\end{tabulary}
\end{center}

\textbf{Requirements Elicitation તકનીકો:}
\begin{itemize}
    \item \keyword{Interviews}: Stakeholders સાથે એક-નાસીક ચર્ચા
    \item \keyword{Questionnaires}: મોટા યુઝર ગ્રૂપ માટે structured surveys
    \item \keyword{Observation}: હાલની કાર્ય પ્રક્રિયાઓનો અભ્યાસ
    \item \keyword{Workshops}: Requirement gathering માટે જૂથ સત્રો
    \item \keyword{Prototyping}: Feedback માટે પ્રારંભિક વર્ઝન બનાવવા
\end{itemize}

\textbf{Analysis પ્રવૃત્તિઓ:}
\begin{itemize}
    \item \keyword{Requirement prioritization}: મહત્વ પ્રમાણે requirements ને રેંક કરવી
    \item \keyword{Feasibility study}: તકનીકી અને આર્થિક વ્યવહાર્યતાનું મૂલ્યાંકન
    \item \keyword{Conflict resolution}: વિરોધાભાસી requirements ને ઉકેલવી
    \item \keyword{Requirement modeling}: દ્રશ્ય પ્રતિનિધિત્વો બનાવવા
\end{itemize}

\textbf{Validation તકનીકો:}
\begin{itemize}
    \item \keyword{Requirement reviews}: Documented requirements ની ઔપચારિક તપાસ
    \item \keyword{Prototyping}: સમજણીને validate કરવા માટે models બનાવવા
    \item \keyword{Test case generation}: Requirements પરથી ટેસ્ટ્સ બનાવવા
\end{itemize}

\textbf{Requirements Analysis માં પડકારો:}
\begin{itemize}
    \item \keyword{બદલાતી requirements}: Stakeholder જરૂરિયાતો સમય સાથે વિકસિત થાય છે
    \item \keyword{સંદેશાવ્યવહાર ગેપ}: યુઝર્સ અને developers વચ્ચે ગેરસમજ
    \item \keyword{અધૂરી requirements}: ગુમ અથવા અસ્પષ્ટ વર્ણનો
    \item \keyword{વિરોધાભાસી stakeholder જરૂરિયાતો}: અલગ યુઝર ગ્રૂપોની અલગ પ્રાથમિકતાઓ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Every Analysis Specification Validates: Requirements analysis ના મુખ્ય તબક્કાઓ.}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Gantt Chart સમજાવો.}

\begin{solutionbox}
Gantt Chart એ દૃશ્ય પ્રોજેક્ટ મેનેજમેન્ટ ટૂલ છે જે timeline સામે પ્રોજેક્ટ કાર્યો દર્શાવે છે, task duration, dependencies, અને પ્રગતિ બતાવે છે.

\begin{center}
\captionof{table}{Gantt Chart ઘટકો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઘટક} & \textbf{વર્ણન} & \textbf{હેતુ} \\ \hline
\textbf{Tasks} & ઊભી રીતે સૂચિબદ્ધ પ્રોજેક્ટ પ્રવૃત્તિઓ & કાર્ય વિભાજન દર્શાવે \\ \hline
\textbf{Timeline} & આડું સમય માપદંડ & પ્રોજેક્ટ અવધિ દર્શાવે \\ \hline
\textbf{Bars} & Task duration દર્શાવતા આડા બાર્સ & દૃશ્ય task પ્રતિનિધિત્વ \\ \hline
\textbf{Dependencies} & સંબંધિત tasks ને જોડતી લાઇનો & Task સંબંધો દર્શાવે \\ \hline
\textbf{Milestones} & મુખ્ય પ્રોજેક્ટ checkpoints & મહત્વપૂર્ણ ઇવેન્ટ્સ માર્ક કરે \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[x=1cm, y=0.6cm]
    \draw[help lines] (0,0) grid (5,4);
    
    \node[anchor=east] at (0,3.5) {Requirements};
    \node[anchor=east] at (0,2.5) {Design};
    \node[anchor=east] at (0,1.5) {Coding};
    \node[anchor=east] at (0,0.5) {Testing};

    \fill[blue!50] (0,3.2) rectangle (1.5,3.8);
    \fill[blue!50] (1.5,2.2) rectangle (3,2.8);
    \fill[blue!50] (3,1.2) rectangle (4.5,1.8);
    \fill[blue!50] (4,0.2) rectangle (5,0.8);
    
    \node[anchor=south] at (0.75,3.8) {Wk 1};
    \node[anchor=south] at (2.25,2.8) {Wk 2};
    \node[anchor=south] at (3.75,1.8) {Wk 3};
    \node[anchor=south] at (4.5,0.8) {Wk 4};

\end{tikzpicture}
\captionof{figure}{Sample Gantt Chart}
\end{center}

\textbf{ફાયદાઓ:}
\begin{itemize}
    \item \keyword{દૃશ્ય સ્પષ્ટતા}: પ્રોજેક્ટ timeline સમજવામાં સરળ
    \item \keyword{પ્રગતિ ટ્રેકિંગ}: પૂર્ણ વિ બાકી કામ દર્શાવે છે
    \item \keyword{સંસાધન આયોજન}: સંસાધનો અસરકારક રીતે ફાળવવામાં મદદ કરે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Gantt Graphs Timeline Tasks: પ્રોજેક્ટ tasks નું દૃશ્ય timeline પ્રતિનિધિત્વ.}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{સંક્ષિપ્તમાં લખો: સોફ્ટવેર પ્રોજેક્ટ મેનેજરની જવાબદારીઓ અને કુશળતા.}

\begin{solutionbox}
સોફ્ટવેર પ્રોજેક્ટ મેનેજર સમગ્ર સોફ્ટવેર ડેવલપમેન્ટ lifecycle ની દેખરેખ રાખે છે, પ્રોજેક્ટ્સ સમયસર, બજેટમાં, અને ગુણવત્તા ધોરણો પૂરા કરીને પૂર્ણ થાય તે સુનિશ્ચિત કરે છે.

\begin{center}
\captionof{table}{પ્રોજેક્ટ મેનેજર જવાબદારીઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શ્રેણી} & \textbf{જવાબદારીઓ} & \textbf{મુખ્ય પ્રવૃત્તિઓ} \\ \hline
\textbf{આયોજન} & પ્રોજેક્ટ scope અને timeline વ્યાખ્યા & WBS બનાવટ, શેડ્યુલિંગ \\ \hline
\textbf{સંસાધન મેનેજમેન્ટ} & ટીમ ફાળવણી અને સંકલન & સ્ટાફ assignment, skill matching \\ \hline
\textbf{જોખમ મેનેજમેન્ટ} & પ્રોજેક્ટ જોખમો ઓળખવા અને ઘટાડવા & જોખમ મૂલ્યાંકન, contingency આયોજન \\ \hline
\textbf{સંદેશાવ્યવહાર} & Stakeholder સંકલન & સ્થિતિ રિપોર્ટિંગ, બેઠકો \\ \hline
\textbf{ગુણવત્તા બાંયધરી} & Deliverable ગુણવત્તા સુનિશ્ચિત કરવી & સમીક્ષા પ્રક્રિયાઓ, ધોરણો \\ \hline
\end{tabulary}
\end{center}

\textbf{આવશ્યક કુશળતાઓ:}
\begin{itemize}
    \item \keyword{તકનીકી કુશળતાઓ}: સોફ્ટવેર ડેવલપમેન્ટ પ્રક્રિયાઓની સમજ
    \item \keyword{નેતૃત્વ કુશળતાઓ}: ટીમ પ્રેરણા અને માર્ગદર્શન
    \item \keyword{સંદેશાવ્યવહાર કુશળતાઓ}: અસરકારક stakeholder આંતરક્રિયા
    \item \keyword{સમસ્યા-નિરાકરણ કુશળતાઓ}: ઝડપી મુદ્દા નિરાકરણ
    \item \keyword{સમય મેનેજમેન્ટ}: કાર્યક્ષમ કાર્ય પ્રાથમિકતા
\end{itemize}

\textbf{મુખ્ય જવાબદારીઓ:}
\begin{itemize}
    \item \keyword{પ્રોજેક્ટ આયોજન}: Scope, timeline, અને સંસાધનો વ્યાખ્યાયિત કરવા
    \item \keyword{ટીમ સંકલન}: ડેવલપમેન્ટ ટીમ પ્રવૃત્તિઓ મેનેજ કરવી
    \item \keyword{Stakeholder મેનેજમેન્ટ}: ક્લાઇન્ટ અને sponsor સંબંધો જાળવવા
    \item \keyword{જોખમ ઘટાડો}: સંભવિત સમસ્યાઓ ઓળખવી અને સંબોધવી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Managers Plan Resources Risks Communication: પ્રોજેક્ટ મેનેજર્સની મુખ્ય જવાબદારીઓ.}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Risk Management પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}
Risk Management એ સોફ્ટવેર ડેવલપમેન્ટની સફળતાને અસર કરી શકે તેવા પ્રોજેક્ટ જોખમોને ઓળખવા, વિશ્લેષણ કરવા, અને તેનો પ્રતિસાદ આપવાની વ્યવસ્થિત પ્રક્રિયા છે.

\begin{center}
\captionof{table}{Risk Management Process}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{તબક્કો} & \textbf{પ્રવૃત્તિઓ} & \textbf{તકનીકો} & \textbf{પરિણામો} \\ \hline
\textbf{Risk Identification} & સંભવિત જોખમો શોધવા & Brainstorming, checklists & Risk register \\ \hline
\textbf{Risk Analysis} & સંભાવના અને અસરનું મૂલ્યાંકન & Risk matrices, scoring & પ્રાથમિકતા આપેલા જોખમો \\ \hline
\textbf{Risk Planning} & પ્રતિસાદ વ્યૂહરચના વિકસિત કરવી & Mitigation, avoidance & Risk response plans \\ \hline
\textbf{Risk Monitoring} & જોખમોને ટ્રેક અને કંટ્રોલ કરવા & નિયમિત સમીક્ષાઓ & અપડેટેડ જોખમ સ્થિતિ \\ \hline
\end{tabulary}
\end{center}

\textbf{સોફ્ટવેર પ્રોજેક્ટ જોખમોના પ્રકારો:}

\textbf{તકનીકી જોખમો:}
\begin{itemize}
    \item \keyword{ટેકનોલોજી અનિશ્ચિતતા}: નવી અથવા અપ્રમાણિત ટેકનોલોજીઓ
    \item \keyword{Performance મુદ્દાઓ}: સિસ્ટમ performance requirements પૂરા ન કરવા
    \item \keyword{Integration સમસ્યાઓ}: સિસ્ટમ ઘટકોને જોડવામાં મુશ્કેલી
\end{itemize}

\textbf{પ્રોજેક્ટ જોખમો:}
\begin{itemize}
    \item \keyword{શેડ્યુલ વિલંબ}: કાર્યો અંદાજ કરતાં વધારે સમય લેવા
    \item \keyword{સંસાધન અવરોધો}: અપૂરતા સ્ટાફ અથવા બજેટ
    \item \keyword{Scope creep}: અનિયંત્રિત requirement બદલાવો
\end{itemize}

\textbf{બિઝનેસ જોખમો:}
\begin{itemize}
    \item \keyword{બજાર બદલાવો}: બદલાતી બિઝનેસ requirements
    \item \keyword{સ્પર્ધા}: સ્પર્ધાત્મક પ્રોડક્ટ્સ પ્રોજેક્ટ મૂલ્યને અસર કરવા
    \item \keyword{નિયમનકારી બદલાવો}: નવી compliance requirements
\end{itemize}

\textbf{Risk પ્રતિસાદ વ્યૂહરચનાઓ:}
\begin{itemize}
    \item \keyword{Risk Avoidance}: પ્રોજેક્ટ અભિગમ બદલીને જોખમ દૂર કરવું
    \item \keyword{Risk Mitigation}: જોખમની સંભાવના અથવા અસર ઘટાડવી
    \item \keyword{Risk Transfer}: ત્રીજા પક્ષને જોખમ હસ્તાંતરિત કરવું (વીમો, આઉટસોર્સિંગ)
    \item \keyword{Risk Acceptance}: જોખમ સ્વીકારવું અને contingency યોજનાઓ વિકસિત કરવી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Identify Analyze Plan Monitor: જોખમ મેનેજમેન્ટ પ્રક્રિયાના ચાર તબક્કાઓ.}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{ઉદાહરણ સાથે WBS સમજાવો.}

\begin{solutionbox}
Work Breakdown Structure (WBS) એ પ્રોજેક્ટ કાર્યનું હાયરાર્કિકલ વિઘટન છે જે નાના, મેનેજ કરી શકાય તેવા ઘટકોમાં વિભાજિત થાય છે જેનો સરળતાથી અંદાજ, અસાઇનમેન્ટ, અને ટ્રેકિંગ થઈ શકે.

\begin{center}
\begin{tikzpicture}[level 1/.style={sibling distance=3cm}, level 2/.style={sibling distance=1.5cm}, nodes={gtu block, draw, minimum height=0.6cm, align=center, font=\scriptsize}]
    \node {E-commerce\\Website}
        child { node {Frontend\\Development}
            child { node {UI} }
            child { node {Cart} }
            child { node {Payment} }
        }
        child { node {Backend\\Development}
            child { node {DB} }
            child { node {User} }
            child { node {Orders} }
        }
        child { node {Testing}
            child { node {Unit} }
            child { node {Integration} }
        }
        child { node {Deployment} };
\end{tikzpicture}
\captionof{figure}{E-commerce Website માટે WBS ઉદાહરણ}
\end{center}

\textbf{WBS લાક્ષણિકતાઓ:}
\begin{itemize}
    \item \keyword{હાયરાર્કિકલ સ્ટ્રક્ચર}: પ્રોજેક્ટ scope નું ટોપ-ડાઉન વિભાજન
    \item \keyword{100\% નિયમ}: WBS માં પ્રોજેક્ટ scope દ્વારા વ્યાખ્યાયિત 100\% કાર્ય સામેલ
    \item \keyword{પરસ્પર વિશિષ્ટ}: WBS ઘટકો વચ્ચે કોઈ ઓવરલેપ નહીં
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Work Breaks Small: કાર્યને નાના મેનેજ કરી શકાય તેવા ટુકડાઓમાં તોડવું.}
\end{mnemonicbox}


\questionmarks{3(b OR)}{4}{પ્રોજેક્ટ મોનિટરિંગ અને નિયંત્રણ સમજાવો.}

\begin{solutionbox}
પ્રોજેક્ટ મોનિટરિંગ અને કંટ્રોલમાં પ્રોજેક્ટ પ્રગતિને ટ્રેક કરવું, આયોજિત performance સામે વાસ્તવિક performance ની તુલના કરવી, અને જરૂર પડે ત્યારે સુધારાત્મક પગલાં લેવાનો સમાવેશ થાય છે.

\begin{center}
\captionof{table}{મોનિટરિંગ અને કંટ્રોલ પ્રવૃત્તિઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રવૃત્તિ} & \textbf{વર્ણન} & \textbf{ટૂલ્સ/તકનીકો} \\ \hline
\textbf{પ્રગતિ ટ્રેકિંગ} & Task completion મોનિટર કરવું & Gantt charts, dashboards \\ \hline
\textbf{Performance માપણ} & વાસ્તવિક વિ આયોજિત તુલના & Earned value analysis \\ \hline
\textbf{ગુણવત્તા નિયંત્રણ} & Deliverable ગુણવત્તા સુનિશ્ચિત કરવી & Reviews, testing \\ \hline
\textbf{જોખમ મોનિટરિંગ} & ઓળખાયેલા જોખમોને ટ્રેક કરવા & Risk registers, reports \\ \hline
\textbf{બદલાવ નિયંત્રણ} & Scope બદલાવો મેનેજ કરવા & Change request process \\ \hline
\end{tabulary}
\end{center}

\textbf{મુખ્ય મોનિટરિંગ મેટ્રિક્સ:}
\begin{itemize}
    \item \keyword{શેડ્યુલ performance}: સમયસર પૂર્ણ થયેલા tasks
    \item \keyword{ખર્ચ performance}: બજેટ ઉપયોગ અને variance
    \item \keyword{ગુણવત્તા મેટ્રિક્સ}: ખામી દરો, ગ્રાહક સંતોષ
    \item \keyword{સંસાધન ઉપયોગ}: ટીમ ઉત્પાદકતા અને કાર્યક્ષમતા
\end{itemize}

\textbf{કંટ્રોલ ક્રિયાઓ:}
\begin{itemize}
    \item \keyword{સુધારાત્મક ક્રિયાઓ}: Performance વિચલનોને સંબોધવા
    \item \keyword{નિવારક ક્રિયાઓ}: સંભવિત સમસ્યાઓ ટાળવા
    \item \keyword{બદલાવ મેનેજમેન્ટ}: Scope મોડિફિકેશન હેન્ડલ કરવું
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Monitor Progress Performance Quality: પ્રોજેક્ટ મોનિટરિંગના મુખ્ય ક્ષેત્રો.}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{યોગ્ય ઉદાહરણ સાથે Critical Path Method (CPM) સમજાવો.}

\begin{solutionbox}
Critical Path Method (CPM) એ પ્રોજેક્ટ મેનેજમેન્ટ તકનીક છે જે dependent tasks નો સૌથી લાંબો ક્રમ ઓળખે છે અને ન્યૂનતમ પ્રોજેક્ટ પૂર્ણતા સમય નક્કી કરે છે.

\begin{center}
\captionof{table}{Sample પ્રોજેક્ટ Tasks}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Task} & \textbf{અવધિ (દિવસો)} & \textbf{Predecessors} \\ \hline
A - Requirements & 5 & - \\ \hline
B - Design & 8 & A \\ \hline
C - Database Setup & 6 & A \\ \hline
D - Frontend Coding & 10 & B \\ \hline
E - Backend Coding & 12 & B, C \\ \hline
F - Integration & 4 & D, E \\ \hline
G - Testing & 6 & F \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, every node/.style={circle, draw, font=\small}]
    \node (A) {A:5};
    \node [above right=1cm and 1cm of A] (B) {B:8};
    \node [below right=1cm and 1cm of A] (C) {C:6};
    
    \node [right=1cm of B] (D) {D:10};
    \node [below right=1cm and 1cm of B] (E) {E:12};
    
    \node [right=1cm of E] (F) {F:4};
    \node [right=1cm of F] (G) {G:6};

    \path [gtu arrow] (A) -- (B);
    \path [gtu arrow] (A) -- (C);
    \path [gtu arrow] (B) -- (D);
    \path [gtu arrow] (B) -- (E);
    \path [gtu arrow] (C) -- (E);
    \path [gtu arrow] (D) -- (F);
    \path [gtu arrow] (E) -- (F);
    \path [gtu arrow] (F) -- (G);
\end{tikzpicture}
\captionof{figure}{CPM Network}
\end{center}

\textbf{Critical Path ગણતરી:}
\begin{itemize}
    \item \textbf{Path 1}: A $\to$ B $\to$ D $\to$ F $\to$ G = 5 + 8 + 10 + 4 + 6 = 33 દિવસ
    \item \textbf{Path 2}: A $\to$ B $\to$ E $\to$ F $\to$ G = 5 + 8 + 12 + 4 + 6 = 35 દિવસ (Critical Path)
    \item \textbf{Path 3}: A $\to$ C $\to$ E $\to$ F $\to$ G = 5 + 6 + 12 + 4 + 6 = 33 દિવસ
\end{itemize}

\textbf{CPM ફાયદાઓ:}
\begin{itemize}
    \item \keyword{પ્રોજેક્ટ અવધિ}: ન્યૂનતમ પૂર્ણતા સમય નક્કી કરે છે
    \item \keyword{Critical પ્રવૃત્તિઓ}: Tasks ઓળખે છે જે વિલંબિત થઈ શકતા નથી
    \item \keyword{Float ગણતરી}: Non-critical tasks માટે ઉપલબ્ધ slack time દર્શાવે છે
    \item \keyword{સંસાધન ઑપ્ટિમાઇઝેશન}: સંસાધનો કાર્યક્ષમ રીતે ફાળવવામાં મદદ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Critical Paths Minimize Project Duration: CPM ન્યૂનતમ સમય નક્કી કરતો સૌથી લાંબો path શોધે છે.}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{ડિઝાઇન પ્રવૃત્તિઓના વર્ગીકરણ પર નોંધ લખો.}

\begin{solutionbox}
સોફ્ટવેર ડિઝાઇન પ્રવૃત્તિઓને ડિઝાઇન પ્રક્રિયાને વ્યવસ્થિત કરવા અને વ્યાપક સિસ્ટમ ડેવલપમેન્ટ સુનિશ્ચિત કરવા માટે વ્યવસ્થિત રીતે વર્ગીકૃત કરવામાં આવે છે.

\begin{center}
\captionof{table}{ડિઝાઇન પ્રવૃત્તિઓનું વર્ગીકરણ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{વર્ગીકરણ} & \textbf{પ્રવૃત્તિઓ} & \textbf{ફોકસ ક્ષેત્ર} \\ \hline
\textbf{Architectural Design} & સિસ્ટમ સ્ટ્રક્ચર, ઘટકો & ઉચ્ચ-સ્તરીય સંગઠન \\ \hline
\textbf{Interface Design} & યુઝર interface, સિસ્ટમ interfaces & Interaction design \\ \hline
\textbf{Component Design} & Module વિગતો, algorithms & નીચલા-સ્તરીય implementation \\ \hline
\textbf{Data Design} & Database, data structures & ડેટા સંગઠન \\ \hline
\end{tabulary}
\end{center}

\textbf{ડિઝાઇન પ્રવૃત્તિ સ્તરો:}
\begin{itemize}
    \item \keyword{સિસ્ટમ લેવલ}: સમગ્ર સિસ્ટમ આર્કિટેક્ચર અને મુખ્ય ઘટકો
    \item \keyword{Subsystem લેવલ}: વ્યક્તિગત subsystem ડિઝાઇન અને interfaces
    \item \keyword{Component લેવલ}: વિગતવાર module ડિઝાઇન અને algorithms
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Architects Interface Components Data: ચાર મુખ્ય ડિઝાઇન પ્રવૃત્તિ વર્ગીકરણો.}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{કપલિંગ વ્યાખ્યાયિત કરો. તેનું વર્ગીકરણ સમજાવો.}

\begin{solutionbox}
Coupling એ સોફ્ટવેર modules વચ્ચેની આંતરનિર્ભરતાની ડિગ્રીનો ઉલ્લેખ કરે છે. ઓછું coupling વધુ maintainable અને લવચીક કોડ સાથે બહેતર સોફ્ટવેર ડિઝાઇન દર્શાવે છે.

\begin{center}
\captionof{table}{Coupling ના પ્રકારો (ઢીલાથી કડકા સુધી)}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Coupling પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{Data Coupling} & Modules parameters દ્વારા વાતચીત કરે & સરળ parameters સાથે function calls \\ \hline
\textbf{Stamp Coupling} & Modules composite data structure શેર કરે & Parameter તરીકે record/structure પાસ કરવું \\ \hline
\textbf{Control Coupling} & એક module બીજાના execution ને કંટ્રોલ કરે & Control flags પાસ કરવા \\ \hline
\textbf{External Coupling} & Modules બાહ્ય format પર આધાર રાખે & Shared file format અથવા protocol \\ \hline
\textbf{Common Coupling} & Modules global data શેર કરે & Global variables એક્સેસ \\ \hline
\textbf{Content Coupling} & એક module બીજાના data ને modify કરે & બીજા module ના data ને સીધો એક્સેસ \\ \hline
\end{tabulary}
\end{center}

\textbf{Loose Coupling ના ફાયદાઓ:}
\begin{itemize}
    \item \keyword{જાળવણીક્ષમતા}: વ્યક્તિગત modules ને modify કરવું સરળ
    \item \keyword{પુનઃઉપયોગિતા}: Modules અલગ contexts માં ઉપયોગ કરી શકાય
    \item \keyword{ટેસ્ટેબિલિટી}: Modules સ્વતંત્ર રીતે ટેસ્ટ કરી શકાય
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Data Stamp Control External Common Content: ઢીલાથી કડક સુધીના coupling પ્રકારો.}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Online shopping web application માટે use-case ડાયાગ્રામ દોરો.}

\begin{solutionbox}
Use case diagram એ actors અને સિસ્ટમ સાથેની તેમની આંતરક્રિયાઓ દર્શાવીને online shopping સિસ્ટમની functional requirements બતાવે છે.

\begin{center}
\begin{tikzpicture}[
    actor/.style={shape=circle, draw, align=center, minimum size=0.8cm},
    usecase/.style={shape=ellipse, draw, align=center, font=\footnotesize},
    edge/.style={->, >=stealth}
]
    % Actors
    \node[actor] (Cust) at (0, 0) {Cust};
    \node[actor] (Admin) at (8, 0) {Admin};
    \node[actor] (PaySys) at (4, -5) {Payment\\System};

    % Customer Use Cases
    \node[usecase] (Browse) at (3, 2) {Browse\\Products};
    \node[usecase] (Search) at (3, 1) {Search\\Products};
    \node[usecase] (Cart) at (3, 0) {Add to\\Cart};
    \node[usecase] (Checkout) at (4, -1.5) {Checkout};
    \node[usecase] (Payment) at (4, -3) {Make\\Payment};
    
    % Admin Use Cases
    \node[usecase] (ManageProd) at (5, 2) {Manage\\Products};
    \node[usecase] (ProcessOrder) at (5, 1) {Process\\Orders};

    % Connections
    \draw (Cust) -- (Browse);
    \draw (Cust) -- (Search);
    \draw (Cust) -- (Cart);
    \draw (Cust) -- (Checkout);
    
    \draw (Admin) -- (ManageProd);
    \draw (Admin) -- (ProcessOrder);
    
    \draw[edge, dashed] (Checkout) -- node[left, font=\tiny]{include} (Payment);
    \draw[edge, dashed] (Payment) -- (PaySys);

\end{tikzpicture}
\captionof{figure}{Online Shopping Use Case Diagram}
\end{center}

\textbf{મુખ્ય Use Cases સમજાવ્યા:}

\textbf{Customer Use Cases:}
\begin{itemize}
    \item \keyword{Browse Products}: શ્રેણી પ્રમાણે ઉપલબ્ધ products જોવા
    \item \keyword{Search Products}: keywords વાપરીને ચોક્કસ products શોધવા
    \item \keyword{Shopping Cart}: Cart items ઉમેરવા, દૂર કરવા, અને modify કરવા
    \item \keyword{Checkout Process}: shipping વિગતો સાથે ખરીદી પૂર્ણ કરવી
\end{itemize}

\textbf{Admin Use Cases:}
\begin{itemize}
    \item \keyword{Product Management}: Products અને categories ઉમેરવા, edit કરવા, delete કરવા
    \item \keyword{Order Processing}: Order fulfillment અને shipping મેનેજ કરવું
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Customers Browse Buy, Admins Manage Monitor: મુખ્ય use case શ્રેણીઓ.}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{સારા UI ના લક્ષણો સમજાવો.}

\begin{solutionbox}
સારી User Interface (UI) ડિઝાઇન intuitive અને user-friendly ડિઝાઇન સિદ્ધાંતો દ્વારા સોફ્ટવેર સિસ્ટમ્સ સાથે અસરકારક યુઝર interaction સુનિશ્ચિત કરે છે.

\begin{center}
\captionof{table}{સારા UI ની લાક્ષણિકતાઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લાક્ષણિકતા} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{સુસંગતતા} & એપ્લિકેશન દરમિયાન એકરૂપ ડિઝાઇન & સમગ્રમાં સમાન button styles \\ \hline
\textbf{સરળતા} & સમજવા અને ઉપયોગ કરવામાં સરળ & ન્યૂનતમ, સ્વચ્છ interface \\ \hline
\textbf{દૃશ્યતા} & મહત્વપૂર્ણ ઘટકો સ્પષ્ટ રીતે દેખાય & મુખ્ય ક્રિયાઓ અગ્રણી રીતે પ્રદર્શિત \\ \hline
\textbf{Feedback} & યુઝર ક્રિયાઓનો સિસ્ટમ પ્રતિસાદ & Progress bars, confirmations \\ \hline
\textbf{ભૂલ અટકાવણ} & યુઝર ભૂલો અટકાવે છે & Input validation, confirmations \\ \hline
\textbf{લવચીકતા} & અલગ યુઝર જરૂરિયાતોને સમાવે છે & Customizable interfaces \\ \hline
\end{tabulary}
\end{center}

\textbf{UI ડિઝાઇન સિદ્ધાંતો:}
\begin{itemize}
    \item \keyword{યુઝર-કેન્દ્રિત}: યુઝર જરૂરિયાતો અને લક્ષ્યો પર કેન્દ્રિત ડિઝાઇન
    \item \keyword{પહોંચિયાત}: અલગ ક્ષમતાઓ ધરાવતા લોકો દ્વારા ઉપયોગ્ય
    \item \keyword{કાર્યક્ષમતા}: કાર્યો પૂર્ણ કરવા માટે પગલાં ઘટાડે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Consistent Simple Visible Feedback: મુખ્ય UI ડિઝાઇન લાક્ષણિકતાઓ.}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Cohesion વ્યાખ્યાયિત કરો. તેનું વર્ગીકરણ સમજાવો.}

\begin{solutionbox}
Cohesion એ સિંગલ module ની જવાબદારીઓ કેટલી નજીકથી સંબંધિત અને કેન્દ્રિત છે તેનો ઉલ્લેખ કરે છે. ઉચ્ચ cohesion સંબંધિત functionality સાથે સારી રીતે ડિઝાઇન કરેલા modules દર્શાવે છે.

\begin{center}
\captionof{table}{Cohesion ના પ્રકારો (નબળાથી મજબૂત સુધી)}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Cohesion પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{Coincidental} & ઘટકો મનસ્વી રીતે જૂથબદ્ધ & અસંબંધિત functions સાથે utility module \\ \hline
\textbf{Logical} & ઘટકો સમાન તાર્કિક functions કરે & બધા input/output operations \\ \hline
\textbf{Temporal} & ઘટકો એક જ સમયે execute થાય & સિસ્ટમ initialization module \\ \hline
\textbf{Procedural} & ઘટકો ચોક્કસ sequence અનુસરે & Sequential processing steps \\ \hline
\textbf{Communicational} & ઘટકો સમાન data પર operate કરે & સમાન record પર process કરતું module \\ \hline
\textbf{Sequential} & એક ઘટકનું output બીજાનું input બને & Data transformation pipeline \\ \hline
\textbf{Functional} & બધા ઘટકો સિંગલ task માં ફાળો આપે & કર્મચારીનો પગાર calculate કરવો \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉચ્ચ Cohesion ના ફાયદાઓ:}
\begin{itemize}
    \item \keyword{જાળવણીક્ષમતા}: સમજવા અને modify કરવામાં સરળ
    \item \keyword{વિશ્વસનીયતા}: ભૂલો થવાની શક્યતા ઓછી
    \item \keyword{પુનઃઉપયોગિતા}: સિંગલ-હેતુ modules વધુ પુનઃઉપયોગ્ય
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Coincidental Logical Temporal Procedural Communicational Sequential Functional: નબળાથી મજબૂત સુધીના cohesion પ્રકારો.}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{Library system માટે સંદર્ભ રેખાકૃતિ દોરો.}

\begin{solutionbox}
Context diagram લાઇબ્રેરી સિસ્ટમને સિંગલ process તરીકે તેના બાહ્ય entities અને data flows સાથે દર્શાવે છે, સિસ્ટમ બાઉન્ડરીઝનું ઉચ્ચ-સ્તરીય દૃશ્ય પૂરું પાડે છે.

\begin{center}
\begin{tikzpicture}[
    node distance=2.5cm,
    entity/.style={gtu block, minimum height=1cm, minimum width=2cm},
    system/.style={gtu state, minimum size=2.5cm, fill=blue!10},
    flow/.style={gtu arrow}
]
    \node[system] (Sys) {Library\\Management\\System};
    
    \node[entity, above=of Sys] (Lib) {Librarian};
    \node[entity, left=of Sys] (Stu) {Student};
    \node[entity, right=of Sys] (Adm) {Administrator};
    \node[entity, below=of Sys] (Pub) {Publisher};
    
    % Flows for Student
    \draw[flow, bend left] (Stu) to node[above, sloped, font=\tiny]{Book Req} (Sys);
    \draw[flow, bend left] (Sys) to node[below, sloped, font=\tiny]{Book Details} (Stu);
    
    % Flows for Librarian
    \draw[flow, bend left] (Lib) to node[right, font=\tiny]{Issue/Return} (Sys);
    \draw[flow, bend left] (Sys) to node[left, font=\tiny]{Book Status} (Lib);
    
    % Flows for Admin
    \draw[flow, bend left] (Adm) to node[left, font=\tiny]{Manage} (Sys);
    \draw[flow, bend left] (Sys) to node[right, font=\tiny]{Reports} (Adm);
    
    % Flows for Publisher
    \draw[flow, bend left] (Pub) to node[right, font=\tiny]{Catalogs} (Sys);
    \draw[flow, bend left] (Sys) to node[left, font=\tiny]{Orders} (Pub);

\end{tikzpicture}
\captionof{figure}{Library System Context Diagram}
\end{center}

\textbf{બાહ્ય Entities:}
\begin{itemize}
    \item \keyword{Student (લાઇબ્રેરી સભ્ય)}: Inputs (Requests), Outputs (Availability)
    \item \keyword{Librarian}: Inputs (Transactions), Outputs (Book Status)
    \item \keyword{Administrator}: Inputs (Management), Outputs (Reports)
    \item \keyword{Publisher/Supplier}: Inputs (Catalogs), Outputs (Orders)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Students Librarians Admins Publishers: લાઇબ્રેરી સિસ્ટમ સાથે આંતરક્રિયા કરતા ચાર મુખ્ય બાહ્ય entities.}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{ચકાસણી અને માન્યતાને અલગ પાડો.}

\begin{solutionbox}
ચકાસણી (Verification) અને માન્યતા (Validation) એ બે પૂરક ગુણવત્તા બાંયધરી પ્રક્રિયાઓ છે જે સોફ્ટવેર requirements અને યુઝર જરૂરિયાતો પૂરી કરે તે સુનિશ્ચિત કરે છે.

\begin{center}
\captionof{table}{ચકાસણી વિ માન્યતા}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{ચકાસણી (Verification)} & \textbf{માન્યતા (Validation)} \\ \hline
\textbf{પ્રશ્ન} & શું આપણે પ્રોડક્ટ યોગ્ય રીતે બનાવી રહ્યા છીએ? & શું આપણે યોગ્ય પ્રોડક્ટ બનાવી રહ્યા છીએ? \\ \hline
\textbf{ફોકસ} & પ્રક્રિયા અને ધોરણો અનુપાલન & પ્રોડક્ટ યુઝર જરૂરિયાતો પૂરી કરે \\ \hline
\textbf{ક્યારે} & વિકાસ દરમિયાન & પ્રોડક્ટ પૂર્ણતા પછી \\ \hline
\textbf{પદ્ધતિઓ} & Reviews, inspections, walkthroughs & Testing, user acceptance \\ \hline
\textbf{ઉદ્દેશ્ય} & Specifications સાથે અનુરૂપતા સુનિશ્ચિત કરવી & ઉપયોગ માટે યોગ્યતા સુનિશ્ચિત કરવી \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Verification Verifies Process, Validation Validates Product: બંને વચ્ચેનો મુખ્ય ભેદ.}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{કોડ સમીક્ષા સમજાવો.}

\begin{solutionbox}
કોડ Review એ ખામીઓ ઓળખવા, કોડ ગુણવત્તા સુધારવા, અને કોડિંગ ધોરણોનું પાલન સુનિશ્ચિત કરવા માટે લેખક સિવાયના developers દ્વારા source code ની વ્યવસ્થિત તપાસ છે.

\begin{center}
\captionof{table}{કોડ Review ના પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વર્ણન} & \textbf{સહભાગીઓ} & \textbf{ઔપચારિકતા} \\ \hline
\textbf{Code Walkthrough} & લેખક reviewers ને કોડ સમજાવે છે & લેખક + 2-3 reviewers & અનૌપચારિક \\ \hline
\textbf{Code Inspection} & ઔપચારિક વ્યવસ્થિત તપાસ & Moderator, લેખક, reviewers & ઔપચારિક \\ \hline
\textbf{Peer Review} & સહયોગી કોડ બદલાવો review કરે છે & 1-2 peer developers & અર્ધ-ઔપચારિક \\ \hline
\textbf{Tool-Assisted Review} & Automated tools review માં મદદ કરે છે & લેખક + automated tools & ચલ \\ \hline
\end{tabulary}
\end{center}

\textbf{Review માપદંડો:}
\begin{itemize}
    \item \keyword{Functionality}: કોડ હેતુપૂર્વકની કામગીરી યોગ્ય રીતે કરે છે
    \item \keyword{ધોરણો અનુપાલન}: કોડિંગ પરંપરાઓ અને માર્ગદર્શિકાઓનું પાલન
    \item \keyword{જાળવણીક્ષમતા}: કોડ વાંચી શકાય તેવો અને સારી રીતે documented છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Reviews Reveal Errors Early: કોડ reviews testing પહેલાં ખામીઓ પકડે છે.}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{વ્હાઇટ બોક્સ ટેસ્ટિંગ પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}
વ્હાઇટ બોક્સ Testing એ સોફ્ટવેર testing તકનીક છે જે એપ્લિકેશનની આંતરિક સ્ટ્રક્ચર, ડિઝાઇન, અને કોડિંગની તપાસ કરીને input-output flow ચકાસે છે અને ડિઝાઇન અને usability સુધારે છે.

\begin{center}
\captionof{table}{વ્હાઇટ બોક્સ Testing તકનીકો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{તકનીક} & \textbf{વર્ણન} & \textbf{Coverage માપદંડ} \\ \hline
\textbf{Statement Coverage} & દરેક statement execute કરવું & બધા statements ઓછામાં ઓછા એકવાર execute \\ \hline
\textbf{Branch Coverage} & બધા decision points ટેસ્ટ કરવા & બધી branches (true/false) covered \\ \hline
\textbf{Path Coverage} & બધા શક્ય paths ટેસ્ટ કરવા & બધા independent paths execute \\ \hline
\textbf{Condition Coverage} & બધા conditions ટેસ્ટ કરવા & બધા boolean conditions ટેસ્ટ \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, every node/.style={gtu block, align=center, font=\small}]
    \node (Analysis) {Code\\Analysis};
    \node [right=of Analysis] (Design) {Test Case\\Design};
    \node [right=of Design] (Exec) {Test\\Execution};
    \node [below=of Exec] (Cov) {Coverage\\Analysis};
    \node [left=of Cov] (Report) {Report\\Generation};

    \path [gtu arrow] (Analysis) -- (Design);
    \path [gtu arrow] (Design) -- (Exec);
    \path [gtu arrow] (Exec) -- (Cov);
    \path [gtu arrow] (Cov) -- (Report);
\end{tikzpicture}
\captionof{figure}{White Box Testing Process}
\end{center}

\textbf{ફાયદાઓ:}
\begin{itemize}
    \item \keyword{સંપૂર્ણ Testing}: બધા કોડ paths અને logic ની તપાસ
    \item \keyword{પ્રારંભિક ખામી શોધ}: વિકાસ દરમિયાન ભૂલો શોધે છે
    \item \keyword{Optimization}: બિનઉપયોગી કોડ અને કાર્યક્ષમતાની ઓળખ
\end{itemize}

\textbf{વ્હાઇટ બોક્સ વિ બ્લેક બોક્સ:}
\begin{itemize}
    \item \keyword{વ્હાઇટ બોક્સ}: આંતરિક સ્ટ્રક્ચર ફોકસ, કોડ-આધારિત testing
    \item \keyword{બ્લેક બોક્સ}: Functional વર્તન ફોકસ, specification-આધારિત testing
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{White Box Sees Inside Structure: આંતરિક કોડ સ્ટ્રક્ચર testing અભિગમ.}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{વિવિધ કોડિંગ ધોરણો અને માર્ગદર્શિકાઓની યાદી બનાવો.}

\begin{solutionbox}
કોડિંગ ધોરણો અને માર્ગદર્શિકાઓ વિકાસ ટીમો અને પ્રોજેક્ટ્સમાં સુસંગત, વાંચી શકાય તેવા, અને જાળવી શકાય તેવા કોડને સુનિશ્ચિત કરે છે.

\begin{center}
\captionof{table}{કોડિંગ ધોરણોની શ્રેણીઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શ્રેણી} & \textbf{ધોરણો} & \textbf{ઉદાહરણો} \\ \hline
\textbf{નામકરણ પરંપરાઓ} & Variable, function, class નામકરણ & camelCase, PascalCase \\ \hline
\textbf{કોડ સ્ટ્રક્ચર} & Indentation, spacing, brackets & 4-space indentation \\ \hline
\textbf{Documentation} & Comments, function headers & Inline comments, API docs \\ \hline
\textbf{Error Handling} & Exception handling, logging & Try-catch blocks \\ \hline
\end{tabulary}
\end{center}

\textbf{Language-વિશિષ્ટ ધોરણો:}
\begin{itemize}
    \item \textbf{Java}: Oracle Java Code Conventions
    \item \textbf{Python}: PEP 8 Style Guide
    \item \textbf{JavaScript}: Airbnb JavaScript Style Guide
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Names Structure Documentation Errors: ચાર મુખ્ય કોડિંગ ધોરણ શ્રેણીઓ.}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{ટેસ્ટ કેસ અને ટેસ્ટ સ્યુટ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
ટેસ્ટ કેસેસ એ ચોક્કસ પરિસ્થિતિઓ છે જેના હેઠળ tester નક્કી કરે છે કે સોફ્ટવેર એપ્લિકેશન યોગ્ય રીતે કામ કરી રહી છે કે નહીં, જ્યારે ટેસ્ટ સ્યુટ એ સંબંધિત ટેસ્ટ કેસેસનો સંગ્રહ છે.

\begin{center}
\captionof{table}{ટેસ્ટ કેસ વિ ટેસ્ટ સ્યુટ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{ટેસ્ટ કેસ} & \textbf{ટેસ્ટ સ્યુટ} \\ \hline
\textbf{વ્યાખ્યા} & સિંગલ ટેસ્ટ સિનેરિયો & ટેસ્ટ કેસેસનો સંગ્રહ \\ \hline
\textbf{વ્યાપ્તિ} & ચોક્કસ functionality & સંબંધિત functionalities \\ \hline
\textbf{Execution} & વ્યક્તિગત ટેસ્ટ & જૂથ execution \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણ ટેસ્ટ કેસ:}
\begin{lstlisting}[caption={Sample ટેસ્ટ કેસ}]
ટેસ્ટ કેસ ID: TC_LOGIN_001
વર્ણન: માન્ય credentials સાથે યુઝર લોગિન ચકાસવું
Preconditions: સિસ્ટમમાં યુઝર એકાઉન્ટ અસ્તિત્વમાં છે
ટેસ્ટ પગલાં:
1. લોગિન પેજ પર navigate કરો
2. માન્ય username દાખલ કરો
3. માન્ય password દાખલ કરો
4. Login બટન ક્લિક કરો
અપેક્ષિત પરિણામ: યુઝર dashboard પર redirect થાય
\end{lstlisting}

\textbf{ટેસ્ટ સ્યુટ ઉદાહરણ:}
\begin{itemize}
    \item \keyword{લોગિન ટેસ્ટ સ્યુટ}: બધા લોગિન-સંબંધિત ટેસ્ટ કેસેસ સમાવે છે
    \item TC\_LOGIN\_001: માન્ય લોગિન
    \item TC\_LOGIN\_002: અમાન્ય username
    \item TC\_LOGIN\_003: અમાન્ય password
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Cases Test Functions, Suites Group Cases: વ્યક્તિગત વિ સંગ્રહ સંબંધ.}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{બ્લેક બોક્સ ટેસ્ટિંગ પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}
બ્લેક બોક્સ Testing એ સોફ્ટવેર testing પદ્ધતિ છે જે આંતરિક કોડ સ્ટ્રક્ચરના જ્ઞાન વિના functionality ની તપાસ કરે છે, input-output વર્તન અને requirement compliance પર ધ્યાન કેન્દ્રિત કરે છે.

\begin{center}
\captionof{table}{બ્લેક બોક્સ Testing તકનીકો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{તકનીક} & \textbf{વર્ણન} & \textbf{એપ્લિકેશન} \\ \hline
\textbf{Equivalence Partitioning} & Inputs ને સમકક્ષ જૂથોમાં વિભાજિત કરવા & Input validation testing \\ \hline
\textbf{Boundary Value Analysis} & Edge values અને boundaries ટેસ્ટ કરવા & Range અને limit testing \\ \hline
\textbf{Decision Table Testing} & Conditions ના combinations ટેસ્ટ કરવા & જટિલ બિઝનેસ logic \\ \hline
\textbf{State Transition Testing} & State બદલાવો ટેસ્ટ કરવા & Workflow અને status testing \\ \hline
\textbf{Use Case Testing} & યુઝર scenarios ટેસ્ટ કરવા & End-to-end functionality \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto, every node/.style={gtu block, align=center, font=\small}]
    \node (Req) {Requirement\\Analysis};
    \node [right=of Req] (Design) {Test Case\\Design};
    \node [right=of Design] (Prep) {Test Data\\Preparation};
    \node [below=of Prep] (Exec) {Test\\Execution};
    \node [left=of Exec] (Res) {Result\\Analysis};

    \path [gtu arrow] (Req) -- (Design);
    \path [gtu arrow] (Design) -- (Prep);
    \path [gtu arrow] (Prep) -- (Exec);
    \path [gtu arrow] (Exec) -- (Res);
\end{tikzpicture}
\captionof{figure}{Black Box Testing Process}
\end{center}

\textbf{ફાયદાઓ:}
\begin{itemize}
    \item \keyword{યુઝર પરિપ્રેક્ષ્ય}: End-user દૃષ્ટિકોણથી ટેસ્ટ કરે છે
    \item \keyword{કોડ જ્ઞાનની જરૂર નહીં}: Testers ને programming skills ની જરૂર નથી
    \item \keyword{નિષ્પક્ષ Testing}: કોડ implementation દ્વારા પ્રભાવિત નથી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Black Box Behavior Based: આંતરિક જ્ઞાન વિના બાહ્ય functionality પર ધ્યાન.}
\end{mnemonicbox}

\end{document}
