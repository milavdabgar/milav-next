\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331604 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{સોફ્ટવેર એન્જિનિયરિંગ layered approach સમજાવો.}

\begin{solutionbox}

સોફ્ટવેર એન્જિનિયરિંગ એક layered approach અપનાવે છે જેમાં ચાર મુખ્ય layers હોય છે જે
ગુણવત્તાયુક્ત સોફ્ટવેર પ્રોડક્ટ બનાવવા માટે સાથે કામ કરે છે.

\textbf{ટેબલ: સોફ્ટવેર એન્જિનિયરિંગ Layered Approach}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3810}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Layer
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Quality Focus} & સતત સુધારા પર ભાર મૂકતું foundation layer &
ખામી-મુક્ત પ્રોડક્ટ્સ બનાવવા \\
\textbf{Process} & પ્રવૃત્તિઓ અને કાર્યોનું framework & વ્યવસ્થિત વિકાસ પ્રક્રિયા
પૂરી પાડવી \\
\textbf{Methods} & વિશ્લેષણ, ડિઝાઇન, કોડિંગ, ટેસ્ટિંગ માટે તકનીકી પ્રક્રિયાઓ &
``કેવી રીતે કરવું'' તે માર્ગદર્શન આપવું \\
\textbf{Tools} & Process અને methods માટે automated support & કાર્યક્ષમતા અને
સુસંગતતા પૂરી પાડવી \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Quality Focus}: ગ્રાહક સંતોષ સુનિશ્ચિત કરતું foundation બનાવે છે
\item
  \textbf{Process Layer}: કાર્યપ્રવાહ અને પ્રોજેક્ટ મેનેજમેન્ટ પ્રવૃત્તિઓ વ્યાખ્યાયિત
  કરે છે
\item
  \textbf{Methods Layer}: દરેક વિકાસ તબક્કા માટે તકનીકી અભિગમ પૂરો પાડે છે
\item
  \textbf{Tools Layer}: ઓટોમેશન અને integration ને સપોર્ટ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Quality Processes Make Tools'' - નીચેથી ઉપર સુધીના
ચાર layers યાદ રાખો.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{Iterative Waterfall model સમજાવો.}

\begin{solutionbox}

Iterative Waterfall Model એ waterfall ની structured approach અને સુધારા અને
ભૂલ સુધારણા માટે feedback loops ને જોડે છે.

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Requirements Analysis] {-{-}{} B[System Design]}
    B {-{-}{} C[Implementation]}
    C {-{-}{} D[Integration \& Testing]}
    D {-{-}{} E[Deployment]}
    E {-{-}{} F[Maintenance]}
    B {-.{-}{}|Feedback| A}
    C {-.{-}{}|Feedback| B}
    D {-.{-}{}|Feedback| C}
    E {-.{-}{}|Feedback| D}
    F {-.{-}{}|Feedback| E}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{ક્રમિક તબક્કાઓ}: દરેક તબક્કો પૂર્ણ થયા પછી આગળનો શરૂ થાય છે
\item
  \textbf{Feedback loops}: અગાઉના તબક્કાઓમાં પાછા જવાની મંજૂરી આપે છે
\item
  \textbf{Documentation driven}: દરેક તબક્કામાં documentation પર ભારે ભાર
\item
  \textbf{ભૂલ સુધારણા}: પછીના તબક્કાઓમાં ઓળખાયેલી સમસ્યાઓ સુધારી શકાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Water Falls Back Up'' - ઉપરની તરફ feedback ક્ષમતા
સાથે sequential flow.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{Agile મોડેલ અને Agile Principles સમજાવો.}

\begin{solutionbox}

Agile એ iterative સોફ્ટવેર ડેવલપમેન્ટ methodology છે જે સહયોગ, ગ્રાહક feedback,
અને કાર્યશીલ સોફ્ટવેરની ઝડપી delivery પર ભાર મૂકે છે.

\textbf{ટેબલ: Agile Values વિ Traditional Approach}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Agile Values & Traditional Approach \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
વ્યક્તિઓ અને આંતરક્રિયાઓ & પ્રક્રિયાઓ અને ટૂલ્સ \\
કાર્યશીલ સોફ્ટવેર & વ્યાપક documentation \\
ગ્રાહક સહયોગ & કરાર વાટાઘાટ \\
પરિવર્તનનો પ્રતિસાદ & યોજનાને અનુસરવી \\
\end{longtable}
}

\textbf{મુખ્ય Agile સિદ્ધાંતો:}

\begin{itemize}
\tightlist
\item
  \textbf{ગ્રાહક સંતોષ}: મૂલ્યવાન સોફ્ટવેર વહેલી અને સતત delivery
\item
  \textbf{પરિવર્તનનું સ્વાગત}: વિકાસ દરમિયાન મોડેથી આવતા બદલાવો પણ સ્વીકારવા
\item
  \textbf{વારંવાર delivery}: કાર્યશીલ સોફ્ટવેર વારંવાર deliver કરવું (મહિનાને
  બદલે અઠવાડિયાઓમાં)
\item
  \textbf{સહયોગ}: વ્યાપારિક લોકો અને developers દરરોજ સાથે કામ કરે
\item
  \textbf{પ્રેરિત વ્યક્તિઓ}: પ્રેરિત લોકોની આસપાસ પ્રોજેક્ટ્સ બનાવવા
\item
  \textbf{આમને-સામનો વાતચીત}: સંદેશાવ્યવહારની સૌથી અસરકારક પદ્ધતિ
\item
  \textbf{કાર્યશીલ સોફ્ટવેર}: પ્રગતિનું પ્રાથમિક માપદંડ
\item
  \textbf{ટકાઉ વિકાસ}: અનિશ્ચિત સમય સુધી સતત ગતિ જાળવવી
\item
  \textbf{તકનીકી ઉત્કૃષ્ટતા}: સારી ડિઝાઇન પર સતત ધ્યાન
\item
  \textbf{સરળતા}: ન કરેલા કામને વધુ મહત્ત્વ આપવાની કળા
\item
  \textbf{સ્વ-સંગઠિત ટીમો}: સ્વ-સંગઠિત ટીમોમાંથી શ્રેષ્ઠ requirements બહાર આવે છે
\item
  \textbf{નિયમિત પ્રતિબિંબ}: ટીમ વર્તનને પ્રતિબિંબિત કરે અને ગોઠવે છે
\end{itemize}

\textbf{આકૃતિ: Agile Development Cycle}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Planning] {-{-}{} B[Design]}
    B {-{-}{} C[Coding]}
    C {-{-}{} D[Testing]}
    D {-{-}{} E[Review]}
    E {-{-}{} A}
    E {-{-}{} F[Release]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}
``Customer Change Frequently Collaborates'' - મુખ્ય
agile સિદ્ધાંતો પર ધ્યાન.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1c-or-7-uxa97uxaa3}

\textbf{Scrum પર ટૂંક નોંધ લખો.}

\begin{solutionbox}

Scrum એ ટીમ સહયોગ અને iterative પ્રગતિ પર ભાર મૂકીને સોફ્ટવેર ડેવલપમેન્ટ મેનેજ કરવા
માટેનું agile framework છે.

\textbf{ટેબલ: Scrum Roles અને જવાબદારીઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1622}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3514}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4865}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Role
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
જવાબદારીઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
મુખ્ય પ્રવૃત્તિઓ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Product Owner} & પ્રોડક્ટ features અને priorities વ્યાખ્યાયિત કરે &
Product backlog મેનેજ કરે \\
\textbf{Scrum Master} & પ્રક્રિયાને સુવિધા આપે અને અવરોધો દૂર કરે & Ceremonies
આયોજિત કરે \\
\textbf{Development Team} & કાર્યશીલ સોફ્ટવેર બનાવે & સ્વ-સંગઠિત અને
cross-functional \\
\end{longtable}
}

\textbf{Scrum Events:}

\begin{itemize}
\tightlist
\item
  \textbf{Sprint}: 1-4 અઠવાડિયાનું iteration જે સંભવિત shippable product
  બનાવે
\item
  \textbf{Sprint Planning}: આગામી sprint માટે ટીમ કામની યોજના બનાવે
\item
  \textbf{Daily Scrum}: 15 મિનિટની દૈનિક synchronization બેઠક
\item
  \textbf{Sprint Review}: stakeholders ને પૂર્ણ થયેલું કામ દર્શાવવું
\item
  \textbf{Sprint Retrospective}: પ્રક્રિયા સુધારણા પર ટીમનું પ્રતિબિંબ
\end{itemize}

\textbf{Scrum Artifacts:}

\begin{itemize}
\tightlist
\item
  \textbf{Product Backlog}: features ની પ્રાથમિકતા આધારિત યાદી
\item
  \textbf{Sprint Backlog}: વર્તમાન sprint માટે પસંદ કરેલી items
\item
  \textbf{Increment}: Sprint ના અંતે કાર્યશીલ પ્રોડક્ટ
\end{itemize}

\textbf{આકૃતિ: Scrum Process Flow}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Product Backlog] {-{-}{} B[Sprint Planning]}
    B {-{-}{} C[Sprint Backlog]}
    C {-{-}{} D[Daily Scrum]}
    D {-{-}{} E[Sprint Review]}
    E {-{-}{} F[Sprint Retrospective]}
    F {-{-}{} B}
    E {-{-}{} G[Product Increment]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}
``Product Sprints Daily Reviews'' - મુખ્ય scrum
elements નો ક્રમ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{જો તમે એક word processing software બનાવી રહ્યા હોઈ તો તમે ક્યા
process model નો ઉપયોગ કરશો? તમારો જવાબ સમજાવો.}

\begin{solutionbox}

Word processing software ડેવલપમેન્ટ માટે હું \textbf{Incremental Model} ને સૌથી
યોગ્ય process model તરીકે પસંદ કરીશ.

\textbf{બચાવ:}

\begin{itemize}
\tightlist
\item
  \textbf{જટિલ functionality}: Word processors માં અસંખ્ય features છે
  (editing, formatting, spell-check) જે incrementally વિકસિત કરી શકાય
\item
  \textbf{User feedback}: પ્રારંભિક increments user testing અને feedback
  incorporation ની મંજૂરી આપે છે
\item
  \textbf{જોખમ મેનેજમેન્ટ}: મુખ્ય features પહેલા deliver, advanced features
  પછીથી ઉમેરવા
\item
  \textbf{બજાર લાભ}: બેઝિક વર્ઝન વહેલું રિલીઝ કરીને બજારમાં હાજરી મેળવી શકાય
\end{itemize}

\textbf{ડેવલપમેન્ટ Increments:}

\begin{enumerate}
\tightlist
\item
  \textbf{Increment 1}: મૂળભૂત text editing અને file operations
\item
  \textbf{Increment 2}: Formatting અને font management
\item
  \textbf{Increment 3}: Advanced features (spell-check, templates)
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Word Processing Increments User Feedback'' - જટિલ
સોફ્ટવેર માટે incremental approach યોગ્ય.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{સારા SRS ની લાક્ષણિકતાઓ સમજાવો.}

\begin{solutionbox}

સારા Software Requirements Specification (SRS) દસ્તાવેજમાં સફળ સોફ્ટવેર
ડેવલપમેન્ટ સુનિશ્ચિત કરવા માટે ચોક્કસ લાક્ષણિકતાઓ હોવી જરૂરી છે.

\textbf{ટેબલ: સારા SRS ની લાક્ષણિકતાઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4483}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2759}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2759}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લાક્ષણિકતા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
મહત્વ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સંપૂર્ણ} & બધી જરૂરી requirements ધરાવે & Scope creep અટકાવે છે \\
\textbf{સુસંગત} & કોઈ વિરોધાભાસી requirements નહીં & Implementation
confusion ટાળે છે \\
\textbf{અસ્પષ્ટતા રહિત} & સ્પષ્ટ અને ચોક્કસ ભાષા & એક જ અર્થઘટન શક્ય \\
\textbf{ચકાસી શકાય તેવું} & Requirements ટેસ્ટ કરી શકાય & Validation શક્ય
બનાવે \\
\textbf{સુધારી શકાય તેવું} & બદલવા અને જાળવવામાં સરળ & Requirement evolution ને
સપોર્ટ કરે \\
\textbf{ટ્રેસેબલ} & Requirements સ્રોતો સાથે જોડાયેલ & Impact analysis શક્ય
બનાવે \\
\end{longtable}
}

\textbf{વધારાની લાક્ષણિકતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{શક્ય}: તકનીકી અને આર્થિક રીતે સાધ્ય
\item
  \textbf{જરૂરી}: દરેક requirement નો હેતુ હોય
\item
  \textbf{પ્રાથમિકતા આપેલ}: Requirements મહત્વ પ્રમાણે ક્રમાંકિત
\item
  \textbf{ટેસ્ટ કરી શકાય તેવું}: ચકાસણી માટે ચોક્કસ માપદંડો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Complete Consistent Unambiguous Verifiable'' - મુખ્ય
SRS ગુણવત્તા લક્ષણો.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{ATM software માટે functional અને non-functional requirements
સમજાવો.}

\begin{solutionbox}

ATM software requirements ને functional (સિસ્ટમ શું કરે છે) અને non-functional
(સિસ્ટમ કેવી રીતે perform કરે છે) requirements માં વર્ગીકૃત કરવામાં આવે છે.

\textbf{ટેબલ: ATM Functional Requirements}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3571}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{પ્રમાણીકરણ} & યુઝર લોગિન અને ચકાસણી & PIN validation, card
reading \\
\textbf{એકાઉન્ટ ઓપરેશન્સ} & મૂળભૂત બેંકિંગ વ્યવહારો & બેલેન્સ પૂછપરછ, રોકડ ઉપાડ \\
\textbf{Transaction Processing} & પૈસા ટ્રાન્સફર અને જમા & એકાઉન્ટ-ટુ-એકાઉન્ટ
ટ્રાન્સફર \\
\textbf{Receipt Generation} & વ્યવહાર documentation & Transaction
receipts પ્રિન્ટ કરવી \\
\textbf{Session Management} & યુઝર session નિયંત્રણ & Timeout, logout
functionality \\
\end{longtable}
}

\textbf{ટેબલ: ATM Non-Functional Requirements}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
શ્રેણી & Requirement & સ્પેસિફિકેશન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Performance} & Response time & પ્રતિ transaction મહત્તમ 3 સેકન્ડ \\
\textbf{Security} & ડેટા સુરક્ષા & બધા ડેટા માટે 256-bit encryption \\
\textbf{Reliability} & સિસ્ટમ ઉપલબ્ધતા & 99.9\% uptime requirement \\
\textbf{Usability} & યુઝર interface & બધી ઉંમરના લોકો માટે સરળ interface \\
\textbf{Scalability} & લોડ હેન્ડલિંગ & 1000 concurrent users ને સપોર્ટ \\
\end{longtable}
}

\textbf{Functional Requirements વિગતો:}

\begin{itemize}
\tightlist
\item
  \textbf{રોકડ ઉપાડ}: સફળ પ્રમાણીકરણ પછી રોકડ આપવી
\item
  \textbf{બેલેન્સ પૂછપરછ}: વર્તમાન એકાઉન્ટ બેલેન્સ દર્શાવવું
\item
  \textbf{PIN બદલવી}: યુઝર્સને તેમની PIN અપડેટ કરવાની મંજૂરી
\item
  \textbf{મિની સ્ટેટમેન્ટ}: છેલ્લા 10 transactions પૂરા પાડવા
\end{itemize}

\textbf{Non-Functional Requirements વિગતો:}

\begin{itemize}
\tightlist
\item
  \textbf{સુરક્ષા}: Multi-factor authentication, transaction logging
\item
  \textbf{Performance}: ઝડપી transaction processing, ન્યૂનતમ રાહ જોવાનો
  સમય
\item
  \textbf{ઉપલબ્ધતા}: ન્યૂનતમ downtime સાથે 24/7 ઓપરેશન
\item
  \textbf{જાળવણીક્ષમતા}: સરળ software updates અને hardware maintenance
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Functions Work, Quality Matters'' - Functional વિ
non-functional ભેદ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2a-or-3-uxa97uxaa3}

\textbf{આકૃતિ સાથે Incremental Model સમજાવો.}

\begin{solutionbox}

Incremental Model એ સોફ્ટવેરને increments તરીકે ઓળખાતા નાના, મેનેજ કરી શકાય
તેવા ભાગોમાં વિકસિત કરે છે, જેમાં દરેક increment હાલની સિસ્ટમમાં નવી
functionality ઉમેરે છે.

\textbf{આકૃતિ: Incremental Model}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Requirements] {-{-}{} B[Increment 1]}
    A {-{-}{} C[Increment 2]}
    A {-{-}{} D[Increment 3]}
    
    B {-{-}{} B1[Analysis]}
    B1 {-{-}{} B2[Design]}
    B2 {-{-}{} B3[Code]}
    B3 {-{-}{} B4[Test]}
    B4 {-{-}{} B5[Release 1]}
    
    C {-{-}{} C1[Analysis]}
    C1 {-{-}{} C2[Design]}
    C2 {-{-}{} C3[Code]}
    C3 {-{-}{} C4[Test]}
    C4 {-{-}{} C5[Release 2]}
    
    D {-{-}{} D1[Analysis]}
    D1 {-{-}{} D2[Design]}
    D2 {-{-}{} D3[Code]}
    D3 {-{-}{} D4[Test]}
    D4 {-{-}{} D5[Final Release]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{સમાંતર વિકાસ}: અનેક increments એક સાથે વિકસિત
\item
  \textbf{પ્રારંભિક delivery}: પ્રથમ increment પછી કાર્યશીલ સોફ્ટવેર ઉપલબ્ધ
\item
  \textbf{જોખમ ઘટાડો}: મુખ્ય functionality પહેલા deliver
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Increments Build Upon Previous'' - દરેક increment
હાલની functionality પર ઉમેરે છે.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2b-or-4-uxa97uxaa3}

\textbf{Functional અને non-functional requirements નો તફાવત સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Functional વિ Non-Functional Requirements}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1034}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4138}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4828}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Functional Requirements
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Non-Functional Requirements
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{વ્યાખ્યા} & સિસ્ટમ શું કરે છે & સિસ્ટમ કેવી રીતે perform કરે છે \\
\textbf{ફોકસ} & સિસ્ટમ વર્તન અને features & સિસ્ટમ ગુણવત્તા લક્ષણો \\
\textbf{ટેસ્ટિંગ} & Black-box testing & Performance અને stress testing \\
\textbf{Documentation} & Use cases, user stories & Quality metrics,
constraints \\
\textbf{ઉદાહરણો} & Login, search, calculate & Speed, security,
usability \\
\textbf{ચકાસણી} & Functional testing & Non-functional testing \\
\textbf{બદલાવની અસર} & Feature modification & Performance tuning \\
\textbf{યુઝર દૃશ્યતા} & યુઝર્સને સીધી દેખાય છે & પરોક્ષ રીતે અનુભવાય છે \\
\end{longtable}
}

\textbf{Functional Requirements લાક્ષણિકતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{વર્તન-કેન્દ્રિત}: સિસ્ટમ ક્રિયાઓ અને પ્રતિસાદો વ્યાખ્યાયિત કરે
\item
  \textbf{Feature-વિશિષ્ટ}: દરેક requirement ચોક્કસ ક્ષમતા વર્ણવે છે
\item
  \textbf{યુઝર-સંચાલિત}: યુઝર જરૂરિયાતો અને બિઝનેસ પ્રક્રિયાઓ પર આધારિત
\end{itemize}

\textbf{Non-Functional Requirements લાક્ષણિકતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ગુણવત્તા-કેન્દ્રિત}: Performance અને ગુણવત્તા ધોરણો વ્યાખ્યાયિત કરે
\item
  \textbf{સિસ્ટમ-વ્યાપી}: ચોક્કસ features ને બદલે સમગ્ર સિસ્ટમ પર લાગુ પડે
\item
  \textbf{અવરોધ-સંચાલિત}: સિસ્ટમ ઓપરેશન માટે મર્યાદાઓ અને બાઉન્ડરીઝ સેટ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Functions Do, Quality Shows'' - Functional
requirements ક્રિયાઓ વ્યાખ્યાયિત કરે, non-functional ગુણવત્તા વ્યાખ્યાયિત કરે.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2c-or-7-uxa97uxaa3}

\textbf{Requirements Analysis પર ટૂંક નોંધ લખો.}

\begin{solutionbox}

Requirements Analysis એ યુઝર જરૂરિયાતોનો અભ્યાસ કરવાની અને સોફ્ટવેર સિસ્ટમે શું
સિદ્ધ કરવું જોઈએ તે સમજવા માટે સિસ્ટમ requirements વ્યાખ્યાયિત કરવાની પ્રક્રિયા છે.

\textbf{ટેબલ: Requirements Analysis Process}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3529}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4118}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
તબક્કો
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પ્રવૃત્તિઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Deliverables
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Elicitation} & Stakeholders પાસેથી requirements ભેગી કરવી &
Requirement lists, interviews \\
\textbf{Analysis} & Requirements નો અભ્યાસ અને સમજ & Requirement models,
prototypes \\
\textbf{Specification} & Requirements ને ઔપચારિક રીતે document કરવી & SRS
document, use cases \\
\textbf{Validation} & Requirements ની શુદ્ધતા ચકાસવી & Validated
requirements \\
\end{longtable}
}

\textbf{Requirements Elicitation તકનીકો:}

\begin{itemize}
\tightlist
\item
  \textbf{Interviews}: Stakeholders સાથે એક-નાસીક ચર્ચા
\item
  \textbf{Questionnaires}: મોટા યુઝર ગ્રૂપ માટે structured surveys
\item
  \textbf{Observation}: હાલની કાર્ય પ્રક્રિયાઓનો અભ્યાસ
\item
  \textbf{Workshops}: Requirement gathering માટે જૂથ સત્રો
\item
  \textbf{Prototyping}: Feedback માટે પ્રારંભિક વર્ઝન બનાવવા
\end{itemize}

\textbf{Analysis પ્રવૃત્તિઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Requirement prioritization}: મહત્વ પ્રમાણે requirements ને રેંક કરવી
\item
  \textbf{Feasibility study}: તકનીકી અને આર્થિક વ્યવહાર્યતાનું મૂલ્યાંકન
\item
  \textbf{Conflict resolution}: વિરોધાભાસી requirements ને ઉકેલવી
\item
  \textbf{Requirement modeling}: દ્રશ્ય પ્રતિનિધિત્વો બનાવવા
\end{itemize}

\textbf{Validation તકનીકો:}

\begin{itemize}
\tightlist
\item
  \textbf{Requirement reviews}: Documented requirements ની ઔપચારિક તપાસ
\item
  \textbf{Prototyping}: સમજણીને validate કરવા માટે models બનાવવા
\item
  \textbf{Test case generation}: Requirements પરથી ટેસ્ટ્સ બનાવવા
\end{itemize}

\textbf{Requirements Analysis માં પડકારો:}

\begin{itemize}
\tightlist
\item
  \textbf{બદલાતી requirements}: Stakeholder જરૂરિયાતો સમય સાથે વિકસિત થાય
  છે
\item
  \textbf{સંદેશાવ્યવહાર ગેપ}: યુઝર્સ અને developers વચ્ચે ગેરસમજ
\item
  \textbf{અધૂરી requirements}: ગુમ અથવા અસ્પષ્ટ વર્ણનો
\item
  \textbf{વિરોધાભાસી stakeholder જરૂરિયાતો}: અલગ યુઝર ગ્રૂપોની અલગ
  પ્રાથમિકતાઓ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Every Analysis Specification Validates'' -
Requirements analysis ના મુખ્ય તબક્કાઓ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{Gantt Chart સમજાવો.}

\begin{solutionbox}

Gantt Chart એ દૃશ્ય પ્રોજેક્ટ મેનેજમેન્ટ ટૂલ છે જે timeline સામે પ્રોજેક્ટ કાર્યો દર્શાવે
છે, task duration, dependencies, અને પ્રગતિ બતાવે છે.

\textbf{ટેબલ: Gantt Chart ઘટકો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & વર્ણન & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Tasks} & ઊભી રીતે સૂચિબદ્ધ પ્રોજેક્ટ પ્રવૃત્તિઓ & કાર્ય વિભાજન દર્શાવે \\
\textbf{Timeline} & આડું સમય માપદંડ & પ્રોજેક્ટ અવધિ દર્શાવે \\
\textbf{Bars} & Task duration દર્શાવતા આડા બાર્સ & દૃશ્ય task પ્રતિનિધિત્વ \\
\textbf{Dependencies} & સંબંધિત tasks ને જોડતી લાઇનો & Task સંબંધો દર્શાવે \\
\textbf{Milestones} & મુખ્ય પ્રોજેક્ટ checkpoints & મહત્વપૂર્ણ ઇવેન્ટ્સ માર્ક કરે \\
\end{longtable}
}

\textbf{આકૃતિ: Sample Gantt Chart}

\begin{verbatim}
Task Name       | Week 1 | Week 2 | Week 3 | Week 4 |
Requirements    |████████|        |        |        |
Design          |        |████████|████████|        |
Coding          |        |        |████████|████████|
Testing         |        |        |        |████████|
\end{verbatim}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{દૃશ્ય સ્પષ્ટતા}: પ્રોજેક્ટ timeline સમજવામાં સરળ
\item
  \textbf{પ્રગતિ ટ્રેકિંગ}: પૂર્ણ વિ બાકી કામ દર્શાવે છે
\item
  \textbf{સંસાધન આયોજન}: સંસાધનો અસરકારક રીતે ફાળવવામાં મદદ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Gantt Graphs Timeline Tasks'' - પ્રોજેક્ટ tasks નું દૃશ્ય
timeline પ્રતિનિધિત્વ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{સંક્ષિપ્તમાં લખો: સોફ્ટવેર પ્રોજેક્ટ મેનેજરની જવાબદારીઓ અને કુશળતા.}

\begin{solutionbox}

સોફ્ટવેર પ્રોજેક્ટ મેનેજર સમગ્ર સોફ્ટવેર ડેવલપમેન્ટ lifecycle ની દેખરેખ રાખે છે, પ્રોજેક્ટ્સ
સમયસર, બજેટમાં, અને ગુણવત્તા ધોરણો પૂરા કરીને પૂર્ણ થાય તે સુનિશ્ચિત કરે છે.

\textbf{ટેબલ: પ્રોજેક્ટ મેનેજર જવાબદારીઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1842}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3421}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4737}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શ્રેણી
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
જવાબદારીઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
મુખ્ય પ્રવૃત્તિઓ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{આયોજન} & પ્રોજેક્ટ scope અને timeline વ્યાખ્યા & WBS બનાવટ, શેડ્યુલિંગ \\
\textbf{સંસાધન મેનેજમેન્ટ} & ટીમ ફાળવણી અને સંકલન & સ્ટાફ assignment, skill
matching \\
\textbf{જોખમ મેનેજમેન્ટ} & પ્રોજેક્ટ જોખમો ઓળખવા અને ઘટાડવા & જોખમ મૂલ્યાંકન,
contingency આયોજન \\
\textbf{સંદેશાવ્યવહાર} & Stakeholder સંકલન & સ્થિતિ રિપોર્ટિંગ, બેઠકો \\
\textbf{ગુણવત્તા બાંયધરી} & Deliverable ગુણવત્તા સુનિશ્ચિત કરવી & સમીક્ષા
પ્રક્રિયાઓ, ધોરણો \\
\end{longtable}
}

\textbf{આવશ્યક કુશળતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{તકનીકી કુશળતાઓ}: સોફ્ટવેર ડેવલપમેન્ટ પ્રક્રિયાઓની સમજ
\item
  \textbf{નેતૃત્વ કુશળતાઓ}: ટીમ પ્રેરણા અને માર્ગદર્શન
\item
  \textbf{સંદેશાવ્યવહાર કુશળતાઓ}: અસરકારક stakeholder આંતરક્રિયા
\item
  \textbf{સમસ્યા-નિરાકરણ કુશળતાઓ}: ઝડપી મુદ્દા નિરાકરણ
\item
  \textbf{સમય મેનેજમેન્ટ}: કાર્યક્ષમ કાર્ય પ્રાથમિકતા
\end{itemize}

\textbf{મુખ્ય જવાબદારીઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રોજેક્ટ આયોજન}: Scope, timeline, અને સંસાધનો વ્યાખ્યાયિત કરવા
\item
  \textbf{ટીમ સંકલન}: ડેવલપમેન્ટ ટીમ પ્રવૃત્તિઓ મેનેજ કરવી
\item
  \textbf{Stakeholder મેનેજમેન્ટ}: ક્લાઇન્ટ અને sponsor સંબંધો જાળવવા
\item
  \textbf{જોખમ ઘટાડો}: સંભવિત સમસ્યાઓ ઓળખવી અને સંબોધવી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Managers Plan Resources Risks Communication'' -
પ્રોજેક્ટ મેનેજર્સની મુખ્ય જવાબદારીઓ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{Risk Management પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}

Risk Management એ સોફ્ટવેર ડેવલપમેન્ટની સફળતાને અસર કરી શકે તેવા પ્રોજેક્ટ જોખમોને
ઓળખવા, વિશ્લેષણ કરવા, અને તેનો પ્રતિસાદ આપવાની વ્યવસ્થિત પ્રક્રિયા છે.

\textbf{ટેબલ: Risk Management Process}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1795}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3077}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2821}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
તબક્કો
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પ્રવૃત્તિઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
તકનીકો
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પરિણામો
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Risk Identification} & સંભવિત જોખમો શોધવા & Brainstorming,
checklists & Risk register \\
\textbf{Risk Analysis} & સંભાવના અને અસરનું મૂલ્યાંકન & Risk matrices, scoring
& પ્રાથમિકતા આપેલા જોખમો \\
\textbf{Risk Planning} & પ્રતિસાદ વ્યૂહરચના વિકસિત કરવી & Mitigation,
avoidance & Risk response plans \\
\textbf{Risk Monitoring} & જોખમોને ટ્રેક અને કંટ્રોલ કરવા & નિયમિત સમીક્ષાઓ &
અપડેટેડ જોખમ સ્થિતિ \\
\end{longtable}
}

\textbf{સોફ્ટવેર પ્રોજેક્ટ જોખમોના પ્રકારો:}

\textbf{તકનીકી જોખમો:}

\begin{itemize}
\tightlist
\item
  \textbf{ટેકનોલોજી અનિશ્ચિતતા}: નવી અથવા અપ્રમાણિત ટેકનોલોજીઓ
\item
  \textbf{Performance મુદ્દાઓ}: સિસ્ટમ performance requirements પૂરા ન કરવા
\item
  \textbf{Integration સમસ્યાઓ}: સિસ્ટમ ઘટકોને જોડવામાં મુશ્કેલી
\end{itemize}

\textbf{પ્રોજેક્ટ જોખમો:}

\begin{itemize}
\tightlist
\item
  \textbf{શેડ્યુલ વિલંબ}: કાર્યો અંદાજ કરતાં વધારે સમય લેવા
\item
  \textbf{સંસાધન અવરોધો}: અપૂરતા સ્ટાફ અથવા બજેટ
\item
  \textbf{Scope creep}: અનિયંત્રિત requirement બદલાવો
\end{itemize}

\textbf{બિઝનેસ જોખમો:}

\begin{itemize}
\tightlist
\item
  \textbf{બજાર બદલાવો}: બદલાતી બિઝનેસ requirements
\item
  \textbf{સ્પર્ધા}: સ્પર્ધાત્મક પ્રોડક્ટ્સ પ્રોજેક્ટ મૂલ્યને અસર કરવા
\item
  \textbf{નિયમનકારી બદલાવો}: નવી compliance requirements
\end{itemize}

\textbf{Risk પ્રતિસાદ વ્યૂહરચનાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Risk Avoidance}: પ્રોજેક્ટ અભિગમ બદલીને જોખમ દૂર કરવું
\item
  \textbf{Risk Mitigation}: જોખમની સંભાવના અથવા અસર ઘટાડવી
\item
  \textbf{Risk Transfer}: ત્રીજા પક્ષને જોખમ હસ્તાંતરિત કરવું (વીમો, આઉટસોર્સિંગ)
\item
  \textbf{Risk Acceptance}: જોખમ સ્વીકારવું અને contingency યોજનાઓ વિકસિત
  કરવી
\end{itemize}

\textbf{Risk Monitoring તકનીકો:}

\begin{itemize}
\tightlist
\item
  \textbf{નિયમિત જોખમ સમીક્ષાઓ}: જોખમ સ્થિતિનું સામયિક મૂલ્યાંકન
\item
  \textbf{Risk metrics}: જોખમ exposure ના માત્રાત્મક માપદંડો
\item
  \textbf{પ્રારંભિક ચેતવણી સૂચકાંકો}: ઉભરતા જોખમોના સંકેતો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Identify Analyze Plan Monitor'' - જોખમ મેનેજમેન્ટ
પ્રક્રિયાના ચાર તબક્કાઓ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3a-or-3-uxa97uxaa3}

\textbf{ઉદાહરણ સાથે WBS સમજાવો.}

\begin{solutionbox}

Work Breakdown Structure (WBS) એ પ્રોજેક્ટ કાર્યનું હાયરાર્કિકલ વિઘટન છે જે નાના,
મેનેજ કરી શકાય તેવા ઘટકોમાં વિભાજિત થાય છે જેનો સરળતાથી અંદાજ, અસાઇનમેન્ટ, અને
ટ્રેકિંગ થઈ શકે.

\textbf{આકૃતિ: E-commerce Website માટે WBS ઉદાહરણ}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[E{-commerce Website] {-}{-}{} B[Frontend Development]}
    A {-{-}{} C[Backend Development]}
    A {-{-}{} D[Testing]}
    A {-{-}{} E[Deployment]}
    
    B {-{-}{} B1[User Interface]}
    B {-{-}{} B2[Shopping Cart]}
    B {-{-}{} B3[Payment Gateway]}
    
    C {-{-}{} C1[Database Design]}
    C {-{-}{} C2[User Management]}
    C {-{-}{} C3[Order Processing]}
    
    D {-{-}{} D1[Unit Testing]}
    D {-{-}{} D2[Integration Testing]}
    D {-{-}{} D3[User Acceptance Testing]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{WBS લાક્ષણિકતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{હાયરાર્કિકલ સ્ટ્રક્ચર}: પ્રોજેક્ટ scope નું ટોપ-ડાઉન વિભાજન
\item
  \textbf{100\% નિયમ}: WBS માં પ્રોજેક્ટ scope દ્વારા વ્યાખ્યાયિત 100\% કાર્ય
  સામેલ
\item
  \textbf{પરસ્પર વિશિષ્ટ}: WBS ઘટકો વચ્ચે કોઈ ઓવરલેપ નહીં
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Work Breaks Small'' - કાર્યને નાના મેનેજ કરી શકાય તેવા
ટુકડાઓમાં તોડવું.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3b-or-4-uxa97uxaa3}

\textbf{પ્રોજેક્ટ મોનિટરિંગ અને નિયંત્રણ સમજાવો.}

\begin{solutionbox}

પ્રોજેક્ટ મોનિટરિંગ અને કંટ્રોલમાં પ્રોજેક્ટ પ્રગતિને ટ્રેક કરવું, આયોજિત performance સામે
વાસ્તવિક performance ની તુલના કરવી, અને જરૂર પડે ત્યારે સુધારાત્મક પગલાં લેવાનો
સમાવેશ થાય છે.

\textbf{ટેબલ: મોનિટરિંગ અને કંટ્રોલ પ્રવૃત્તિઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3030}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2424}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4545}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રવૃત્તિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ટૂલ્સ/તકનીકો
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{પ્રગતિ ટ્રેકિંગ} & Task completion મોનિટર કરવું & Gantt charts,
dashboards \\
\textbf{Performance માપણ} & વાસ્તવિક વિ આયોજિત તુલના & Earned value
analysis \\
\textbf{ગુણવત્તા નિયંત્રણ} & Deliverable ગુણવત્તા સુનિશ્ચિત કરવી & Reviews,
testing \\
\textbf{જોખમ મોનિટરિંગ} & ઓળખાયેલા જોખમોને ટ્રેક કરવા & Risk registers,
reports \\
\textbf{બદલાવ નિયંત્રણ} & Scope બદલાવો મેનેજ કરવા & Change request
process \\
\end{longtable}
}

\textbf{મુખ્ય મોનિટરિંગ મેટ્રિક્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{શેડ્યુલ performance}: સમયસર પૂર્ણ થયેલા tasks
\item
  \textbf{ખર્ચ performance}: બજેટ ઉપયોગ અને variance
\item
  \textbf{ગુણવત્તા મેટ્રિક્સ}: ખામી દરો, ગ્રાહક સંતોષ
\item
  \textbf{સંસાધન ઉપયોગ}: ટીમ ઉત્પાદકતા અને કાર્યક્ષમતા
\end{itemize}

\textbf{કંટ્રોલ ક્રિયાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{સુધારાત્મક ક્રિયાઓ}: Performance વિચલનોને સંબોધવા
\item
  \textbf{નિવારક ક્રિયાઓ}: સંભવિત સમસ્યાઓ ટાળવા
\item
  \textbf{બદલાવ મેનેજમેન્ટ}: Scope મોડિફિકેશન હેન્ડલ કરવું
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Monitor Progress Performance Quality'' - પ્રોજેક્ટ
મોનિટરિંગના મુખ્ય ક્ષેત્રો.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3c-or-7-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે Critical Path Method (CPM) સમજાવો.}

\begin{solutionbox}

Critical Path Method (CPM) એ પ્રોજેક્ટ મેનેજમેન્ટ તકનીક છે જે dependent tasks નો
સૌથી લાંબો ક્રમ ઓળખે છે અને ન્યૂનતમ પ્રોજેક્ટ પૂર્ણતા સમય નક્કી કરે છે.

\textbf{ટેબલ: Sample પ્રોજેક્ટ Tasks}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Task & અવધિ (દિવસો) & Predecessors \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A - Requirements & 5 & - \\
B - Design & 8 & A \\
C - Database Setup & 6 & A \\
D - Frontend Coding & 10 & B \\
E - Backend Coding & 12 & B, C \\
F - Integration & 4 & D, E \\
G - Testing & 6 & F \\
\end{longtable}
}

\textbf{આકૃતિ: CPM Network}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[A:5] {-{-}{} B[B:8]}
    A {-{-}{} C[C:6]}
    B {-{-}{} D[D:10]}
    B {-{-}{} E[E:12]}
    C {-{-}{} E}
    D {-{-}{} F[F:4]}
    E {-{-}{} F}
    F {-{-}{} G[G:6]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Critical Path ગણતરી:}

\begin{itemize}
\tightlist
\item
  \textbf{Path 1}: A \rightarrow B \rightarrow D \rightarrow F \rightarrow G = 5 + 8 + 10 + 4 + 6 = 33 દિવસ
\item
  \textbf{Path 2}: A \rightarrow B \rightarrow E \rightarrow F \rightarrow G = 5 + 8 + 12 + 4 + 6 = 35 દિવસ
  (Critical Path)
\item
  \textbf{Path 3}: A \rightarrow C \rightarrow E \rightarrow F \rightarrow G = 5 + 6 + 12 + 4 + 6 = 33 દિવસ
\end{itemize}

\textbf{CPM ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રોજેક્ટ અવધિ}: ન્યૂનતમ પૂર્ણતા સમય નક્કી કરે છે
\item
  \textbf{Critical પ્રવૃત્તિઓ}: Tasks ઓળખે છે જે વિલંબિત થઈ શકતા નથી
\item
  \textbf{Float ગણતરી}: Non-critical tasks માટે ઉપલબ્ધ slack time દર્શાવે છે
\item
  \textbf{સંસાધન ઑપ્ટિમાઇઝેશન}: સંસાધનો કાર્યક્ષમ રીતે ફાળવવામાં મદદ કરે છે
\end{itemize}

\textbf{CPM પગલાં:}

\begin{enumerate}
\tightlist
\item
  \textbf{પ્રવૃત્તિ ઓળખ}: બધી પ્રોજેક્ટ પ્રવૃત્તિઓની યાદી બનાવવી
\item
  \textbf{Dependency mapping}: Task સંબંધો નક્કી કરવા
\item
  \textbf{અવધિ અંદાજ}: દરેક પ્રવૃત્તિ માટે સમયનો અંદાજ
\item
  \textbf{Network બાંધકામ}: પ્રોજેક્ટ network diagram બનાવવું
\item
  \textbf{Critical path ગણતરી}: Network દ્વારા સૌથી લાંબો path શોધવો
\end{enumerate}

\textbf{Float પ્રકારો:}

\begin{itemize}
\tightlist
\item
  \textbf{Total Float}: પ્રોજેક્ટ પૂર્ણતાને અસર કર્યા વિના મહત્તમ વિલંબ
\item
  \textbf{Free Float}: Successor પ્રવૃત્તિઓને અસર કર્યા વિના વિલંબ
\item
  \textbf{Independent Float}: Predecessors અથવા successors ને અસર કર્યા
  વિના વિલંબ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Critical Paths Minimize Project Duration'' - CPM
ન્યૂનતમ સમય નક્કી કરતો સૌથી લાંબો path શોધે છે.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{ડિઝાઇન પ્રવૃત્તિઓના વર્ગીકરણ પર નોંધ લખો.}

\begin{solutionbox}

સોફ્ટવેર ડિઝાઇન પ્રવૃત્તિઓને ડિઝાઇન પ્રક્રિયાને વ્યવસ્થિત કરવા અને વ્યાપક સિસ્ટમ
ડેવલપમેન્ટ સુનિશ્ચિત કરવા માટે વ્યવસ્થિત રીતે વર્ગીકૃત કરવામાં આવે છે.

\textbf{ટેબલ: ડિઝાઇન પ્રવૃત્તિઓનું વર્ગીકરણ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3429}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
વર્ગીકરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પ્રવૃત્તિઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ફોકસ ક્ષેત્ર
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Architectural Design} & સિસ્ટમ સ્ટ્રક્ચર, ઘટકો & ઉચ્ચ-સ્તરીય સંગઠન \\
\textbf{Interface Design} & યુઝર interface, સિસ્ટમ interfaces &
Interaction design \\
\textbf{Component Design} & Module વિગતો, algorithms & નીચલા-સ્તરીય
implementation \\
\textbf{Data Design} & Database, data structures & ડેટા સંગઠન \\
\end{longtable}
}

\textbf{ડિઝાઇન પ્રવૃત્તિ સ્તરો:}

\begin{itemize}
\tightlist
\item
  \textbf{સિસ્ટમ લેવલ}: સમગ્ર સિસ્ટમ આર્કિટેક્ચર અને મુખ્ય ઘટકો
\item
  \textbf{Subsystem લેવલ}: વ્યક્તિગત subsystem ડિઝાઇન અને interfaces
\item
  \textbf{Component લેવલ}: વિગતવાર module ડિઝાઇન અને algorithms
\end{itemize}

\textbf{ડિઝાઇન અભિગમો:}

\begin{itemize}
\tightlist
\item
  \textbf{Top-down design}: ઉચ્ચ-સ્તરથી શરૂ કરીને decompose કરવું
\item
  \textbf{Bottom-up design}: વ્યક્તિગત ઘટકોથી ઉપરની તરફ બિલ્ડ કરવું
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Architects Interface Components Data'' - ચાર મુખ્ય
ડિઝાઇન પ્રવૃત્તિ વર્ગીકરણો.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{કપલિંગ વ્યાખ્યાયિત કરો. તેનું વર્ગીકરણ સમજાવો.}

\begin{solutionbox}

Coupling એ સોફ્ટવેર modules વચ્ચેની આંતરનિર્ભરતાની ડિગ્રીનો ઉલ્લેખ કરે છે. ઓછું
coupling વધુ maintainable અને લવચીક કોડ સાથે બહેતર સોફ્ટવેર ડિઝાઇન દર્શાવે છે.

\textbf{ટેબલ: Coupling ના પ્રકારો (ઢીલાથી કડકા સુધી)}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4706}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2941}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Coupling પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Data Coupling} & Modules parameters દ્વારા વાતચીત કરે & સરળ
parameters સાથે function calls \\
\textbf{Stamp Coupling} & Modules composite data structure શેર કરે &
Parameter તરીકે record/structure પાસ કરવું \\
\textbf{Control Coupling} & એક module બીજાના execution ને કંટ્રોલ કરે &
Control flags પાસ કરવા \\
\textbf{External Coupling} & Modules બાહ્ય format પર આધાર રાખે & Shared
file format અથવા protocol \\
\textbf{Common Coupling} & Modules global data શેર કરે & Global variables
એક્સેસ \\
\textbf{Content Coupling} & એક module બીજાના data ને modify કરે & બીજા
module ના data ને સીધો એક્સેસ \\
\end{longtable}
}

\textbf{Coupling લાક્ષણિકતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Data coupling}: શ્રેષ્ઠ પ્રકાર - ન્યૂનતમ આંતરનિર્ભરતા
\item
  \textbf{Stamp coupling}: સ્વીકાર્ય - shared data structures
\item
  \textbf{Control coupling}: મધ્યમ - control માહિતી પાસ કરવી
\item
  \textbf{Content coupling}: સૌથી ખરાબ પ્રકાર - ઉચ્ચ આંતરનિર્ભરતા
\end{itemize}

\textbf{Loose Coupling ના ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{જાળવણીક્ષમતા}: વ્યક્તિગત modules ને modify કરવું સરળ
\item
  \textbf{પુનઃઉપયોગિતા}: Modules અલગ contexts માં ઉપયોગ કરી શકાય
\item
  \textbf{ટેસ્ટેબિલિટી}: Modules સ્વતંત્ર રીતે ટેસ્ટ કરી શકાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Data Stamp Control External Common Content'' -
ઢીલાથી કડક સુધીના coupling પ્રકારો.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{Online shopping web application માટે use-case ડાયાગ્રામ દોરો.}

\begin{solutionbox}

Use case diagram એ actors અને સિસ્ટમ સાથેની તેમની આંતરક્રિયાઓ દર્શાવીને online
shopping સિસ્ટમની functional requirements બતાવે છે.

\textbf{આકૃતિ: Online Shopping Use Case Diagram}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    Customer((Customer))
    Admin((Admin))
    PaymentSystem((Payment System))
    
    Customer {-{-}{} UC1[Browse Products]}
    Customer {-{-}{} UC2[Search Products]}
    Customer {-{-}{} UC3[Add to Cart]}
    Customer {-{-}{} UC4[View Cart]}
    Customer {-{-}{} UC5[Checkout]}
    Customer {-{-}{} UC6[Make Payment]}
    Customer {-{-}{} UC7[Track Order]}
    Customer {-{-}{} UC8[Register Account]}
    Customer {-{-}{} UC9[Login/Logout]}
    Customer {-{-}{} UC10[View Order History]}
    
    Admin {-{-}{} UC11[Manage Products]}
    Admin {-{-}{} UC12[Manage Categories]}
    Admin {-{-}{} UC13[Process Orders]}
    Admin {-{-}{} UC14[Generate Reports]}
    Admin {-{-}{} UC15[Manage Users]}
    
    UC6 {-{-}{} PaymentSystem}
    
    UC5 {-.{-}{}|includes| UC3}
    UC5 {-.{-}{}|includes| UC6}
    UC11 {-.{-}{}|extends| UC16[Update Inventory]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{મુખ્ય Use Cases સમજાવ્યા:}

\textbf{Customer Use Cases:}

\begin{itemize}
\tightlist
\item
  \textbf{Browse Products}: શ્રેણી પ્રમાણે ઉપલબ્ધ products જોવા
\item
  \textbf{Search Products}: keywords વાપરીને ચોક્કસ products શોધવા
\item
  \textbf{Shopping Cart}: Cart items ઉમેરવા, દૂર કરવા, અને modify કરવા
\item
  \textbf{Checkout Process}: shipping વિગતો સાથે ખરીદી પૂર્ણ કરવી
\item
  \textbf{Payment Processing}: સુરક્ષિત payment transactions હેન્ડલ કરવા
\item
  \textbf{Order Management}: Orders ટ્રેક કરવા અને ખરીદી history જોવા
\end{itemize}

\textbf{Admin Use Cases:}

\begin{itemize}
\tightlist
\item
  \textbf{Product Management}: Products અને categories ઉમેરવા, edit કરવા,
  delete કરવા
\item
  \textbf{Order Processing}: Order fulfillment અને shipping મેનેજ કરવું
\item
  \textbf{User Management}: Customer accounts અને permissions હેન્ડલ કરવા
\item
  \textbf{Reporting}: Sales અને inventory reports જનરેટ કરવા
\end{itemize}

\textbf{સિસ્ટમ સંબંધો:}

\begin{itemize}
\tightlist
\item
  \textbf{Include}: ફરજિયાત sub-use cases (checkout માં payment include)
\item
  \textbf{Extend}: વૈકલ્પિક extensions (inventory update product
  management ને extend કરે)
\item
  \textbf{Inheritance}: વિશિષ્ટ actor વર્તણૂકો
\end{itemize}

\textbf{Actors:}

\begin{itemize}
\tightlist
\item
  \textbf{Primary Actors}: Customer, Admin (use cases શરૂ કરે છે)
\item
  \textbf{Secondary Actors}: Payment System (સિસ્ટમ requests ને જવાબ આપે છે)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Customers Browse Buy, Admins Manage Monitor'' -
મુખ્ય use case શ્રેણીઓ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4a-or-3-uxa97uxaa3}

\textbf{સારા UI ના લક્ષણો સમજાવો.}

\begin{solutionbox}

સારી User Interface (UI) ડિઝાઇન intuitive અને user-friendly ડિઝાઇન
સિદ્ધાંતો દ્વારા સોફ્ટવેર સિસ્ટમ્સ સાથે અસરકારક યુઝર interaction સુનિશ્ચિત કરે છે.

\textbf{ટેબલ: સારા UI ની લાક્ષણિકતાઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4194}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2581}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3226}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લાક્ષણિકતા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સુસંગતતા} & એપ્લિકેશન દરમિયાન એકરૂપ ડિઝાઇન & સમગ્રમાં સમાન button
styles \\
\textbf{સરળતા} & સમજવા અને ઉપયોગ કરવામાં સરળ & ન્યૂનતમ, સ્વચ્છ interface \\
\textbf{દૃશ્યતા} & મહત્વપૂર્ણ ઘટકો સ્પષ્ટ રીતે દેખાય & મુખ્ય ક્રિયાઓ અગ્રણી રીતે
પ્રદર્શિત \\
\textbf{Feedback} & યુઝર ક્રિયાઓનો સિસ્ટમ પ્રતિસાદ & Progress bars,
confirmations \\
\textbf{ભૂલ અટકાવણ} & યુઝર ભૂલો અટકાવે છે & Input validation,
confirmations \\
\textbf{લવચીકતા} & અલગ યુઝર જરૂરિયાતોને સમાવે છે & Customizable interfaces \\
\end{longtable}
}

\textbf{UI ડિઝાઇન સિદ્ધાંતો:}

\begin{itemize}
\tightlist
\item
  \textbf{યુઝર-કેન્દ્રિત}: યુઝર જરૂરિયાતો અને લક્ષ્યો પર કેન્દ્રિત ડિઝાઇન
\item
  \textbf{પહોંચિયાત}: અલગ ક્ષમતાઓ ધરાવતા લોકો દ્વારા ઉપયોગ્ય
\item
  \textbf{કાર્યક્ષમતા}: કાર્યો પૂર્ણ કરવા માટે પગલાં ઘટાડે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Consistent Simple Visible Feedback'' - મુખ્ય UI
ડિઝાઇન લાક્ષણિકતાઓ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4b-or-4-uxa97uxaa3}

\textbf{Cohesion વ્યાખ્યાયિત કરો. તેનું વર્ગીકરણ સમજાવો.}

\begin{solutionbox}

Cohesion એ સિંગલ module ની જવાબદારીઓ કેટલી નજીકથી સંબંધિત અને કેન્દ્રિત છે તેનો
ઉલ્લેખ કરે છે. ઉચ્ચ cohesion સંબંધિત functionality સાથે સારી રીતે ડિઝાઇન કરેલા
modules દર્શાવે છે.

\textbf{ટેબલ: Cohesion ના પ્રકારો (નબળાથી મજબૂત સુધી)}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4706}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2941}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Cohesion પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Coincidental} & ઘટકો મનસ્વી રીતે જૂથબદ્ધ & અસંબંધિત functions સાથે
utility module \\
\textbf{Logical} & ઘટકો સમાન તાર્કિક functions કરે & બધા input/output
operations \\
\textbf{Temporal} & ઘટકો એક જ સમયે execute થાય & સિસ્ટમ initialization
module \\
\textbf{Procedural} & ઘટકો ચોક્કસ sequence અનુસરે & Sequential processing
steps \\
\textbf{Communicational} & ઘટકો સમાન data પર operate કરે & સમાન record પર
process કરતું module \\
\textbf{Sequential} & એક ઘટકનું output બીજાનું input બને & Data
transformation pipeline \\
\textbf{Functional} & બધા ઘટકો સિંગલ task માં ફાળો આપે & કર્મચારીનો પગાર
calculate કરવો \\
\end{longtable}
}

\textbf{Cohesion લાક્ષણિકતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Functional cohesion}: શ્રેષ્ઠ પ્રકાર - સિંગલ, સારી રીતે વ્યાખ્યાયિત હેતુ
\item
  \textbf{Sequential cohesion}: સારું - module દ્વારા data flow
\item
  \textbf{Communicational cohesion}: સ્વીકાર્ય - સમાન data પર operate કરે
\item
  \textbf{Coincidental cohesion}: સૌથી ખરાબ પ્રકાર - કોઈ તાર્કિક સંબંધ નહીં
\end{itemize}

\textbf{ઉચ્ચ Cohesion ના ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{જાળવણીક્ષમતા}: સમજવા અને modify કરવામાં સરળ
\item
  \textbf{વિશ્વસનીયતા}: ભૂલો થવાની શક્યતા ઓછી
\item
  \textbf{પુનઃઉપયોગિતા}: સિંગલ-હેતુ modules વધુ પુનઃઉપયોગ્ય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Coincidental Logical Temporal Procedural
Communicational Sequential Functional'' - નબળાથી મજબૂત સુધીના cohesion
પ્રકારો.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4c-or-7-uxa97uxaa3}

\textbf{Library system માટે સંદર્ભ રેખાકૃતિ દોરો.}

\begin{solutionbox}

Context diagram લાઇબ્રેરી સિસ્ટમને સિંગલ process તરીકે તેના બાહ્ય entities અને
data flows સાથે દર્શાવે છે, સિસ્ટમ બાઉન્ડરીઝનું ઉચ્ચ-સ્તરીય દૃશ્ય પૂરું પાડે છે.

\textbf{આકૃતિ: Library System Context Diagram}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    Student((Student))
    Librarian((Librarian))
    Administrator((Administrator))
    Publisher((Publisher))
    
    LibrarySystem[Library Management System]
    
    Student {-{-}{}|Book Request| LibrarySystem}
    Student {-{-}{}|Return Request| LibrarySystem}
    LibrarySystem {-{-}{}|Book Details| Student}
    LibrarySystem {-{-}{}|Due Date Notice| Student}
    
    Librarian {-{-}{}|Issue/Return Books| LibrarySystem}
    Librarian {-{-}{}|Search Books| LibrarySystem}
    LibrarySystem {-{-}{}|Book Status| Librarian}
    LibrarySystem {-{-}{}|Member Details| Librarian}
    
    Administrator {-{-}{}|Add/Remove Books| LibrarySystem}
    Administrator {-{-}{}|Manage Members| LibrarySystem}
    LibrarySystem {-{-}{}|System Reports| Administrator}
    LibrarySystem {-{-}{}|Overdue Reports| Administrator}
    
    Publisher {-{-}{}|Book Catalog| LibrarySystem}
    LibrarySystem {-{-}{}|Purchase Orders| Publisher}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{બાહ્ય Entities:}

\textbf{Student (લાઇબ્રેરી સભ્ય):}

\begin{itemize}
\tightlist
\item
  \textbf{Inputs}: પુસ્તક શોધ requests, reservation requests, return
  notifications
\item
  \textbf{Outputs}: પુસ્તક ઉપલબ્ધતા માહિતી, due dates, fine વિગતો
\end{itemize}

\textbf{Librarian:}

\begin{itemize}
\tightlist
\item
  \textbf{Inputs}: પુસ્તક issue/return transactions, સભ્ય ચકાસણી
\item
  \textbf{Outputs}: પુસ્તક સ્થિતિ updates, સભ્ય માહિતી, transaction
  confirmations
\end{itemize}

\textbf{Administrator:}

\begin{itemize}
\tightlist
\item
  \textbf{Inputs}: નવી પુસ્તક ઉમેરણા, સભ્ય મેનેજમેન્ટ, સિસ્ટમ configuration
\item
  \textbf{Outputs}: સિસ્ટમ reports, આંકડા, overdue notifications
\end{itemize}

\textbf{Publisher/Supplier:}

\begin{itemize}
\tightlist
\item
  \textbf{Inputs}: પુસ્તક catalogs, ઉપલબ્ધતા updates
\item
  \textbf{Outputs}: ખરીદી orders, procurement requests
\end{itemize}

\textbf{Data Flows:}

\begin{itemize}
\tightlist
\item
  \textbf{પુસ્તક માહિતી}: પુસ્તકો, ઉપલબ્ધતા, સ્થાન વિશેની વિગતો
\item
  \textbf{સભ્ય ડેટા}: વિદ્યાર્થી/શિક્ષક માહિતી, ધિરાણ history
\item
  \textbf{Transaction Records}: Issue/return વિગતો, fine ગણતરીઓ
\item
  \textbf{Reports}: ઉપયોગ આંકડા, overdue યાદીઓ, inventory reports
\end{itemize}

\textbf{સિસ્ટમ Boundary:} Context diagram સ્પષ્ટ રીતે વ્યાખ્યાયિત કરે છે કે
લાઇબ્રેરી સિસ્ટમની અંદર શું છે (પુસ્તક મેનેજમેન્ટ, સભ્ય મેનેજમેન્ટ, transaction
processing) અને બહાર શું છે (બાહ્ય entities જેવા કે વિદ્યાર્થીઓ, સ્ટાફ, અને
suppliers).

\textbf{મુખ્ય Data Stores (સિસ્ટમની અંદરના):}

\begin{itemize}
\tightlist
\item
  પુસ્તક catalog database
\item
  સભ્ય માહિતી database
\item
  Transaction history database
\item
  Fine અને payment records
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Students Librarians Admins Publishers'' - લાઇબ્રેરી
સિસ્ટમ સાથે આંતરક્રિયા કરતા ચાર મુખ્ય બાહ્ય entities.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{ચકાસણી અને માન્યતાને અલગ પાડો.}

\begin{solutionbox}

ચકાસણી (Verification) અને માન્યતા (Validation) એ બે પૂરક ગુણવત્તા બાંયધરી
પ્રક્રિયાઓ છે જે સોફ્ટવેર requirements અને યુઝર જરૂરિયાતો પૂરી કરે તે સુનિશ્ચિત કરે છે.

\textbf{ટેબલ: ચકાસણી વિ માન્યતા}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1224}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4490}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4286}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ચકાસણી (Verification)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
માન્યતા (Validation)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{પ્રશ્ન} & શું આપણે પ્રોડક્ટ યોગ્ય રીતે બનાવી રહ્યા છીએ? & શું આપણે યોગ્ય
પ્રોડક્ટ બનાવી રહ્યા છીએ? \\
\textbf{ફોકસ} & પ્રક્રિયા અને ધોરણો અનુપાલન & પ્રોડક્ટ યુઝર જરૂરિયાતો પૂરી કરે \\
\textbf{ક્યારે} & વિકાસ દરમિયાન & પ્રોડક્ટ પૂર્ણતા પછી \\
\textbf{પદ્ધતિઓ} & Reviews, inspections, walkthroughs & Testing, user
acceptance \\
\textbf{ખર્ચ} & ખામી શોધની ઓછી કિંમત & વધારે કિંમત પરંતુ આવશ્યક \\
\textbf{ઉદ્દેશ્ય} & Specifications સાથે અનુરૂપતા સુનિશ્ચિત કરવી & ઉપયોગ માટે
યોગ્યતા સુનિશ્ચિત કરવી \\
\end{longtable}
}

\textbf{ચકાસણી પ્રવૃત્તિઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{કોડ reviews}: કોડિંગ ધોરણો સામે કોડ ચકાસવો
\item
  \textbf{ડિઝાઇન reviews}: ડિઝાઇન requirements પૂરી કરે છે તે સુનિશ્ચિત કરવું
\item
  \textbf{દસ્તાવેજ reviews}: Documentation પૂર્ણતા ચકાસવી
\end{itemize}

\textbf{માન્યતા પ્રવૃત્તિઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{સિસ્ટમ testing}: સંપૂર્ણ integrated સિસ્ટમનું testing
\item
  \textbf{યુઝર acceptance testing}: End-user દ્વારા functionality ની
  માન્યતા
\item
  \textbf{Performance testing}: સિસ્ટમ performance requirements ની માન્યતા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Verification Verifies Process, Validation
Validates Product'' - બંને વચ્ચેનો મુખ્ય ભેદ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{કોડ સમીક્ષા સમજાવો.}

\begin{solutionbox}

કોડ Review એ ખામીઓ ઓળખવા, કોડ ગુણવત્તા સુધારવા, અને કોડિંગ ધોરણોનું પાલન
સુનિશ્ચિત કરવા માટે લેખક સિવાયના developers દ્વારા source code ની વ્યવસ્થિત
તપાસ છે.

\textbf{ટેબલ: કોડ Review ના પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2286}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3143}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સહભાગીઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઔપચારિકતા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Code Walkthrough} & લેખક reviewers ને કોડ સમજાવે છે & લેખક + 2-3
reviewers & અનૌપચારિક \\
\textbf{Code Inspection} & ઔપચારિક વ્યવસ્થિત તપાસ & Moderator, લેખક,
reviewers & ઔપચારિક \\
\textbf{Peer Review} & સહયોગી કોડ બદલાવો review કરે છે & 1-2 peer
developers & અર્ધ-ઔપચારિક \\
\textbf{Tool-Assisted Review} & Automated tools review માં મદદ કરે છે & લેખક
+ automated tools & ચલ \\
\end{longtable}
}

\textbf{કોડ Review પ્રક્રિયા:}

\begin{enumerate}
\tightlist
\item
  \textbf{તૈયારી}: લેખક કોડ અને documentation તૈયાર કરે છે
\item
  \textbf{Review બેઠક}: ટીમ કોડની વ્યવસ્થિત તપાસ કરે છે
\item
  \textbf{ખામી Logging}: મુદ્દાઓ અને સુધારાઓ દસ્તાવેજિત કરવામાં આવે છે
\item
  \textbf{Follow-up}: લેખક ઓળખાયેલા મુદ્દાઓનું નિરાકરણ કરે છે
\item
  \textbf{Re-review}: જરૂર પડે તો fixes ની ચકાસણી
\end{enumerate}

\textbf{Review માપદંડો:}

\begin{itemize}
\tightlist
\item
  \textbf{Functionality}: કોડ હેતુપૂર્વકની કામગીરી યોગ્ય રીતે કરે છે
\item
  \textbf{ધોરણો અનુપાલન}: કોડિંગ પરંપરાઓ અને માર્ગદર્શિકાઓનું પાલન
\item
  \textbf{જાળવણીક્ષમતા}: કોડ વાંચી શકાય તેવો અને સારી રીતે documented છે
\item
  \textbf{Performance}: કાર્યક્ષમ algorithms અને સંસાધન ઉપયોગ
\end{itemize}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ખામી શોધ}: testing પહેલાં bugs અને મુદ્દાઓની પ્રારંભિક ઓળખ
\item
  \textbf{જ્ઞાન શેરિંગ}: ટીમ એકબીજાના કોડમાંથી શીખે છે
\item
  \textbf{ગુણવત્તા સુધારો}: ટીમ દરમિયાન સુસંગત કોડિંગ ધોરણો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Reviews Reveal Errors Early'' - કોડ reviews
testing પહેલાં ખામીઓ પકડે છે.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{વ્હાઇટ બોક્સ ટેસ્ટિંગ પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}

વ્હાઇટ બોક્સ Testing એ સોફ્ટવેર testing તકનીક છે જે એપ્લિકેશનની આંતરિક સ્ટ્રક્ચર,
ડિઝાઇન, અને કોડિંગની તપાસ કરીને input-output flow ચકાસે છે અને ડિઝાઇન અને
usability સુધારે છે.

\textbf{ટેબલ: વ્હાઇટ બોક્સ Testing તકનીકો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5294}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
તકનીક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Coverage માપદંડ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Statement Coverage} & દરેક statement execute કરવું & બધા statements
ઓછામાં ઓછા એકવાર execute \\
\textbf{Branch Coverage} & બધા decision points ટેસ્ટ કરવા & બધી branches
(true/false) covered \\
\textbf{Path Coverage} & બધા શક્ય paths ટેસ્ટ કરવા & બધા independent paths
execute \\
\textbf{Condition Coverage} & બધા conditions ટેસ્ટ કરવા & બધા boolean
conditions ટેસ્ટ \\
\end{longtable}
}

\textbf{વ્હાઇટ બોક્સ Testing પ્રક્રિયા:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Code Analysis] {-{-}{} B[Test Case Design]}
    B {-{-}{} C[Test Execution]}
    C {-{-}{} D[Coverage Analysis]}
    D {-{-}{} E[Report Generation]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Coverage પ્રકારો સમજાવ્યા:}

\textbf{Statement Coverage:}

\begin{itemize}
\tightlist
\item
  દરેક કોડ લાઇન ઓછામાં ઓછી એકવાર execute થાય તે સુનિશ્ચિત કરે
\item
  Formula: (Statements Executed / Total Statements) \times 100
\item
  Testing ની ન્યૂનતમ આવશ્યક સ્તર
\end{itemize}

\textbf{Branch Coverage:}

\begin{itemize}
\tightlist
\item
  બધા decision points (if-else, switch-case) ટેસ્ટ કરે છે
\item
  true અને false બંને conditions ટેસ્ટ થાય તે સુનિશ્ચિત કરે
\item
  Statement coverage કરતાં વધુ સંપૂર્ણ
\end{itemize}

\textbf{Path Coverage:}

\begin{itemize}
\tightlist
\item
  કોડ દ્વારા બધા શક્ય execution paths ટેસ્ટ કરે છે
\item
  સૌથી વ્યાપક પરંતુ જટિલ programs માટે અવારનવાર અવ્યવહારુ
\item
  Paths નક્કી કરવા માટે cyclomatic complexity વાપરે છે
\end{itemize}

\textbf{Condition Coverage:}

\begin{itemize}
\tightlist
\item
  બધા boolean sub-expressions વ્યક્તિગત રીતે ટેસ્ટ કરે છે
\item
  દરેક condition true અને false બંનેમાં evaluate થાય તે સુનિશ્ચિત કરે
\item
  જટિલ conditional statements માટે મહત્વપૂર્ણ
\end{itemize}

\textbf{વ્હાઇટ બોક્સ Testing ટૂલ્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{Static Analysis ટૂલ્સ}: Execution વિના કોડની તપાસ
\item
  \textbf{Dynamic Analysis ટૂલ્સ}: Execution દરમિયાન કોડ monitor કરે છે
\item
  \textbf{Coverage ટૂલ્સ}: Test coverage ટકાવારી માપે છે
\item
  \textbf{Profiling ટૂલ્સ}: Performance લાક્ષણિકતાઓનું વિશ્લેષણ
\end{itemize}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{સંપૂર્ણ Testing}: બધા કોડ paths અને logic ની તપાસ
\item
  \textbf{પ્રારંભિક ખામી શોધ}: વિકાસ દરમિયાન ભૂલો શોધે છે
\item
  \textbf{Optimization}: બિનઉપયોગી કોડ અને કાર્યક્ષમતાની ઓળખ
\item
  \textbf{સુરક્ષા Testing}: સંભવિત સુરક્ષા vulnerabilities પ્રગટ કરે છે
\end{itemize}

\textbf{ગેરફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{સમય બરબાદ}: વિગતવાર કોડ જ્ઞાનની આવશ્યકતા
\item
  \textbf{મોંઘું}: કોડથી પરિચિત કુશળ testers ની જરૂર
\item
  \textbf{મર્યાદિત વ્યાપ્તિ}: Integration અને system-level મુદ્દાઓ ચૂકી શકે
\item
  \textbf{જાળવણી}: કોડ બદલાવા સાથે test cases અપડેટ કરવાની જરૂર
\end{itemize}

\textbf{વ્હાઇટ બોક્સ વિ બ્લેક બોક્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{વ્હાઇટ બોક્સ}: આંતરિક સ્ટ્રક્ચર ફોકસ, કોડ-આધારિત testing
\item
  \textbf{બ્લેક બોક્સ}: Functional વર્તન ફોકસ, specification-આધારિત testing
\item
  \textbf{પૂરક}: વ્યાપક testing માટે બંને અભિગમો જરૂરી
\end{itemize}

\textbf{Test Case ડિઝાઇન માર્ગદર્શિકાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{Boundary Testing}: Edge cases અને limits ટેસ્ટ કરવા
\item
  \textbf{Loop Testing}: Loop conditions અને iterations ચકાસવા
\item
  \textbf{Data Flow Testing}: Variable definitions અને usage ને follow
  કરવા
\item
  \textbf{Control Flow Testing}: Decision logic અને branches ટેસ્ટ કરવા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``White Box Sees Inside Structure'' - આંતરિક કોડ
સ્ટ્રક્ચર testing અભિગમ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5a-or-3-uxa97uxaa3}

\textbf{વિવિધ કોડિંગ ધોરણો અને માર્ગદર્શિકાઓની યાદી બનાવો.}

\begin{solutionbox}

કોડિંગ ધોરણો અને માર્ગદર્શિકાઓ વિકાસ ટીમો અને પ્રોજેક્ટ્સમાં સુસંગત, વાંચી શકાય તેવા,
અને જાળવી શકાય તેવા કોડને સુનિશ્ચિત કરે છે.

\textbf{ટેબલ: કોડિંગ ધોરણોની શ્રેણીઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2800}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શ્રેણી
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ધોરણો
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણો
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{નામકરણ પરંપરાઓ} & Variable, function, class નામકરણ & camelCase,
PascalCase \\
\textbf{કોડ સ્ટ્રક્ચર} & Indentation, spacing, brackets & 4-space
indentation \\
\textbf{Documentation} & Comments, function headers & Inline comments,
API docs \\
\textbf{Error Handling} & Exception handling, logging & Try-catch
blocks \\
\end{longtable}
}

\textbf{સામાન્ય કોડિંગ માર્ગદર્શિકાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{અર્થપૂર્ણ નામો}: Variable અને function નામો વર્ણનાત્મક વાપરવા
\item
  \textbf{સુસંગત indentation}: સુસંગત spacing (2 અથવા 4 spaces) વાપરવી
\item
  \textbf{કોડ comment}: જટિલ logic અને બિઝનેસ rules સમજાવવા
\item
  \textbf{Function સાઇઝ}: Functions નાના અને કેન્દ્રિત રાખવા
\item
  \textbf{Error handling}: યોગ્ય exception handling implement કરવું
\end{itemize}

\textbf{Language-વિશિષ્ટ ધોરણો:}

\begin{itemize}
\tightlist
\item
  \textbf{Java}: Oracle Java Code Conventions
\item
  \textbf{Python}: PEP 8 Style Guide
\item
  \textbf{JavaScript}: Airbnb JavaScript Style Guide
\item
  \textbf{C++}: Google C++ Style Guide
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Names Structure Documentation Errors'' - ચાર મુખ્ય
કોડિંગ ધોરણ શ્રેણીઓ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5b-or-4-uxa97uxaa3}

\textbf{ટેસ્ટ કેસ અને ટેસ્ટ સ્યુટ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

ટેસ્ટ કેસેસ એ ચોક્કસ પરિસ્થિતિઓ છે જેના હેઠળ tester નક્કી કરે છે કે સોફ્ટવેર એપ્લિકેશન
યોગ્ય રીતે કામ કરી રહી છે કે નહીં, જ્યારે ટેસ્ટ સ્યુટ એ સંબંધિત ટેસ્ટ કેસેસનો સંગ્રહ છે.

\textbf{ટેબલ: ટેસ્ટ કેસ વિ ટેસ્ટ સ્યુટ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પાસું & ટેસ્ટ કેસ & ટેસ્ટ સ્યુટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{વ્યાખ્યા} & સિંગલ ટેસ્ટ સિનેરિયો & ટેસ્ટ કેસેસનો સંગ્રહ \\
\textbf{વ્યાપ્તિ} & ચોક્કસ functionality & સંબંધિત functionalities \\
\textbf{Execution} & વ્યક્તિગત ટેસ્ટ & જૂથ execution \\
\textbf{મેનેજમેન્ટ} & સિંગલ ટેસ્ટ મેનેજમેન્ટ & Batch મેનેજમેન્ટ \\
\end{longtable}
}

\textbf{ટેસ્ટ કેસ ઘટકો:}

\begin{itemize}
\tightlist
\item
  \textbf{ટેસ્ટ કેસ ID}: અનન્ય identifier (TC\_001)
\item
  \textbf{ટેસ્ટ વર્ણન}: શું ટેસ્ટ કરવામાં આવી રહ્યું છે
\item
  \textbf{Preconditions}: સેટઅપ આવશ્યકતાઓ
\item
  \textbf{ટેસ્ટ પગલાં}: પગલાં-દર-પગલાં પ્રક્રિયા
\item
  \textbf{અપેક્ષિત પરિણામ}: અપેક્ષિત પરિણામ
\item
  \textbf{વાસ્તવિક પરિણામ}: અવલોકન કરેલ પરિણામ
\item
  \textbf{સ્થિતિ}: Pass/Fail/Blocked
\end{itemize}

\textbf{ઉદાહરણ ટેસ્ટ કેસ:}

\begin{verbatim}
ટેસ્ટ કેસ ID: TC_LOGIN_001
વર્ણન: માન્ય credentials સાથે યુઝર લોગિન ચકાસવું
Preconditions: સિસ્ટમમાં યુઝર એકાઉન્ટ અસ્તિત્વમાં છે
ટેસ્ટ પગલાં:
1. લોગિન પેજ પર navigate કરો
2. માન્ય username દાખલ કરો
3. માન્ય password દાખલ કરો
4. Login બટન ક્લિક કરો
અપેક્ષિત પરિણામ: યુઝર dashboard પર redirect થાય
વાસ્તવિક પરિણામ: [Execution દરમિયાન ભરવાનું]
સ્થિતિ: [Pass/Fail]
\end{verbatim}

\textbf{ટેસ્ટ સ્યુટ ઉદાહરણ:}

\begin{itemize}
\tightlist
\item
  \textbf{લોગિન ટેસ્ટ સ્યુટ}: બધા લોગિન-સંબંધિત ટેસ્ટ કેસેસ સમાવે છે

  \begin{itemize}
  \tightlist
  \item
    TC\_LOGIN\_001: માન્ય લોગિન
  \item
    TC\_LOGIN\_002: અમાન્ય username
  \item
    TC\_LOGIN\_003: અમાન્ય password
  \item
    TC\_LOGIN\_004: ખાલી fields
  \end{itemize}
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Cases Test Functions, Suites Group Cases'' -
વ્યક્તિગત વિ સંગ્રહ સંબંધ.

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5c-or-7-uxa97uxaa3}

\textbf{બ્લેક બોક્સ ટેસ્ટિંગ પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}

બ્લેક બોક્સ Testing એ સોફ્ટવેર testing પદ્ધતિ છે જે આંતરિક કોડ સ્ટ્રક્ચરના જ્ઞાન વિના
functionality ની તપાસ કરે છે, input-output વર્તન અને requirement compliance
પર ધ્યાન કેન્દ્રિત કરે છે.

\textbf{ટેબલ: બ્લેક બોક્સ Testing તકનીકો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2759}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2759}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4483}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
તકનીક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
એપ્લિકેશન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Equivalence Partitioning} & Inputs ને સમકક્ષ જૂથોમાં વિભાજિત કરવા &
Input validation testing \\
\textbf{Boundary Value Analysis} & Edge values અને boundaries ટેસ્ટ કરવા &
Range અને limit testing \\
\textbf{Decision Table Testing} & Conditions ના combinations ટેસ્ટ કરવા &
જટિલ બિઝનેસ logic \\
\textbf{State Transition Testing} & State બદલાવો ટેસ્ટ કરવા & Workflow અને
status testing \\
\textbf{Use Case Testing} & યુઝર scenarios ટેસ્ટ કરવા & End-to-end
functionality \\
\end{longtable}
}

\textbf{બ્લેક બોક્સ Testing પ્રક્રિયા:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Requirement Analysis] {-{-}{} B[Test Case Design]}
    B {-{-}{} C[Test Data Preparation]}
    C {-{-}{} D[Test Execution]}
    D {-{-}{} E[Result Analysis]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Testing તકનીકો સમજાવી:}

\textbf{Equivalence Partitioning:}

\begin{itemize}
\tightlist
\item
  Input domain ને સમકક્ષ data ના વર્ગોમાં વિભાજિત કરે છે
\item
  દરેક partition માંથી એક ટેસ્ટ કેસ સમગ્ર class ને પ્રતિનિધિત્વ આપે છે
\item
  Coverage જાળવતી વખતે ટેસ્ટ કેસેસની સંખ્યા ઘટાડે છે
\item
  ઉદાહરણ: ઉંમર input (0-17: નાબાલિગ, 18-65: પુખ્ત, 65+: વરિષ્ઠ)
\end{itemize}

\textbf{Boundary Value Analysis:}

\begin{itemize}
\tightlist
\item
  Equivalence partitions ની boundaries પર values ટેસ્ટ કરે છે
\item
  Edge cases પર ધ્યાન કેન્દ્રિત કરે છે જ્યાં સામાન્ય રીતે ભૂલો થાય છે
\item
  Minimum, maximum, અને boundaries ની અંદર/બહાર ટેસ્ટ કરે છે
\item
  ઉદાહરણ: Range 1-100 માટે, ટેસ્ટ: 0, 1, 2, 99, 100, 101
\end{itemize}

\textbf{Decision Table Testing:}

\begin{itemize}
\tightlist
\item
  જટિલ બિઝનેસ rules ને tabular format માં રજૂ કરે છે
\item
  Conditions અને actions ના બધા શક્ય combinations દર્શાવે છે
\item
  બિઝનેસ logic scenarios ના સંપૂર્ણ coverage ને સુનિશ્ચિત કરે છે
\item
  અનેક આંતરક્રિયા કરતી conditions વાળી સિસ્ટમ્સ માટે ઉપયોગી
\end{itemize}

\textbf{State Transition Testing:}

\begin{itemize}
\tightlist
\item
  સિસ્ટમ વર્તનને states અને transitions તરીકે model કરે છે
\item
  માન્ય અને અમાન્ય state બદલાવો ટેસ્ટ કરે છે
\item
  સિસ્ટમ state transitions યોગ્ય રીતે handle કરે છે તે ચકાસે છે
\item
  ઉદાહરણ: Order states (Pending \rightarrow Processing \rightarrow Shipped \rightarrow Delivered)
\end{itemize}

\textbf{Use Case Testing:}

\begin{itemize}
\tightlist
\item
  યુઝર scenarios અને use cases પર આધારિત
\item
  સંપૂર્ણ બિઝનેસ workflows end-to-end ટેસ્ટ કરે છે
\item
  યુઝર પરિપ્રેક્ષ્ય અને વાસ્તવિક-જગતના ઉપયોગ પર ધ્યાન કેન્દ્રિત કરે છે
\item
  સિસ્ટમ યુઝર requirements પૂરી કરે છે તે validate કરે છે
\end{itemize}

\textbf{બ્લેક બોક્સ Testing સ્તરો:}

\begin{itemize}
\tightlist
\item
  \textbf{Unit Testing}: વ્યક્તિગત component functionality
\item
  \textbf{Integration Testing}: Component interaction testing
\item
  \textbf{System Testing}: સંપૂર્ણ સિસ્ટમ functionality
\item
  \textbf{Acceptance Testing}: યુઝર requirement validation
\end{itemize}

\textbf{ફાયદાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{યુઝર પરિપ્રેક્ષ્ય}: End-user દૃષ્ટિકોણથી ટેસ્ટ કરે છે
\item
  \textbf{કોડ જ્ઞાનની જરૂર નહીં}: Testers ને programming skills ની જરૂર નથી
\item
  \textbf{નિષ્પક્ષ Testing}: કોડ implementation દ્વારા પ્રભાવિત નથી
\item
  \textbf{પ્રારંભિક Testing}: Requirements specification સાથે શરૂ કરી શકાય
\end{itemize}

\textbf{ગેરફાયદાઓ:}

\begin{itemize}
\item
  \textbf{મર્યાદિત Coverage}: આંતરિક logic ભૂલો ચૂકી શકે છે
\item
  \textbf{અકાર્યક્ષમ}: બધા શક્ય inputs ઓળખવું મુશ્કેલ
\item
  \textbf{અનાવશ્યક Testing}: ટેસ્ટ scenarios duplicate થઈ શકે છે
\item
  \textbf{અંધ Testing}: ચોક્કસ કોડ ક્ષેત્રોને target કરી શકાતું નથી
\item
  \textbf{માન્ય Inputs}: સામાન્ય ઓપરેશનલ conditions ટેસ્ટ કરવા
\item
  \textbf{અમાન્ય Inputs}: Error handling ક્ષમતાઓ ટેસ્ટ કરવા
\item
  \textbf{Edge Cases}: Boundary conditions અને limits ટેસ્ટ કરવા
\item
  \textbf{Stress Inputs}: અત્યંત conditions હેઠળ સિસ્ટમ ટેસ્ટ કરવી
\end{itemize}

\textbf{બ્લેક બોક્સ વિ વ્હાઇટ બોક્સ તુલના:}

\begin{itemize}
\tightlist
\item
  \textbf{બ્લેક બોક્સ}: બાહ્ય વર્તન, specification-આધારિત
\item
  \textbf{વ્હાઇટ બોક્સ}: આંતરિક સ્ટ્રક્ચર, કોડ-આધારિત
\item
  \textbf{ગ્રે બોક્સ}: બંને અભિગમોનું સંયોજન
\item
  \textbf{પૂરક}: સંપૂર્ણ testing માટે બંને જરૂરી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Black Box Behavior Based'' - આંતરિક જ્ઞાન વિના બાહ્ય
functionality પર ધ્યાન.

\end{mnemonicbox}

\end{document}
