\documentclass{article}
% Adjust the relative path to point to the latex-templates directory
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{Python Programming (4311601) - Summer 2024 Solution}
\date{18 જૂન, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{સમસ્યાનું નિરાકરણ વ્યાખ્યાયિત કરો અને સમસ્યા હલ કરવાના પગલાંની સૂચિ બનાવો.}

\begin{solutionbox}
સમસ્યાનું નિરાકરણ એ એક વ્યવસ્થિત પદ્ધતિ છે જે તર્કસંગત વિચારસરણી અને સંરચિત પદ્ધતિઓનો ઉપયોગ કરીને સમસ્યાઓને ઓળખવા, તેનું વિશ્લેષણ કરવા અને હલ કરવા માટે વપરાય છે.

\textbf{સમસ્યા નિરાકરણના પગલાં:}

\begin{center}
\captionof{table}{સમસ્યા નિરાકરણના પગલાં}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પગલું} & \textbf{વર્ણન} \\ \hline
1. \textbf{સમસ્યાની ઓળખ} & સમસ્યાને સ્પષ્ટપણે સમજવી અને વ્યાખ્યાયિત કરવી \\ \hline
2. \textbf{સમસ્યાનું વિશ્લેષણ} & સમસ્યાને નાના ભાગોમાં વિભાજિત કરવી \\ \hline
3. \textbf{સોલ્યુશન ડિઝાઇન} & સંભવિત ઉકેલો અથવા એલ્ગોરિધમ વિકસાવવા \\ \hline
4. \textbf{અમલીકરણ} & પસંદ કરેલા ઉકેલને અમલમાં મૂકવો \\ \hline
5. \textbf{ટેસ્ટિંગ અને વેલિડેશન} & ઉકેલ યોગ્ય રીતે કામ કરે છે તેની ખાતરી કરવી \\ \hline
6. \textbf{ડોક્યુમેન્ટેશન} & ભાવિ સંદર્ભ માટે ઉકેલને રેકોર્ડ કરવો \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{હું હંમેશા ડિઝાઇન અમલીકરણ ટેસ્ટ દૈનિક}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{વેરિએબલ વ્યાખ્યાયિત કરો અને વેરિએબલના નામ પસંદ કરવા માટેના નિયમનો ઉલ્લેખ કરો.}

\begin{solutionbox}
\textbf{વેરિએબલ}: મેમરીમાં એક નામાંકિત સ્ટોરેજ સ્થાન છે જે ડેટા વેલ્યુઝ ધરાવે છે અને પ્રોગ્રામ એક્ઝિક્યુશન દરમિયાન બદલાઈ શકે છે.

\textbf{વેરિએબલ નામકરણ નિયમો:}

\begin{center}
\captionof{table}{વેરિએબલ નામકરણ નિયમો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{નિયમ} & \textbf{વર્ણન} \\ \hline
\textbf{શરૂઆતી અક્ષર} & અક્ષર (a-z, A-Z) અથવા અન્ડરસ્કોર (\_) થી શરૂ થવું જોઈએ \\ \hline
\textbf{મંજૂર અક્ષરો} & અક્ષરો, અંકો (0-9), અને અન્ડરસ્કોર હોઈ શકે \\ \hline
\textbf{કેસ સેંસિટિવ} & \code{myVar} અને \code{MyVar} જુદા વેરિએબલ છે \\ \hline
\textbf{કોઈ કીવર્ડ્સ નહીં} & Python ના રિઝર્વ્ડ શબ્દો વાપરી શકાતા નથી (if, for, while) \\ \hline
\textbf{કોઈ સ્પેસ નહીં} & સ્પેસની જગ્યાએ અન્ડરસ્કોર વાપરો \\ \hline
\textbf{વર્ણનાત્મક નામ} & અર્થપૂર્ણ નામ પસંદ કરો (age, x નહીં) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{અક્ષરથી શરૂઆત, સાવધાનીથી ચાલુ, ક્યારેય કીવર્ડ્સ નહીં}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{આપેલ ત્રણ નંબરોમાંથી મહત્તમ સંખ્યા શોધવા માટે ફ્લોચાર્ટ ડિઝાઇન કરો.}

\begin{solutionbox}
ફ્લોચાર્ટ કમ્પેરિઝન ઓપરેશન્સ વાપરીને ત્રણ નંબરોમાંથી મહત્તમ શોધવાના તાર્કિક પ્રવાહને દર્શાવે છે.

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=1cm of start] (input) {Input: num1, num2, num3};
    \node [gtu decision, below=1cm of input] (dec1) {num1 $>$ num2?};
    
    \node [gtu decision, below left=1.5cm and 1cm of dec1] (dec2) {num1 $>$ num3?};
    \node [gtu decision, below right=1.5cm and 1cm of dec1] (dec3) {num2 $>$ num3?};
    
    \node [gtu block, below left=1.5cm and 0.5cm of dec2] (res1) {max = num1};
    \node [gtu block, below right=1.5cm and 0.5cm of dec2] (res2) {max = num3};
    
    \node [gtu block, below left=1.5cm and 0.5cm of dec3] (res3) {max = num2};
    \node [gtu block, below right=1.5cm and 0.5cm of dec3] (res4) {max = num3};
    
    \node [gtu block, below=4cm of dec1] (output) {Output: max};
    \node [gtu state, below=1cm of output] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (dec1);
    
    \path [gtu arrow] (dec1) -| node [near start] {Yes} (dec2);
    \path [gtu arrow] (dec1) -| node [near start] {No} (dec3);
    
    \path [gtu arrow] (dec2) -| node [near start] {Yes} (res1);
    \path [gtu arrow] (dec2) -| node [near start] {No} (res2);
    
    \path [gtu arrow] (dec3) -| node [near start] {Yes} (res3);
    \path [gtu arrow] (dec3) -| node [near start] {No} (res4);
    
    \path [gtu arrow] (res1) -- (output);
    \path [gtu arrow] (res2) -- (output);
    \path [gtu arrow] (res3) -- (output);
    \path [gtu arrow] (res4) -- (output);
    \path [gtu arrow] (output) -- (end);
\end{tikzpicture}
\captionof{figure}{ત્રણ નંબરોમાંથી મહત્તમ શોધવા માટે ફ્લોચાર્ટ}
\end{center}

\textbf{મુખ્ય મુદ્દાઓ:}
\begin{itemize}
    \item \keyword{ઇનપુટ}: ત્રણ નંબરો (num1, num2, num3)
    \item \keyword{પ્રોસેસ}: નેસ્ટેડ કંડિશન્સ વાપરીને નંબરોની તુલના
    \item \keyword{આઉટપુટ}: ત્રણેય વચ્ચે મહત્તમ મૂલ્ય
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{પહેલા બેની તુલના, પછી ત્રીજા સાથે}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{દાખલ કરેલ નંબર પોઝિટિવ છે અને 5 કરતા વધારે છે કે નહીં તે તપાસવા એક એલ્ગોરિધમ બનાવો.}

\begin{solutionbox}
એક નંબર પોઝિટિવ અને 5 કરતા વધારે છે કે કેમ તે ચકાસવા માટેનું એલ્ગોરિધમ.

\textbf{એલ્ગોરિધમ:}

\begin{lstlisting}
Algorithm: CheckPositiveGreaterThan5
Step 1: START
Step 2: INPUT number
Step 3: IF number > 0 AND number > 5 THEN
           PRINT "Number is positive and greater than 5"
        ELSE
           PRINT "Number does not meet criteria"
        END IF
Step 4: END
\end{lstlisting}

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=1cm of start] (input) {Input: number};
    \node [gtu decision, below=1cm of input, aspect=2.5] (dec) {number $>$ 0 AND number $>$ 5?};
    \node [gtu block, below left=1.5cm and 0.5cm of dec] (yes) {Print: Matches criteria};
    \node [gtu block, below right=1.5cm and 0.5cm of dec] (no) {Print: No match};
    \node [gtu state, below=3.5cm of dec] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (dec);
    \path [gtu arrow] (dec) -| node [near start] {Yes} (yes);
    \path [gtu arrow] (dec) -| node [near start] {No} (no);
    \path [gtu arrow] (yes) |- (end);
    \path [gtu arrow] (no) |- (end);
\end{tikzpicture}
\captionof{figure}{પોઝિટિવ અને 5 કરતા વધારે માટે ફ્લોચાર્ટ}
\end{center}

\textbf{મુખ્ય શરતો:}
\begin{itemize}
    \item \keyword{પોઝિટિવ}: number $>$ 0
    \item \keyword{5 કરતા વધારે}: number $>$ 5
    \item \keyword{સંયુક્ત}: બંને શરતો સાચી હોવી જોઈએ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{પોઝિટિવ પ્લસ પાંચ}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{એરિથમેટિક ઓપરેટરો પર શોર્ટ નોટ લખો.}

\begin{solutionbox}
એરિથમેટિક ઓપરેટરો Python પ્રોગ્રામિંગમાં ન્યુમેરિક વેલ્યુઝ પર ગાણિતિક ગણતરીઓ કરે છે.

\begin{center}
\captionof{table}{એરિથમેટિક ઓપરેટરો}
\begin{tabulary}{\linewidth}{|C|L|L|C|}
\hline
\textbf{Op} & \textbf{નામ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\ \hline
\code{+} & ઉમેરાણ & \code{5 + 3} & 8 \\ \hline
\code{-} & બાદબાકી & \code{5 - 3} & 2 \\ \hline
\code{*} & ગુણાકાર & \code{5 * 3} & 15 \\ \hline
\code{/} & ભાગાકાર & \code{5 / 3} & 1.67 \\ \hline
\code{//} & ફ્લોર ડિવિઝન & \code{5 // 3} & 1 \\ \hline
\code{\%} & મોડ્યુલસ & \code{5 \% 3} & 2 \\ \hline
\code{**} & ઘાત & \code{5 ** 3} & 125 \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ઉમેરો બાદ કરો ગુણો ભાગો ફ્લોર મોડ પાવર}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{કંટિન્યુ અને બ્રેક સ્ટેટમેંટની જરૂરિયાત સમજાવો.}

\begin{solutionbox}
કંટિન્યુ અને બ્રેક સ્ટેટમેંટ્સ કાર્યક્ષમ પ્રોગ્રામિંગ માટે લૂપ એક્ઝિક્યુશન ફ્લોને નિયંત્રિત કરે છે.

\textbf{સ્ટેટમેંટ કમ્પેરિઝન:}

\begin{center}
\captionof{table}{break vs continue}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{સ્ટેટમેંટ} & \textbf{હેતુ} & \textbf{ક્રિયા} \\ \hline
\keyword{break} & લૂપમાંથી સંપૂર્ણ બહાર નીકળવું & સંપૂર્ણ લૂપને સમાપ્ત કરે છે \\ \hline
\keyword{continue} & વર્તમાન આવૃત્તિ છોડવી & આગલી આવૃત્તિ પર જાય છે \\ \hline
\end{tabulary}
\end{center}

\textbf{વપરાશના ઉદાહરણો:}
\begin{itemize}
    \item \keyword{break}: શરત પૂરી થાય ત્યારે બહાર નીકળવું (ચોક્કસ મૂલ્ય શોધવું)
    \item \keyword{continue}: અયોગ્ય ડેટા છોડવો (પોઝિટિવ લિસ્ટમાં નેગેટિવ નંબરો)
\end{itemize}

\textbf{ફાયદાઓ:}
\begin{itemize}
    \item \keyword{કાર્યક્ષમતા}: બિનજરૂરી આવૃત્તિઓ ટાળવી
    \item \keyword{નિયંત્રણ}: પ્રોગ્રામ ફ્લોનું વધુ સારું મેનેજમેંટ
    \item \keyword{સ્પષ્ટતા}: વધુ સ્વચ્છ કોડ લોજિક
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{બ્રેક બહાર નીકળે, કંટિન્યુ છોડે}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{દાખલ કરેલ સંખ્યા સમ છે કે વિષમ છે તે તપાસવા માટે એક પ્રોગ્રામ બનાવો.}

\begin{solutionbox}
મોડ્યુલસ ઓપરેટર વાપરીને મુલ્ય સમ કે વિષમ છે તે નિર્ધારિત કરવા માટેનો Python પ્રોગ્રામ.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
# સમ કે વિષમ તપાસવા માટેનો પ્રોગ્રામ
number = int(input("એક નંબર દાખલ કરો: "))

if number % 2 == 0:
    print(f"{number} સમ છે")
else:
    print(f"{number} વિષમ છે")
\end{lstlisting}

\textbf{લોજિક સમજૂતી:}

\begin{center}
\captionof{table}{સમ vs વિષમ લોજિક}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શરત} & \textbf{પરિણામ} & \textbf{સમજૂતી} \\ \hline
\code{number \% 2 == 0} & સમ & 2 વડે વિભાજ્ય, કોઈ બાકી નહીં \\ \hline
\code{number \% 2 == 1} & વિષમ & 2 વડે વિભાજ્ય નહીં, બાકી 1 \\ \hline
\end{tabulary}
\end{center}

\textbf{સેમ્પલ આઉટપુટ:}
\begin{itemize}
    \item ઇનપુટ: 8 $\rightarrow$ આઉટપુટ: "8 સમ છે"
    \item ઇનપુટ: 7 $\rightarrow$ આઉટપુટ: "7 વિષમ છે"
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{મોડ્યુલસ શૂન્ય સમ, એક વિષમ}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{Python ના કમ્પેરિઝન ઓપરેટરોનો સારાંશ આપો.}

\begin{solutionbox}
કમ્પેરિઝન ઓપરેટરો વેલ્યુઝની તુલના કરે છે અને બુલિયન પરિણામો (True/False) આપે છે.

\begin{center}
\captionof{table}{કમ્પેરિઝન ઓપરેટરો}
\begin{tabulary}{\linewidth}{|C|L|L|C|}
\hline
\textbf{Op} & \textbf{નામ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\ \hline
\code{==} & બરાબર & \code{5 == 5} & True \\ \hline
\code{!=} & બરાબર નથી & \code{5 != 3} & True \\ \hline
\code{>} & મોટું & \code{5 > 3} & True \\ \hline
\code{<} & નાનું & \code{5 < 3} & False \\ \hline
\code{>=} & મોટું અથવા બરાબર & \code{5 >= 5} & True \\ \hline
\code{<=} & નાનું અથવા બરાબર & \code{5 <= 3} & False \\ \hline
\end{tabulary}
\end{center}

\textbf{રિટર્ન ટાઇપ:} બધા ઓપરેટરો બુલિયન વેલ્યુઝ (True/False) આપે છે
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{બરાબર નહીં મોટું નાનું મોટું-બરાબર નાનું-બરાબર}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{While લૂપ પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}
While લૂપ જ્યાં સુધી શરત સાચી રહે છે ત્યાં સુધી કોડ બ્લોકને વારંવાર એક્ઝિક્યુટ કરે છે.

\textbf{While લૂપ સ્ટ્રક્ચર:}

\begin{center}
\captionof{table}{While લૂપ ઘટકો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઘટક} & \textbf{વર્ણન} \\ \hline
\textbf{પ્રારંભિકરણ} & લૂપ પહેલાં પ્રારંભિક મૂલ્ય સેટ કરવું \\ \hline
\textbf{શરત} & તપાસવા માટેનું બુલિયન એક્સપ્રેશન \\ \hline
\textbf{બોડી} & વારંવાર એક્ઝિક્યુટ કરવાનો કોડ \\ \hline
\textbf{અપડેટ} & અનંત લૂપ ટાળવા માટે વેરિએબલ બદલવો \\ \hline
\end{tabulary}
\end{center}

\textbf{સિન્ટેક્સ:}
\begin{lstlisting}[language=Python]
while condition:
    # loop body
    # update statement
\end{lstlisting}

\textbf{લક્ષણો:}
\begin{itemize}
    \item \keyword{પ્રી-ટેસ્ટેડ}: એક્ઝિક્યુશન પહેલાં શરત તપાસાય છે
    \item \keyword{વેરિએબલ આવૃત્તિઓ}: અજાણી સંખ્યામાં પુનરાવર્તન
    \item \keyword{નિયંત્રણ}: શરત ચાલુ રાખવું નક્કી કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{જ્યારે શરત સાચી, લૂપ ચલાવો}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{યુઝર પાસેથી ત્રણ નંબરો વાંચવા અને તે નંબરોની સરેરાશ શોધવા માટે એક પ્રોગ્રામ બનાવો.}

\begin{solutionbox}
યુઝર-ઇનપુટ ત્રણ નંબરોની સરેરાશ ગણવા માટેનો Python પ્રોગ્રામ.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
# ત્રણ નંબરોની સરેરાશ શોધવા માટેનો પ્રોગ્રામ
num1 = float(input("પહેલો નંબર દાખલ કરો: "))
num2 = float(input("બીજો નંબર દાખલ કરો: "))
num3 = float(input("ત્રીજો નંબર દાખલ કરો: "))

average = (num1 + num2 + num3) / 3

print(f"{num1}, {num2}, {num3} ની સરેરાશ: {average:.2f} છે")
\end{lstlisting}

\textbf{ગણતરી પ્રક્રિયા:}
\begin{itemize}
    \item \keyword{ઇનપુટ}: ત્રણ નંબરો વાંચો
    \item \keyword{સરવાળો}: ત્રણેય નંબરો ઉમેરો
    \item \keyword{ભાગાકાર}: સરવાળો / 3
    \item \keyword{આઉટપુટ}: ફોર્મેટ કરેલ પરિણામ દર્શાવો
\end{itemize}

\textbf{સેમ્પલ એક્ઝિક્યુશન:}
\begin{itemize}
    \item ઇનપુટ: 10, 20, 30
    \item સરવાળો: 60
    \item સરેરાશ: 20.00
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ત્રણ ઉમેરો ભાગો દર્શાવો}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{કંટ્રોલ સ્ટ્રક્ચર્સ વ્યાખ્યાયિત કરો, પાયથોનમાં ઉપલબ્ધ કંટ્રોલ સ્ટ્રક્ચર્સની સૂચિ બનાવો.}

\begin{solutionbox}
કંટ્રોલ સ્ટ્રક્ચર્સ પ્રોગ્રામમાં એક્ઝિક્યુશન ફ્લો અને સ્ટેટમેંટ્સનો ક્રમ નિર્ધારિત કરે છે.

\textbf{Python કંટ્રોલ સ્ટ્રક્ચર્સ:}

\begin{center}
\captionof{table}{કંટ્રોલ સ્ટ્રક્ચર્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{સ્ટ્રક્ચર્સ} & \textbf{હેતુ} \\ \hline
\textbf{સિક્વેન્શિયલ} & સામાન્ય ફ્લો & સ્ટેટમેંટ્સ ક્રમમાં એક્ઝિક્યુટ કરવા \\ \hline
\textbf{સિલેક્શન} & if, if-else, elif & વિકલ્પો વચ્ચે પસંદગી \\ \hline
\textbf{આઇટરેશન} & for, while & કોડ બ્લોક્સનું પુનરાવર્તન \\ \hline
\textbf{જમ્પ} & break, continue, pass & સામાન્ય ફ્લો બદલવો \\ \hline
\end{tabulary}
\end{center}

\textbf{કેટેગરીઝ:}
\begin{itemize}
    \item \keyword{કંડિશનલ}: નિર્ણય લેવો (if સ્ટેટમેંટ્સ)
    \item \keyword{લૂપિંગ}: પુનરાવર્તન (for/while લૂપ્સ)
    \item \keyword{બ્રાન્ચિંગ}: ફ્લો કંટ્રોલ (break/continue)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{સિક્વેન્સ સિલેક્ટ આઇટરેટ જમ્પ}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{યુઝર ડિફાઇન્ડ ફંકશન વ્યાખ્યાયિત કરો અને કેવી રીતે યુઝર ડિફાઇન્ડ ફંકશન કૉલ કરવું તે ઉદાહરણ આપીને સમજાવો.}

\begin{solutionbox}
યુઝર-ડિફાઇન્ડ ફંકશન્સ ચોક્કસ કાર્યો કરતા પુનઃ ઉપયોગી કોડના કસ્ટમ બ્લોક્સ છે.

\textbf{ફંકશન સ્ટ્રક્ચર:}

\begin{center}
\captionof{table}{ફંકશન ઘટકો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઘટક} & \textbf{સ્ટ્રક્ચર} & \textbf{હેતુ} \\ \hline
\textbf{ડેફિનિશન} & \code{def name():} & ફંકશન બનાવવું \\ \hline
\textbf{પેરામીટર્સ} & \code{def f(p1, p2):} & ઇનપુટ્સ સ્વીકારવા \\ \hline
\textbf{બોડી} & ઇન્ડેન્ટેડ બ્લોક & ફંકશન લોજિક \\ \hline
\textbf{રિટર્ન} & \code{return val} & પરિણામ પાછું મોકલવું \\ \hline
\textbf{કૉલ} & \code{name()} & ફંકશન એક્ઝિક્યુટ કરવું \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણ કોડ:}
\begin{lstlisting}[language=Python]
# ફંકશન ડેફિનિશન
def greet_user(name):
    message = f"નમસ્તે, {name}!"
    return message

# ફંકશન કૉલ
result = greet_user("Python")
print(result)  # આઉટપુટ: નમસ્તે, Python!
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ડિફાઇન પેરામીટર્સ બોડી રિટર્ન કૉલ}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{લૂપ કોન્સેપ્ટનો ઉપયોગ કરીને નીચેની પેટર્ન દર્શાવવા માટે એક પ્રોગ્રામ બનાવો}

\begin{solutionbox}
નેસ્ટેડ લૂપ્સ વાપરીને મુલ્ય પેટર્ન બનાવવા માટેનો Python પ્રોગ્રામ.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
# પેટર્ન પ્રિન્ટિંગ પ્રોગ્રામ
for i in range(1, 6):
    for j in range(1, i + 1):
        print(i, end="")
    print()  # દરેક પંક્તિ પછી નવી લાઇન
\end{lstlisting}

\textbf{પેટર્ન લોજિક:}

\begin{center}
\captionof{table}{પેટર્ન લોજિક}
\begin{tabulary}{\linewidth}{|C|C|L|}
\hline
\textbf{પંક્તિ} & \textbf{આવૃત્તિઓ} & \textbf{આઉટપુટ} \\ \hline
1 & 1 વખત & 1 \\ \hline
2 & 2 વખત & 22 \\ \hline
3 & 3 વખત & 333 \\ \hline
4 & 4 વખત & 4444 \\ \hline
5 & 5 વખત & 55555 \\ \hline
\end{tabulary}
\end{center}

\textbf{લૂપ સ્ટ્રક્ચર:}
\begin{itemize}
    \item \keyword{બાહ્ય લૂપ}: પંક્તિઓને નિયંત્રિત કરે છે (1 થી 5)
    \item \keyword{આંતરિક લૂપ}: વર્તમાન પંક્તિ નંબર પ્રિન્ટ કરે છે
    \item \keyword{પેટર્ન}: પંક્તિ નંબર પંક્તિ વખત પુનરાવર્તિત
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{બાહ્ય પંક્તિઓ આંતરિક પુનરાવર્તન}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{યોગ્ય ઉદાહરણનો ઉપયોગ કરીને નેસ્ટેડ લૂપ સમજાવો.}

\begin{solutionbox}
નેસ્ટેડ લૂપ એ બીજા લૂપની અંદર આવેલ લૂપ છે જ્યાં દરેક બાહ્ય લૂપ આવૃત્તિ માટે આંતરિક લૂપ તેની બધી આવૃત્તિઓ પૂર્ણ કરે છે.

\textbf{નેસ્ટેડ લૂપ સ્ટ્રક્ચર:}
\begin{itemize}
    \item \keyword{બાહ્ય લૂપ}: મુખ્ય આવૃત્તિઓને નિયંત્રિત કરે છે
    \item \keyword{આંતરિક લૂપ}: દરેક બાહ્ય આવૃત્તિ માટે સંપૂર્ણ એક્ઝિક્યુટ થાય છે
    \item \keyword{એક્ઝિક્યુશન}: આંતરિક લૂપ કુલ $n \times m$ વખત ચાલે છે
\end{itemize}

\textbf{ઉદાહરણ કોડ:}
\begin{lstlisting}[language=Python]
# નેસ્ટેડ લૂપ ઉદાહરણ - ગુણાકાર કોષ્ટક
for i in range(1, 4):      # બાહ્ય લૂપ
    for j in range(1, 4):  # આંતરિક લૂપ
        print(f"{i}x{j}={i*j}", end=" ")
    print()  # નવી લાઇન
\end{lstlisting}

\textbf{આઉટપુટ પેટર્ન:}
\begin{lstlisting}
1x1=1 1x2=2 1x3=3
2x1=2 2x2=4 2x3=6
3x1=3 3x2=6 3x3=9
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{લૂપ અંદર લૂપ}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{વેરિએબલના લોકલ અને ગ્લોબલ સ્કોપ પર શોર્ટ નોંધ લખો}

\begin{solutionbox}
વેરિએબલ સ્કોપ નિર્ધારિત કરે છે કે પ્રોગ્રામમાં વેરિએબલ્સ ક્યાં એક્સેસ કરી શકાય છે.

\textbf{સ્કોપ કમ્પેરિઝન:}

\begin{center}
\captionof{table}{લોકલ vs ગ્લોબલ સ્કોપ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{સ્કોપ પ્રકાર} & \textbf{વ્યાખ્યા} & \textbf{એક્સેસ} & \textbf{જીવનકાળ} \\ \hline
\textbf{લોકલ} & ફંકશનની અંદર & ફક્ત ફંકશન & ફંકશન એક્ઝિક્યુશન \\ \hline
\textbf{ગ્લોબલ} & ફંકશન્સની બહાર & સંપૂર્ણ પ્રોગ્રામ & પ્રોગ્રામ એક્ઝિક્યુશન \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણ કોડ:}
\begin{lstlisting}[language=Python]
global_var = "હું ગ્લોબલ છું"  # ગ્લોબલ સ્કોપ

def my_function():
    local_var = "હું લોકલ છું"    # લોકલ સ્કોપ
    global global_var
    print(global_var)   # એક્સેસિબલ
    print(local_var)    # એક્સેસિબલ

print(global_var)   # એક્સેસિબલ
# print(local_var)  # એરર - એક્સેસિબલ નથી
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{લોકલ મર્યાદિત, ગ્લોબલ સામાન્ય}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{આપેલ સંખ્યાના ફેક્ટોરિયલ શોધવા માટે યુઝર ડિફાઇન્ડ ફંકશન વિકસાવો.}

\begin{solutionbox}
પોઝિટિવ પૂર્ણાંકના ફેક્ટોરિયલની ગણતરી કરવા માટેનું રિકર્સિવ ફંકશન.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
def factorial(n):
    """n નું ફેક્ટોરિયલ ગણવું"""
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

# ફંકશનને ટેસ્ટ કરવું
number = int(input("એક નંબર દાખલ કરો: "))
if number < 0:
    print("નેગેટિવ નંબરો માટે ફેક્ટોરિયલ વ્યાખ્યાયિત નથી")
else:
    result = factorial(number)
    print(f"{number} નું ફેક્ટોરિયલ {result} છે")
\end{lstlisting}

\textbf{ફેક્ટોરિયલ લોજિક:}

\begin{center}
\captionof{table}{ફેક્ટોરિયલ ગણતરી}
\begin{tabulary}{\linewidth}{|C|L|C|}
\hline
\textbf{ઇનપુટ} & \textbf{ગણતરી} & \textbf{પરિણામ} \\ \hline
0 & બેઝ કેસ & 1 \\ \hline
1 & બેઝ કેસ & 1 \\ \hline
5 & $5 \times 4 \times 3 \times 2 \times 1$ & 120 \\ \hline
\end{tabulary}
\end{center}

\textbf{ફંકશન લક્ષણો:}
\begin{itemize}
    \item \keyword{રિકર્સિવ}: ફંકશન પોતાને કૉલ કરે છે
    \item \keyword{બેઝ કેસ}: n=0 અથવા n=1 પર રિકર્શન રોકે છે
    \item \keyword{વેલિડેશન}: નેગેટિવ ઇનપુટ્સને હેન્ડલ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{બધા પાછલા નંબરોનો ગુણાકાર}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{મેથ મોડ્યુલ વિવિધ ફંકશન સાથે સમજાવો}

\begin{solutionbox}
મેથ મોડ્યુલ ન્યુમેરિકલ કોમ્પ્યુટેશન્સ માટે ગાણિતિક ફંકશન્સ અને કોન્સ્ટન્ટ્સ પ્રદાન કરે છે.

\textbf{મેથ મોડ્યુલ ફંકશન્સ:}

\begin{center}
\captionof{table}{મેથ મોડ્યુલ ફંકશન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફંકશન} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\ \hline
\code{math.sqrt()} & વર્ગમૂળ & \code{math.sqrt(16) = 4.0} \\ \hline
\code{math.pow()} & ઘાત ગણતરી & \code{math.pow(2, 3) = 8.0} \\ \hline
\code{math.ceil()} & ઉપર રાઉન્ડ & \code{math.ceil(4.3) = 5} \\ \hline
\code{math.floor()} & નીચે રાઉન્ડ & \code{math.floor(4.7) = 4} \\ \hline
\code{math.factorial()} & ફેક્ટોરિયલ & \code{math.factorial(5) = 120} \\ \hline
\end{tabulary}
\end{center}

\textbf{વપરાશ:}
\begin{lstlisting}[language=Python]
import math
result = math.sqrt(25)  # 5.0 રિટર્ન કરે છે
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{વર્ગ ઘાત સીલિંગ ફ્લોર ફેક્ટોરિયલ}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{નીચેના લિસ્ટના ફંકશનની ચર્ચા કરો: i. len() ii. sum() iii. sort() iv. index()}

\begin{solutionbox}
ડેટા મેનિપ્યુલેશન અને વિશ્લેષણ માટેના આવશ્યક લિસ્ટ ફંકશન્સ.

\textbf{લિસ્ટ ફંકશન્સ કમ્પેરિઝન:}

\begin{center}
\captionof{table}{લિસ્ટ ફંકશન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ફંકશન} & \textbf{હેતુ} & \textbf{રિટર્ન ટાઇપ} & \textbf{ઉદાહરણ} \\ \hline
\code{len()} & એલિમેન્ટ્સ ગણવા & Integer & \code{len([1,2,3]) = 3} \\ \hline
\code{sum()} & બધા નંબરોનો સરવાળો & Number & \code{sum([1,2,3]) = 6} \\ \hline
\code{sort()} & ક્રમમાં ગોઠવવું & None (લિસ્ટ બદલે છે) & \code{list.sort()} \\ \hline
\code{index()} & એલિમેન્ટની સ્થિતિ શોધવી & Integer & \code{[1,2,3].index(2) = 1} \\ \hline
\end{tabulary}
\end{center}

\textbf{વપરાશની નોંધો:}
\begin{itemize}
    \item \code{len()}: કોઈપણ સિક્વેન્સ સાથે કામ કરે છે
    \item \code{sum()}: ફક્ત ન્યુમેરિક લિસ્ટ્સ
    \item \code{sort()}: મૂળ લિસ્ટને બદલે છે
    \item \code{index()}: પ્રથમ ઓકરન્સ રિટર્ન કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{લેન્થ સમ સોર્ટ ઇન્ડેક્સ}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{0 થી N નંબરોની ફિબોનાકી શ્રેણીને છાપવા માટે યુઝર ડિફાઇન્ડ ફંકશન બનાવો. (જ્યાં N પૂર્ણાંક સંખ્યા છે અને આર્ગ્યુમેન્ટ તરીકે પસાર થાય છે)}

\begin{solutionbox}
N ટર્મ્સ સુધી ફિબોનાકી સિક્વેન્સ જનરેટ અને ડિસ્પ્લે કરવા માટેનું ફંકશન.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
def fibonacci_series(n):
    """n ટર્મ્સની ફિબોનાકી શ્રેણી પ્રિન્ટ કરવું"""
    if n <= 0:
        print("કૃપા કરીને પોઝિટિવ નંબર દાખલ કરો")
        return
    
    # પ્રથમ બે ટર્મ્સ
    a, b = 0, 1
    
    if n == 1:
        print(f"ફિબોનાકી શ્રેણી: {a}")
        return
    
    print(f"ફિબોનાકી શ્રેણી: {a}, {b}", end="")
    
    # બાકીના ટર્મ્સ જનરેટ કરવા
    for i in range(2, n):
        c = a + b
        print(f", {c}", end="")
        a, b = b, c
    print()  # નવી લાઇન

# ફંકશનને ટેસ્ટ કરવું
num = int(input("ટર્મ્સની સંખ્યા દાખલ કરો: "))
fibonacci_series(num)
\end{lstlisting}

\textbf{ફિબોનાકી લોજિક:}

\begin{center}
\captionof{table}{ફિબોનાકી શ્રેણી}
\begin{tabulary}{\linewidth}{|C|C|L|}
\hline
\textbf{ટર્મ} & \textbf{મૂલ્ય} & \textbf{ગણતરી} \\ \hline
1મી & 0 & આપેલ \\ \hline
2જી & 1 & આપેલ \\ \hline
3જી & 1 & 0 + 1 \\ \hline
4થી & 2 & 1 + 1 \\ \hline
5મી & 3 & 1 + 2 \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{પાછલા બે નંબરોનો ઉમેરો}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{રેન્ડમ મોડ્યુલ વિવિધ ફંકશન સાથે સમજાવો}

\begin{solutionbox}
રેન્ડમ મોડ્યુલ વિવિધ એપ્લિકેશન્સ માટે રેન્ડમ નંબરો જનરેટ કરે છે અને રેન્ડમ સિલેક્શન્સ કરે છે.

\textbf{રેન્ડમ મોડ્યુલ ફંકશન્સ:}

\begin{center}
\captionof{table}{રેન્ડમ મોડ્યુલ ફંકશન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફંકશન} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\ \hline
\code{random()} & 0.0 થી 1.0 ફ્લોટ & \code{random.random()} \\ \hline
\code{randint()} & રેન્જમાં ઇન્ટિજર & \code{random.randint(1, 10)} \\ \hline
\code{choice()} & રેન્ડમ લિસ્ટ એલિમેન્ટ & \code{random.choice([1,2,3])} \\ \hline
\code{shuffle()} & લિસ્ટનો ક્રમ ભેળસેળ કરવો & \code{random.shuffle(list)} \\ \hline
\code{uniform()} & રેન્જમાં ફ્લોટ & \code{random.uniform(1.0, 5.0)} \\ \hline
\end{tabulary}
\end{center}

\textbf{વપરાશ:}
\begin{lstlisting}[language=Python]
import random
number = random.randint(1, 100)
\end{lstlisting}

\textbf{એપ્લિકેશન્સ:} ગેમ્સ, સિમ્યુલેશન્સ, ટેસ્ટિંગ, ક્રિપ્ટોગ્રાફી
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{રેન્ડમ રેન્જ ચોઇસ શફલ યુનિફોર્મ}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{આપેલ એલિમેન્ટ લિસ્ટનું સભ્ય છે કે નહીં તે તપાસવા માટે પાયથોન કોડ બનાવો}

\begin{solutionbox}
મેમ્બરશિપ ઓપરેટર વાપરીને લિસ્ટમાં એલિમેન્ટ અસ્તિત્વમાં છે કે કેમ તે ચકાસવા માટેનો Python પ્રોગ્રામ.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
# લિસ્ટમાં એલિમેન્ટ મેમ્બરશિપ તપાસવું
def check_membership():
    # સેમ્પલ લિસ્ટ
    numbers = [10, 20, 30, 40, 50]
    
    # શોધવા માટેનું એલિમેન્ટ મેળવવું
    element = int(input("શોધવા માટે એલિમેન્ટ દાખલ કરો: "))
    
    # મેમ્બરશિપ તપાસવી
    if element in numbers:
        print(f"{element} લિસ્ટમાં હાજર છે")
        print(f"સ્થિતિ: {numbers.index(element)}")
    else:
        print(f"{element} લિસ્ટમાં હાજર નથી")

# ફંકશન કૉલ કરવું
check_membership()
\end{lstlisting}

\textbf{મેમ્બરશિપ મેથડ્સ:}

\begin{center}
\captionof{table}{મેમ્બરશિપ ઓપરેટરો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{મેથડ} & \textbf{સિન્ટેક્સ} & \textbf{રિટર્ન કરે છે} \\ \hline
\textbf{in ઓપરેટર} & \code{element in list} & Boolean \\ \hline
\textbf{not in ઓપરેટર} & \code{element not in list} & Boolean \\ \hline
\textbf{count() મેથડ} & \code{list.count(element)} & Integer \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{લિસ્ટમાં ટ્રુ ફોલ્સ}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{દાખલ કરેલ શબ્દમાળા શબ્દોને ઉલટાવે તે માટે યુઝર ડિફાઇન્ડ ફંકશન વિકસાવો}

\begin{solutionbox}
શબ્દની સ્થિતિ જાળવીને સ્ટ્રિંગમાં દરેક શબ્દને ઉલટાવવા માટેનું ફંકશન.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
def reverse_string_words(text):
    """સ્ટ્રિંગમાં દરેક શબ્દને ઉલટાવવું"""
    # સ્ટ્રિંગને શબ્દોમાં વિભાજિત કરવી
    words = text.split()
    
    # દરેક શબ્દને ઉલટાવવું
    reversed_words = []
    for word in words:
        reversed_word = word[::-1]  # ઉલટાવવા માટે સ્લાઇસ નોટેશન
        reversed_words.append(reversed_word)
    
    # શબ્દોને પાછા જોડવા
    result = " ".join(reversed_words)
    return result

# ફંકશનને ટેસ્ટ કરવું
input_string = input("એક સ્ટ્રિંગ દાખલ કરો: ")
output = reverse_string_words(input_string)
print(f"ઇનપુટ: \"{input_string}\"")
print(f"આઉટપુટ: \"{output}\"")

# આપેલ ઇનપુટ સાથે ઉદાહરણ
test_input = "Hello IT"
test_output = reverse_string_words(test_input)
print(f"ઇનપુટ: \"{test_input}\"")
print(f"આઉટપુટ: \"{test_output}\"")  # આઉટપુટ: "olleH TI"
\end{lstlisting}

\textbf{પ્રોસેસ સ્ટેપ્સ:}

\begin{center}
\captionof{table}{ઉલટાવવાની પ્રક્રિયા}
\begin{tabulary}{\linewidth}{|C|L|L|}
\hline
\textbf{સ્ટેપ} & \textbf{ઓપરેશન} & \textbf{ઉદાહરણ} \\ \hline
1 & શબ્દોમાં વિભાજિત કરવું & ["Hello", "IT"] \\ \hline
2 & દરેક શબ્દ ઉલટાવવો & ["olleH", "TI"] \\ \hline
3 & સ્પેસ સાથે જોડવું & "olleH TI" \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{વિભાજિત ઉલટાવો જોડો}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{આપેલ સ્ટ્રિંગની પદ્ધતિઓ સમજાવો: i. count() ii. strip() iii. replace()}

\begin{solutionbox}
ટેક્સ્ટ પ્રોસેસિંગ અને મેનિપ્યુલેશન માટેના આવશ્યક સ્ટ્રિંગ મેથડ્સ.

\textbf{સ્ટ્રિંગ મેથડ્સ કમ્પેરિઝન:}

\begin{center}
\captionof{table}{સ્ટ્રિંગ મેથડ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{મેથડ} & \textbf{હેતુ} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} \\ \hline
\code{count()} & ઓકરન્સ ગણવા & \code{str.count(sub)} & \code{"hello".count("l") = 2} \\ \hline
\code{strip()} & વ્હાઇટસ્પેસ હટાવવો & \code{str.strip()} & \code{" t ".strip() = "t"} \\ \hline
\code{replace()} & સબસ્ટ્રિંગ બદલવો & \code{str.replace(o, n)} & \code{"hi".replace("i", "ello")} \\ \hline
\end{tabulary}
\end{center}

\textbf{રિટર્ન વેલ્યુઝ:}
\begin{itemize}
    \item \keyword{count()}: ઇન્ટિજર (ઓકરન્સની સંખ્યા)
    \item \keyword{strip()}: નવી સ્ટ્રિંગ (વ્હાઇટસ્પેસ હટાવેલ)
    \item \keyword{replace()}: નવી સ્ટ્રિંગ (બદલાવ કરેલ)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ગણો સ્ટ્રિપ બદલો}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{સ્ટ્રિંગમાં કેવી રીતે ટ્રાવર્સલ કરવું તે ઉદાહરણ આપીને સમજાવો.}

\begin{solutionbox}
સ્ટ્રિંગ ટ્રાવર્સલ માનેે સ્ટ્રિંગમાં દરેક કેરેક્ટરને ક્રમિક રીતે એક્સેસ કરવું.

\textbf{ટ્રાવર્સલ મેથડ્સ:}

\begin{center}
\captionof{table}{સ્ટ્રિંગ ટ્રાવર્સલ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{મેથડ} & \textbf{સિન્ટેક્સ} & \textbf{ઉપયોગ} \\ \hline
\textbf{ઇન્ડેક્સ-બેઝ્ડ} & \code{for i in range(len(str))} & સ્થિતિ જરૂરી \\ \hline
\textbf{ડાયરેક્ટ આઇટરેશન} & \code{for char in string} & ફક્ત કેરેક્ટર્સ \\ \hline
\textbf{એન્યુમરેટ} & \code{for i, c in enumerate(str)} & ઇન્ડેક્સ અને કેરેક્ટર બંને \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણ કોડ:}
\begin{lstlisting}[language=Python]
text = "Python"

# મેથડ 1: ડાયરેક્ટ આઇટરેશન
for char in text:
    print(char, end=" ")  # P y t h o n

# મેથડ 2: ઇન્ડેક્સ-બેઝ્ડ
for i in range(len(text)):
    print(f"{i}: {text[i]}")

# મેથડ 3: એન્યુમરેટ
for index, character in enumerate(text):
    print(f"સ્થિતિ {index}: {character}")
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ડાયરેક્ટ ઇન્ડેક્સ એન્યુમરેટ}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{નીચેની આપેલ લિસ્ટના ઓપરેશન માટેના પ્રોગ્રામ વિકસાવો:}

\begin{solutionbox}
આવશ્યક લિસ્ટ ઓપરેશન્સ અને વિશ્લેષણ માટેના બે પ્રોગ્રામ્સ.

\textbf{પ્રોગ્રામ 1: એલિમેન્ટ અસ્તિત્વ તપાસવું}
\begin{lstlisting}[language=Python]
def check_element_exists(lst, element):
    """લિસ્ટમાં એલિમેન્ટ અસ્તિત્વમાં છે કે કેમ તપાસવું"""
    if element in lst:
        return True, lst.index(element)
    else:
        return False, -1

# પ્રોગ્રામ 1 ટેસ્ટ કરવું
numbers = [10, 25, 30, 45, 50]
search_item = int(input("શોધવા માટે એલિમેન્ટ દાખલ કરો: "))
exists, position = check_element_exists(numbers, search_item)

if exists:
    print(f"{search_item} સ્થિતિ {position} પર મળ્યું")
else:
    print(f"{search_item} લિસ્ટમાં નથી મળ્યું")
\end{lstlisting}

\textbf{પ્રોગ્રામ 2: સૌથી નાનું અને મોટું શોધવું}
\begin{lstlisting}[language=Python]
def find_min_max(lst):
    """સૌથી નાના અને મોટા એલિમેન્ટ્સ શોધવા"""
    if not lst:  # ખાલી લિસ્ટ તપાસવી
        return None, None
    
    smallest = min(lst)
    largest = max(lst)
    return smallest, largest

# પ્રોગ્રામ 2 ટેસ્ટ કરવું
numbers = [15, 8, 23, 4, 16, 42]
min_val, max_val = find_min_max(numbers)
print(f"લિસ્ટ: {numbers}")
print(f"સૌથી નાનું: {min_val}")
print(f"સૌથી મોટું: {max_val}")
\end{lstlisting}

\textbf{મુખ્ય ઓપરેશન્સ:}
\begin{itemize}
    \item \keyword{મેમ્બરશિપ}: 'in' ઓપરેટર વાપરવો
    \item \keyword{Min/Max}: બિલ્ટ-ઇન ફંકશન્સ
    \item \keyword{વેલિડેશન}: ખાલી લિસ્ટ હેન્ડલિંગ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{શોધો મેળવો તુલના કરો}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{લિસ્ટનું સ્લાઇસિંગ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
લિસ્ટ સ્લાઇસિંગ ઇન્ડેક્સ રેન્જ વાપરીને લિસ્ટના ચોક્કસ ભાગો કાઢે છે.

\textbf{સ્લાઇસિંગ સિન્ટેક્સ:}

\begin{center}
\captionof{table}{સ્લાઇસિંગ સિન્ટેક્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફોર્મેટ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\code{list[start:end]} & start થી end-1 સુધીના એલિમેન્ટ્સ & \code{[1,2,3,4][1:3] = [2,3]} \\ \hline
\code{list[:end]} & શરૂઆતથી end-1 સુધી & \code{[1,2,3,4][:2] = [1,2]} \\ \hline
\code{list[start:]} & start થી અંત સુધી & \code{[1,2,3,4][2:] = [3,4]} \\ \hline
\code{list[::step]} & દરેક step એલિમેન્ટ & \code{[1,2,3,4][::2] = [1,3]} \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણ:}
\begin{lstlisting}[language=Python]
numbers = [0, 1, 2, 3, 4, 5]
print(numbers[1:4])   # [1, 2, 3]
print(numbers[:3])    # [0, 1, 2]
print(numbers[3:])    # [3, 4, 5]
print(numbers[::2])   # [0, 2, 4]
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{શરૂઆત અંત સ્ટેપ}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{લિસ્ટમાં કેવી રીતે ટ્રાવર્સલ કરવું તે ઉદાહરણ આપીને સમજાવો.}

\begin{solutionbox}
લિસ્ટ ટ્રાવર્સલમાં લિસ્ટમાં દરેક એલિમેન્ટને વ્યવસ્થિત રીતે એક્સેસ કરવાનો સમાવેશ થાય છે.

\textbf{ટ્રાવર્સલ ટેકનિક્સ:}

\begin{center}
\captionof{table}{લિસ્ટ ટ્રાવર્સલ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{મેથડ} & \textbf{સિન્ટેક્સ} & \textbf{આઉટપુટ ટાઇપ} \\ \hline
\textbf{વેલ્યુ આઇટરેશન} & \code{for item in list} & ફક્ત એલિમેન્ટ્સ \\ \hline
\textbf{ઇન્ડેક્સ આઇટરેશન} & \code{for i in range(len(list))} & ઇન્ડેક્સ એક્સેસ \\ \hline
\textbf{એન્યુમરેટ} & \code{for i, v in enumerate(list)} & ઇન્ડેક્સ અને વેલ્યુ \\ \hline
\end{tabulary}
\end{center}

\textbf{ઉદાહરણ કોડ:}
\begin{lstlisting}[language=Python]
fruits = ["સફરજન", "કેળું", "નારંગી"]

# મેથડ 1: ડાયરેક્ટ વેલ્યુ એક્સેસ
print("ફક્ત વેલ્યુઝ:")
for fruit in fruits:
    print(fruit)

# મેથડ 2: ઇન્ડેક્સ-બેઝ્ડ એક્સેસ
print("\nઇન્ડેક્સ સાથે:")
for i in range(len(fruits)):
    print(f"ઇન્ડેક્સ {i}: {fruits[i]}")

# મેથડ 3: એન્યુમરેટ
print("\nએન્યુમરેટ વાપરીને:")
for index, fruit in enumerate(fruits):
    print(f"{index} -> {fruit}")
\end{lstlisting}

\textbf{ઉપયોગના કેસ:}
\begin{itemize}
    \item \keyword{ફક્ત વેલ્યુ}: સાદી પ્રોસેસિંગ
    \item \keyword{ઇન્ડેક્સ એક્સેસ}: પોઝિશન-આધારિત ઓપરેશન્સ
    \item \keyword{એન્યુમરેટ}: ઇન્ડેક્સ અને વેલ્યુ બંને જરૂરી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{વેલ્યુ ઇન્ડેક્સ બંને}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{1 થી 50 ની શ્રેણીમાં પ્રાઇમ અને નોન-પ્રાઇમ નંબરોનું લિસ્ટ બનાવવા માટે પાયથોન કોડ વિકસાવો.}

\begin{solutionbox}
નંબરોને પ્રાઇમ અને નોન-પ્રાઇમ લિસ્ટ્સમાં વર્ગીકૃત કરવા માટેનો Python પ્રોગ્રામ.

\textbf{Python કોડ:}
\begin{lstlisting}[language=Python]
def is_prime(n):
    """નંબર પ્રાઇમ છે કે કેમ તે તપાસવું"""
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def categorize_numbers(start, end):
    """પ્રાઇમ અને નોન-પ્રાઇમ નંબરોની લિસ્ટ બનાવવી"""
    prime_numbers = []
    non_prime_numbers = []
    
    for num in range(start, end + 1):
        if is_prime(num):
            prime_numbers.append(num)
        else:
            non_prime_numbers.append(num)
    
    return prime_numbers, non_prime_numbers

# 1 થી 50 માટે લિસ્ટ્સ જનરેટ કરવી
primes, non_primes = categorize_numbers(1, 50)

print("પ્રાઇમ નંબરો (1-50):")
print(primes)
print(f"\nકુલ પ્રાઇમ નંબરો: {len(primes)}")

print("\nનોન-પ્રાઇમ નંબરો (1-50):")
print(non_primes)
print(f"\nકુલ નોન-પ્રાઇમ નંબરો: {len(non_primes)}")
\end{lstlisting}

\textbf{પ્રાઇમ લોજિક:}

\begin{center}
\captionof{table}{પ્રાઇમ vs નોન-પ્રાઇમ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{નંબર પ્રકાર} & \textbf{શરત} & \textbf{ઉદાહરણો} \\ \hline
\textbf{પ્રાઇમ} & ફક્ત 1 અને પોતાના વડે જ ભાગાય & 2, 3, 5, 7, 11 \\ \hline
\textbf{નોન-પ્રાઇમ} & અન્ય ભાજકો છે & 1, 4, 6, 8, 9 \\ \hline
\end{tabulary}
\end{center}

\textbf{એલ્ગોરિધમ સ્ટેપ્સ:}
\begin{itemize}
    \item \keyword{ભાજ્યતા તપાસવી} 2 થી $\sqrt{n}$ સુધી
    \item \keyword{વર્ગીકરણ} પ્રાઇમ ટેસ્ટના આધારે
    \item \keyword{સ્ટોર} યોગ્ય લિસ્ટ્સમાં
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{તપાસો ભાગો વર્ગીકૃત કરો સ્ટોર કરો}
\end{mnemonicbox}

\end{document}

