\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4321602 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{પાયથનમાં સેટ અને ડિક્શનરી વચ્ચેનો તફાવત લખો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{લક્ષણ} & \textbf{સેટ} & \textbf{ડિક્શનરી} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ડેટા સ્ટોરેજ} & ફક્ત યુનિક એલિમેન્ટ્સ સ્ટોર કરે & કી-વેલ્યુ પેર સ્ટોર કરે \\
\textbf{ક્રમ} & અનઓર્ડર્ડ કલેક્શન & ઓર્ડર્ડ (Python 3.7+) \\
\textbf{ડુપ્લિકેટ્સ} & ડુપ્લિકેટ્સની મંજૂરી નથી & કીઝ યુનિક હોવી જોઈએ \\
\textbf{એક્સેસ} & ઈન્ડેક્સ દ્વારા એક્સેસ કરી શકાતું નથી & કીઝ દ્વારા વેલ્યુઝ એક્સેસ
કરવા \\
\textbf{સિન્ટેક્સ} & \texttt{\{1,\ 2,\ 3\}} &
\texttt{\{\textquotesingle{}key\textquotesingle{}:\ \textquotesingle{}value\textquotesingle{}\}} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{સેટ}: યુનિક, અનઓર્ડર્ડ એલિમેન્ટ્સનો કલેક્શન
\item
  \textbf{ડિક્શનરી}: યુનિક કીઝ સાથે કી-વેલ્યુ પેરનો કલેક્શન
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``સેટ્સ યુનિક, ડિક્ટ્સ કીઝ વાળા''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{પાયથોનમાં લિસ્ટ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{લિસ્ટ} એક ઓર્ડર્ડ, મ્યુટેબલ કલેક્શન છે જે વિવિધ ડેટા ટાઈપ્સ સ્ટોર કરી શકે છે.

\textbf{લિસ્ટ ઓપરેશન્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{ઓપરેશન} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બનાવવું} & \texttt{list\_name\ =\ []} &
\texttt{fruits\ =\ [\textquotesingle{}apple\textquotesingle{},\ \textquotesingle{}banana\textquotesingle{}]} \\
\textbf{એક્સેસ} & \texttt{list[index]} & \texttt{fruits[0]} રિટર્ન
`apple' \\
\textbf{ઉમેરવું} & \texttt{append()} &
\texttt{fruits.append(\textquotesingle{}orange\textquotesingle{})} \\
\textbf{હટાવવું} & \texttt{remove()} &
\texttt{fruits.remove(\textquotesingle{}apple\textquotesingle{})} \\
\end{longtable}
}

\begin{verbatim}
\# ઉદાહરણ
numbers = [1, 2, 3, 4, 5]
numbers.append(6)  \# [1, 2, 3, 4, 5, 6]
print(numbers[0])  \# આઉટપુટ: 1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઓર્ડર્ડ}: એલિમેન્ટ્સ તેમની પોઝિશન જાળવે છે
\item
  \textbf{મ્યુટેબલ}: બનાવ્યા પછી મોડિફાઈ કરી શકાય છે
\item
  \textbf{ફ્લેક્સિબલ}: કોઈપણ ડેટા ટાઈપ સ્ટોર કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``લિસ્ટ્સ ઓર્ડર્ડ અને મોડિફાઈ કરી શકાય તેવી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{પાયથોનમાં ટપલ શું છે? બે ટપલ વેલ્યુને અદલાબદલી કરવાનો પાયથન પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{ટપલ} એક ઓર્ડર્ડ, ઈમ્યુટેબલ કલેક્શન છે જે મલ્ટિપલ આઈટમ્સ સ્ટોર કરે છે.

\textbf{ટપલના લક્ષણોનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{પ્રોપર્ટી} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઈમ્યુટેબલ} & બનાવ્યા પછી બદલી શકાતું નથી &
\texttt{t\ =\ (1,\ 2,\ 3)} \\
\textbf{ઓર્ડર્ડ} & એલિમેન્ટ્સનો નિર્ધારિત ક્રમ & ઈન્ડેક્સ દ્વારા એક્સેસ \\
\textbf{ડુપ્લિકેટ્સ} & ડુપ્લિકેટ વેલ્યુઝની મંજૂરી & \texttt{(1,\ 1,\ 2)} \\
\textbf{ઈન્ડેક્સિંગ} & પોઝિશન દ્વારા એલિમેન્ટ્સ એક્સેસ & \texttt{t[0]} \\
\end{longtable}
}

\begin{verbatim}
\# બે ટપલ વેલ્યુઝને સ્વેપ કરવાનો પ્રોગ્રામ
def swap\_tuple\_values(tup, pos1, pos2):
    \# સ્વેપિંગ માટે ટપલને લિસ્ટમાં કન્વર્ટ કરો
    temp\_list = list(tup)
    
    \# વેલ્યુઝ સ્વેપ કરો
    temp\_list[pos1], temp\_list[pos2] = temp\_list[pos2], temp\_list[pos1]
    
    \# પાછું ટપલમાં કન્વર્ટ કરો
    return tuple(temp\_list)

\# ઉદાહરણ ઉપયોગ
original\_tuple = (10, 20, 30, 40, 50)
print("મૂળ ટપલ:", original\_tuple)

\# પોઝિશન 1 અને 3 પર વેલ્યુઝ સ્વેપ કરો
swapped\_tuple = swap\_tuple\_values(original\_tuple, 1, 3)
print("સ્વેપિંગ પછી:", swapped\_tuple)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઈમ્યુટેબલ}: એકવાર બનાવ્યા પછી મોડિફાઈ કરી શકાતું નથી
\item
  \textbf{ઓર્ડર્ડ}: એલિમેન્ટ સિક્વન્સ જાળવે છે
\item
  \textbf{હેટેરોજીનિયસ}: વિવિધ ડેટા ટાઈપ્સ સ્ટોર કરી શકે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ટપલ્સ ઈમ્યુટેબલ અને ઓર્ડર્ડ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક OR) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{પાયથોનમાં ડિક્શનરી શું છે? લૂપની મદદથી ડિક્શનરીને ટ્રાવર્સ કરવાનો પાયથન
પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{ડિક્શનરી} એક યુનિક કીઝ સાથે કી-વેલ્યુ પેરનો અનઓર્ડર્ડ કલેક્શન છે.

\textbf{ડિક્શનરી મેથડ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{મેથડ} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{keys()} & બધી કીઝ મેળવો & \texttt{dict.keys()} \\
\textbf{values()} & બધી વેલ્યુઝ મેળવો & \texttt{dict.values()} \\
\textbf{items()} & કી-વેલ્યુ પેર મેળવો & \texttt{dict.items()} \\
\textbf{get()} & સેફ કી એક્સેસ &
\texttt{dict.get(\textquotesingle{}key\textquotesingle{})} \\
\end{longtable}
}

\begin{verbatim}
\# લૂપ વાપરીને ડિક્શનરી ટ્રાવર્સ કરવાનો પ્રોગ્રામ
student\_marks = \{
    {Alice}: 85,
    {Bob}: 92,
    {Charlie}: 78,
    {Diana}: 96,
    {Eve}: 89
\}

print("ડિક્શનરી ટ્રાવર્સલ મેથડ્સ:")
print("{-"} * 30)

\# મેથડ 1: ફક્ત કીઝ ટ્રાવર્સ કરો
print("1. ફક્ત કીઝ:")
for key in student\_marks:
    print(f"   \{key\}")

\# મેથડ 2: ફક્ત વેલ્યુઝ ટ્રાવર્સ કરો
print("{n}2. ફક્ત વેલ્યુઝ:")
for value in student\_marks.values():
    print(f"   \{value\}")

\# મેથડ 3: કી{-વેલ્યુ પેર ટ્રાવર્સ કરો}
print("{n}3. કી{-વેલ્યુ પેર:"})
for key, value in student\_marks.items():
    print(f"   \{key\}: \{value\}")

\# મેથડ 4: keys() મેથડ વાપરીને
print("{n}4. keys() મેથડ વાપરીને:")
for key in student\_marks.keys():
    print(f"   \{key\} ને \{student\_marks[key]\} માર્ક્સ મળ્યા")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કી-વેલ્યુ સ્ટોરેજ}: દરેક કી એક વેલ્યુ સાથે મેપ થાય છે
\item
  \textbf{યુનિક કીઝ}: ડુપ્લિકેટ કીઝની મંજૂરી નથી
\item
  \textbf{ફાસ્ટ લુકઅપ}: O(1) એવરેજ ટાઈમ કોમ્પ્લેક્સિટી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ડિક્ટ્સ કીઝને વેલ્યુઝ સાથે મેપ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{પેકેજ શું છે? પેકેજનો ઉપયોગ કરવાના ફાયદાઓની યાદી આપો.}

\begin{solutionbox}

\textbf{પેકેજ} એક ડિરેક્ટરી છે જેમાં મલ્ટિપલ મોડ્યુલ્સ એકસાથે ઓર્ગેનાઈઝ કરવામાં આવે છે.

\textbf{પેકેજના ફાયદાઓનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{ફાયદો} & \textbf{વર્ણન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઓર્ગેનાઈઝેશન} & સંબંધિત મોડ્યુલ્સને એકસાથે ગ્રુપ કરે \\
\textbf{નેમસ્પેસ} & નામિંગ કોન્ફ્લિક્ટ્સ ટાળે \\
\textbf{રીયુઝેબિલિટી} & કોડ પ્રોજેક્ટ્સમાં ફરીથી વાપરી શકાય \\
\textbf{મેઈન્ટેનેબિલિટી} & મોટા કોડબેસ મેનેજ કરવું સરળ \\
\textbf{ડિસ્ટ્રિબ્યુશન} & શેર કરવું અને ઈન્સ્ટોલ કરવું સરળ \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ્યુલર સ્ટ્રક્ચર}: વધુ સારું કોડ ઓર્ગેનાઈઝેશન
\item
  \textbf{હાયરાર્કિકલ નેમસ્પેસ}: નેમ કોન્ફ્લિક્ટ્સ અટકાવે
\item
  \textbf{કોડ રીયુઝ}: સોફ્ટવેર રીયુઝેબિલિટીને પ્રમોટ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``પેકેજિસ રિલેટેડ મોડ્યુલ્સ ઓર્ગેનાઈઝ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{કોઈપણ બે પેકેજ આયાત પદ્ધતિઓ ઉદાહરણો સાથે સમજાવો.}

\begin{solutionbox}

\textbf{આયાત મેથડ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2632}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4211}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3158}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{મેથડ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{સિન્ટેક્સ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉપયોગ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{નોર્મલ આયાત} & \texttt{import\ package.module} & ફુલ પાથ સાથે
એક્સેસ \\
\textbf{ફ્રમ આયાત} & \texttt{from\ package\ import\ module} & ડાયરેક્ટ
મોડ્યુલ એક્સેસ \\
\textbf{સ્પેસિફિક આયાત} & \texttt{from\ package.module\ import\ function}
& સ્પેસિફિક આઈટમ્સ આયાત \\
\textbf{વાઈલ્ડકાર્ડ આયાત} & \texttt{from\ package\ import\ *} & બધા મોડ્યુલ્સ
આયાત \\
\end{longtable}
}

\begin{verbatim}
\# મેથડ 1: નોર્મલ આયાત
import mypackage.calculator
result = mypackage.calculator.add(5, 3)
print(f"નોર્મલ આયાત પરિણાม: \{result\}")

\# મેથડ 2: ફ્રમ આયાત
from mypackage import calculator
result = calculator.multiply(4, 6)
print(f"ફ્રમ આયાત પરિણાม: \{result\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{નોર્મલ આયાત}: ફુલ પેકેજ પાથ જરૂરી
\item
  \textbf{ફ્રમ આયાત}: ડાયરેક્ટ મોડ્યુલ એક્સેસની મંજૂરી
\item
  \textbf{સ્પેસિફિક ફંક્શન આયાત}: ફક્ત જરૂરી ફંક્શન્સ આયાત
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``આયાત નોર્મલી અથવા પેકેજથી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{ઈન્ટ્રા-પેકેજ સંદર્ભ વિશે ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ઈન્ટ્રા-પેકેજ રેફરન્સ} પેકેજની અંદરના મોડ્યુલ્સને એકબીજાથી આયાત કરવાની મંજૂરી
આપે છે.

\textbf{પેકેજ સ્ટ્રક્ચરનો ડાયાગ્રામ:}

\begin{verbatim}
mypackage/
├── \_\_init\_\_.py
├── math\_ops/
│   ├── \_\_init\_\_.py
│   ├── basic.py
│   └── advanced.py
└── utils/
    ├── \_\_init\_\_.py
    └── helpers.py
\end{verbatim}

\textbf{રેફરન્સ ટાઈપ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2564}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4103}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{ટાઈપ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{સિન્ટેક્સ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉપયોગ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{એબ્સોલ્યુટ} & \texttt{from\ mypackage.math\_ops\ import\ basic} &
પેકેજ રૂટથી ફુલ પાથ \\
\textbf{રિલેટિવ} & \texttt{from\ .\ import\ basic} & વર્તમાન પેકેજ \\
\textbf{પેરન્ટ} & \texttt{from\ ..\ import\ utils} & પેરન્ટ પેકેજ \\
\textbf{સિબલિંગ} & \texttt{from\ ..utils\ import\ helpers} & સિબલિંગ
પેકેજ \\
\end{longtable}
}

\begin{verbatim}
\# પેકેજ સ્ટ્રક્ચર ઉદાહરણ
\# mypackage/math\_ops/advanced.py
from . import basic  \# સેમ પેકેજથી રિલેટિવ આયાત
from ..utils import helpers  \# સિબલિંગ પેકેજથી આયાત

def power\_operation(base, exp):
    \# બેસિક મોડ્યુલથી ફંક્શન વાપરીને
    if basic.is\_valid\_number(base) and basic.is\_valid\_number(exp):
        result = base ** exp
        \# હેલ્પર ફંક્શન વાપરીને
        return helpers.format\_result(result)
    return None

\# mypackage/math\_ops/basic.py
def is\_valid\_number(num):
    return isinstance(num, (int, float))

def add(a, b):
    return a + b

\# mypackage/utils/helpers.py
def format\_result(value):
    return f"પરિણાम: \{value:.2f\}"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{રિલેટિવ આયાત્સ}: વર્તમાન પેકેજ માટે ડોટ્સ (.) વાપરો
\item
  \textbf{એબ્સોલ્યુટ આયાત્સ}: ફુલ પેકેજ પાથ
\item
  \textbf{પેકેજ હાયરાર્કી}: ડોટ નોટેશન વાપરીને નેવિગેટ કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ડોટ્સ પેકેજ લેવલ્સ નેવિગેટ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ OR) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{મોડ્યુલ શું છે? મોડ્યુલનો ઉપયોગ કરવાના ફાયદાઓની યાદી આપો.}

\begin{solutionbox}

\textbf{મોડ્યુલ} એક Python ફાઈલ છે જેમાં ડેફિનિશન્સ, સ્ટેટમેન્ટ્સ અને ફંક્શન્સ હોય છે.

\textbf{મોડ્યુલના ફાયદાઓનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{ફાયદો} & \textbf{વર્ણન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{કોડ રીયુઝેબિલિટી} & એકવાર લખો, અનેક વાર વાપરો \\
\textbf{નેમસ્પેસ} & ફંક્શન્સ માટે અલગ નેમસ્પેસ \\
\textbf{ઓર્ગેનાઈઝેશન} & વધુ સારું કોડ સ્ટ્રક્ચર \\
\textbf{મેઈન્ટેનેબિલિટી} & ડિબગ અને અપડેટ કરવું સરળ \\
\textbf{કોલેબોરેશન} & મલ્ટિપલ ડેવલપર્સ કામ કરી શકે \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{રીયુઝેબલ કોડ}: ફંક્શન્સ ગમે ત્યાં આયાત કરી શકાય
\item
  \textbf{મોડ્યુલર ડિઝાઈન}: મોટા પ્રોગ્રામ્સને નાના ભાગોમાં વહેંચો
\item
  \textbf{સરળ મેઈન્ટેનન્સ}: એક જગ્યાએ ફેરફાર બધી આયાત્સને અસર કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``મોડ્યુલ્સ કોડ રીયુઝેબલ બનાવે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ OR) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{કોઈપણ બે મોડ્યુલ આયાત પદ્ધતિ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{મોડ્યુલ આયાત મેથડ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{મેથડ} & \textbf{સિન્ટેક્સ} & \textbf{એક્સેસ પેટર્ન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ડાયરેક્ટ આયાત} & \texttt{import\ module\_name} &
\texttt{module\_name.function()} \\
\textbf{ફ્રમ આયાત} & \texttt{from\ module\_name\ import\ function} &
\texttt{function()} \\
\textbf{એલિયાસ આયાત} & \texttt{import\ module\_name\ as\ alias} &
\texttt{alias.function()} \\
\textbf{વાઈલ્ડકાર્ડ આયાત} & \texttt{from\ module\_name\ import\ *} &
\texttt{function()} \\
\end{longtable}
}

\begin{verbatim}
\# મેથડ 1: ડાયરેક્ટ આયાત
import math
result1 = math.sqrt(16)
print(f"ડાયરેક્ટ આયાત: \{result1\}")

\# મેથડ 2: ફ્રમ આયાત
from math import pi, sin
result2 = sin(pi/2)
print(f"ફ્રમ આયાત: \{result2\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ડાયરેક્ટ આયાત}: મોડ્યુલ નામ પ્રીફિક્સ સાથે એક્સેસ
\item
  \textbf{ફ્રમ આયાત}: પ્રીફિક્સ વગર ડાયરેક્ટ ફંક્શન એક્સેસ
\item
  \textbf{નેમસ્પેસ કંટ્રોલ}: યોગ્ય આયાત મેથડ પસંદ કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``આયાત ડાયરેક્ટલી અથવા મોડ્યુલથી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક OR) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{વતુળનું ક્ષેત્રફળ અને પરિઘ શોધવા માટેના મોડ્યુલનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\# circle\_operations.py (મોડ્યુલ ફાઈલ)
import math

def area(radius):
    """વતુળનું ક્ષેત્રફળ ગણો"""
    if radius {=} 0:
        return 0
    return math.pi * radius * radius

def circumference(radius):
    """વતુળનો પરિઘ ગણો"""
    if radius {=} 0:
        return 0
    return 2 * math.pi * radius

def display\_info(radius):
    """વતુળની માહિતી દર્શાવો"""
    print(f"ત્રિજ્યા \{radius\} વાળું વતુળ:")
    print(f"ક્ષેત્રફળ: \{area(radius):.2f\}")
    print(f"પરિઘ: \{circumference(radius):.2f\}")

\# કોન્સ્ટન્ટ્સ
PI = math.pi

\# અ) મોડ્યુલને બીજા પ્રોગ્રામમાં આયાત કરો

\# main\_program.py
import circle\_operations

radius = 5
print("મેથડ 1: સંપૂર્ણ મોડ્યુલ આયાત")
area\_result = circle\_operations.area(radius)
circumference\_result = circle\_operations.circumference(radius)

print(f"ક્ષેત્રફળ: \{area\_result:.2f\}")
print(f"પરિઘ: \{circumference\_result:.2f\}")

\# બ) મોડ્યુલમાંથી બીજા પ્રોગ્રામમાં ચોક્કસ ફંક્શન આયાત કરો
\# specific\_import.py
from circle\_operations import area, circumference

radius = 7
print("{n}મેથડ 2: ચોક્કસ ફંક્શન્સ આયાત")
area\_result = area(radius)
circumference\_result = circumference(radius)

print(f"ક્ષેત્રફળ: \{area\_result:.2f\}")
print(f"પરિઘ: \{circumference\_result:.2f\}")
\end{verbatim}

\textbf{મોડ્યુલ ફીચર્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{ફીચર} & \textbf{ઇમ્પ્લિમેન્ટેશન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ફંક્શન્સ} & area(), circumference() \\
\textbf{એરર હેન્ડલિંગ} & નેગેટિવ ત્રિજ્યા માટે ચેક \\
\textbf{કોન્સ્ટન્ટ્સ} & PI વેલ્યુ \\
\textbf{ડોક્યુમેન્ટેશન} & ફંક્શન ડોકસ્ટ્રિંગ્સ \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ્યુલ બનાવવું}: ફંક્શન્સને .py ફાઈલમાં સેવ કરો
\item
  \textbf{આયાત લવચીકતા}: સંપૂર્ણ મોડ્યુલ અથવા ચોક્કસ ફંક્શન્સ
\item
  \textbf{કોડ રીયુઝ}: એક જ ફંક્શન્સ મલ્ટિપલ પ્રોગ્રામ્સમાં વાપરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``મોડ્યુલ્સમાં રીયુઝેબલ ફંક્શન્સ હોય''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{પાયથોનમાં ભૂલના પ્રકારો સમજાવો.}

\begin{solutionbox}

\textbf{Python એરર ટાઈપ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{એરર ટાઈપ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સિન્ટેક્સ એરર} & ખોટું Python સિન્ટેક્સ & કોલન \texttt{:} ભૂલી જવું \\
\textbf{રનટાઈમ એરર} & એક્ઝિક્યુશન દરમિયાન થાય & શૂન્યથી ભાગાકાર \\
\textbf{લોજિકલ એરર} & ખોટું પ્રોગ્રામ લોજિક & ખોટું અલ્ગોરિધમ \\
\textbf{નેમ એરર} & અંડિફાઈન્ડ વેરિએબલ & અઘોષિત વેરિએબલ વાપરવું \\
\textbf{ટાઈપ એરર} & ખોટું ડેટા ટાઈપ ઓપરેશન & સ્ટ્રિંગ + ઇન્ટિજર \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{સિન્ટેક્સ એરર}: પ્રોગ્રામ રન થાય તે પહેલાં શોધાય
\item
  \textbf{રનટાઈમ એરર}: પ્રોગ્રામ એક્ઝિક્યુશન દરમિયાન થાય
\item
  \textbf{લોજિકલ એરર}: પ્રોગ્રામ રન થાય પણ ખોટા પરિણામ આપે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``સિન્ટેક્સ, રનટાઈમ, લોજિક એરર્સ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{યુઝર-ડિફાઈન્ડ એક્સેપ્શન રેઈઝ સ્ટેટમેન્ટ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{યુઝર-ડિફાઈન્ડ એક્સેપ્શન્સ} પ્રોગ્રામર્સ દ્વારા બનાવવામાં આવેલા કસ્ટમ એરર
ક્લાસીસ છે.

\textbf{એક્સેપ્શન કોમ્પોનન્ટ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4103}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2564}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{કોમ્પોનન્ટ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{હેતુ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉદાહરણ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ક્લાસ ડેફિનિશન} & કસ્ટમ એક્સેપ્શન બનાવો &
\texttt{class\ CustomError(Exception):} \\
\textbf{રેઈઝ સ્ટેટમેન્ટ} & એક્સેપ્શન ટ્રિગર કરો &
\texttt{raise\ CustomError("message")} \\
\textbf{એરર મેસેજ} & સમસ્યાનું વર્ણન & માહિતીપ્રદ ટેક્સ્ટ \\
\textbf{એક્સેપ્શન હેન્ડલિંગ} & કસ્ટમ એક્સેપ્શન પકડો &
\texttt{except\ CustomError:} \\
\end{longtable}
}

\begin{verbatim}
\# કસ્ટમ એક્સેપ્શન ડિફાઈન કરો
class AgeValidationError(Exception):
    def \_\_init\_\_(self, age, message="અયોગ્ય વય આપેલ છે"):
        self.age = age
        self.message = message
        super().\_\_init\_\_(self.message)

def validate\_age(age):
    if age {} 0:
        raise AgeValidationError(age, "વય નેગેટિવ હોઈ શકે નહીં")
    elif age {} 150:
        raise AgeValidationError(age, "વય 150 કરતાં વધુ હોઈ શકે નહીં")
    else:
        print(f"યોગ્ય વય: \{age\}")

\# કસ્ટમ એક્સેપ્શનનો ઉપયોગ
try:
    validate\_age({-}5)
except AgeValidationError as e:
    print(f"એરર: \{e.message\}, વય: \{e.age\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કસ્ટમ એક્સેપ્શન ક્લાસ}: Exception થી ઇન્હેરિટ કરે
\item
  \textbf{રેઈઝ સ્ટેટમેન્ટ}: મેન્યુઅલી એક્સેપ્શન્સ ટ્રિગર કરે
\item
  \textbf{અર્થપૂર્ણ મેસેજિસ}: ડિબગિંગમાં મદદ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``વેલિડેશન માટે કસ્ટમ એક્સેપ્શન રેઈઝ કરો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{ટ્રાય-એક્સેપ્ટ-ફાઈનલી ક્લોઝ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ટ્રાય-એક્સેપ્ટ-ફાઈનલી} સંપૂર્ણ એક્સેપ્શન હેન્ડલિંગ મિકેનિઝમ પૂરું પાડે છે.

\textbf{એક્સેપ્શન હેન્ડલિંગ બ્લોક્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{બ્લોક} & \textbf{હેતુ} & \textbf{એક્ઝિક્યુશન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & એક્સેપ્શન ઉઠાવી શકે તેવો કોડ & હંમેશા પહેલા એક્ઝિક્યુટ \\
\textbf{except} & ચોક્કસ એક્સેપ્શન્સ હેન્ડલ કરે & ફક્ત એક્સેપ્શન આવે તો \\
\textbf{else} & કોઈ એક્સેપ્શન નહીં આવે ત્યારે & ફક્ત કોઈ એક્સેપ્શન નહીં આવે તો \\
\textbf{finally} & ક્લીનઅપ કોડ & હંમેશા એક્ઝિક્યુટ થાય \\
\end{longtable}
}

\begin{verbatim}
\# સંપૂર્ણ એક્સેપ્શન હેન્ડલિંગ ઉદાહરણ
def divide\_numbers():
    try:
        print("ભાગાકાર ઓપરેશન શરૂ કરી રહ્યા છીએ...")
        
        \# યુઝરથી ઇનપુટ મેળવો
        num1 = float(input("પહેલો નંબર દાખલ કરો: "))
        num2 = float(input("બીજો નંબર દાખલ કરો: "))
        
        \# ભાગાકાર કરો
        result = num1 / num2
        
    except ValueError:
        print("એરર: કૃપા કરીને ફક્ત યોગ્ય નંબર્સ દાખલ કરો")
        return None
        
    except ZeroDivisionError:
        print("એરર: શૂન્યથી ભાગાકાર કરી શકાતો નથી")
        return None
        
    except Exception as e:
        print(f"અનપેક્ષિત એરર આવ્યું: \{e\}")
        return None
        
    else:
        print(f"ભાગાકાર સફળ: \{num1\}  \{num2\} = \{result\}")
        return result
        
    finally:
        print("ભાગાકાર ઓપરેશન પૂર્ણ")
        print("રિસોર્સિસ ક્લીન કરી રહ્યા છીએ...")

\# ઉદાહરણ ઉપયોગ
result = divide\_numbers()
if result:
    print(f"અંતિમ પરિણાম: \{result\}")
\end{verbatim}

\textbf{ફ્લો ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A[try block] {-{-} B\{એક્સેપ્શન આવ્યું?\}}
    B {-{-}|હા| C[except block]}
    B {-{-}|ના| D[else block]}
    C {-{-} E[finally block]}
    D {-{-} E}
    E {-{-} F[અંત]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{try}: જોખમી કોડ હોય છે
\item
  \textbf{except}: ચોક્કસ એરર્સ હેન્ડલ કરે
\item
  \textbf{finally}: ક્લીનઅપ માટે હંમેશા એક્ઝિક્યુટ થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ટ્રાય-એક્સેપ્ટ-ફાઈનલી હંમેશા ક્લીન કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ OR) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{બિલ્ટ-ઇન એક્સેપ્શન શું છે? કોઇ પણ બેની તેમના અર્થ સાથે યાદી બનાવો.}

\begin{solutionbox}

\textbf{બિલ્ટ-ઇન એક્સેપ્શન્સ} Python માં પૂર્વ-નિર્ધારિત એરર ટાઈપ્સ છે.

\textbf{બિલ્ટ-ઇન એક્સેપ્શન્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{એક્સેપ્શન} & \textbf{અર્થ} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ValueError} & યોગ્ય ટાઈપ પણ અમાન્ય વેલ્યુ & \texttt{int("abc")} \\
\textbf{TypeError} & ખોટું ડેટા ટાઈપ ઓપરેશન & \texttt{"5"\ +\ 5} \\
\textbf{IndexError} & લિસ્ટ ઇન્ડેક્સ રેન્જની બહાર & 5-આઇટમ લિસ્ટ માટે
\texttt{list[10]} \\
\textbf{KeyError} & ડિક્શનરી કી મળી નહીં &
\texttt{dict["missing\_key"]} \\
\textbf{ZeroDivisionError} & શૂન્યથી ભાગાકાર & \texttt{10\ /\ 0} \\
\end{longtable}
}

\textbf{બે મુખ્ય બિલ્ટ-ઇન એક્સેપ્શન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{ValueError}: જ્યારે ફંક્શનને યોગ્ય ટાઈપ પણ અમાન્ય વેલ્યુ મળે
\item
  \textbf{TypeError}: જ્યારે અયોગ્ય ડેટા ટાઈપ પર ઓપરેશન કરવામાં આવે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``બિલ્ટ-ઇન એક્સેપ્શન્સ સામાન્ય એરર્સ હેન્ડલ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ OR) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{ટ્રાય-એક્સેપ્ટ ક્લોઝ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ટ્રાય-એક્સેપ્ટ} પ્રોગ્રામ એક્ઝિક્યુશન દરમિયાન આવી શકે તેવા એક્સેપ્શન્સ હેન્ડલ કરે
છે.

\textbf{એક્સેપ્શન હેન્ડલિંગનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{કોમ્પોનન્ટ} & \textbf{હેતુ} & \textbf{સિન્ટેક્સ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & નિષ્ફળ થઈ શકે તેવો કોડ & \texttt{try:} \\
\textbf{except} & ચોક્કસ એક્સેપ્શન હેન્ડલ કરે & \texttt{except\ ErrorType:} \\
\textbf{મલ્ટિપલ except} & વિવિધ એરર્સ હેન્ડલ કરે & મલ્ટિપલ except બ્લોક્સ \\
\textbf{જનરલ except} & કોઈપણ એક્સેપ્શન પકડે & \texttt{except:} \\
\end{longtable}
}

\begin{verbatim}
\# ટ્રાય{-એક્સેપ્ટ ક્લોઝનું ઉદાહરણ}
def safe\_division():
    try:
        \# એક્સેપ્શન્સ ઉઠાવી શકે તેવો કોડ
        dividend = int(input("ભાજ્ય દાખલ કરો: "))
        divisor = int(input("ભાજક દાખલ કરો: "))
        
        result = dividend / divisor
        print(f"પરિણાम: \{dividend\}  \{divisor\} = \{result\}")
        
    except ValueError:
        print("એરર: કૃપા કરીને ફક્ત યોગ્ય ઇન્ટિજર્સ દાખલ કરો")
        
    except ZeroDivisionError:
        print("એરર: શૂન્યથી ભાગાકાર કરી શકાતો નથી")
        
    except Exception as e:
        print(f"અનપેક્ષિત એરર આવ્યું: \{e\}")
    
    print("એક્સેપ્શન હેન્ડલિંગ પછી પ્રોગ્રામ ચાલુ રહે છે")

\# ઉદાહરણ ઉપયોગ
safe\_division()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{try બ્લોક}: સંભવિત જોખમી કોડ હોય છે
\item
  \textbf{except બ્લોક}: ચોક્કસ એક્સેપ્શન ટાઈપ્સ હેન્ડલ કરે
\item
  \textbf{મલ્ટિપલ હેન્ડલર્સ}: વિવિધ એક્સેપ્શન્સ અલગ અલગ હેન્ડલ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``જોખમી કોડ ટ્રાય કરો, એક્સેપ્ટ એરર્સ હેન્ડલ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક OR) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{ડિવાઇડ બાય ઝીરો એક્સેપ્શન ફાઈનલી ક્લોઝ સાથે કેચ કરવાનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\# ફાઈનલી ક્લોઝ સાથે ડિવાઇડ બાય ઝીરો હેન્ડલ કરવાનો પ્રોગ્રામ
def advanced\_calculator():
    """વ્યાપક એક્સેપ્શન હેન્ડલિંગ સાથે કેલ્ક્યુલેટર"""
    
    try:
        print("=== એડવાન્સ કેલ્ક્યુલેટર ===")
        print("ભાગાકાર માટે બે નંબર દાખલ કરો")
        
        \# ઇનપુટ સેક્શન
        numerator = float(input("અંશ દાખલ કરો: "))
        denominator = float(input("છેદ દાખલ કરો: "))
        
        print(f"{n}\{numerator\} ને \{denominator\} થી ભાગવાનો પ્રયાસ કરી રહ્યા છીએ...")
        
        \# ક્રિટિકલ ઓપરેશન જે નિષ્ફળ થઈ શકે
        if denominator == 0:
            raise ZeroDivisionError("શૂન્યથી ભાગાકારની મંજૂરી નથી")
        
        result = numerator / denominator
        
        \# સફળતાનો સંદેશ
        print(f"✓ ભાગાકાર સફળ!")
        print(f"✓ પરિણામ: \{numerator\}  \{denominator\} = \{result:.4f\}")
        
        return result
        
    except ZeroDivisionError as zde:
        print(f"✗ ઝીરો ડિવિઝન એરર: \{zde\}")
        print("✗ કૃપા કરીને શૂન્ય સિવાયનો છેદ વાપરો")
        return None
        
    except ValueError as ve:
        print(f"✗ વેલ્યુ એરર: અમાન્ય ઇનપુટ આપ્યું")
        print("✗ કૃપા કરીને ફક્ત નંબરિક વેલ્યુઝ દાખલ કરો")
        return None
        
    except Exception as e:
        print(f"✗ અનપેક્ષિત એરર: \{e\}")
        return None
        
    finally:
        print("{n}" + "="*40)
        print("ક્લીનઅપ ઓપરેશન્સ:")
        print("{- કેલ્ક્યુલેટર સેશન બંધ કરી રહ્યા છીએ"})
        print("{- ઓપરેશન લોગ સેવ કરી રહ્યા છીએ"})
        print("{- મેમરી રિસોર્સિસ છોડી રહ્યા છીએ"})
        print("{- કેલ્ક્યુલેટર શટડાઉન પૂર્ણ"})
        print("="*40)

\# વિવિધ સ્થિતિઓ સાથે કેલ્ક્યુલેટર ટેસ્ટ કરવાનું ફંક્શન
def test\_calculator():
    """વિવિધ પરિસ્થિતિઓ સાથે કેલ્ક્યુલેટર ટેસ્ટ કરો"""
    
    test\_cases = [
        (10, 2),    \# સામાન્ય ભાગાકાર
        (15, 0),    \# ઝીરો ડિવિઝન
        (7, 3),     \# દશાંશ સાથે સામાન્ય ભાગાકાર
    ]
    
    for i, (num, den) in enumerate(test\_cases, 1):
        print(f"{n}{-{-}{-} ટેસ્ટ કેસ }\{i\} {-{-}{-}"})
        print(f"ટેસ્ટિંગ: \{num\}  \{den\}")
        
        \# વાસ્તવિક પરિસ્થિતિમાં આ ઇન્ટરેક્ટિવ હશે
        \# આ ફક્ત ડેમોન્સ્ટ્રેશન માટે છે
        print(f"\{num\} ને \{den\} થી ભાગવાનું સિમ્યુલેશન")
        
        try:
            if den == 0:
                raise ZeroDivisionError("શૂન્યથી ભાગાકાર કરી શકાતો નથી")
            result = num / den
            print(f"પરિણામ: \{result\}")
        except ZeroDivisionError as e:
            print(f"એરર પકડાયું: \{e\}")
        finally:
            print("ટેસ્ટ કેસ પૂર્ણ")

\# કેલ્ક્યુલેટર ચલાવો
if \_\_name\_\_ == "\_\_main\_\_":
    result = advanced\_calculator()
    
    if result is not None:
        print(f"{n}અંતિમ ગણેલું પરિણામ: \{result\}")
    else:
        print("{n}એરર્સના કારણે ગણતરી નિષ્ફળ")
\end{verbatim}

\textbf{એક્સેપ્શન હેન્ડલિંગ ફીચર્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{ફીચર} & \textbf{ઇમ્પ્લિમેન્ટેશન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ZeroDivisionError} & શૂન્યથી ભાગાકાર માટે ચોક્કસ હેન્ડલિંગ \\
\textbf{ValueError} & અમાન્ય ઇનપુટ ટાઈપ્સ હેન્ડલ કરે \\
\textbf{જનરિક એક્સેપ્શન} & અનપેક્ષિત એરર્સ પકડે \\
\textbf{ફાઈનલી બ્લોક} & હંમેશા ક્લીનઅપ કોડ એક્ઝિક્યુટ \\
\end{longtable}
}

\textbf{એક્સેપ્શન હેન્ડલિંગ ફ્લો:}

\begin{verbatim}
flowchart LR
    A[ભાગાકાર શરૂ] {-{-} B[try block]}
    B {-{-} C\{એક્સેપ્શન?\}}
    C {-{-}|ZeroDivisionError| D[ઝીરો ડિવિઝન હેન્ડલ]}
    C {-{-}|ValueError| E[અમાન્ય ઇનપુટ હેન્ડલ]}
    C {-{-}|અન્ય| F[જનરિક એરર હેન્ડલ]}
    C {-{-}|કંઈ નહીં| G[સફળતાનું પરિણામ]}
    D {-{-} H[finally block]}
    E {-{-} H}
    F {-{-} H}
    G {-{-} H}
    H {-{-} I[પ્રોગ્રામ સમાપ્ત]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ચોક્કસ એક્સેપ્શન હેન્ડલિંગ}: ZeroDivisionError અલગથી પકડાય
\item
  \textbf{ફાઈનલી ક્લોઝ}: ક્લીનઅપ માટે હંમેશા એક્ઝિક્યુટ થાય
\item
  \textbf{રિસોર્સ મેનેજમેન્ટ}: એરર્સ છતાં યોગ્ય ક્લીનઅપ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ફાઈનલી હંમેશા રિસોર્સિસ ક્લીન કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{વ્યાખ્યાયિત કરો: ફાઇલ, બાઇનરી ફાઇલ, ટેક્સ્ટ ફાઇલ}

\begin{solutionbox}

\textbf{ફાઈલ વ્યાખ્યાઓનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2571}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3714}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{શબ્દ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{વ્યાખ્યા}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉદાહરણ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ફાઈલ} & ડિસ્ક પર નામવાળું સ્ટોરેજ સ્થાન & document.txt, image.jpg \\
\textbf{બાઈનરી ફાઈલ} & બાઈનરી ફોર્મેટમાં નોન-ટેક્સ્ટ ડેટા સમાવે & .exe, .jpg,
.mp3, .pdf \\
\textbf{ટેક્સ્ટ ફાઈલ} & માનવ-વાંચી શકાય તેવા ટેક્સ્ટ કેરેક્ટર્સ સમાવે & .txt, .py,
.html, .csv \\
\end{longtable}
}

\textbf{વિગતવાર વ્યાખ્યાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ફાઈલ}: સ્ટોરેજ ડિવાઈસ પર યુનિક નામ સાથે સ્ટોર કરેલો ડેટાનો કલેક્શન
\item
  \textbf{બાઈનરી ફાઈલ}: બાઈનરી ફોર્મેટ (0s અને 1s) માં ડેટા સ્ટોર કરે,
  માનવ-વાંચી ન શકાય
\item
  \textbf{ટેક્સ્ટ ફાઈલ}: ASCII અથવા Unicode કેરેક્ટર્સ સમાવે, માનવ-વાંચી શકાય તેવું
  ફોર્મેટ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ફાઈલ્સ ડેટા સ્ટોર કરે, બાઈનરી=મશીન, ટેક્સ્ટ=માનવ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{write() અને writelines() ફંક્શન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{રાઈટ ફંક્શન્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2292}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2083}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3125}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{ફંક્શન}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{હેતુ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{પેરામીટર}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉપયોગ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{write()} & સિંગલ સ્ટ્રિંગ લખે & સ્ટ્રિંગ &
\texttt{file.write("Hello")} \\
\textbf{writelines()} & સ્ટ્રિંગ્સની લિસ્ટ લખે & લિસ્ટ/સિક્વન્સ &
\texttt{file.writelines(["line1",\ "line2"])} \\
\end{longtable}
}

\begin{verbatim}
\# write() અને writelines() ફંક્શન્સનું ઉદાહરણ
def demonstrate\_write\_functions():
    
    \# write() ફંક્શન વાપરીને
    with open("write\_demo.txt", "w") as file:
        file.write("નમસ્તે વિશ્વ!{n}")
        file.write("આ બીજી લાઈન છે{n}")
        file.write("આ ત્રીજી લાઈન છે{n}")
    
    \# writelines() ફંક્શન વાપરીને
    lines = [
        "writelines વાપરીને પહેલી લાઈન{n}",
        "writelines વાપરીને બીજી લાઈન{n}", 
        "writelines વાપરીને ત્રીજી લાઈન{n}"
    ]
    
    with open("writelines\_demo.txt", "w") as file:
        file.writelines(lines)
    
    print("ફાઈલ્સ સફળતાપૂર્વક બનાવાઈ!")

\# ડેમોન્સ્ટ્રેશન ચલાવો
demonstrate\_write\_functions()
\end{verbatim}

\textbf{મુખ્ય તફાવતો:}

\begin{itemize}
\tightlist
\item
  \textbf{write()}: એક સમયે એક સ્ટ્રિંગ લખે
\item
  \textbf{writelines()}: સિક્વન્સમાંથી મલ્ટિપલ સ્ટ્રિંગ્સ લખે
\item
  \textbf{ન્યુલાઈન્સ}: \texttt{\textbackslash{}n} મેન્યુઅલી ઉમેરવું પડે
\item
  \textbf{રિટર્ન વેલ્યુ}: બંને લખાયેલા કેરેક્ટર્સની સંખ્યા રિટર્ન કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``write() સિંગલ, writelines() મલ્ટિપલ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{tell() અને seek() ફંક્શન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ફાઈલ પોઈન્ટર ફંક્શન્સ} ફાઈલની અંદર રીડિંગ/રાઈટિંગ માટે પોઝિશન કંટ્રોલ કરે
છે.

\textbf{પોઝિશન ફંક્શન્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2037}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1852}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2222}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{ફંક્શન}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{હેતુ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{રિટર્ન/પેરામીટર}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉપયોગ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{tell()} & વર્તમાન પોઝિશન મેળવો & વર્તમાન બાઈટ પોઝિશન રિટર્ન &
\texttt{pos\ =\ file.tell()} \\
\textbf{seek(offset, whence)} & ચોક્કસ પોઝિશન પર જાઓ & offset: બાઈટ્સ,
whence: રેફરન્સ & \texttt{file.seek(10,\ 0)} \\
\end{longtable}
}

\textbf{Seek Whence વેલ્યુઝ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{વેલ્યુ} & \textbf{રેફરન્સ પોઈન્ટ} & \textbf{વર્ણન} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{0} & ફાઈલની શરૂઆત & એબ્સોલ્યુટ પોઝિશનિંગ \\
\textbf{1} & વર્તમાન પોઝિશન & વર્તમાનના સંબંધમાં \\
\textbf{2} & ફાઈલનો અંત & અંતના સંબંધમાં \\
\end{longtable}
}

\begin{verbatim}
\# tell() અને seek() ફંક્શન્સનું સંપૂર્ણ ઉદાહરણ
def demonstrate\_file\_positioning():
    
    \# સેમ્પલ ફાઈલ બનાવો
    sample\_text = "નમસ્તે વિશ્વ! આ tell() અને seek() ફંક્શન્સ દર્શાવવા માટે સેમ્પલ ફાઈલ છે."
    
    with open("position\_demo.txt", "w", encoding={utf{-}8}) as file:
        file.write(sample\_text)
    
    \# tell() અને seek() દર્શાવો
    with open("position\_demo.txt", "r", encoding={utf{-}8}) as file:
        
        \# શરૂઆતની પોઝિશન
        print(f"1. શરૂઆતની પોઝિશન: \{file.tell()\}")
        
        \# પહેલા 5 કેરેક્ટર્સ વાંચો
        data1 = file.read(5)
        print(f"2. {}\{data1\}{ વાંચ્યું, વર્તમાન પોઝિશન: }\{file.tell()\}")
        
        \# પોઝિશન 15 પર જાઓ
        file.seek(15)
        print(f"3. seek(15) પછી, પોઝિશન: \{file.tell()\}")
        
        \# આગળના 10 કેરેક્ટર્સ વાંચો
        data2 = file.read(10)
        print(f"4. {}\{data2\}{ વાંચ્યું, વર્તમાન પોઝિશન: }\{file.tell()\}")
        
        \# seek(0, 0) વાપરીને શરૂઆતમાં જાઓ
        file.seek(0, 0)
        print(f"5. seek(0,0) પછી, પોઝિશન: \{file.tell()\}")
        
        \# seek(0, 2) વાપરીને અંતમાં જાઓ
        file.seek(0, 2)
        print(f"6. seek(0,2) પછી, પોઝિશન: \{file.tell()\}")
        
        \# વર્તમાન પોઝિશનથી પાછળ જાઓ
        file.seek({-}10, 1)
        print(f"7. seek({-10,1) પછી, પોઝિશન: }\{file.tell()\}")
        
        \# બાકીનું કન્ટેન્ટ વાંચો
        remaining = file.read()
        print(f"8. બાકીનું કન્ટેન્ટ: {}\{remaining\}{"})

\# બાઈનરી ફાઈલ સાથે ઉદાહરણ
def binary\_file\_positioning():
    
    \# બાઈનરી ફાઈલ બનાવો
    data = b"Binary file positioning example"
    
    with open("binary\_demo.bin", "wb") as file:
        file.write(data)
    
    \# પોઝિશનિંગ સાથે વાંચો
    with open("binary\_demo.bin", "rb") as file:
        print(f"{n}બાઈનરી ફાઈલ પોઝિશન: \{file.tell()\}")
        
        \# પહેલા 6 બાઈટ્સ વાંચો
        chunk1 = file.read(6)
        print(f"વાંચ્યું: \{chunk1\}, પોઝિશન: \{file.tell()\}")
        
        \# પોઝિશન 20 પર જમ્પ કરો
        file.seek(20)
        chunk2 = file.read(7)
        print(f"વાંચ્યું: \{chunk2\}, પોઝિશન: \{file.tell()\}")

\# ડેમોન્સ્ટ્રેશન્સ ચલાવો
demonstrate\_file\_positioning()
binary\_file\_positioning()
\end{verbatim}

\textbf{પોઝિશન કંટ્રોલ ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A[ફાઈલ શરૂઆત] {-{-} B["tell(): 0"]}
    B {-{-} C["read(5)"]}
    C {-{-} D["tell(): 5"]}
    D {-{-} E["seek(15)"]}
    E {-{-} F["tell(): 15"]}
    F {-{-} G["seek(0,2)"]}
    G {-{-} H["tell(): અંત"]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{tell()}: ફાઈલમાં વર્તમાન બાઈટ પોઝિશન રિટર્ન કરે
\item
  \textbf{seek()}: ફાઈલ પોઈન્ટરને સ્પેસિફાઈડ પોઝિશન પર મૂવ કરે
\item
  \textbf{પોઝિશનિંગ}: રેન્ડમ ફાઈલ એક્સેસ માટે જરૂરી
\item
  \textbf{બાઈનરી મોડ}: બાઈટ પોઝિશન્સ સાથે કામ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``tell() પોઝિશન, seek() મૂવમેન્ટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ OR) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{એબ્સોલ્યુટ અને રિલેટિવ પાથ શું છે?}

\begin{solutionbox}

\textbf{પાથ ટાઈપ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3421}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3158}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3421}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{પાથ ટાઈપ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{વર્ણન}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉદાહરણ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{એબ્સોલ્યુટ પાથ} & રૂટ ડિરેક્ટરીથી સંપૂર્ણ પાથ &
\texttt{/home/user/documents/file.txt} \\
\textbf{રિલેટિવ પાથ} & વર્તમાન ડિરેક્ટરીના સંબંધમાં પાથ &
\texttt{../documents/file.txt} \\
\end{longtable}
}

\textbf{પાથ સિમ્બોલ્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{સિમ્બોલ} & \textbf{અર્થ} & \textbf{ઉદાહરણ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{/} & રૂટ ડિરેક્ટરી (Linux/Mac) & \texttt{/home/user/} \\
\textbf{C:\textbackslash{}} & ડ્રાઈવ લેટર (Windows) &
\texttt{C:\textbackslash{}\textbackslash{}Users\textbackslash{}\textbackslash{}Documents\textbackslash{}\textbackslash{}} \\
\textbf{.} & વર્તમાન ડિરેક્ટરી & \texttt{./file.txt} \\
\textbf{..} & પેરન્ટ ડિરેક્ટરી & \texttt{../folder/file.txt} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{એબ્સોલ્યુટ}: સિસ્ટમ રૂટથી સંપૂર્ણ પાથ
\item
  \textbf{રિલેટિવ}: વર્તમાન વર્કિંગ ડિરેક્ટરીથી પાથ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``એબ્સોલ્યુટ રૂટથી, રિલેટિવ વર્તમાનથી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ OR) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{બાયનરી અને ટેક્સ્ટ ફાઇલ ખોલવાના વિવિધ મોડ સમજાવો.}

\begin{solutionbox}

\textbf{ફાઈલ ઓપનિંગ મોડ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\textbf{મોડ} & \textbf{ટાઈપ} & \textbf{હેતુ} & \textbf{ફાઈલ પોઈન્ટર} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{`r'} & ટેક્સ્ટ & ફક્ત વાંચવા & શરૂઆત \\
\textbf{`w'} & ટેક્સ્ટ & લખવા (ઓવરરાઈટ) & શરૂઆત \\
\textbf{`a'} & ટેક્સ્ટ & ઉમેરવા & અંત \\
\textbf{`rb'} & બાઈનરી & બાઈનરી વાંચવા & શરૂઆત \\
\textbf{`wb'} & બાઈનરી & બાઈનરી લખવા & શરૂઆત \\
\textbf{`ab'} & બાઈનરી & બાઈનરી ઉમેરવા & અંત \\
\textbf{`r+'} & ટેક્સ્ટ & વાંચવા અને લખવા & શરૂઆત \\
\textbf{`w+'} & ટેક્સ્ટ & લખવા અને વાંચવા & શરૂઆત \\
\end{longtable}
}

\begin{verbatim}
\# વિવિધ ફાઈલ મોડ્સના ઉદાહરણો
def demonstrate\_file\_modes():
    
    \# ટેક્સ્ટ ફાઈલ મોડ્સ
    with open("text\_file.txt", "w") as f:  \# રાઈટ મોડ
        f.write("નમસ્તે વિશ્વ")
    
    with open("text\_file.txt", "r") as f:  \# રીડ મોડ
        content = f.read()
        print(f"ટેક્સ્ટ કન્ટેન્ટ: \{content\}")
    
    \# બાઈનરી ફાઈલ મોડ્સ
    data = b"Binary data example"
    with open("binary\_file.bin", "wb") as f:  \# બાઈનરી રાઈટ
        f.write(data)
    
    with open("binary\_file.bin", "rb") as f:  \# બાઈનરી રીડ
        binary\_content = f.read()
        print(f"બાઈનરી કન્ટેન્ટ: \{binary\_content\}")

demonstrate\_file\_modes()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ટેક્સ્ટ મોડ્સ}: એન્કોડિંગ સાથે સ્ટ્રિંગ ડેટા હેન્ડલ કરે
\item
  \textbf{બાઈનરી મોડ્સ}: એન્કોડિંગ વગર રો બાઈટ્સ હેન્ડલ કરે
\item
  \textbf{પ્લસ મોડ્સ}: રીડિંગ અને રાઈટિંગ બંનેની મંજૂરી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ટેક્સ્ટ સ્ટ્રિંગ્સ માટે, બાઈનરી બાઈટ્સ માટે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક OR) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{વિદ્યાર્થીના વિષય રેકોર્ડ જેવાં કે શાખાનું નામ, સેમેસ્ટર, વિષયનો કોડ અને
વિષયનું નામ બાઇનરી ફાઇલમાં લખવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
import pickle
import os

class StudentSubjectRecord:
    """વિદ્યાર્થી વિષય રેકોર્ડ હેન્ડલ કરવા માટેનો ક્લાસ"""
    
    def \_\_init\_\_(self, branch\_name, semester, subject\_code, subject\_name):
        self.branch\_name = branch\_name
        self.semester = semester
        self.subject\_code = subject\_code
        self.subject\_name = subject\_name
    
    def \_\_str\_\_(self):
        return f"શાખા: \{self.branch\_name\}, સેમેસ્ટર: \{self.semester\}, કોડ: \{self.subject\_code\}, વિષય: \{self.subject\_name\}"

def write\_student\_records():
    """વિદ્યાર્થી રેકોર્ડ્સ બાઈનરી ફાઈલમાં લખો"""
    
    \# સેમ્પલ વિદ્યાર્થી રેકોર્ડ્સ
    records = [
        StudentSubjectRecord("ઈન્ફોર્મેશન ટેક્નોલોજી", 2, "4321602", "એડવાન્સ પાયથન પ્રોગ્રામિંગ"),
        StudentSubjectRecord("ઈન્ફોર્મેશન ટેક્નોલોજી", 2, "4321601", "ડેટાબેસ મેનેજમેન્ટ સિસ્ટમ"),
        StudentSubjectRecord("કમ્પ્યુટર એન્જિનિયરિંગ", 3, "4330701", "ડેટા સ્ટ્રક્ચર"),
        StudentSubjectRecord("ઈન્ફોર્મેશન ટેક્નોલોજી", 2, "4321603", "વેબ ડેવલપમેન્ટ"),
        StudentSubjectRecord("કમ્પ્યુટર એન્જિનિયરિંગ", 3, "4330702", "કમ્પ્યુટર નેટવર્ક્સ")
    ]
    
    \# pickle વાપરીને રેકોર્ડ્સને બાઈનરી ફાઈલમાં લખો
    try:
        with open("student\_records.bin", "wb") as binary\_file:
            pickle.dump(records, binary\_file)
        
        print("✓ વિદ્યાર્થી રેકોર્ડ્સ બાઈનરી ફાઈલમાં સફળતાપૂર્વક લખાયા!")
        print(f"✓ કુલ લખાયેલા રેકોર્ડ્સ: \{len(records)\}")
        
    except Exception as e:
        print(f"✗ બાઈનરી ફાઈલમાં લખવામાં એરર: \{e\}")

def read\_student\_records():
    """બાઈનરી ફાઈલમાંથી વિદ્યાર્થી રેકોર્ડ્સ વાંચો"""
    
    try:
        if not os.path.exists("student\_records.bin"):
            print("✗ બાઈનરી ફાઈલ મળી નહીં!")
            return
        
        with open("student\_records.bin", "rb") as binary\_file:
            records = pickle.load(binary\_file)
        
        print("{n}" + "="*60)
        print("બાઈનરી ફાઈલમાંથી વિદ્યાર્થી વિષય રેકોર્ડ્સ")
        print("="*60)
        
        for i, record in enumerate(records, 1):
            print(f"\{i\}. \{record\}")
        
        print("="*60)
        print(f"કુલ વાંચેલા રેકોર્ડ્સ: \{len(records)\}")
        
    except Exception as e:
        print(f"✗ બાઈનરી ફાઈલમાંથી વાંચવામાં એરર: \{e\}")

def add\_new\_record():
    """હાલની બાઈનરી ફાઈલમાં નવો વિદ્યાર્થી રેકોર્ડ ઉમેરો"""
    
    try:
        \# હાલના રેકોર્ડ્સ વાંચો
        records = []
        if os.path.exists("student\_records.bin"):
            with open("student\_records.bin", "rb") as binary\_file:
                records = pickle.load(binary\_file)
        
        \# નવા રેકોર્ડની વિગતો મેળવો
        print("{n}નવા વિદ્યાર્થી રેકોર્ડની વિગતો દાખલ કરો:")
        branch = input("શાખાનું નામ: ")
        semester = int(input("સેમેસ્ટર: "))
        code = input("વિષયનો કોડ: ")
        subject = input("વિષયનું નામ: ")
        
        \# નવો રેકોર્ડ બનાવો
        new\_record = StudentSubjectRecord(branch, semester, code, subject)
        records.append(new\_record)
        
        \# ફાઈલમાં પાછું લખો
        with open("student\_records.bin", "wb") as binary\_file:
            pickle.dump(records, binary\_file)
        
        print("✓ નવો રેકોર્ડ સફળતાપૂર્વક ઉમેર્યો!")
        
    except Exception as e:
        print(f"✗ નવો રેકોર્ડ ઉમેરવામાં એરર: \{e\}")

def search\_records\_by\_branch(branch\_name):
    """શાખાના નામ દ્વારા રેકોર્ડ્સ શોધો"""
    
    try:
        if not os.path.exists("student\_records.bin"):
            print("✗ બાઈનરી ફાઈલ મળી નહીં!")
            return
        
        with open("student\_records.bin", "rb") as binary\_file:
            records = pickle.load(binary\_file)
        
        \# શાખા દ્વારા રેકોર્ડ્સ ફિલ્ટર કરો
        filtered\_records = [record for record in records 
                          if record.branch\_name.lower() == branch\_name.lower()]
        
        if filtered\_records:
            print(f"{n}\{branch\_name\} માટેના રેકોર્ડ્સ:")
            print("{-"} * 40)
            for record in filtered\_records:
                print(f"  \{record\}")
        else:
            print(f"શાખા માટે કોઈ રેકોર્ડ મળ્યો નહીં: \{branch\_name\}")
            
    except Exception as e:
        print(f"✗ રેકોર્ડ્સ શોધવામાં એરર: \{e\}")

\# મુખ્ય પ્રોગ્રામ એક્ઝિક્યુશન
def main():
    """બાઈનરી ફાઈલ ઓપરેશન્સ દર્શાવવા માટેનું મુખ્ય ફંક્શન"""
    
    print("=== વિદ્યાર્થી વિષય રેકોર્ડ મેનેજમેન્ટ ==={n}")
    
    \# શરૂઆતના રેકોર્ડ્સ લખો
    print("1. બાઈનરી ફાઈલમાં વિદ્યાર્થી રેકોર્ડ્સ લખી રહ્યા છીએ...")
    write\_student\_records()
    
    \# રેકોર્ડ્સ વાંચો અને દર્શાવો
    print("{n}2. બાઈનરી ફાઈલમાંથી રેકોર્ડ્સ વાંચી રહ્યા છીએ...")
    read\_student\_records()
    
    \# શાખા દ્વારા શોધો
    print("{n}3. શાખા દ્વારા રેકોર્ડ્સ શોધી રહ્યા છીએ...")
    search\_records\_by\_branch("ઈન્ફોર્મેશન ટેક્નોલોજી")
    
    \# ફાઈલની માહિતી દર્શાવો
    if os.path.exists("student\_records.bin"):
        file\_size = os.path.getsize("student\_records.bin")
        print(f"{n}બાઈનરી ફાઈલ સાઈઝ: \{file\_size\} બાઈટ્સ")

\# પ્રોગ્રામ એક્ઝિક્યુટ કરો
if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\textbf{બાઈનરી ફાઈલ ઓપરેશન્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{ઓપરેશન} & \textbf{મેથડ} & \textbf{હેતુ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{લખવું} & \texttt{pickle.dump()} & ઓબ્જેક્ટ્સને બાઈનરીમાં સીરિયલાઈઝ \\
\textbf{વાંચવું} & \texttt{pickle.load()} & બાઈનરીમાંથી ઓબ્જેક્ટ્સ
ડીસીરિયલાઈઝ \\
\textbf{ઉમેરવું} & વાંચવું + ઉમેરવું + લખવું & નવા રેકોર્ડ્સ ઉમેરો \\
\textbf{શોધવું} & લોડ કરેલો ડેટા ફિલ્ટર & ચોક્કસ રેકોર્ડ્સ શોધો \\
\end{longtable}
}

\textbf{બાઈનરી ફાઈલ સ્ટ્રક્ચર:}

\begin{verbatim}
flowchart LR
    A[વિદ્યાર્થી રેકોર્ડ્સ] {-{-} B["pickle.dump()"]}
    B {-{-} C[બાઈનરી ફાઈલ .bin]}
    C {-{-} D["pickle.load()"]}
    D {-{-} E[Python ઓબ્જેક્ટ્સ]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{બાઈનરી સ્ટોરેજ}: ઓબ્જેક્ટ સીરિયલાઈઝેશન માટે pickle વાપરે
\item
  \textbf{કાર્યક્ષમ સ્ટોરેજ}: કોમ્પેક્ટ બાઈનરી ફોર્મેટ
\item
  \textbf{ઓબ્જેક્ટ પ્રિઝર્વેશન}: ડેટા સ્ટ્રક્ચર ઈન્ટેગ્રિટી જાળવે
\item
  \textbf{ક્રોસ-પ્લેટફોર્મ}: વિવિધ ઓપરેટિંગ સિસ્ટમ્સ પર કામ કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Pickle Python ઓબ્જેક્ટ્સ પ્રિઝર્વ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{વ્યાખ્યાયિત કરો: GUI, CLI}

\begin{solutionbox}

\textbf{ઈન્ટરફેસ વ્યાખ્યાઓનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1837}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3061}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2449}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2653}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{શબ્દ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{પૂરું નામ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{વર્ણન}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉદાહરણ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{GUI} & Graphical User Interface & વિન્ડોઝ, બટન્સ, આઈકોન્સ સાથે
વિઝ્યુઅલ ઈન્ટરફેસ & Windows, Mac ડેસ્કટોપ \\
\textbf{CLI} & Command Line Interface & કમાન્ડ્સ વાપરીને ટેક્સ્ટ-આધારિત ઈન્ટરફેસ
& ટર્મિનલ, કમાન્ડ પ્રોમ્પ્ટ \\
\end{longtable}
}

\textbf{મુખ્ય તફાવતો:}

\begin{itemize}
\tightlist
\item
  \textbf{GUI}: યુઝર-ફ્રેન્ડલી, માઉસ-ડ્રિવન, વિઝ્યુઅલ એલિમેન્ટ્સ
\item
  \textbf{CLI}: ટેક્સ્ટ-આધારિત, કીબોર્ડ-ડ્રિવન, કમાન્ડ સિન્ટેક્સ
\item
  \textbf{ઈન્ટરેક્શન}: GUI ક્લિક્સ વાપરે, CLI ટાઈપ કરેલા કમાન્ડ્સ વાપરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``GUI ગ્રાફિક્સ, CLI કમાન્ડ્સ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{ટર્ટલનો ઉપયોગ કરીને for અને while લૂપનો ઉપયોગ કરીને ચોરસ આકાર દોરવા
માટે પાયથોન પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
import turtle

def draw\_square\_with\_for\_loop():
    """for લૂપ વાપરીને ચોરસ દોરો"""
    
    \# ટર્ટલ સેટઅપ
    screen = turtle.Screen()
    screen.bgcolor("white")
    square\_turtle = turtle.Turtle()
    square\_turtle.color("blue")
    square\_turtle.pensize(3)
    
    \# for લૂપ વાપરીને ચોરસ દોરો
    print("for લૂપ વાપરીને ચોરસ દોરી રહ્યા છીએ...")
    side\_length = 100
    
    for i in range(4):
        square\_turtle.forward(side\_length)
        square\_turtle.right(90)
    
    square\_turtle.penup()
    square\_turtle.goto(150, 0)
    square\_turtle.pendown()
    
    return square\_turtle

def draw\_square\_with\_while\_loop(turtle\_obj):
    """while લૂપ વાપરીને ચોરસ દોરો"""
    
    \# બીજા ચોરસ માટે રંગ બદલો
    turtle\_obj.color("red")
    
    \# while લૂપ વાપરીને ચોરસ દોરો
    print("while લૂપ વાપરીને ચોરસ દોરી રહ્યા છીએ...")
    side\_length = 100
    sides\_drawn = 0
    
    while sides\_drawn {} 4:
        turtle\_obj.forward(side\_length)
        turtle\_obj.right(90)
        sides\_drawn += 1
    
    \# ટેક્સ્ટ માટે ટર્ટલને સેન્ટરમાં મૂવ કરો
    turtle\_obj.penup()
    turtle\_obj.goto({-}50, {-}150)
    turtle\_obj.write("નીલો: for લૂપ, લાલ: while લૂપ", 
                    font=("Arial", 12, "normal"))

\# મુખ્ય એક્ઝિક્યુશન
def main():
    \# ચોરસ દોરો
    turtle\_obj = draw\_square\_with\_for\_loop()
    draw\_square\_with\_while\_loop(turtle\_obj)
    
    \# વિન્ડો ખુલ્લી રાખો
    turtle.Screen().exitonclick()

\# પ્રોગ્રામ ચલાવો
main()
\end{verbatim}

\textbf{લૂપ કમ્પેરિઝનનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\textbf{લૂપ ટાઈપ} & \textbf{સ્ટ્રક્ચર} & \textbf{ઉપયોગ} & \textbf{કંટ્રોલ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{for લૂપ} & \texttt{for\ i\ in\ range(4):} & જાણીતા ઈટરેશન્સ &
કાઉન્ટર-આધારિત \\
\textbf{while લૂપ} & \texttt{while\ condition:} & કન્ડિશનલ ઈટરેશન્સ &
કન્ડિશન-આધારિત \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{for લૂપ}: જાણીતી સંખ્યાના ઈટરેશન્સ માટે શ્રેષ્ઠ
\item
  \textbf{while લૂપ}: કન્ડિશન-આધારિત રિપેટિશન માટે શ્રેષ્ઠ
\item
  \textbf{બંને અચીવ કરે}: એક જ ચોરસ દોરવાનું પરિણામ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``For કાઉન્ટ, While કન્ડિશન''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{ટર્ટલનો ઉપયોગ કરીને ચેસબોર્ડ દોરવા માટે પાયથોન પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
import turtle

def setup\_chessboard():
    """ચેસબોર્ડ માટે ટર્ટલ સ્ક્રીન અને પ્રોપર્ટીઝ સેટઅપ કરો"""
    
    screen = turtle.Screen()
    screen.bgcolor("white")
    screen.title("Python ટર્ટલ વાપરીને ચેસબોર્ડ")
    screen.setup(width=600, height=600)
    
    \# ડ્રોઈંગ માટે ટર્ટલ બનાવો
    chess\_turtle = turtle.Turtle()
    chess\_turtle.speed(0)  \# સૌથી ઝડપી સ્પીડ
    chess\_turtle.penup()
    
    return screen, chess\_turtle

def draw\_square(turtle\_obj, size, fill\_color):
    """આપેલા રંગ સાથે એક ચોરસ દોરો"""
    
    turtle\_obj.pendown()
    turtle\_obj.fillcolor(fill\_color)
    turtle\_obj.begin\_fill()
    
    \# ચોરસ દોરો
    for \_ in range(4):
        turtle\_obj.forward(size)
        turtle\_obj.right(90)
    
    turtle\_obj.end\_fill()
    turtle\_obj.penup()

def draw\_chessboard():
    """સંપૂર્ણ 8x8 ચેસબોર્ડ દોરો"""
    
    screen, chess\_turtle = setup\_chessboard()
    
    \# ચેસબોર્ડ પેરામીટર્સ
    square\_size = 40
    board\_size = 8
    start\_x = {-}160
    start\_y = 160
    
    print("ચેસબોર્ડ દોરી રહ્યા છીએ...")
    
    \# બોર્ડ દોરો
    for row in range(board\_size):
        for col in range(board\_size):
            
            \# પોઝિશન ગણો
            x = start\_x + (col * square\_size)
            y = start\_y {-} (row * square\_size)
            
            \# ટર્ટલને પોઝિશન પર મૂવ કરો
            chess\_turtle.goto(x, y)
            
            \# ચોરસનો રંગ નક્કી કરો (અલ્ટર્નેટિંગ પેટર્ન)
            if (row + col) \% 2 == 0:
                color = "white"
            else:
                color = "black"
            
            \# ચોરસ દોરો
            draw\_square(chess\_turtle, square\_size, color)
    
    \# ચેસબોર્ડની આસપાસ બોર્ડર ઉમેરો
    draw\_border(chess\_turtle, start\_x, start\_y, square\_size, board\_size)
    
    \# લેબલ્સ ઉમેરો
    add\_chessboard\_labels(chess\_turtle, start\_x, start\_y, square\_size, board\_size)
    
    return screen

def draw\_border(turtle\_obj, start\_x, start\_y, square\_size, board\_size):
    """ચેસબોર્ડની આસપાસ બોર્ડર દોરો"""
    
    turtle\_obj.goto(start\_x {-} 5, start\_y + 5)
    turtle\_obj.pencolor("brown")
    turtle\_obj.pensize(3)
    turtle\_obj.pendown()
    
    \# બોર્ડર રેક્ટેંગલ દોરો
    border\_width = board\_size * square\_size + 10
    border\_height = board\_size * square\_size + 10
    
    for \_ in range(2):
        turtle\_obj.forward(border\_width)
        turtle\_obj.right(90)
        turtle\_obj.forward(border\_height)
        turtle\_obj.right(90)
    
    turtle\_obj.penup()
    turtle\_obj.pensize(1)
    turtle\_obj.pencolor("black")

def add\_chessboard\_labels(turtle\_obj, start\_x, start\_y, square\_size, board\_size):
    """ચેસબોર્ડમાં રો અને કોલમ લેબલ્સ ઉમેરો"""
    
    turtle\_obj.color("blue")
    
    \# કોલમ લેબલ્સ (A{-H)}
    columns = [{A}, {B}, {C}, {D}, {E}, {F}, {G}, {H}]
    for i, letter in enumerate(columns):
        x = start\_x + (i * square\_size) + (square\_size // 2)
        y = start\_y {-} (board\_size * square\_size) {-} 20
        turtle\_obj.goto(x, y)
        turtle\_obj.write(letter, align="center", font=("Arial", 12, "bold"))
    
    \# રો લેબલ્સ (1{-8)}
    for i in range(board\_size):
        x = start\_x {-} 20
        y = start\_y {-} (i * square\_size) {-} (square\_size // 2)
        turtle\_obj.goto(x, y)
        turtle\_obj.write(str(8{-}i), align="center", font=("Arial", 12, "bold"))
    
    \# શીર્ષક
    turtle\_obj.goto(0, start\_y + 30)
    turtle\_obj.write("Python ટર્ટલ ચેસબોર્ડ", align="center", 
                    font=("Arial", 16, "bold"))

def draw\_enhanced\_chessboard\_with\_pieces():
    """ચેસ પીસ ઈન્ડિકેટર્સ સાથે એન્હાન્સ વર્ઝન"""
    
    screen = draw\_chessboard()
    
    \# પીસીસ માટે નવો ટર્ટલ બનાવો
    piece\_turtle = turtle.Turtle()
    piece\_turtle.speed(0)
    piece\_turtle.penup()
    
    \# કેટલાક પીસ સિમ્બોલ્સ ઉમેરો (સિમ્પ્લિફાઈડ)
    pieces = [
        ({-}120, 120, "♜"), ({-}80, 120, "♞"), ({-}40, 120, "♝"), (0, 120, "♛"),
        ({-}120, {-}120, "♖"), ({-}80, {-}120, "♘"), ({-}40, {-}120, "♗"), (0, {-}120, "♕")
    ]
    
    piece\_turtle.color("red")
    for x, y, symbol in pieces:
        piece\_turtle.goto(x, y)
        piece\_turtle.write(symbol, align="center", font=("Arial", 20, "normal"))
    
    piece\_turtle.hideturtle()
    
    \# આંકડાકીય માહિતી દર્શાવો
    total\_squares = 64
    black\_squares = 32
    white\_squares = 32
    
    piece\_turtle.goto(0, {-}200)
    piece\_turtle.color("green")
    piece\_turtle.write(f"ચેસબોર્ડ: \{total\_squares\} ચોરસ (\{black\_squares\} કાળા, \{white\_squares\} સફેદ)", 
                      align="center", font=("Arial", 12, "normal"))
    
    return screen

\# મુખ્ય એક્ઝિક્યુશન
def main():
    """ચેસબોર્ડ બનાવવા માટેનું મુખ્ય ફંક્શન"""
    
    print("Python ટર્ટલ વાપરીને ચેસબોર્ડ બનાવી રહ્યા છીએ...")
    screen = draw\_enhanced\_chessboard\_with\_pieces()
    
    print("ચેસબોર્ડ સફળતાપૂર્વક બનાવ્યું!")
    print("વિન્ડો બંધ કરવા માટે સ્ક્રીન પર ક્લિક કરો.")
    
    \# ક્લિક કરવામાં આવે ત્યાં સુધી વિન્ડો ખુલ્લી રાખો
    screen.exitonclick()

\# પ્રોગ્રામ ચલાવો
if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\textbf{ચેસબોર્ડ કોમ્પોનન્ટ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{કોમ્પોનન્ટ} & \textbf{ઇમ્પ્લિમેન્ટેશન} & \textbf{હેતુ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ચોરસ} & 8x8 ગ્રિડ ઓલ્ટર્નેટિંગ કલર્સ & મુખ્ય બોર્ડ પેટર્ન \\
\textbf{રંગો} & કાળો અને સફેદ ઓલ્ટર્નેટિંગ & પરંપરાગત ચેસ પેટર્ન \\
\textbf{બોર્ડર} & બ્રાઉન રેક્ટેંગલ આઉટલાઈન & બોર્ડને ફ્રેમ કરો \\
\textbf{લેબલ્સ} & A-H કોલમ્સ, 1-8 રોઝ & ચેસ નોટેશન \\
\textbf{પીસીસ} & યુનિકોડ ચેસ સિમ્બોલ્સ & સેમ્પલ પીસ પ્લેસમેન્ટ \\
\end{longtable}
}

\textbf{ચેસબોર્ડ પેટર્ન લોજિક:}

\begin{verbatim}
flowchart LR
    A[રો 0 શરૂ] {-{-} B\{દરેક રો માટે\}}
    B {-{-} C\{દરેક કોલમ માટે\}}
    C {-{-} D\{row + col સમ?\}}
    D {-{-}|હા| E[સફેદ ચોરસ]}
    D {-{-}|ના| F[કાળો ચોરસ]}
    E {-{-} G[આગળનો કોલમ]}
    F {-{-} G}
    G {-{-} C}
    C {-{-}|રો પૂર્ણ| H[આગળનો રો]}
    H {-{-} B}
    B {-{-}|બધા રો પૂર્ણ| I[સંપૂર્ણ બોર્ડ]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઓલ્ટર્નેટિંગ પેટર્ન}: (row + col) \% 2 રંગ નક્કી કરે
\item
  \textbf{ગ્રિડ સિસ્ટમ}: ચોક્કસ પોઝિશનિંગ સાથે 8x8 ચોરસ
\item
  \textbf{વિઝ્યુઅલ એન્હાન્સમેન્ટ્સ}: બોર્ડર, લેબલ્સ અને સેમ્પલ પીસીસ
\item
  \textbf{સ્કેલેબલ ડિઝાઈન}: ચોરસ સાઈઝ મોડિફાઈ કરવું સરળ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ગ્રિડ પેટર્નમાં ઓલ્ટર્નેટ કલર્સ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ OR) [3
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{ટર્ટલમાં કેટલા પ્રકારના આકાર હોય છે? કોઈપણ એક આકાર યોગ્ય ઉદાહરણ સાથે
સમજાવો.}

\begin{solutionbox}

\textbf{ટર્ટલ શેપ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{શેપ ટાઈપ} & \textbf{ઉદાહરણો} & \textbf{મેથડ} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બેસિક શેપ્સ} & વતુળ, ચોરસ, ત્રિકોણ & બિલ્ટ-ઇન ફંક્શન્સ \\
\textbf{લાઈન પેટર્ન્સ} & સીધી લાઈનો, કર્વ્સ & forward(), backward() \\
\textbf{પોલિગોન્સ} & પંચકોણ, ષટકોણ, અષ્ટકોણ & એંગલ્સ સાથે લૂપ \\
\textbf{કોમ્પ્લેક્સ શેપ્સ} & તારા, સ્પાઈરલ્સ, ફ્રેક્ટલ્સ & ગાણિતિક પેટર્ન્સ \\
\textbf{કસ્ટમ શેપ્સ} & યુઝર-ડિફાઈન્ડ પેટર્ન્સ & મૂવમેન્ટ્સનું કોમ્બિનેશન \\
\end{longtable}
}

\textbf{વતુળ શેપ ઉદાહરણ:}

\begin{verbatim}
import turtle

def draw\_circle\_example():
    screen = turtle.Screen()
    circle\_turtle = turtle.Turtle()
    
    \# 50 ત્રિજ્યા સાથે વતુળ દોરો
    circle\_turtle.circle(50)
    
    screen.exitonclick()

draw\_circle\_example()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{બિલ્ટ-ઇન શેપ્સ}: વતુળ, ચોરસ, ત્રિકોણ સહેલાઈથી ઉપલબ્ધ
\item
  \textbf{કસ્ટમ શેપ્સ}: મૂવમેન્ટ કોમ્બિનેશન વાપરીને બનાવાય
\item
  \textbf{ગાણિતિક શેપ્સ}: ચોક્કસ ડ્રોઈંગ માટે ભૂમિતિ વાપરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ટર્ટલ ઘણા શેપ ટાઈપ્સ દોરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ OR) [4
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{ટર્ટલ મોડ્યુલની ચાર મૂળભૂત પદ્ધતિઓ વિશે સમજાવો.}

\begin{solutionbox}

\textbf{બેસિક ટર્ટલ મેથડ્સનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{મેથડ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{હેતુ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{પેરામીટર્સ}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{ઉદાહરણ}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{forward(distance)} & ટર્ટલને આગળ ખસેડો & પિક્સલ્સમાં અંતર &
\texttt{turtle.forward(100)} \\
\textbf{backward(distance)} & ટર્ટલને પાછળ ખસેડો & પિક્સલ્સમાં અંતર &
\texttt{turtle.backward(50)} \\
\textbf{right(angle)} & ટર્ટલને જમણે ફેરવો & ડિગ્રીમાં એંગલ &
\texttt{turtle.right(90)} \\
\textbf{left(angle)} & ટર્ટલને ડાબે ફેરવો & ડિગ્રીમાં એંગલ &
\texttt{turtle.left(45)} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_basic\_methods():
    \# ટર્ટલ બનાવો
    demo\_turtle = turtle.Turtle()
    
    \# 1. આગળની મૂવમેન્ટ
    demo\_turtle.forward(100)  \# 100 પિક્સલ્સ આગળ મૂવ કરો
    
    \# 2. જમણે ટર્ન
    demo\_turtle.right(90)     \# 90 ડિગ્રી જમણે ટર્ન કરો
    
    \# 3. પાછળની મૂવમેન્ટ  
    demo\_turtle.backward(50)  \# 50 પિક્સલ્સ પાછળ મૂવ કરો
    
    \# 4. ડાબે ટર્ન
    demo\_turtle.left(135)     \# 135 ડિગ્રી ડાબે ટર્ન કરો
    
    turtle.done()

demonstrate\_basic\_methods()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મૂવમેન્ટ મેથડ્સ}: અંતર માટે forward() અને backward()
\item
  \textbf{રોટેશન મેથડ્સ}: દિશા બદલવા માટે right() અને left()
\item
  \textbf{કોઓર્ડિનેટ સિસ્ટમ}: વર્તમાન ટર્ટલ પોઝિશન અને હેડિંગ આધારિત
\item
  \textbf{એંગલ મેઝરમેન્ટ}: ડિગ્રીઝ (0-360)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``આગળ, પાછળ, જમણે, ડાબે બેસિક્સ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક OR) [7
માર્ક્સ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{ટર્ટલનો ઉપયોગ કરીને ચોરસ, લાંબચોરસ અને વતુળ દોરવા માટે પાયથોન પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\begin{verbatim}
import turtle
import math

def setup\_drawing\_environment():
    """ટર્ટલ સ્ક્રીન અને ડ્રોઈંગ એન્વાયરનમેન્ટ સેટઅપ કરો"""
    
    screen = turtle.Screen()
    screen.bgcolor("lightblue")
    screen.title("આકાર દોરવા: ચોરસ, લાંબચોરસ, વતુળ")
    screen.setup(width=800, height=600)
    
    \# મુખ્ય ડ્રોઈંગ ટર્ટલ બનાવો
    shape\_turtle = turtle.Turtle()
    shape\_turtle.speed(3)
    shape\_turtle.pensize(2)
    
    return screen, shape\_turtle

def draw\_square(turtle\_obj, size, color, position):
    """આપેલા સાઈઝ અને કલર સાથે ચોરસ દોરો"""
    
    x, y = position
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    turtle\_obj.begin\_fill()
    
    \# 4 સમાન બાજુઓ વાપરીને ચોરસ દોરો
    for \_ in range(4):
        turtle\_obj.forward(size)
        turtle\_obj.right(90)
    
    turtle\_obj.end\_fill()
    
    \# લેબલ ઉમેરો
    turtle\_obj.penup()
    turtle\_obj.goto(x + size//2, y {-} 30)
    turtle\_obj.color("black")
    turtle\_obj.write(f"ચોરસ (\{size\}x\{size\})", align="center", 
                    font=("Arial", 10, "bold"))

def draw\_rectangle(turtle\_obj, width, height, color, position):
    """આપેલા dimensions અને કલર સાથે લાંબચોરસ દોરો"""
    
    x, y = position
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    turtle\_obj.begin\_fill()
    
    \# લંબાઈ અને પહોળાઈ બદલીને લાંબચોરસ દોરો
    for \_ in range(2):
        turtle\_obj.forward(width)
        turtle\_obj.right(90)
        turtle\_obj.forward(height)
        turtle\_obj.right(90)
    
    turtle\_obj.end\_fill()
    
    \# લેબલ ઉમેરો
    turtle\_obj.penup()
    turtle\_obj.goto(x + width//2, y {-} height {-} 20)
    turtle\_obj.color("black")
    turtle\_obj.write(f"લાંબચોરસ (\{width\}x\{height\})", align="center", 
                    font=("Arial", 10, "bold"))

def draw\_circle(turtle\_obj, radius, color, position):
    """આપેલા ત્રિજ્યા અને કલર સાથે વતુળ દોરો"""
    
    x, y = position
    turtle\_obj.penup()
    turtle\_obj.goto(x, y {-} radius)  \# વતુળના તળિયે પોઝિશન
    turtle\_obj.pendown()
    
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    turtle\_obj.begin\_fill()
    
    \# વતુળ દોરો
    turtle\_obj.circle(radius)
    
    turtle\_obj.end\_fill()
    
    \# ક્ષેત્રફળ ગણતરી સાથે લેબલ ઉમેરો
    area = math.pi * radius * radius
    turtle\_obj.penup()
    turtle\_obj.goto(x, y {-} radius {-} 30)
    turtle\_obj.color("black")
    turtle\_obj.write(f"વતુળ (r=\{radius\}, ક્ષેત્રફળ=\{area:.1f\})", align="center", 
                    font=("Arial", 10, "bold"))

def draw\_all\_shapes():
    """ત્રણેય આકાર દોરવા માટેનું મુખ્ય ફંક્શન"""
    
    screen, shape\_turtle = setup\_drawing\_environment()
    
    print("ભૌમિતિક આકાર દોરી રહ્યા છીએ...")
    
    \# ચોરસ દોરો
    print("1. ચોરસ દોરી રહ્યા છીએ...")
    draw\_square(shape\_turtle, 80, "red", ({-}300, 100))
    
    \# લાંબચોરસ દોરો  
    print("2. લાંબચોરસ દોરી રહ્યા છીએ...")
    draw\_rectangle(shape\_turtle, 120, 80, "green", ({-}50, 100))
    
    \# વતુળ દોરો
    print("3. વતુળ દોરી રહ્યા છીએ...")
    draw\_circle(shape\_turtle, 60, "blue", (200, 100))
    
    \# શીર્ષક અને માહિતી ઉમેરો
    add\_shape\_information(shape\_turtle)
    
    print("બધા આકાર સફળતાપૂર્વક દોર્યા!")
    return screen

def add\_shape\_information(turtle\_obj):
    """શીર્ષક અને આકારની માહિતી ઉમેરો"""
    
    \# શીર્ષક
    turtle\_obj.penup()
    turtle\_obj.goto(0, 200)
    turtle\_obj.color("purple")
    turtle\_obj.write("Python ટર્ટલ આકારો", align="center", 
                    font=("Arial", 18, "bold"))
    
    \# આકારની પ્રોપર્ટીઝ ટેબલ
    turtle\_obj.goto({-}350, {-}50)
    turtle\_obj.color("black")
    turtle\_obj.write("આકારની પ્રોપર્ટીઝ:", font=("Arial", 12, "bold"))
    
    properties = [
        "• ચોરસ: 4 સમાન બાજુઓ, 4 કાટકોણ",
        "• લાંબચોરસ: 4 બાજુઓ, સામેની બાજુઓ સમાન", 
        "• વતુળ: કેન્દ્રથી બધા બિંદુઓ સમાન અંતરે"
    ]
    
    for i, prop in enumerate(properties):
        turtle\_obj.goto({-}350, {-}80 {-} (i * 20))
        turtle\_obj.write(prop, font=("Arial", 10, "normal"))
    
    \# ગાણિતિક સૂત્રો
    turtle\_obj.goto({-}350, {-}170)
    turtle\_obj.color("blue")
    turtle\_obj.write("સૂત્રો:", font=("Arial", 12, "bold"))
    
    formulas = [
        "• ચોરસ ક્ષેત્રફળ: બાજુ^{2"},
        "• લાંબચોરસ ક્ષેત્રફળ: લંબાઈ  પહોળાઈ",
        "• વતુળ ક્ષેત્રફળ: π  ત્રિજ્યા^{2"}
    ]
    
    for i, formula in enumerate(formulas):
        turtle\_obj.goto({-}350, {-}200 {-} (i * 20))
        turtle\_obj.write(formula, font=("Arial", 10, "normal"))

def interactive\_shape\_drawer():
    """યુઝર ઇન્ટરેક્શન સાથે એન્હાન્સ વર્ઝન"""
    
    screen, shape\_turtle = setup\_drawing\_environment()
    
    \# યુઝર પ્રાથમિકતાઓ મેળવો
    print("{n}=== ઇન્ટરેક્ટિવ આકાર ડ્રોવર ===")
    
    try:
        \# ચોરસ પેરામીટર્સ
        square\_size = int(input("ચોરસ સાઈઝ દાખલ કરો (50{-100): "}) or "80")
        square\_color = input("ચોરસ રંગ દાખલ કરો (લાલ/નીલો/લીલો): ") or "red"
        
        \# લાંબચોરસ પેરામીટર્સ  
        rect\_width = int(input("લાંબચોરસ પહોળાઈ દાખલ કરો (80{-150): "}) or "120")
        rect\_height = int(input("લાંબચોરસ ઊંચાઈ દાખલ કરો (60{-100): "}) or "80")
        rect\_color = input("લાંબચોરસ રંગ દાખલ કરો: ") or "green"
        
        \# વતુળ પેરામીટર્સ
        circle\_radius = int(input("વતુળ ત્રિજ્યા દાખલ કરો (40{-80): "}) or "60")
        circle\_color = input("વતુળ રંગ દાખલ કરો: ") or "blue"
        
        \# યુઝર પેરામીટર્સ સાથે આકાર દોરો
        draw\_square(shape\_turtle, square\_size, square\_color, ({-}300, 100))
        draw\_rectangle(shape\_turtle, rect\_width, rect\_height, rect\_color, ({-}50, 100))
        draw\_circle(shape\_turtle, circle\_radius, circle\_color, (200, 100))
        
        add\_shape\_information(shape\_turtle)
        
    except ValueError:
        print("અમાન્ય ઇનપુટ! ડિફોલ્ટ વેલ્યુઝ વાપરી રહ્યા છીએ...")
        return draw\_all\_shapes()
    
    return screen

\# મુખ્ય એક્ઝિક્યુશન
def main():
    """વિકલ્પો સાથે મુખ્ય ફંક્શન"""
    
    print("ડ્રોઈંગ મોડ પસંદ કરો:")
    print("1. ડિફોલ્ટ આકારો")
    print("2. ઇન્ટરેક્ટિવ મોડ")
    
    choice = input("પસંદગી દાખલ કરો (1 અથવા 2): ").strip()
    
    if choice == "2":
        screen = interactive\_shape\_drawer()
    else:
        screen = draw\_all\_shapes()
    
    print("{n}વિન્ડો બંધ કરવા માટે સ્ક્રીન પર ક્લિક કરો.")
    screen.exitonclick()

\# પ્રોગ્રામ ચલાવો
if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\textbf{આકાર લક્ષણોનું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\textbf{આકાર} & \textbf{બાજુઓ} & \textbf{પ્રોપર્ટીઝ} & \textbf{ક્ષેત્રફળ
સૂત્ર} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ચોરસ} & 4 સમાન & બધા કોણ 90^\circ & બાજુ^{2} \\
\textbf{લાંબચોરસ} & 4 (2 જોડ) & સામેની બાજુઓ સમાન & લંબાઈ \times પહોળાઈ \\
\textbf{વતુળ} & 0 (વક્ર) & બધા બિંદુઓ સમદૂર & π \times ત્રિજ્યા^{2} \\
\end{longtable}
}

\textbf{આકાર ડ્રોઈંગ પ્રક્રિયા:}

\begin{verbatim}
flowchart LR
    A[ડ્રોઈંગ શરૂ] {-{-} B[ટર્ટલ સેટઅપ]}
    B {-{-} C[ચોરસ દોરો]}
    C {-{-} D[લાંબચોરસ દોરો] }
    D {-{-} E[વતુળ દોરો]}
    E {-{-} F[લેબલ્સ ઉમેરો]}
    F {-{-} G[માહિતી દર્શાવો]}
    G {-{-} H[પૂર્ણ]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ભૌમિતિક ચોકસાઈ}: ચોક્કસ કોણ અને અંતર માપદંડો
\item
  \textbf{વિઝ્યુઅલ અપીલ}: વિવિધ રંગો અને ભરેલા આકારો
\item
  \textbf{શૈક્ષણિક મૂલ્ય}: સૂત્રો દર્શાવે છે
\item
  \textbf{ગાણિતિક ગણતરીઓ}: ક્ષેત્રફળ સૂત્રો સામેલ
\item
  \textbf{ઇન્ટરેક્ટિવ ફીચર્સ}: યુઝર પેરામીટર્સ કસ્ટમાઈઝ કરી શકે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ચોરસ સમાન, લાંબચોરસ સામેના, વતુળ ગોળ''

\end{mnemonicbox}

\end{document}
