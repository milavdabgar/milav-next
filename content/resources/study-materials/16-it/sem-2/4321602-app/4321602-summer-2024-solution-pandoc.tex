\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4321602 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Give the difference between Tuple and List in python.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4091}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3182}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tuple
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
List
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mutability} & Immutable (cannot be changed) & Mutable (can be
changed) \\
\textbf{Syntax} & Created using () & Created using [] \\
\textbf{Performance} & Faster & Slower \\
\textbf{Methods} & Limited methods (count, index) & Many methods
(append, remove, etc.) \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Memory efficient}: Tuples use less memory than lists
\item
  \textbf{Use case}: Tuples for fixed data, lists for dynamic data
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Tuples are Tight, Lists are Loose''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Define Set and how is it created in python?}

\begin{solutionbox}

\textbf{Set} is an unordered collection of unique elements in Python.

\textbf{Creating Sets:}

\begin{verbatim}
\# Empty set
my\_set = set()

\# Set with elements
fruits = \{"apple", "banana", "orange"\}

\# From list
numbers = set([1, 2, 3, 4])
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Unique elements}: No duplicates allowed
\item
  \textbf{Unordered}: Elements have no specific order
\item
  \textbf{Operations}: Union, intersection, difference supported
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Sets are Special - Unique and Unordered''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{What is Dictionary in Python? Write a program to concatenate two
dictionary into new one.}

\begin{solutionbox}

\textbf{Dictionary} is an ordered collection of key-value pairs in
Python.

\textbf{Program:}

\begin{verbatim}
\# Two dictionaries
dict1 = \{1: 10, 2: 20\}
dict2 = \{3: 30, 4: 40\}

\# Method 1: Using update()
result1 = dict1.copy()
result1.update(dict2)

\# Method 2: Using ** operator
result2 = \{**dict1, **dict2\}

print("Result:", result2)
\# Output: \{1: 10, 2: 20, 3: 30, 4: 40\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Key-value pairs}: Each element has a key and value
\item
  \textbf{Mutable}: Can be modified after creation
\item
  \textbf{Fast access}: O(1) average time complexity
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dictionaries are Dynamic Key-Value stores''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{What is a list in python? Write a program that finds maximum and
minimum numbers from a list.}

\begin{solutionbox}

\textbf{List} is an ordered, mutable collection of elements in Python.

\textbf{Program:}

\begin{verbatim}
\# Input list
numbers = [45, 12, 78, 23, 56, 89, 34]

\# Find maximum and minimum
maximum = max(numbers)
minimum = min(numbers)

print(f"Maximum: \{maximum\}")
print(f"Minimum: \{minimum\}")

\# Manual method
max\_val = numbers[0]
min\_val = numbers[0]
for num in numbers:
    if num {} max\_val:
        max\_val = num
    if num {} min\_val:
        min\_val = num
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Ordered}: Elements maintain insertion order
\item
  \textbf{Indexing}: Accessed using index [0, 1, 2\ldots]
\item
  \textbf{Built-in functions}: min(), max(), len() available
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Lists are Linear and Indexed''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Explain Nested Tuple with example.}

\begin{solutionbox}

\textbf{Nested Tuple} is a tuple containing other tuples as elements.

\textbf{Example:}

\begin{verbatim}
\# Nested tuple
student\_data = (
    ("John", 85, "A"),
    ("Alice", 92, "A+"),
    ("Bob", 78, "B")
)

\# Accessing elements
print(student\_data[0][1])  \# Output: 85
print(student\_data[1][0])  \# Output: Alice
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Multi-dimensional}: Tuples within tuples
\item
  \textbf{Indexing}: Use multiple indices [i][j]
\item
  \textbf{Immutable}: Cannot change nested elements
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Nested means Tuples inside Tuples''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{What is random module? Explain with example.}

\begin{solutionbox}

\textbf{Random module} generates random numbers and performs random
operations.

\textbf{Example:}

\begin{verbatim}
import random

\# Random integer
num = random.randint(1, 10)
print(f"Random number: \{num\}")

\# Random choice from list
colors = ["red", "blue", "green"]
choice = random.choice(colors)
print(f"Random color: \{choice\}")

\# Random float
decimal = random.random()
print(f"Random decimal: \{decimal\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Import required}: import random
\item
  \textbf{Various functions}: randint(), choice(), random()
\item
  \textbf{Useful for}: Games, simulations, testing
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Random makes things Unpredictable''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Explain different ways of importing package. Give one example of
it.}

\begin{solutionbox}

\textbf{Import Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & Syntax & Usage \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Normal import} & \texttt{import\ package} &
package.function() \\
\textbf{From import} & \texttt{from\ package\ import\ function} &
function() \\
\textbf{Import all} & \texttt{from\ package\ import\ *} & function() \\
\textbf{Alias import} & \texttt{import\ package\ as\ alias} &
alias.function() \\
\end{longtable}
}

\textbf{Example:}

\begin{verbatim}
\# Normal import
import math
result1 = math.sqrt(16)

\# From import
from math import sqrt
result2 = sqrt(16)

\# Import with alias
import math as m
result3 = m.sqrt(16)

\# Import all (not recommended)
from math import *
result4 = sqrt(16)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Namespace}: Normal import keeps separate namespace
\item
  \textbf{Direct access}: From import allows direct function call
\item
  \textbf{Alias}: Shorter names for convenience
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Import methods: Normal, From, All, Alias''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{Write down the properties of dictionary in python.}

\begin{solutionbox}

\textbf{Dictionary Properties:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Property & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Ordered} & Maintains insertion order (Python 3.7+) \\
\textbf{Mutable} & Can be modified after creation \\
\textbf{Key-unique} & No duplicate keys allowed \\
\textbf{Heterogeneous} & Keys and values can be different types \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Fast access}: O(1) average lookup time
\item
  \textbf{Dynamic size}: Can grow or shrink
\item
  \textbf{Key restrictions}: Keys must be immutable
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dictionaries are Ordered, Mutable, Unique,
Heterogeneous''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{What is the dir() function in python. Explain with example.}

\begin{solutionbox}

\textbf{dir() function} returns all attributes and methods of an object.

\textbf{Example:}

\begin{verbatim}
\# List all attributes of string
text = "hello"
attributes = dir(text)
print(attributes[:5])  \# First 5 attributes

\# Check available methods
print("upper" in dir(text))  \# True

\# For modules
import math
math\_methods = dir(math)
print("sqrt" in math\_methods)  \# True

\# For custom objects
class MyClass:
    def my\_method(self):
        pass

obj = MyClass()
print(dir(obj))
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Introspection}: Examines object properties
\item
  \textbf{Debugging}: Helps find available methods
\item
  \textbf{All objects}: Works with any Python object
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``dir() shows Directory of object attributes''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Write a program to define module to find sum of two numbers.
Import module to another program.}

\begin{solutionbox}

\textbf{Module file (calculator.py):}

\begin{verbatim}
\# calculator.py
def add\_numbers(a, b):
    """Function to add two numbers"""
    return a + b

def multiply\_numbers(a, b):
    """Function to multiply two numbers"""
    return a * b

def get\_sum(num1, num2):
    """Alternative sum function"""
    result = num1 + num2
    return result
\end{verbatim}

\textbf{Main program:}

\begin{verbatim}
\# main.py
import calculator

\# Using the module
result1 = calculator.add\_numbers(10, 20)
print(f"Sum: \{result1\}")

\# From import
from calculator import get\_sum
result2 = get\_sum(15, 25)
print(f"Sum using from import: \{result2\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Module creation}: Save functions in .py file
\item
  \textbf{Import}: Use import statement to access
\item
  \textbf{Code reusability}: Use same module in multiple programs
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Modules make code Reusable and Organized''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{What is Runtime error and Logical error. Explain with example.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Error Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Runtime Error} & Occurs during program execution & Division by
zero, file not found \\
\textbf{Logical Error} & Program runs but gives wrong output & Wrong
formula, incorrect condition \\
\end{longtable}
}

\textbf{Examples:}

\begin{verbatim}
\# Runtime Error
x = 10
y = 0
result = x / y  \# ZeroDivisionError

\# Logical Error
def calculate\_area(radius):
    return 3.14 * radius  \# Should be radius * radius
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Runtime}: Crashes program execution
\item
  \textbf{Logical}: Program continues but wrong result
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Runtime Crashes, Logical Confuses''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Write points on Except and explaining it.}

\begin{solutionbox}

\textbf{Except clause} handles specific exceptions in try-except block.

\textbf{Key Points:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Syntax} & \texttt{except\ ExceptionType:} \\
\textbf{Multiple} & Can have multiple except blocks \\
\textbf{Generic} & \texttt{except:} catches all exceptions \\
\textbf{Variable} & \texttt{except\ Exception\ as\ e:} stores error \\
\end{longtable}
}

\begin{verbatim}
try:
    number = int(input("Enter number: "))
    result = 10 / number
except ValueError:
    print("Invalid input")
except ZeroDivisionError:
    print("Cannot divide by zero")
except Exception as e:
    print(f"Error: \{e\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Specific handling}: Different exceptions handled differently
\item
  \textbf{Error recovery}: Program continues after handling
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Except Catches and Handles errors''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Write a program to catch Divide by zero Exception. Also use
finally block.}

\begin{solutionbox}

\begin{verbatim}
def safe\_division():
    try:
        \# Get input from user
        numerator = float(input("Enter numerator: "))
        denominator = float(input("Enter denominator: "))
        
        \# Perform division
        result = numerator / denominator
        print(f"Result: \{numerator\} / \{denominator\} = \{result\}")
        
    except ZeroDivisionError:
        print("Error: Cannot divide by zero!")
        print("Please enter a non{-zero denominator"})
        
    except ValueError:
        print("Error: Please enter valid numbers only")
        
    except Exception as e:
        print(f"Unexpected error occurred: \{e\}")
        
    finally:
        print("Division operation completed")
        print("Thank you for using the calculator")

\# Call the function
safe\_division()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Try block}: Contains risky code
\item
  \textbf{Except}: Handles ZeroDivisionError specifically
\item
  \textbf{Finally}: Always executes regardless of exception
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try risky code, Except handles errors, Finally
always runs''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

\textbf{What are the built-in exceptions and gives its types.}

\begin{solutionbox}

\textbf{Built-in Exception Types:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ValueError} & Invalid value for operation & int(``abc'') \\
\textbf{TypeError} & Wrong data type & ``5'' + 5 \\
\textbf{IndexError} & Index out of range & list[10] for 5-element
list \\
\textbf{KeyError} & Key not found in dictionary &
dict[``missing\_key''] \\
\textbf{FileNotFoundError} & File doesn't exist &
open(``missing.txt'') \\
\end{longtable}
}

\begin{verbatim}
\# Examples
try:
    int("hello")  \# ValueError
    "5" + 5       \# TypeError
    [1,2,3][5]    \# IndexError
except (ValueError, TypeError, IndexError) as e:
    print(f"Error: \{type(e).\_\_name\_\_\}")
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Value, Type, Index, Key, File - common error
types''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Explain Syntax error and how do we identify it? Give an
example.}

\begin{solutionbox}

\textbf{Syntax Error} occurs when Python cannot parse the code due to
incorrect syntax.

\textbf{Identification:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Method & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Python interpreter} & Shows error message with line number \\
\textbf{IDE highlighting} & Code editors highlight syntax errors \\
\textbf{Error message} & Points to exact location of error \\
\end{longtable}
}

\textbf{Examples:}

\begin{verbatim}
\# Missing colon
if x {} 5
    print("Greater")  \# SyntaxError

\# Unmatched parentheses
print("Hello"  \# SyntaxError

\# Incorrect indentation
def my\_function():
print("Hello")  \# IndentationError

\# Invalid variable name
2variable = 10  \# SyntaxError
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Detection}: Before program execution
\item
  \textbf{Error message}: Shows line and character position
\item
  \textbf{Common causes}: Missing colons, brackets, wrong indentation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Syntax errors Stop code from Starting''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{What is Exception handling in python? Explain with proper
example.}

\begin{solutionbox}

\textbf{Exception Handling} is a mechanism to handle runtime errors
gracefully without crashing the program.

\textbf{Structure:}

\begin{verbatim}
try:
    \# Risky code
    pass
except SpecificException:
    \# Handle specific error
    pass
except Exception as e:
    \# Handle any other error
    pass
else:
    \# Runs if no exception
    pass
finally:
    \# Always runs
    pass
\end{verbatim}

\textbf{Complete Example:}

\begin{verbatim}
def file\_processor():
    filename = None
    try:
        filename = input("Enter filename: ")
        with open(filename, {r}) as file:
            content = file.read()
            numbers = [int(x) for x in content.split()]
            average = sum(numbers) / len(numbers)
            print(f"Average: \{average\}")
            
    except FileNotFoundError:
        print(f"Error: File {}\{filename\}{ not found"})
        
    except ValueError:
        print("Error: File contains non{-numeric data"})
        
    except ZeroDivisionError:
        print("Error: No numbers found in file")
        
    except Exception as e:
        print(f"Unexpected error: \{e\}")
        
    else:
        print("File processed successfully")
        
    finally:
        print("File processing operation completed")

\# Run the function
file\_processor()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Graceful handling}: Program continues after error
\item
  \textbf{Multiple exceptions}: Different error types handled separately
\item
  \textbf{Else clause}: Runs only if no exception occurs
\item
  \textbf{Finally clause}: Always executes for cleanup
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try-Except-Else-Finally: Complete error handling''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{What kind of different operations we can perform in a file?}

\begin{solutionbox}

\textbf{File Operations:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Description & Method \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Read} & Read file content & read(), readline(), readlines() \\
\textbf{Write} & Write data to file & write(), writelines() \\
\textbf{Append} & Add data to end & open with `a' mode \\
\textbf{Create} & Create new file & open with `w' or `x' mode \\
\textbf{Delete} & Remove file & os.remove() \\
\textbf{Seek} & Move file pointer & seek() \\
\end{longtable}
}

\begin{verbatim}
\# Example operations
with open({file.txt}, {w}) as f:
    f.write("Hello")  \# Write
    
with open({file.txt}, {r}) as f:
    content = f.read()  \# Read
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Read, Write, Append, Create, Delete, Seek''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Give list of file modes. Write Description of any four mode.}

\begin{solutionbox}

\textbf{File Modes:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Mode & Description & Purpose \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{`r'} & Read mode (default) & Read existing file \\
\textbf{`w'} & Write mode & Create new or overwrite existing \\
\textbf{`a'} & Append mode & Add to end of existing file \\
\textbf{`x'} & Exclusive creation & Create new file, fail if exists \\
\textbf{`b'} & Binary mode & Handle binary files \\
\textbf{`t'} & Text mode (default) & Handle text files \\
\textbf{`+'} & Read and write & Both operations allowed \\
\end{longtable}
}

\textbf{Four Mode Descriptions:}

\begin{enumerate}
\tightlist
\item
  \textbf{`r' (Read)}: Opens file for reading only, file pointer at
  beginning
\item
  \textbf{`w' (Write)}: Opens for writing, truncates file or creates new
  one
\item
  \textbf{`a' (Append)}: Opens for writing, file pointer at end of file
\item
  \textbf{`r+' (Read/Write)}: Opens for both reading and writing
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``Read, Write, Append, eXclusive - main file modes''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Write a program to sort all the words in a file and put it in
list.}

\begin{solutionbox}

\begin{verbatim}
def sort\_words\_from\_file():
    try:
        \# Input filename
        filename = input("Enter filename: ")
        
        \# Read file content
        with open(filename, {r}) as file:
            content = file.read()
        
        \# Split into words and clean them
        words = content.lower().split()
        
        \# Remove punctuation and empty strings
        import string
        clean\_words = []
        for word in words:
            clean\_word = word.translate(str.maketrans({}, {}, string.punctuation))
            if clean\_word:  \# Add only non{-empty words}
                clean\_words.append(clean\_word)
        
        \# Sort the words
        sorted\_words = sorted(clean\_words)
        
        \# Display results
        print("Sorted words:")
        print(sorted\_words)
        
        \# Save to new file
        with open({sorted\_words.txt}, {w}) as output\_file:
            for word in sorted\_words:
                output\_file.write(word + {}{n}{})
        
        print(f"Total words: \{len(sorted\_words)\}")
        print("Sorted words saved to {sorted\_words.txt"})
        
    except FileNotFoundError:
        print("Error: File not found")
    except Exception as e:
        print(f"Error: \{e\}")

\# Run the program
sort\_words\_from\_file()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{File reading}: Read entire file content
\item
  \textbf{Word processing}: Split, clean, and sort words
\item
  \textbf{List creation}: Store sorted words in list
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read, Split, Clean, Sort, Save''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{What is file handling? List files handling operation and explain
it.}

\begin{solutionbox}

\textbf{File Handling} is the process of working with files to store and
retrieve data permanently.

\textbf{File Handling Operations:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Function & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Open} & open() & Opens file in specified mode \\
\textbf{Read} & read(), readline() & Reads data from file \\
\textbf{Write} & write(), writelines() & Writes data to file \\
\textbf{Close} & close() & Closes file and frees resources \\
\textbf{Seek} & seek() & Moves file pointer position \\
\textbf{Tell} & tell() & Returns current file pointer position \\
\end{longtable}
}

\begin{verbatim}
\# Basic file operations
file = open({data.txt}, {w})  \# Open
file.write({Hello World})     \# Write
file.close()                  \# Close

file = open({data.txt}, {r})  \# Open for reading
content = file.read()         \# Read
file.close()                  \# Close
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Open, Read, Write, Close - basic file cycle''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Explain load() method with example.}

\begin{solutionbox}

\textbf{load() method} is used to deserialize data from a file (usually
with pickle module).

\textbf{Pickle load() Example:}

\begin{verbatim}
import pickle

\# First, save some data
data\_to\_save = \{
    {name}: {John},
    {age}: 25,
    {scores}: [85, 92, 78]
\}

\# Save data to file
with open({data.pkl}, {wb}) as file:
    pickle.dump(data\_to\_save, file)

\# Load data from file
with open({data.pkl}, {rb}) as file:
    loaded\_data = pickle.load(file)

print("Loaded data:", loaded\_data)
print("Name:", loaded\_data[{name}])
print("Scores:", loaded\_data[{scores}])
\end{verbatim}

\textbf{JSON load() Example:}

\begin{verbatim}
import json

\# Load JSON data
with open({config.json}, {r}) as file:
    config = json.load(file)
    
print("Configuration:", config)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Deserialization}: Converts file data back to Python objects
\item
  \textbf{Binary mode}: Use `rb' mode for pickle files
\item
  \textbf{Error handling}: Handle FileNotFoundError
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``load() brings file data back to Python objects''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Write a program that inputs a text file. The program should
print all of the unique words in the file in alphabetical order.}

\begin{solutionbox}

\begin{verbatim}
def find\_unique\_words():
    try:
        \# Get filename from user
        filename = input("Enter text filename: ")
        
        \# Read file content
        with open(filename, {r}, encoding={utf{-}8}) as file:
            content = file.read().lower()
        
        \# Clean and extract words
        import re
        import string
        
        \# Remove punctuation and split into words
        words = re.findall(r{}{b}[a{-zA{-}Z]}+{b}{}, content.lower())
        
        \# Create set to get unique words
        unique\_words = set(words)
        
        \# Convert to sorted list
        sorted\_unique\_words = sorted(list(unique\_words))
        
        \# Display results
        print("{n}Unique words in alphabetical order:")
        print("{-"} * 40)
        
        for i, word in enumerate(sorted\_unique\_words, 1):
            print(f"\{i:3d\}. \{word\}")
        
        print(f"{n}Total unique words: \{len(sorted\_unique\_words)\}")
        
        \# Save results to file
        with open({unique\_words\_output.txt}, {w}) as output\_file:
            output\_file.write("Unique Words in Alphabetical Order{n}")
            output\_file.write("=" * 40 + "{nn}")
            for word in sorted\_unique\_words:
                output\_file.write(word + {}{n}{})
        
        print("Results saved to {unique\_words\_output.txt"})
        
    except FileNotFoundError:
        print(f"Error: File {}\{filename\}{ not found"})
    except PermissionError:
        print("Error: Permission denied to read file")
    except Exception as e:
        print(f"Unexpected error: \{e\}")

\# Example usage
def create\_sample\_file():
    sample\_text = """
    Python is a powerful programming language.
    Python is easy to learn and Python is versatile.
    Programming with Python is fun and programming is rewarding.
    """
    
    with open({sample.txt}, {w}) as f:
        f.write(sample\_text)
    print("Sample file {sample.txt created"})

\# Create sample and run program
create\_sample\_file()
find\_unique\_words()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Regular expressions}: Extract only alphabetic words
\item
  \textbf{Set data structure}: Automatically removes duplicates
\item
  \textbf{Sorted function}: Arranges words alphabetically
\item
  \textbf{File output}: Saves results for future reference
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read, Extract, Unique, Sort, Display''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Explain the use of the following turtle function with an
appropriate example. (a) turn() (b) move().}

\begin{solutionbox}

\textbf{Note}: Standard turtle module uses \texttt{left()},
\texttt{right()} instead of \texttt{turn()}, and \texttt{forward()},
\texttt{backward()} instead of \texttt{move()}.

\textbf{Turtle Movement Functions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Function & Purpose & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{left(angle)} & Turn left by degrees & turtle.left(90) \\
\textbf{right(angle)} & Turn right by degrees & turtle.right(45) \\
\textbf{forward(distance)} & Move forward & turtle.forward(100) \\
\textbf{backward(distance)} & Move backward & turtle.backward(50) \\
\end{longtable}
}

\begin{verbatim}
import turtle

\# Create turtle
t = turtle.Turtle()

\# Turn functions
t.left(90)    \# Turn left 90 degrees
t.right(45)   \# Turn right 45 degrees

\# Move functions
t.forward(100)  \# Move forward 100 units
t.backward(50)  \# Move backward 50 units

\# Keep window open
turtle.done()
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Turn changes direction, Move changes position''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Explain the various inbuilt methods to change the direction of
the turtle.}

\begin{solutionbox}

\textbf{Direction Control Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{left(angle)} & Turn counterclockwise & turtle.left(90) \\
\textbf{right(angle)} & Turn clockwise & turtle.right(45) \\
\textbf{setheading(angle)} & Set absolute direction &
turtle.setheading(0) \\
\textbf{towards(x, y)} & Point towards coordinates &
turtle.setheading(turtle.towards(100, 100)) \\
\end{longtable}
}

\begin{verbatim}
import turtle

t = turtle.Turtle()

\# Relative turning
t.left(90)        \# Turn left 90^
t.right(45)       \# Turn right 45^

\# Absolute direction
t.setheading(0)   \# Point East (0^)
t.setheading(90)  \# Point North (90^)

\# Point towards specific point
angle = t.towards(100, 100)
t.setheading(angle)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Relative}: left() and right() change current direction
\item
  \textbf{Absolute}: setheading() sets exact direction
\item
  \textbf{Coordinate-based}: towards() calculates direction to point
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Left-Right relative, Heading absolute, Towards
calculates''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Write a program to draw square, rectangle and circle using
turtle.}

\begin{solutionbox}

\begin{verbatim}
import turtle

def draw\_shapes():
    \# Create turtle and screen
    screen = turtle.Screen()
    screen.title("Drawing Shapes with Turtle")
    screen.bgcolor("white")
    screen.setup(800, 600)
    
    \# Create turtle
    pen = turtle.Turtle()
    pen.speed(3)
    pen.color("blue")
    
    \# Draw Square
    pen.penup()
    pen.goto({-}200, 100)
    pen.pendown()
    pen.write("Square", font=("Arial", 12, "bold"))
    pen.goto({-}200, 50)
    
    for i in range(4):
        pen.forward(80)
        pen.right(90)
    
    \# Draw Rectangle
    pen.penup()
    pen.goto(0, 100)
    pen.pendown()
    pen.color("red")
    pen.write("Rectangle", font=("Arial", 12, "bold"))
    pen.goto(0, 50)
    
    for i in range(2):
        pen.forward(120)  \# Length
        pen.right(90)
        pen.forward(60)   \# Width
        pen.right(90)
    
    \# Draw Circle
    pen.penup()
    pen.goto(200, 100)
    pen.pendown()
    pen.color("green")
    pen.write("Circle", font=("Arial", 12, "bold"))
    pen.goto(200, 50)
    
    pen.circle(40)  \# Radius = 40
    
    \# Hide turtle and keep window open
    pen.hideturtle()
    screen.exitonclick()

\# Alternative function for each shape
def draw\_square(turtle\_obj, size):
    """Draw a square with given size"""
    for \_ in range(4):
        turtle\_obj.forward(size)
        turtle\_obj.right(90)

def draw\_rectangle(turtle\_obj, width, height):
    """Draw a rectangle with given dimensions"""
    for \_ in range(2):
        turtle\_obj.forward(width)
        turtle\_obj.right(90)
        turtle\_obj.forward(height)
        turtle\_obj.right(90)

def draw\_circle(turtle\_obj, radius):
    """Draw a circle with given radius"""
    turtle\_obj.circle(radius)

\# Run the main program
draw\_shapes()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Square}: 4 equal sides with 90^\circ turns
\item
  \textbf{Rectangle}: 2 pairs of equal sides
\item
  \textbf{Circle}: Built-in circle() method with radius
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Square: 4 equal sides, Rectangle: 2 pairs, Circle:
radius method''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{What are the various types of pen command in turtle? Explain
them all.}

\begin{solutionbox}

\textbf{Pen Control Commands:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Command & Purpose & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{penup()} & Lift pen (no drawing) & turtle.penup() \\
\textbf{pendown()} & Put pen down (start drawing) & turtle.pendown() \\
\textbf{pensize(width)} & Set pen thickness & turtle.pensize(5) \\
\textbf{pencolor(color)} & Set pen color & turtle.pencolor(``red'') \\
\textbf{fillcolor(color)} & Set fill color &
turtle.fillcolor(``blue'') \\
\textbf{begin\_fill()} & Start filling shape & turtle.begin\_fill() \\
\textbf{end\_fill()} & End filling shape & turtle.end\_fill() \\
\end{longtable}
}

\begin{verbatim}
import turtle

t = turtle.Turtle()

\# Pen control
t.penup()           \# Lift pen
t.goto(50, 50)      \# Move without drawing
t.pendown()         \# Put pen down
t.pensize(3)        \# Set thickness
t.pencolor("red")   \# Set color
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``Up-Down controls drawing, Size-Color controls
appearance''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Draw circle and star shapes using turtle and fill them with red
color.}

\begin{solutionbox}

\begin{verbatim}
import turtle

def draw\_filled\_shapes():
    \# Setup screen
    screen = turtle.Screen()
    screen.bgcolor("white")
    screen.title("Filled Circle and Star")
    
    \# Create turtle
    artist = turtle.Turtle()
    artist.speed(5)
    
    \# Draw filled circle
    artist.penup()
    artist.goto({-}150, 0)
    artist.pendown()
    
    \# Set colors for circle
    artist.color("red", "red")  \# pen color, fill color
    artist.begin\_fill()
    artist.circle(50)
    artist.end\_fill()
    
    \# Draw filled star
    artist.penup()
    artist.goto(100, 0)
    artist.pendown()
    
    \# Set colors for star
    artist.color("red", "red")
    artist.begin\_fill()
    
    \# Draw 5{-pointed star}
    for i in range(5):
        artist.forward(100)
        artist.right(144)
    
    artist.end\_fill()
    
    \# Add labels
    artist.penup()
    artist.goto({-}180, {-}80)
    artist.color("black")
    artist.write("Filled Circle", font=("Arial", 12, "bold"))
    
    artist.goto(70, {-}80)
    artist.write("Filled Star", font=("Arial", 12, "bold"))
    
    \# Hide turtle
    artist.hideturtle()
    screen.exitonclick()

\# Run the program
draw\_filled\_shapes()
\end{verbatim}

\textbf{Key Points:}

\begin{itemize}
\tightlist
\item
  \textbf{begin\_fill()}: Start filling the shape
\item
  \textbf{end\_fill()}: Complete the fill
\item
  \textbf{color()}: Set both pen and fill colors
\item
  \textbf{Star angle}: 144^\circ for 5-pointed star
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Begin fill, Draw shape, End fill = Filled shape''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{Write a program to draw Indian Flag using turtle.}

\begin{solutionbox}

\begin{verbatim}
import turtle

def draw\_indian\_flag():
    \# Create screen
    screen = turtle.Screen()
    screen.bgcolor("white")
    screen.title("Indian Flag")
    screen.setup(800, 600)
    
    \# Create turtle
    flag = turtle.Turtle()
    flag.speed(5)
    flag.pensize(2)
    
    \# Flag dimensions
    flag\_width = 300
    flag\_height = 200
    
    \# Starting position
    start\_x = {-}150
    start\_y = 100
    
    \# Draw flag pole
    flag.penup()
    flag.goto(start\_x {-} 20, start\_y + 50)
    flag.pendown()
    flag.color("brown")
    flag.pensize(8)
    flag.setheading(270)  \# Point downward
    flag.forward(400)
    
    \# Reset pen
    flag.pensize(2)
    flag.color("black")
    
    \# Draw saffron rectangle (top)
    flag.penup()
    flag.goto(start\_x, start\_y)
    flag.pendown()
    flag.color("orange", "orange")
    flag.begin\_fill()
    flag.setheading(0)
    
    for \_ in range(2):
        flag.forward(flag\_width)
        flag.right(90)
        flag.forward(flag\_height // 3)
        flag.right(90)
    flag.end\_fill()
    
    \# Draw white rectangle (middle)
    flag.penup()
    flag.goto(start\_x, start\_y {-} flag\_height // 3)
    flag.pendown()
    flag.color("black", "white")
    flag.begin\_fill()
    
    for \_ in range(2):
        flag.forward(flag\_width)
        flag.right(90)
        flag.forward(flag\_height // 3)
        flag.right(90)
    flag.end\_fill()
    
    \# Draw green rectangle (bottom)
    flag.penup()
    flag.goto(start\_x, start\_y {-} 2 * flag\_height // 3)
    flag.pendown()
    flag.color("green", "green")
    flag.begin\_fill()
    
    for \_ in range(2):
        flag.forward(flag\_width)
        flag.right(90)
        flag.forward(flag\_height // 3)
        flag.right(90)
    flag.end\_fill()
    
    \# Draw Ashoka Chakra (wheel)
    chakra\_center\_x = start\_x + flag\_width // 2
    chakra\_center\_y = start\_y {-} flag\_height // 2
    
    flag.penup()
    flag.goto(chakra\_center\_x, chakra\_center\_y {-} 30)
    flag.pendown()
    flag.color("navy blue")
    flag.pensize(3)
    
    \# Draw outer circle
    flag.circle(30)
    
    \# Draw spokes
    flag.penup()
    flag.goto(chakra\_center\_x, chakra\_center\_y)
    flag.pendown()
    
    for i in range(24):  \# 24 spokes in Ashoka Chakra
        flag.setheading(i * 15)  \# 360/24 = 15 degrees
        flag.forward(30)
        flag.backward(30)
    
    \# Draw inner circle
    flag.penup()
    flag.goto(chakra\_center\_x, chakra\_center\_y {-} 5)
    flag.pendown()
    flag.circle(5)
    
    \# Add title
    flag.penup()
    flag.goto({-}100, 200)
    flag.color("black")
    flag.write("INDIAN FLAG", font=("Arial", 16, "bold"))
    
    \# Hide turtle
    flag.hideturtle()
    screen.exitonclick()

\# Run the program
draw\_indian\_flag()
\end{verbatim}

\textbf{Flag Components:}

\begin{itemize}
\tightlist
\item
  \textbf{Saffron}: Courage and sacrifice (top)
\item
  \textbf{White}: Truth and peace (middle)
\item
  \textbf{Green}: Faith and chivalry (bottom)
\item
  \textbf{Ashoka Chakra}: 24-spoke wheel in navy blue
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Saffron-White-Green stripes with 24-spoke Chakra''

\end{mnemonicbox}

\end{document}
