\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4321602 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{ડિક્શનરી શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

ડિક્શનરી એ Python માં key-value pairs નો collection છે જે mutable અને ordered
હોય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ડિક્શનરીની વિશેષતાઓ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mutable} & Values ને change કરી શકાય છે \\
\textbf{Ordered} & Python 3.7+ માં insertion order maintain રહે છે \\
\textbf{Indexed} & Keys દ્વારા access કરાય છે \\
\textbf{No Duplicates} & Duplicate keys allow નથી \\
\end{longtable}
}

\begin{verbatim}
\# ડિક્શનરી ઉદાહરણ
student = \{
    "name": "રાજ",
    "age": 20,
    "course": "IT"
\}
print(student["name"])  \# આઉટપુટ: રાજ
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Key-Value Structure}: દરેક element માં key અને value હોય છે
\item
  \textbf{Fast Access}: O(1) time complexity માં data access
\item
  \textbf{Dynamic Size}: Runtime માં size વધારી-ઘટાડી શકાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dictionary = Key Value Treasure''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{ટ્યુપલ બિલ્ટ-ઇન ફંકશન અને મેથડોનો વર્ણન કરો.}

\begin{solutionbox}

ટ્યુપલ માં limited built-in methods છે કારણ કે તે immutable છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ટ્યુપલ મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
મેથડ & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{count()} & Element ની frequency return કરે છે &
\texttt{t.count(5)} \\
\textbf{index()} & Element નું first index return કરે છે &
\texttt{t.index(\textquotesingle{}a\textquotesingle{})} \\
\textbf{len()} & ટ્યુપલ નું length return કરે છે & \texttt{len(t)} \\
\textbf{max()} & Maximum value return કરે છે & \texttt{max(t)} \\
\textbf{min()} & Minimum value return કરે છે & \texttt{min(t)} \\
\end{longtable}
}

\begin{verbatim}
\# ટ્યુપલ મેથડો ઉદાહરણ
numbers = (1, 2, 3, 2, 4, 2)
print(numbers.count(2))     \# આઉટપુટ: 3
print(numbers.index(3))     \# આઉટપુટ: 2
print(len(numbers))         \# આઉટપુટ: 6
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Immutable Nature}: Methods ટ્યુપલ ને modify નથી કરતા
\item
  \textbf{Return Values}: બધા methods નવી values return કરે છે
\item
  \textbf{Type Conversion}: tuple() function થી list ને tuple માં convert
  કરી શકાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Count Index Length Max Min''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{સેટ ઓપરેશન્સ દર્શાવવા માટે પાયથન પ્રોગ્રામ લખો.}

\begin{solutionbox}

Set operations mathematics ના set theory પર આધારિત છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{સેટ ઓપરેશન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2941}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2353}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Symbol
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Union} & \texttt{\textbackslash{}\textbar{}} & \texttt{union()}
& બન્ને sets ના elements \\
\textbf{Intersection} & \texttt{\&} & \texttt{intersection()} & Common
elements \\
\textbf{Difference} & \texttt{-} & \texttt{difference()} & First set
માંથી second ને minus \\
\textbf{Symmetric Difference} & \texttt{\^{}} &
\texttt{symmetric\_difference()} & Unique elements only \\
\end{longtable}
}

\begin{verbatim}
\# સેટ ઓપરેશન્સ પ્રોગ્રામ
set1 = \{1, 2, 3, 4, 5\}
set2 = \{4, 5, 6, 7, 8\}

print("Set 1:", set1)
print("Set 2:", set2)

\# યુનિયન ઓપરેશન
union\_result = set1 | set2
print("Union:", union\_result)

\# ઇન્ટરસેક્શન ઓપરેશન  
intersection\_result = set1 \& set2
print("Intersection:", intersection\_result)

\# ડિફરન્સ ઓપરેશન
difference\_result = set1 {-} set2
print("Difference:", difference\_result)

\# સિમેટ્રિક ડિફરન્સ
sym\_diff\_result = set1 \^{} set2
print("Symmetric Difference:", sym\_diff\_result)

\# સબસેટ અને સુપરસેટ
set3 = \{1, 2\}
print("શું set3 એ set1 નો subset છે?", set3.issubset(set1))
print("શું set1 એ set3 નો superset છે?", set1.issuperset(set3))
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Mathematical Operations}: Set theory ના operations implement
  કરે છે
\item
  \textbf{Efficient Processing}: Duplicate elements automatically remove
  થાય છે
\item
  \textbf{Boolean Results}: Subset/superset operations boolean return કરે
  છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Union Intersection Difference Symmetric''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{ડિક્શનરી ફંકશન અને ઓપરેશન્સ દર્શાવવા માટે પાયથન પ્રોગ્રામ લખો.}

\begin{solutionbox}

ડિક્શનરી ઓપરેશન્સ data manipulation માટે powerful tools પ્રદાન કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ડિક્શનરી મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
મેથડ & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{keys()} & બધી keys return કરે છે & \texttt{dict.keys()} \\
\textbf{values()} & બધા values return કરે છે & \texttt{dict.values()} \\
\textbf{items()} & Key-value pairs return કરે છે &
\texttt{dict.items()} \\
\textbf{get()} & Safe value retrieval &
\texttt{dict.get(\textquotesingle{}key\textquotesingle{})} \\
\textbf{update()} & Dictionary merge કરે છે & \texttt{dict.update()} \\
\end{longtable}
}

\begin{verbatim}
\# ડિક્શનરી ઓપરેશન્સ પ્રોગ્રામ
student\_data = \{
    "name": "અમિત",
    "age": 21,
    "course": "IT",
    "semester": 2
\}

print("મૂળ Dictionary:", student\_data)

\# Values ને access કરવું
print("વિદ્યાર્થીનું નામ:", student\_data.get("name"))
print("વિદ્યાર્થીની ઉંમર:", student\_data["age"])

\# નવી key{-value pair ઉમેરવી}
student\_data["city"] = "અમદાવાદ"
print("શહેર ઉમેર્યા પછી:", student\_data)

\# અસ્તિત્વમાં રહેલી value અપડેટ કરવી
student\_data.update(\{"age": 22, "semester": 3\)}
print("અપડેટ કર્યા પછી:", student\_data)

\# ડિક્શનરી મેથડો
print("Keys:", list(student\_data.keys()))
print("Values:", list(student\_data.values()))
print("Items:", list(student\_data.items()))

\# Elements ને remove કરવા
removed\_value = student\_data.pop("semester")
print("Remove કરેલી value:", removed\_value)
print("અંતિમ Dictionary:", student\_data)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic Operations}: Runtime માં keys અને values add/remove કરી
  શકાય
\item
  \textbf{Safe Access}: get() method KeyError prevent કરે છે
\item
  \textbf{Iteration Support}: keys(), values(), items() methods loop માટે
  useful
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Get Keys Values Items Update Pop''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{પાયથનમાં ટ્યુપલ અને લિસ્ટ વચ્ચે તફાવત આપો.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ટ્યુપલ vs લિસ્ટ તુલના}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
વિશેષતા & ટ્યુપલ & લિસ્ટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mutability} & Immutable (બદલાઈ શકતું નથી) & Mutable (બદલાઈ શકે
છે) \\
\textbf{Syntax} & કૌંસ \texttt{()} & ચોરસ કૌંસ \texttt{[]} \\
\textbf{Performance} & ઝડપી & ધીમી \\
\textbf{Memory} & ઓછી memory & વધુ memory \\
\textbf{Methods} & મર્યાદિત (count, index) & ઘણી methods ઉપલબ્ધ \\
\textbf{Use Case} & Fixed data & Dynamic data \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Immutable Nature}: ટ્યુપલ એકવાર create થયા પછી change થઈ શકતું નથી
\item
  \textbf{Performance}: ટ્યુપલ operations લિસ્ટ કરતાં ઝડપી છે
\item
  \textbf{Memory Efficient}: ટ્યુપલ ઓછી memory વાપરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Tuple Tight, List Light''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{પાયથનમાં dir() ફંકશન શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

dir() function એ built-in function છે જે object ના attributes અને methods
ની list return કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{dir() ફંકશનની વિશેષતાઓ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Object Inspection} & Object ના attributes show કરે છે \\
\textbf{Method Discovery} & Available methods list કરે છે \\
\textbf{Namespace Exploration} & Current namespace ના variables show કરે
છે \\
\textbf{Module Analysis} & Module ના contents explore કરે છે \\
\end{longtable}
}

\begin{verbatim}
\# dir() ફંકશન ઉદાહરણ
\# String object માટે
text = "Hello"
string\_methods = dir(text)
print("String methods:", string\_methods[:5])

\# List object માટે  
my\_list = [1, 2, 3]
list\_methods = dir(my\_list)
print("List methods:", [m for m in list\_methods if not m.startswith({\_})][:5])

\# Current namespace માટે
print("Current namespace:", dir()[:3])

\# Built{-in functions માટે}
import math
print("Math module:", dir(math)[:5])
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Interactive Development}: Objects ના capabilities જાણવા માટે
  useful
\item
  \textbf{Debugging Tool}: Available methods quickly identify કરવા માટે
\item
  \textbf{Learning Aid}: નવી libraries explore કરવા માટે helpful
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dir = Directory of Methods''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{સર્કલનો એરિયા અને સિર્કમફેરન્સ શોધવા માટે મોડ્યુલ બનાવો અને બીજા
પ્રોગ્રામમાં મોડ્યુલ ઇમ્પોર્ટ કરો.}

\begin{solutionbox}

Module approach કોડ reusability અને organization સુધારે છે.

\textbf{ડાયાગ્રામ: મોડ્યુલ સ્ટ્રક્ચર}

\begin{verbatim}
┌─────────────────┐    ┌─────────────────┐
│   circle.py     │    │   main.py       │
│   (Module)      │    │   (Main Program)│
├─────────────────┤    ├─────────────────┤
│ • area()        │───▶│ import circle   │
│ • circumference │    │ use functions   │
│ • PI constant   │    │                 │
└─────────────────┘    └─────────────────┘
\end{verbatim}

\textbf{ફાઇલ 1: circle.py (મોડ્યુલ)}

\begin{verbatim}
\# circle.py {- સર્કલ કેલ્ક્યુલેશન મોડ્યુલ}
import math

\# Constants
PI = math.pi

def area(radius):
    """સર્કલનો એરિયા કેલ્ક્યુલેટ કરે છે"""
    if radius {} 0:
        return "Radius negative હોઈ શકે નહીં"
    return PI * radius * radius

def circumference(radius):
    """સર્કલનો circumference કેલ્ક્યુલેટ કરે છે"""
    if radius {} 0:
        return "Radius negative હોઈ શકે નહીં"
    return 2 * PI * radius

def display\_info():
    """મોડ્યુલ માહિતી દર્શાવે છે"""
    print("Circle Module {- Version 1.0"})
    print("Functions: area(), circumference()")
\end{verbatim}

\textbf{ફાઇલ 2: main.py (મુખ્ય પ્રોગ્રામ)}

\begin{verbatim}
\# main.py {- circle module વાપરનાર મુખ્ય પ્રોગ્રામ}
import circle

\# યુઝર પાસેથી radius લો
radius = float(input("Radius દાખલ કરો: "))

\# મોડ્યુલ functions વાપરીને કેલ્ક્યુલેટ કરો
circle\_area = circle.area(radius)
circle\_circumference = circle.circumference(radius)

\# પરિણામો દર્શાવો
print(f"Radius \{radius\} ના સર્કલ માટે:")
print(f"Area: \{circle\_area:.2f\}")
print(f"Circumference: \{circle\_circumference:.2f\}")

\# મોડ્યુલ info દર્શાવો
circle.display\_info()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Modular Design}: Functions ને separate file માં organize કરે છે
\item
  \textbf{Reusability}: Module ને multiple programs માં use કરી શકાય
\item
  \textbf{Namespace Management}: Module prefix થી function access કરાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Import Calculate Display''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{નેસ્ટેડ ટ્યુપલને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

Nested Tuple એ ટ્યુપલ અંદર બીજા tuples હોય છે, જે hierarchical data structure
બનાવે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{નેસ્ટેડ ટ્યુપલની વિશેષતાઓ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Multi-dimensional} & 2D અથવા 3D data structure \\
\textbf{Immutable} & બધા levels પર immutable \\
\textbf{Indexing} & Multiple square brackets વાપરીને access \\
\textbf{Heterogeneous} & અલગ-અલગ data types store કરી શકાય \\
\end{longtable}
}

\begin{verbatim}
\# નેસ્ટેડ ટ્યુપલ ઉદાહરણ
student\_records = (
    ("રાજ", 20, ("IT", 2)),
    ("પ્રિયા", 19, ("CS", 1)), 
    ("અમિત", 21, ("IT", 3))
)

\# નેસ્ટેડ elements ને access કરવા
print("પહેલો વિદ્યાર્થી:", student\_records[0])
print("પહેલા વિદ્યાર્થીનું નામ:", student\_records[0][0])
print("પહેલા વિદ્યાર્થીનો કોર્સ:", student\_records[0][2][0])

\# નેસ્ટેડ ટ્યુપલ પર iterate કરવું
for student in student\_records:
    name, age, (course, semester) = student
    print(f"\{name\} {- ઉંમર: }\{age\}, કોર્સ: \{course\}, સેમ: \{semester\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Data Organization}: સંબંધિત data ને group કરવા માટે useful
\item
  \textbf{Immutable Structure}: એકવાર create થયા પછી structure change થઈ
  શકતું નથી
\item
  \textbf{Efficient Access}: Index-based fast access
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Nested = Tuple Inside Tuple''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{PIP શું છે? પાયથન પેકેજને ઇન્સ્ટોલ અને અનઇન્સ્ટોલ કરવા માટે સિન્ટેક્સ લખો.}

\begin{solutionbox}

PIP (Pip Installs Packages) એ Python package installer છે જે PyPI થી
packages download અને install કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{PIP કમાન્ડો}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3929}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કમાન્ડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Install} & \texttt{pip\ install\ package\_name} & Package
install કરે છે \\
\textbf{Uninstall} & \texttt{pip\ uninstall\ package\_name} & Package
remove કરે છે \\
\textbf{List} & \texttt{pip\ list} & Installed packages show કરે છે \\
\textbf{Show} & \texttt{pip\ show\ package\_name} & Package info display
કરે છે \\
\textbf{Upgrade} & \texttt{pip\ install\ -\/-upgrade\ package\_name} &
Package update કરે છે \\
\end{longtable}
}

\begin{verbatim}
\# PIP કમાન્ડ ઉદાહરણો (Terminal/Command Prompt માં run કરવા)

\# Package install કરવા
\# pip install requests

\# Specific version install કરવા
\# pip install Django==3.2.0

\# Package uninstall કરવા  
\# pip uninstall numpy

\# બધા installed packages list કરવા
\# pip list

\# Package information show કરવા
\# pip show matplotlib

\# Package upgrade કરવા
\# pip install {-{-}upgrade pandas}

\# Requirements file થી install કરવા
\# pip install {-r requirements.txt}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Package Management}: Third-party libraries easily manage કરી
  શકાય
\item
  \textbf{Version Control}: Specific versions install કરી શકાય
\item
  \textbf{Dependency Resolution}: જરૂરી dependencies automatically
  install થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PIP = Package Install Python''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{પેકેજ ઇમ્પોર્ટ કરવાની વિવિધ રીતો સમજાવો. મોડ્યુલ અને પેકેજ એકબીજાની સાથે
કેવી રીતે જોડાયેલા છે?}

\begin{solutionbox}

Python માં imports ના વિવિધ ways છે જે code organization અને namespace
management માટે મહત્વપૂર્ણ છે.

\textbf{ડાયાગ્રામ: પેકેજ સ્ટ્રક્ચર}

\begin{verbatim}
MyPackage/
├── \_\_init\_\_.py
├── module1.py
├── module2.py
└── subpackage/
    ├── \_\_init\_\_.py
    └── module3.py
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ઇમ્પોર્ટ મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4583}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2917}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Basic Import} & \texttt{import\ module} & સંપૂર્ણ module name
જરૂરી \\
\textbf{From Import} & \texttt{from\ module\ import\ function} & Direct
function access \\
\textbf{Alias Import} & \texttt{import\ module\ as\ alias} & Module માટે
ટૂંકું નામ \\
\textbf{Star Import} & \texttt{from\ module\ import\ *} & બધા functions
import કરવા \\
\textbf{Package Import} & \texttt{from\ package\ import\ module} &
Package માંથી import કરવા \\
\end{longtable}
}

\begin{verbatim}
\# વિવિધ ઇમ્પોર્ટ રીતો

\# 1. Basic Import
import math
result = math.sqrt(16)

\# 2. From Import
from math import sqrt, pi
result = sqrt(16)
area = pi * 5 * 5

\# 3. Alias Import
import numpy as np
array = np.array([1, 2, 3])

\# 4. Star Import (ભલામણ નહીં)
from math import *
result = cos(0)

\# 5. Package Import
from mypackage import module1
from mypackage.subpackage import module3

\# 6. Relative Import (package અંદર)
\# from . import module1
\# from ..parent\_module import function
\end{verbatim}

\textbf{મોડ્યુલ-પેકેજ કનેક્શન:}

\begin{itemize}
\tightlist
\item
  \textbf{Modules}: Python code ધરાવતી single .py files
\item
  \textbf{Packages}: \_\_init\_\_.py સાથે multiple modules ધરાવતી
  directories
\item
  \textbf{Namespace}: Packages hierarchical namespace structure બનાવે છે
\item
  \textbf{\_\_init\_\_.py}: Directory ને package બનાવે છે અને imports
  control કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Import From As Star Package''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{રનટાઇમ એરર અને સિન્ટેક્સ એરરનું વર્ણન કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{એરર પ્રકારોની તુલના}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2653}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3061}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2245}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2041}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
એરર પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ક્યારે થાય છે
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Detection
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Syntax Error} & Code parsing time & Execution પહેલાં & Missing
colon, brackets \\
\textbf{Runtime Error} & Execution દરમિયાન & Program run કરતી વખતે &
Division by zero, file not found \\
\textbf{Logic Error} & હંમેશા & Execution પછી & ખોટી calculation logic \\
\end{longtable}
}

\begin{verbatim}
\# સિન્ટેક્સ એરર ઉદાહરણ
\# print("Hello World"  \# Missing closing parenthesis
\# SyntaxError: unexpected EOF while parsing

\# રનટાઇમ એરર ઉદાહરણો
try:
    \# ZeroDivisionError
    result = 10 / 0
except ZeroDivisionError:
    print("શૂન્યથી ભાગ આપી શકાતો નથી")

try:
    \# FileNotFoundError  
    file = open("nonexistent.txt", "r")
except FileNotFoundError:
    print("ફાઇલ મળી નથી")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Syntax Errors}: કોડ run થવા પહેલા જ detect થાય છે
\item
  \textbf{Runtime Errors}: Program execution દરમિયાન થાય છે
\item
  \textbf{Prevention}: Exception handling runtime errors ને handle કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Syntax Before, Runtime During''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{પાયથનમાં Exception હેન્ડલિંગ શું છે? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

Exception handling એ mechanism છે જે runtime errors ને gracefully handle કરે
છે અને program crash થવાથી prevent કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Exception Handling Keywords}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Keyword & હેતુ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & Exception માં થઈ શકે એવો code & Risk code block \\
\textbf{except} & Exception handle કરવા માટે & Error handling block \\
\textbf{finally} & હંમેશા execute થાય & Cleanup code \\
\textbf{else} & Exception ન આવે તો & Success code block \\
\textbf{raise} & Manual exception raise કરવા & Custom error throwing \\
\end{longtable}
}

\begin{verbatim}
\# Exception Handling ઉદાહરણ
def safe\_division(a, b):
    try:
        \# કોડ જે exception raise કરી શકે
        result = a / b
        print(f"ભાગાકાર સફળ: \{result\}")
        
    except ZeroDivisionError:
        \# Specific exception handle કરવા
        print("એરર: શૂન્યથી ભાગ આપી શકાતો નથી")
        result = None
        
    except TypeError:
        \# Type errors handle કરવા
        print("એરર: અયોગ્ય data types")
        result = None
        
    else:
        \# Exception ન આવે તો execute થાય
        print("ભાગાકાર સફળતાપૂર્વક પૂર્ણ થયું")
        
    finally:
        \# હંમેશા execute થાય
        print("ભાગાકાર operation સમાપ્ત")
        
    return result

\# ફંકશનને ટેસ્ટ કરો
safe\_division(10, 2)   \# સામાન્ય કેસ
safe\_division(10, 0)   \# Zero division
safe\_division(10, "a") \# Type error
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Error Prevention}: Program crash થવાથી prevent કરે છે
\item
  \textbf{Graceful Handling}: User-friendly error messages આપે છે
\item
  \textbf{Resource Management}: finally block માં cleanup operations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try Except Finally Else Raise''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{બે સંખ્યાઓના division માટે ફંકશન બનાવો, જો કોઈપણ argument ની value
non-integer હોય તો એરર રેઇઝ થાય અથવા જો બીજી argument 0 હોય તો એરર રેઇઝ
થાય.}

\begin{solutionbox}

Custom exception handling function બનાવવું validation અને error control માટે
મહત્વપૂર્ણ છે.

\textbf{ડાયાગ્રામ: ફંકશન ફ્લો}

\begin{verbatim}
flowchart LR
    A[Input Numbers] {-{-} B\{શું બન્ને integers છે?\}}
    B {-{-}|ના| C[Raise TypeError]}
    B {-{-}|હા| D\{શું બીજી સંખ્યા 0 છે?\}}
    D {-{-}|હા| E[Raise ZeroDivisionError]}
    D {-{-}|ના| F[Division કરો]}
    F {-{-} G[Result Return કરો]}
    C {-{-} H[Error Handle કરો]}
    E {-{-} H}
    H {-{-} I[અંત]}
    G {-{-} I}
\end{verbatim}

\begin{verbatim}
def safe\_integer\_division(num1, num2):
    """
    બે સંખ્યાઓને validation સાથે ભાગ આપે છે
    જો arguments integers નથી તો TypeError raise કરે છે
    જો બીજી argument 0 છે તો ZeroDivisionError raise કરે છે
    """
    
    \# તપાસો કે બન્ને arguments integers છે કે નહીં
    if not isinstance(num1, int):
        raise TypeError(f"પહેલી argument integer હોવી જોઈએ, મળી \{type(num1).\_\_name\_\_\}")
    
    if not isinstance(num2, int):
        raise TypeError(f"બીજી argument integer હોવી જોઈએ, મળી \{type(num2).\_\_name\_\_\}")
    
    \# શૂન્યથી ભાગ માટે તપાસો
    if num2 == 0:
        raise ZeroDivisionError("શૂન્યથી ભાગ આપી શકાતો નથી")
    
    \# ભાગાકાર કરો
    result = num1 / num2
    return result

\# વિવિધ કેસો સાથે ફંકશનનું ટેસ્ટ
def test\_division():
    test\_cases = [
        (10, 2),      \# યોગ્ય કેસ
        (15, 3),      \# યોગ્ય કેસ  
        (10, 0),      \# Zero division error
        (10.5, 2),    \# Non{-integer પહેલી argument}
        (10, 2.5),    \# Non{-integer બીજી argument}
        ("10", 2),    \# String argument
    ]
    
    for num1, num2 in test\_cases:
        try:
            result = safe\_integer\_division(num1, num2)
            print(f"\{num1\}  \{num2\} = \{result\}")
            
        except TypeError as e:
            print(f"Type Error: \{e\}")
            
        except ZeroDivisionError as e:
            print(f"Zero Division Error: \{e\}")
            
        except Exception as e:
            print(f"અનપેક્ષિત Error: \{e\}")
        
        print("{-"} * 40)

\# ટેસ્ટ run કરો
test\_division()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Input Validation}: Arguments ના type અને value check કરે છે
\item
  \textbf{Custom Errors}: Specific exceptions raise કરે છે
\item
  \textbf{Error Messages}: સ્પષ્ટ અને વર્ણનાત્મક error messages
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Validate Type, Check Zero, Divide Safe''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{ટેક્સ્ટ ફાઇલ અને બાયનરી ફાઇલ વચ્ચેના તફાવત પર પાંચ પોઇન્ટ્સ લખો.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ટેક્સ્ટ ફાઇલ vs બાયનરી ફાઇલ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2778}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3611}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3611}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
વિશેષતા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ટેક્સ્ટ ફાઇલ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
બાયનરી ફાઇલ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Content} & Human-readable characters & Binary data (0s અને 1s) \\
\textbf{Encoding} & Character encoding (UTF-8, ASCII) & કોઈ character
encoding નથી \\
\textbf{Opening Mode} & `r', `w', `a' & `rb', `wb', `ab' \\
\textbf{File Size} & સામાન્યતે મોટી & સામાન્યતે નાની \\
\textbf{Platform} & Platform dependent & Platform independent \\
\end{longtable}
}

\begin{verbatim}
\# ટેક્સ્ટ vs બાયનરી ફાઇલ ઉદાહરણો
\# ટેક્સ્ટ ફાઇલ ઉદાહરણ
with open("sample.txt", "w") as f:
    f.write("Hello World")

\# બાયનરી ફાઇલ ઉદાહરણ  
with open("sample.bin", "wb") as f:
    f.write(b{}{x48x65x6cx6cx6f}{})
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Readability}: ટેક્સ્ટ ફાઇલો editor માં read કરી શકાય, બાયનરી ફાઇલો
  માટે special software જોઈએ
\item
  \textbf{Portability}: બાયનરી ફાઇલો different platforms પર easily
  transfer થાય
\item
  \textbf{Processing}: ટેક્સ્ટ ફાઇલો string operations માટે, બાયનરી ફાઇલો
  exact data storage માટે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Text Human, Binary Machine''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{ફાઇલમાંથી ડેટા read કરવા માટે પ્રોગ્રામ લખો અને Uppercase કેરેક્ટર અને
Lowercase કેરેક્ટરને બે અલગ ફાઇલોમાં separate કરો.}

\begin{solutionbox}

ફાઇલ processing માં character-based operations સામાન્ય requirements છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ફાઇલ ઓપરેશન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4545}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Read} & \texttt{read()} & સંપૂર્ણ ફાઇલ content \\
\textbf{Write} & \texttt{write()} & ફાઇલમાં string લખવા \\
\textbf{Character Check} & \texttt{isupper()}, \texttt{islower()} &
Character case detection \\
\textbf{File Handling} & \texttt{with\ open()} & Safe ફાઇલ operations \\
\end{longtable}
}

\begin{verbatim}
def separate\_case\_characters(input\_file, upper\_file, lower\_file):
    """
    ફાઇલ read કરીને uppercase/lowercase characters અલગ કરે છે
    """
    try:
        \# Input ફાઇલમાંથી read કરો
        with open(input\_file, {r}) as infile:
            content = infile.read()
        
        \# Characters અલગ કરો
        uppercase\_chars = ""
        lowercase\_chars = ""
        
        for char in content:
            if char.isupper():
                uppercase\_chars += char
            elif char.islower():
                lowercase\_chars += char
        
        \# Uppercase ફાઇલમાં લખો
        with open(upper\_file, {w}) as upfile:
            upfile.write(uppercase\_chars)
        
        \# Lowercase ફાઇલમાં લખો  
        with open(lower\_file, {w}) as lowfile:
            lowfile.write(lowercase\_chars)
        
        print(f"✓ Characters સફળતાપૂર્વક અલગ કર્યા!")
        print(f"Uppercase characters: \{len(uppercase\_chars)\}")
        print(f"Lowercase characters: \{len(lowercase\_chars)\}")
        
    except FileNotFoundError:
        print(f"એરર: ફાઇલ {}\{input\_file\}{ મળી નથી"})
    except Exception as e:
        print(f"એરર: \{e\}")

\# Sample input ફાઇલ બનાવો
def create\_sample\_file():
    sample\_text = """Hello World! આ એક SAMPLE Text ફાઇલ છે.
તેમાં UPPERCASE અને lowercase Characters છે.
Python Programming ખૂબ જ FUN અને Educational છે."""
    
    with open("input.txt", "w") as f:
        f.write(sample\_text)
    print("Sample input ફાઇલ બનાવી: input.txt")

\# મુખ્ય execution
create\_sample\_file()
separate\_case\_characters("input.txt", "uppercase.txt", "lowercase.txt")

\# પરિણામો દર્શાવો
print("{n}ફાઇલ Contents:")
print("{-"} * 30)

try:
    with open("uppercase.txt", "r") as f:
        print(f"Uppercase ફાઇલ: \{f.read()\}")
    
    with open("lowercase.txt", "r") as f:
        print(f"Lowercase ફાઇલ: \{f.read()\}")
except FileNotFoundError:
    print("Output ફાઇલો મળી નથી")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Character Processing}: દરેક character ની case individually
  check કરાય છે
\item
  \textbf{File Safety}: with statement automatic ફાઇલ closing ensure કરે
  છે
\item
  \textbf{Error Handling}: ફાઇલ operations માં proper exception handling
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read Separate Write''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{dump() અને load() મેથડનું વર્ણન કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

dump() અને load() methods pickle module ના part છે જે object serialization
માટે વાપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Pickle મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
File Mode
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{dump()} & Object ને file માં serialize કરવા & `wb' & Object ને
binary file માં store કરે \\
\textbf{load()} & File માંથી object deserialize કરવા & `rb' & ફાઇલમાંથી
object retrieve કરે \\
\textbf{dumps()} & Bytes માં serialize કરવા & N/A & Object ને bytes માં
convert કરે \\
\textbf{loads()} & Bytes માંથી deserialize કરવા & N/A & Bytes માંથી object
બનાવે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: Serialization Process}

\begin{verbatim}
flowchart LR
    A[Python Object] {-{-}|"dump()"| B[Binary File]}
    B {-{-}|"load()"| C[Python Object]}
    A {-{-}|"dumps()"| D[Bytes String]}
    D {-{-}|"loads()"| C}
\end{verbatim}

\begin{verbatim}
import pickle

\# વિવિધ data types સાથે ઉદાહરણ
def demonstrate\_pickle():
    \# Serialize કરવા માટે sample data
    student\_data = \{
        {name}: {રાજ પટેલ},
        {age}: 20,
        {grades}: [85, 92, 78, 96],
        {subjects}: ({Math}, {Python}, {Database}),
        {is\_active}: True
    \}
    
    class Student:
        def \_\_init\_\_(self, name, roll\_no):
            self.name = name
            self.roll\_no = roll\_no
        
        def \_\_str\_\_(self):
            return f"Student: \{self.name\} (Roll: \{self.roll\_no\})"
    
    \# Objects બનાવો
    student\_obj = Student("પ્રિયા શાહ", 101)
    data\_list = [student\_data, student\_obj, [1, 2, 3, 4, 5]]
    
    \# DUMP {- Objects ને file માં serialize કરો}
    print("=== DUMP Operation ===")
    try:
        with open({student\_data.pkl}, {wb}) as f:
            pickle.dump(data\_list, f)
        print("✓ Data સફળતાપૂર્વક student\_data.pkl માં dump કર્યો")
        
        \# dumps() પણ demonstrate કરો
        serialized\_bytes = pickle.dumps(student\_data)
        print(f"✓ Data ને bytes માં serialize કર્યો: \{len(serialized\_bytes)\} bytes")
        
    except Exception as e:
        print(f"❌ Dump error: \{e\}")
    
    \# LOAD {- File માંથી objects deserialize કરો  }
    print("{n}=== LOAD Operation ===")
    try:
        with open({student\_data.pkl}, {rb}) as f:
            loaded\_data = pickle.load(f)
        
        print("✓ Data સફળતાપૂર્વક student\_data.pkl માંથી load કર્યો")
        print("{n}Loaded Data:")
        print("{-"} * 20)
        
        \# Loaded data display કરો
        for i, item in enumerate(loaded\_data):
            print(f"Item \{i+1\}: \{item\}")
            print(f"Type: \{type(item)\}")
            print()
        
        \# loads() પણ demonstrate કરો
        deserialized\_data = pickle.loads(serialized\_bytes)
        print(f"✓ Bytes માંથી data deserialize કર્યો: \{deserialized\_data\}")
        
    except FileNotFoundError:
        print("❌ Pickle ફાઇલ મળી નથી")
    except Exception as e:
        print(f"❌ Load error: \{e\}")

\# Advanced ઉદાહરણ custom class સાથે
def advanced\_pickle\_example():
    class BankAccount:
        def \_\_init\_\_(self, account\_no, holder\_name, balance):
            self.account\_no = account\_no
            self.holder\_name = holder\_name
            self.balance = balance
            self.transactions = []
        
        def deposit(self, amount):
            self.balance += amount
            self.transactions.append(f"Deposit: +\{amount\}")
        
        def withdraw(self, amount):
            if self.balance {=} amount:
                self.balance {-=} amount
                self.transactions.append(f"Withdraw: {-}\{amount\}")
            else:
                print("અપૂરતું balance")
        
        def \_\_str\_\_(self):
            return f"Account \{self.account\_no\}: \{self.holder\_name\} {- Balance: ₹}\{self.balance\}"
    
    \# Account બનાવો અને વાપરો
    account = BankAccount("12345", "અમિત કુમાર", 5000)
    account.deposit(1500)
    account.withdraw(800)
    
    print("=== Advanced Pickle ઉદાહરણ ===")
    print(f"મૂળ: \{account\}")
    print(f"Transactions: \{account.transactions\}")
    
    \# Account object serialize કરો
    with open({bank\_account.pkl}, {wb}) as f:
        pickle.dump(account, f)
    
    \# Account object load કરો
    with open({bank\_account.pkl}, {rb}) as f:
        loaded\_account = pickle.load(f)
    
    print(f"Loaded: \{loaded\_account\}")
    print(f"Loaded transactions: \{loaded\_account.transactions\}")
    
    \# Object functionality verify કરો
    loaded\_account.deposit(200)
    print(f"નવી deposit પછી: \{loaded\_account\}")

\# Demonstrations run કરો
demonstrate\_pickle()
print("{n}" + "="*50 + "{n}")
advanced\_pickle\_example()
\end{verbatim}

\textbf{ફાયદા અને મર્યાદાઓ:}

\begin{verbatim}
\# ફાયદા
benefits = [
    "સંપૂર્ણ object state preservation",
    "Complex nested objects સાથે કામ કરે છે", 
    "Object relationships maintain કરે છે",
    "Fast serialization/deserialization"
]

\# મર્યાદાઓ  
limitations = [
    "Python{-specific format"},
    "અવિશ્વસનીય data સાથે security risks",
    "Version compatibility issues",
    "Human{-readable નથી"}
]

print("ફાયદા:", benefits)
print("મર્યાદાઓ:", limitations)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Object Persistence}: Python objects ને ફાઇલમાં permanently store
  કરી શકાય
\item
  \textbf{Complete State}: Object ની complete state including methods
  preserve થાય છે
\item
  \textbf{Binary Format}: Efficient storage પણ human-readable નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dump Store, Load Restore''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{ફાઇલ ઓપરેશન માટે પાયથન દ્વારા આપેલ વિવિધ પ્રકારના ફાઇલ modes ની સૂચિ
બનાવો અને તેમના ઉપયોગો સમજાવો.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Python ફાઇલ Modes}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1538}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1795}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2051}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4615}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Mode
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pointer Position
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{`r'} & Text Read & માત્ર read કરવા, ફાઇલ હોવી જરૂરી & શરૂઆત \\
\textbf{`w'} & Text Write & માત્ર write કરવા, creates/overwrites &
શરૂઆત \\
\textbf{`a'} & Text Append & માત્ર write કરવા, creates if not exist &
અંત \\
\textbf{`x'} & Text Create & નવી ફાઇલ બનાવે, exists હોય તો fail & શરૂઆત \\
\textbf{`rb'} & Binary Read & Binary data read કરવા & શરૂઆત \\
\textbf{`wb'} & Binary Write & Binary data write કરવા & શરૂઆત \\
\textbf{`ab'} & Binary Append & Binary data append કરવા & અંત \\
\textbf{`r+'} & Text Read/Write & Read અને write, ફાઇલ હોવી જરૂરી &
શરૂઆત \\
\textbf{`w+'} & Text Write/Read & Write અને read, creates/overwrites &
શરૂઆત \\
\end{longtable}
}

\begin{verbatim}
\# ફાઇલ Modes ઉદાહરણો
import os

\# Demonstration માટે sample ફાઇલ બનાવો
with open({demo.txt}, {w}) as f:
    f.write("મૂળ content{n}Line 2{n}Line 3")

\# Read mode ({r)}
with open({demo.txt}, {r}) as f:
    content = f.read()
    print("Read mode:", content)

\# Append mode ({a)  }
with open({demo.txt}, {a}) as f:
    f.write("{n}Appended line")

\# Read+Write mode ({r+)}
with open({demo.txt}, {r+}) as f:
    f.seek(0)  \# શરૂઆતમાં જાઓ
    f.write("Modified")

print("ફાઇલ modes સફળતાપૂર્વક demonstrate કર્યા")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Safety}: `x' mode accidental ફાઇલ overwriting prevent કરે છે
\item
  \textbf{Efficiency}: Binary modes non-text data માટે ઝડપી છે
\item
  \textbf{Flexibility}: Combined modes બંને read અને write operations allow
  કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read Write Append Create Binary Plus''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{ફાઇલના readline() અને writeline() ફંકશનનું વર્ણન કરો.}

\begin{solutionbox}

\textbf{નોંધ}: Python માં \texttt{writeline()} ફંકશન અસ્તિત્વમાં નથી. યોગ્ય
ફંકશન \texttt{writelines()} છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Line-based ફાઇલ ફંકશન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2353}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1471}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3824}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2353}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંકશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Return Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{readline()} & એક line read કરવા & String & Sequential line
reading \\
\textbf{readlines()} & બધી lines read કરવા & List of strings & Complete
ફાઇલ as list \\
\textbf{writelines()} & Multiple lines write કરવા & None & List of
strings લખવા \\
\textbf{write()} & Single string write કરવા & Number of chars & Basic
writing \\
\end{longtable}
}

\begin{verbatim}
def demonstrate\_line\_functions():
    \# Multiple lines સાથે sample ફાઇલ બનાવો
    lines\_to\_write = [
        "પ્રથમ લાઇન{n}",
        "બીજી લાઇન{n}", 
        "ત્રીજી લાઇન{n}",
        "ચોથી લાઇન newline વગર"
    ]
    
    print("=== WRITELINES() Demonstration ===")
    \# writelines() વાપરીને multiple lines લખો
    with open({sample\_lines.txt}, {w}) as f:
        f.writelines(lines\_to\_write)
    print("✓ writelines() વાપરીને multiple lines લખ્યા")
    
    print("{n}=== READLINE() Demonstration ===")
    \# readline() વાપરીને એક{-એક line read કરો}
    with open({sample\_lines.txt}, {r}) as f:
        line\_count = 0
        while True:
            line = f.readline()
            if not line:  \# ફાઇલનો અંત
                break
            line\_count += 1
            print(f"Line \{line\_count\}: \{line.strip()\}")
    
    print(f"કુલ lines read કર્યા: \{line\_count\}")
    
    print("{n}=== READLINES() Demonstration ===")
    \# readlines() વાપરીને બધી lines એકસાથે read કરો
    with open({sample\_lines.txt}, {r}) as f:
        all\_lines = f.readlines()
    
    print("List તરીકે બધી lines:")
    for i, line in enumerate(all\_lines, 1):
        print(f"  [\{i\}] \{repr(line)\}")
    
    \# Practical ઉદાહરણ: ફાઇલને line by line process કરવી
    print("{n}=== Practical ઉદાહરણ ===")
    student\_data = [
        "રાજ,20,IT{n}",
        "પ્રિયા,19,CS{n}", 
        "અમિત,21,EC{n}",
        "સ્નેહા,20,IT{n}"
    ]
    
    \# Student data લખો
    with open({students.txt}, {w}) as f:
        f.writelines(student\_data)
    
    \# Line by line read અને process કરો
    print("Student Information:")
    with open({students.txt}, {r}) as f:
        while True:
            line = f.readline()
            if not line:
                break
            
            \# દરેક line ને process કરો
            parts = line.strip().split({,})
            if len(parts) == 3:
                name, age, course = parts
                print(f"  \{name\} (ઉંમર: \{age\}, કોર્સ: \{course\})")

\# Demonstration run કરો
demonstrate\_line\_functions()

\# ફાઇલ pointer behavior ઉદાહરણ
def file\_pointer\_demo():
    print("{n}=== ફાઇલ Pointer Behavior ===")
    
    with open({sample\_lines.txt}, {r}) as f:
        print(f"શરૂઆતની position: \{f.tell()\}")
        
        line1 = f.readline()
        print(f"readline() પછી: position \{f.tell()\}")
        print(f"Read: \{repr(line1)\}")
        
        line2 = f.readline()  
        print(f"બીજી readline() પછી: position \{f.tell()\}")
        print(f"Read: \{repr(line2)\}")

file\_pointer\_demo()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Sequential Access}: readline() sequential manner માં lines read
  કરે છે
\item
  \textbf{Memory Efficient}: મોટી ફાઇલો માટે readline() memory-efficient
  છે
\item
  \textbf{List Operations}: writelines() list of strings ને efficiently
  write કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read Line, Write Lines''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{seek() અને tell() methods ને demonstrate કરવા માટે પાયથન પ્રોગ્રામ
લખો.}

\begin{solutionbox}

seek() અને tell() methods ફાઇલ pointer manipulation માટે વાપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ફાઇલ Pointer મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
મેથડ & હેતુ & Parameters & Return Value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{tell()} & Current position & None & Integer (byte position) \\
\textbf{seek()} & Pointer move કરવા & offset, whence & New position \\
\textbf{whence=0} & શરૂઆતથી & Default & Absolute position \\
\textbf{whence=1} & Current થી & Relative & Current + offset \\
\textbf{whence=2} & અંતથી & End relative & End + offset \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: ફાઇલ Pointer Movement}

\begin{verbatim}
ફાઇલ: "Hello World"
      \^{             \^{}         \^{}}
   Position 0   Position 6  Position 11 (EOF)
   
seek(0)    {- શરૂઆતમાં move કરો}
seek(6)    {- Position 6 પર move કરો  }
seek({-5,2) {-} અંતથી 5 positions પહેલાં move કરો}
\end{verbatim}

\begin{verbatim}
def demonstrate\_seek\_tell():
    \# Known content સાથે sample ફાઇલ બનાવો
    sample\_text = "Hello Python Programming World!"
    
    with open({pointer\_demo.txt}, {w}) as f:
        f.write(sample\_text)
    
    print("=== ફાઇલ Pointer Demonstration ===")
    print(f"ફાઇલ content: {}\{sample\_text\}{"})
    print(f"ફાઇલ length: \{len(sample\_text)\} characters")
    print()
    
    with open({pointer\_demo.txt}, {r}) as f:
        \# શરૂઆતની position
        print(f"1. શરૂઆતની position: \{f.tell()\}")
        
        \# કેટલાક characters read કરો
        first\_part = f.read(5)  \# "Hello" read કરો
        print(f"2. {}\{first\_part\}{ read કર્યા પછી: position }\{f.tell()\}")
        
        \# Specific position પર move કરો
        f.seek(6)  \# Position 6 પર move કરો ("Python" ની શરૂઆત)
        print(f"3. seek(6) પછી: position \{f.tell()\}")
        
        \# નવી position થી read કરો
        next\_part = f.read(6)  \# "Python" read કરો
        print(f"4. {}\{next\_part\}{ read કર્યા: position }\{f.tell()\}")
        
        \# શરૂઆતમાં જાઓ
        f.seek(0)  \# શરૂઆતમાં જાઓ
        print(f"5. seek(0) પછી: position \{f.tell()\}")
        
        \# ફાઇલના અંતમાં જાઓ
        f.seek(0, 2)  \# અંતથી 0 offset (position 2 = end)
        print(f"6. seek(0,2) {- ફાઇલના અંતમાં: position }\{f.tell()\}")
        
        \# અંતથી પાછળ move કરો
        f.seek({-}6, 2)  \# અંતથી 6 positions પહેલાં
        print(f"7. seek({-6,2) પછી: position }\{f.tell()\}")
        
        \# બાકીનું content read કરો
        remaining = f.read()
        print(f"8. બાકીનું {}\{remaining\}{ read કર્યા: position }\{f.tell()\}")

def practical\_seek\_tell\_example():
    print("{n}=== Practical ઉદાહરણ: ફાઇલ Editor Simulation ===")
    
    \# Structured data સાથે ફાઇલ બનાવો
    data\_lines = [
        "NAME:John Doe{n}",
        "AGE:25{n}", 
        "CITY:Mumbai{n}",
        "PHONE:9876543210{n}",
        "EMAIL:john@example.com{n}"
    ]
    
    with open({person\_data.txt}, {w}) as f:
        f.writelines(data\_lines)
    
    \# Specific data find અને modify કરવું demonstrate કરો
    with open({person\_data.txt}, {r+}) as f:  \# Read+Write mode
        \# બધી positions find અને display કરો
        positions = \{\}
        
        while True:
            pos = f.tell()
            line = f.readline()
            if not line:
                break
            
            field = line.split({:})[0]
            positions[field] = pos
            print(f"Field {}\{field\}{ position }\{pos\} પર શરૂ થાય છે")
        
        print(f"{n}ફાઇલ positions: \{positions\}")
        
        \# Specific field (AGE) modify કરો
        if {AGE} in positions:
            f.seek(positions[{AGE}])
            print(f"{n}AGE field પર position \{f.tell()\} પર move કર્યા")
            
            \# Current line read કરો
            current\_line = f.readline()
            print(f"Current line: \{current\_line.strip()\}")
            
            \# Overwrite માટે position calculate કરો
            f.seek(positions[{AGE}])
            new\_age\_line = "AGE:26{n}"  \# મૂળ length જેટલી જ
            f.write(new\_age\_line)
            print(f"AGE field અપડેટ કર્યા")
    
    \# Changes verify કરો
    print("{n}અપડેટ કરેલ ફાઇલ content:")
    with open({person\_data.txt}, {r}) as f:
        print(f.read())

def binary\_seek\_tell\_demo():
    print("{n}=== Binary ફાઇલ Seek/Tell Demo ===")
    
    \# Binary ફાઇલ બનાવો
    binary\_data = b{}{x48x65x6cx6cx6fx20x57x6fx72x6cx64}{}  \# "Hello World"
    
    with open({binary\_demo.bin}, {wb}) as f:
        f.write(binary\_data)
    
    with open({binary\_demo.bin}, {rb}) as f:
        print(f"Binary ફાઇલ size: \{len(binary\_data)\} bytes")
        
        \# Binary mode માં બધા seek modes demonstrate કરો
        print(f"શરૂઆતની position: \{f.tell()\}")
        
        \# પહેલા 5 bytes read કરો
        first\_bytes = f.read(5)
        print(f"પહેલા 5 bytes read કર્યા: \{first\_bytes\} at position \{f.tell()\}")
        
        \# Current position થી relative seek (binary mode માં કામ કરે છે)
        f.seek(1, 1)  \# Current થી 1 byte આગળ move કરો
        print(f"seek(1,1) પછી: position \{f.tell()\}")
        
        \# અંતથી seek કરો
        f.seek({-}3, 2)  \# અંતથી 3 bytes પહેલાં
        print(f"seek({-3,2) પછી: position }\{f.tell()\}")
        
        \# બાકીના bytes
        remaining\_bytes = f.read()
        print(f"બાકીના bytes: \{remaining\_bytes\}")

\# બધા demonstrations run કરો
demonstrate\_seek\_tell()
practical\_seek\_tell\_example()
binary\_seek\_tell\_demo()

\# Cleanup
import os
try:
    os.remove({pointer\_demo.txt})
    os.remove({person\_data.txt}) 
    os.remove({binary\_demo.bin})
    print("{n}Demo ફાઇલો સાફ કર્યા")
except:
    pass
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફાઇલ Navigation}: seek() arbitrary position પર move કરવા માટે
  વાપરાય છે
\item
  \textbf{Position Tracking}: tell() current position track કરવા માટે
  useful છે
\item
  \textbf{ફાઇલ Editing}: Specific locations પર data modify કરવા માટે જરૂરી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Tell Position, Seek Destination''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{ટર્ટલનો ઉપયોગ કરીને circle અને rectangle ના આકાર દોરો અને તેમને લાલ
રંગથી ભરો.}

\begin{solutionbox}

Turtle graphics module માં shapes draw કરવા અને fill કરવા માટે specific
methods છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Turtle Shape મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
મેથડ & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{circle()} & Circle draw કરવા & \texttt{turtle.circle(50)} \\
\textbf{forward()} & આગળ move કરવા & \texttt{turtle.forward(100)} \\
\textbf{right()} & જમણે turn કરવા & \texttt{turtle.right(90)} \\
\textbf{begin\_fill()} & Fill શરૂ કરવા & \texttt{turtle.begin\_fill()} \\
\textbf{end\_fill()} & Fill સમાપ્ત કરવા & \texttt{turtle.end\_fill()} \\
\textbf{fillcolor()} & Fill color set કરવા &
\texttt{turtle.fillcolor("red")} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def draw\_filled\_shapes():
    \# Screen અને turtle બનાવો
    screen = turtle.Screen()
    screen.title("Turtle સાથે Filled Shapes")
    screen.bgcolor("white")
    screen.setup(800, 600)
    
    \# Turtle object બનાવો
    painter = turtle.Turtle()
    painter.speed(3)
    
    \# Filled circle draw કરો
    print("Filled circle draw કરી રહ્યા છીએ...")
    painter.penup()
    painter.goto({-}150, 0)  \# ડાબી બાજુ move કરો
    painter.pendown()
    
    painter.fillcolor("red")
    painter.begin\_fill()
    painter.circle(80)  \# Radius = 80
    painter.end\_fill()
    
    \# Filled rectangle draw કરો
    print("Filled rectangle draw કરી રહ્યા છીએ...")
    painter.penup()
    painter.goto(50, 50)  \# જમણી બાજુ move કરો
    painter.pendown()
    
    painter.fillcolor("red")
    painter.begin\_fill()
    
    \# Rectangle draw કરો (100x80)
    for \_ in range(2):
        painter.forward(100)
        painter.right(90)
        painter.forward(80)
        painter.right(90)
    
    painter.end\_fill()
    
    \# Labels ઉમેરો
    painter.penup()
    painter.goto({-}150, {-}120)
    painter.write("લાલ Circle", align="center", font=("Arial", 14, "normal"))
    
    painter.goto(100, {-}50)
    painter.write("લાલ Rectangle", align="center", font=("Arial", 14, "normal"))
    
    \# Turtle hide કરો અને result display કરો
    painter.hideturtle()
    print("Shapes સફળતાપૂર્વક draw કર્યા!")
    
    \# Window open રાખો
    screen.exitonclick()

\# પ્રોગ્રામ run કરો
draw\_filled\_shapes()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Fill Process}: begin\_fill() અને end\_fill() વચ્ચે drawn shape
  automatically fill થાય છે
\item
  \textbf{Color Setting}: fillcolor() method fill color set કરે છે
\item
  \textbf{Shape Drawing}: Geometric shapes માટે specific turtle movements
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Begin Fill Draw End''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{ટર્ટલની Direction બદલવાની વિવિધ inbuilt પદ્ધતિઓ સમજાવો.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Turtle Direction મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2778}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Parameters
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{right()} & angle & Degrees માં જમણે turn કરે છે &
\texttt{turtle.right(90)} \\
\textbf{left()} & angle & Degrees માં ડાબે turn કરે છે &
\texttt{turtle.left(45)} \\
\textbf{setheading()} & angle & Absolute direction set કરે છે &
\texttt{turtle.setheading(0)} \\
\textbf{towards()} & x, y & Coordinates તરફ point કરે છે &
\texttt{turtle.towards(100,\ 50)} \\
\textbf{home()} & none & Center પર return કરે, પૂર્વ તરફ face કરે &
\texttt{turtle.home()} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_direction\_methods():
    screen = turtle.Screen()
    screen.setup(600, 600)
    screen.title("Turtle Direction મેથડો")
    
    t = turtle.Turtle()
    t.speed(2)
    t.shape("turtle")
    
    \# 1. right() મેથડ
    t.write("1. right(90)", font=("Arial", 10, "normal"))
    t.forward(50)
    t.right(90)
    t.forward(50)
    
    \# 2. left() મેથડ  
    t.penup()
    t.goto({-}100, 100)
    t.pendown()
    t.write("2. left(45)", font=("Arial", 10, "normal"))
    t.forward(50)
    t.left(45)
    t.forward(50)
    
    \# 3. setheading() મેથડ
    t.penup()
    t.goto(100, 100)
    t.pendown()
    t.write("3. setheading(180)", font=("Arial", 10, "normal"))
    t.setheading(180)  \# પશ્ચિમ તરફ face કરો
    t.forward(50)
    
    \# 4. towards() મેથડ
    t.penup()
    t.goto({-}100, {-}100)
    t.pendown()
    target\_x, target\_y = 100, {-}100
    t.write("4. towards(100,{-100)"}, font=("Arial", 10, "normal"))
    angle = t.towards(target\_x, target\_y)
    t.setheading(angle)
    t.goto(target\_x, target\_y)
    
    \# 5. home() મેથડ
    t.write("5. home()", font=("Arial", 10, "normal"))
    t.home()  \# Center પર return કરો અને પૂર્વ તરફ face કરો
    
    t.hideturtle()
    screen.exitonclick()

demonstrate\_direction\_methods()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Relative Turns}: right() અને left() current direction થી
  relative turn કરે છે
\item
  \textbf{Absolute Direction}: setheading() absolute compass direction
  set કરે છે
\item
  \textbf{Smart Pointing}: towards() specific coordinates તરફ point કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Right Left Set Towards Home''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{ટર્ટલનો ઉપયોગ કરીને rainbow દોરવા માટે પાયથન પ્રોગ્રામ લખો.}

\begin{solutionbox}

Rainbow drawing માં multiple colored arcs અને proper positioning જરૂરી છે.

\textbf{ડાયાગ્રામ: Rainbow Structure}

\begin{verbatim}
    Red (બાહ્ય)
   Orange  
  Yellow
 Green
Blue
Indigo
Violet (અંદરનો)
\end{verbatim}

\begin{verbatim}
import turtle

def draw\_rainbow():
    \# Screen setup
    screen = turtle.Screen()
    screen.title("સુંદર Rainbow")
    screen.bgcolor("lightblue")
    screen.setup(800, 600)
    
    \# Turtle setup
    rainbow\_turtle = turtle.Turtle()
    rainbow\_turtle.speed(8)
    rainbow\_turtle.pensize(8)
    
    \# Rainbow colors (ROYGBIV)
    colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"]
    
    \# Rainbow parameters
    start\_radius = 200
    radius\_decrease = 15
    start\_y = {-}150
    
    print("Rainbow draw કરી રહ્યા છીએ...")
    
    \# દરેક color arc draw કરો
    for i, color in enumerate(colors):
        \# Color set કરો
        rainbow\_turtle.pencolor(color)
        
        \# Current radius calculate કરો
        current\_radius = start\_radius {-} (i * radius\_decrease)
        
        \# Semi{-circle માટે turtle position કરો}
        rainbow\_turtle.penup()
        rainbow\_turtle.goto({-}current\_radius, start\_y)
        rainbow\_turtle.pendown()
        rainbow\_turtle.setheading(0)  \# પૂર્વ તરફ face કરો
        
        \# Semi{-circle draw કરો (180 degrees)}
        rainbow\_turtle.circle(current\_radius, 180)
        
        print(f"\{color\} arc radius \{current\_radius\} સાથે draw કર્યો")
    
    \# Rainbow ના છેડે clouds ઉમેરો
    draw\_clouds(rainbow\_turtle)
    
    \# Sun ઉમેરો
    draw\_sun(rainbow\_turtle)
    
    \# Text ઉમેરો
    rainbow\_turtle.penup()
    rainbow\_turtle.goto(0, {-}250)
    rainbow\_turtle.pencolor("black")
    rainbow\_turtle.write("🌈 સુંદર Rainbow 🌈", align="center", 
                        font=("Arial", 16, "bold"))
    
    rainbow\_turtle.hideturtle()
    print("Rainbow પૂર્ણ થયું!")
    
    screen.exitonclick()

def draw\_clouds(turtle\_obj):
    """Rainbow ના બંને છેડે clouds draw કરે છે"""
    turtle\_obj.pensize(3)
    turtle\_obj.pencolor("white")
    turtle\_obj.fillcolor("lightgray")
    
    \# Clouds ની positions
    cloud\_positions = [({-}250, {-}100), (250, {-}100)]
    
    for x, y in cloud\_positions:
        turtle\_obj.penup()
        turtle\_obj.goto(x, y)
        turtle\_obj.pendown()
        
        \# Multiple circles વાપરીને cloud draw કરો
        turtle\_obj.begin\_fill()
        for i in range(3):
            turtle\_obj.circle(20)
            turtle\_obj.left(120)
        turtle\_obj.end\_fill()

def draw\_sun(turtle\_obj):
    """Corner માં sun draw કરે છે"""
    turtle\_obj.penup()
    turtle\_obj.goto(300, 200)
    turtle\_obj.pendown()
    turtle\_obj.pencolor("orange")
    turtle\_obj.fillcolor("yellow")
    
    \# Sun body draw કરો
    turtle\_obj.begin\_fill()
    turtle\_obj.circle(30)
    turtle\_obj.end\_fill()
    
    \# Sun rays draw કરો
    turtle\_obj.pensize(2)
    for angle in range(0, 360, 45):
        turtle\_obj.setheading(angle)
        turtle\_obj.forward(45)
        turtle\_obj.backward(45)

\# Alternative rainbow with gradient effect
def draw\_gradient\_rainbow():
    screen = turtle.Screen()
    screen.title("Gradient Rainbow")
    screen.bgcolor("skyblue")
    screen.setup(800, 600)
    
    t = turtle.Turtle()
    t.speed(0)
    t.pensize(5)
    
    \# Gradient effect માટે color variations
    rainbow\_colors = [
        "\#FF0000", "\#FF4500", "\#FFD700", "\#32CD32", 
        "\#0000FF", "\#4B0082", "\#8B00FF"
    ]
    
    \# Varying thickness સાથે rainbow draw કરો
    for i, color in enumerate(rainbow\_colors):
        t.pencolor(color)
        t.pensize(12 {-} i)  \# Decreasing thickness
        
        radius = 150 {-} (i * 10)
        t.penup()
        t.goto({-}radius, {-}100)
        t.pendown()
        t.setheading(0)
        t.circle(radius, 180)
    
    t.hideturtle()
    screen.exitonclick()

\# Rainbow programs run કરો
print("Rainbow પ્રકાર પસંદ કરો:")
print("1. Standard Rainbow")
print("2. Gradient Rainbow")

choice = input("પસંદગી દાખલ કરો (1 અથવા 2): ")
if choice == "2":
    draw\_gradient\_rainbow()
else:
    draw\_rainbow()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Color Sequence}: ROYGBIV (Red Orange Yellow Green Blue Indigo
  Violet) નો proper order
\item
  \textbf{Radius Management}: દરેક arc નો radius gradually decrease કરાય
  છે
\item
  \textbf{Positioning}: Proper positioning માટે penup/pendown અને goto
  methods
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ROYGBIV Arc Radius Position''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{ટર્ટલ સ્ક્રીનનો ડાયાગ્રામ દોરો અને x અને y કોઓર્ડિનેટ્સના તમામ 4
quadrants સમજાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ: Turtle Coordinate System}

\begin{verbatim}
                    +Y
                    |
                    |
        II          |          I
    ({-x,+y)         |      (+x,+y)}
                    |
{-X {-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-} +X}
       {-200  {-}100   0   100  200}
                    |
        III         |         IV  
    ({-x,{-}y)         |      (+x,{-}y)}
                    |
                    |
                   {-Y}
                   
Default Screen: 400x300 pixels
Center: (0, 0)
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Coordinate Quadrants}
\vspace{-10pt}
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Quadrant & X Value & Y Value & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{I} & Positive (+) & Positive (+) & ઉપર-જમણે & (100, 50) \\
\textbf{II} & Negative (-) & Positive (+) & ઉપર-ડાબે & (-100, 50) \\
\textbf{III} & Negative (-) & Negative (-) & નીચે-ડાબે & (-100, -50) \\
\textbf{IV} & Positive (+) & Negative (-) & નીચે-જમણે & (100, -50) \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_coordinate\_system():
    screen = turtle.Screen()
    screen.title("Turtle Coordinate System")
    screen.setup(600, 500)
    screen.bgcolor("white")
    
    t = turtle.Turtle()
    t.speed(3)
    t.shape("turtle")
    
    \# Coordinate axes draw કરો
    t.pencolor("gray")
    t.pensize(2)
    
    \# X{-axis}
    t.penup()
    t.goto({-}250, 0)
    t.pendown()
    t.goto(250, 0)
    
    \# Y{-axis}
    t.penup()
    t.goto(0, {-}200)
    t.pendown()
    t.goto(0, 200)
    
    \# Center mark કરો
    t.penup()
    t.goto(0, 0)
    t.dot(8, "red")
    t.write("(0,0)", font=("Arial", 12, "normal"))
    
    \# દરેક quadrant demonstrate કરો
    quadrants = [
        (100, 100, "I", "red"),     \# Quadrant I
        ({-}100, 100, "II", "blue"),  \# Quadrant II  
        ({-}100, {-}100, "III", "green"), \# Quadrant III
        (100, {-}100, "IV", "orange")   \# Quadrant IV
    ]
    
    for x, y, quad\_name, color in quadrants:
        t.pencolor(color)
        t.penup()
        t.goto(x, y)
        t.pendown()
        t.dot(10, color)
        t.write(f"Q\{quad\_name\}{n}(\{x\},\{y\})", align="center", 
                font=("Arial", 10, "bold"))
    
    t.hideturtle()
    screen.exitonclick()

demonstrate\_coordinate\_system()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Origin}: (0,0) screen ના center પર આવેલું છે
\item
  \textbf{Positive Direction}: X-axis જમણે તરફ, Y-axis ઉપર તરફ positive
\item
  \textbf{Navigation}: goto(x, y) method specific coordinates પર move કરે
  છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Right Up Positive, Left Down Negative''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{Background color, title, screensize અને shapesize ને બદલવા માટે
વિવિધ ટર્ટલ સ્ક્રીન પદ્ધતિઓનું વર્ણન કરો.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Turtle Screen મેથડો}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1818}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1515}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3030}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Parameters
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{bgcolor()} & Background color set કરવા & color name/hex &
\texttt{screen.bgcolor("blue")} \\
\textbf{title()} & Window title set કરવા & string &
\texttt{screen.title("My\ Program")} \\
\textbf{setup()} & Screen size set કરવા & width, height &
\texttt{screen.setup(800,\ 600)} \\
\textbf{screensize()} & Canvas size set કરવા & width, height &
\texttt{screen.screensize(400,\ 300)} \\
\textbf{shapesize()} & Turtle size set કરવા & stretch\_wid, stretch\_len
& \texttt{turtle.shapesize(2,\ 3)} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_screen\_methods():
    \# Screen object બનાવો
    screen = turtle.Screen()
    
    \# 1. Title મેથડ
    screen.title("Screen Methods Demonstration")
    print("✓ Title set કર્યું: {Screen Methods Demonstration"})
    
    \# 2. Background Color મેથડ
    screen.bgcolor("lightgreen")
    print("✓ Background color set કર્યો: lightgreen")
    
    \# 3. Setup મેથડ (window size)
    screen.setup(width=800, height=600)
    print("✓ Window size set કર્યું: 800x600 pixels")
    
    \# 4. Screen Size મેથડ (canvas size)
    screen.screensize(canvwidth=400, canvheight=300)
    print("✓ Canvas size set કર્યું: 400x300")
    
    \# Shapesize demonstrate કરવા માટે turtle બનાવો
    demo\_turtle = turtle.Turtle()
    demo\_turtle.speed(3)
    
    \# 5. Shape Size મેથડ
    demo\_turtle.shape("turtle")
    demo\_turtle.shapesize(stretch\_wid=3, stretch\_len=2, outline=3)
    print("✓ Turtle shape size: width=3x, length=2x, outline=3")
    
    \# વિવિધ background colors demonstrate કરો
    colors = ["lightblue", "lightyellow", "lightpink", "lightcoral"]
    
    for i, color in enumerate(colors):
        screen.bgcolor(color)
        demo\_turtle.write(f"Background: \{color\}", 
                         font=("Arial", 14, "normal"))
        demo\_turtle.forward(50)
        demo\_turtle.right(90)
        screen.ontimer(lambda: None, 1000)  \# 1 સેકન્ડ રાહ જુઓ
    
    \# Final state પર reset કરો
    screen.bgcolor("white")
    demo\_turtle.penup()
    demo\_turtle.goto(0, {-}50)
    demo\_turtle.write("Screen Methods Demo સંપૂર્ણ!", 
                     align="center", font=("Arial", 16, "bold"))
    
    demo\_turtle.hideturtle()
    screen.exitonclick()

def advanced\_screen\_customization():
    """Advanced screen customization ઉદાહરણ"""
    screen = turtle.Screen()
    
    \# બધા parameters સાથે advanced setup
    screen.setup(width=0.8, height=0.8, startx=100, starty=50)
    screen.title("🐢 Advanced Turtle Graphics 🐢")
    screen.bgcolor("\#2E8B57")  \# Sea Green
    
    \# Custom color palette
    screen.colormode(255)  \# RGB mode enable કરો
    
    \# વિવિધ sizes સાથે multiple turtles બનાવો
    turtles = []
    shapes = ["turtle", "circle", "square", "triangle"]
    sizes = [(1, 1), (2, 1), (1, 2), (3, 3)]
    colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0)]
    
    for i in range(4):
        t = turtle.Turtle()
        t.shape(shapes[i])
        t.shapesize(sizes[i][0], sizes[i][1])
        t.color(colors[i])
        t.penup()
        t.goto({-}150 + i*100, 0)
        turtles.append(t)
        
        \# દરેક turtle ને label કરો
        t.write(f"\{shapes[i]\}{n}\{sizes[i]\}", 
               align="center", font=("Arial", 10, "normal"))
    
    \# Instructions ઉમેરો
    instruction\_turtle = turtle.Turtle()
    instruction\_turtle.hideturtle()
    instruction\_turtle.penup()
    instruction\_turtle.goto(0, {-}100)
    instruction\_turtle.color("white")
    instruction\_turtle.write("વિવિધ turtle shapes અને sizes", 
                           align="center", font=("Arial", 16, "bold"))
    
    screen.exitonclick()

\# Demonstrations run કરો
print("Screen Methods Demo run કરી રહ્યા છીએ...")
demonstrate\_screen\_methods()

print("{n}Advanced Customization run કરી રહ્યા છીએ...")
advanced\_screen\_customization()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Window vs Canvas}: setup() window size, screensize() canvas
  size control કરે છે
\item
  \textbf{Color Modes}: bgcolor() color names અથવા hex values accept કરે
  છે
\item
  \textbf{Shape Scaling}: shapesize() turtle appearance ને scale કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Title Background Setup Size Shape''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{ટર્ટલનો ઉપયોગ કરીને સ્ટાર, ત્રિકોણ અને અષ્ટકોણ દોરવા માટે પાયથન પ્રોગ્રામ
લખો.}

\begin{solutionbox}

Geometric shapes drawing માં angles અને sides ની proper calculation જરૂરી
છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Shape Properties}
\vspace{-10pt}
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
આકાર & બાજુઓ & External Angle & Internal Angle & Turn Angle \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ત્રિકોણ} & 3 & 120^\circ & 60^\circ & 120^\circ \\
\textbf{સ્ટાર (5-point)} & 5 & 144^\circ & 36^\circ & 144^\circ \\
\textbf{અષ્ટકોણ} & 8 & 45^\circ & 135^\circ & 45^\circ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: Shape Construction}

\begin{verbatim}
ત્રિકોણ:        સ્ટાર:           અષ્ટકોણ:
   /{             *              /‾‾‾}
  /  {           /             /     }
 /\_\_\_\_{         /             |       |}
               *     *          {     /}
                {   /            \_\_\_/}
                 { /}
                  *
\end{verbatim}

\begin{verbatim}
import turtle
import math

def draw\_geometric\_shapes():
    \# Screen setup
    screen = turtle.Screen()
    screen.title("Geometric Shapes: સ્ટાર, ત્રિકોણ, અષ્ટકોણ")
    screen.bgcolor("black")
    screen.setup(900, 600)
    
    \# Turtle setup
    artist = turtle.Turtle()
    artist.speed(6)
    artist.pensize(3)
    
    \# આકાર 1: ત્રિકોણ
    draw\_triangle(artist, {-}250, 100, 80, "cyan")
    
    \# આકાર 2: પાંચ{-બિંદુવાળો સ્ટાર  }
    draw\_star(artist, 0, 100, 80, "yellow")
    
    \# આકાર 3: અષ્ટકોણ
    draw\_octagon(artist, 250, 100, 60, "magenta")
    
    \# Labels ઉમેરો
    add\_labels(artist)
    
    artist.hideturtle()
    print("બધા આકારો સફળતાપૂર્વક દોર્યા!")
    screen.exitonclick()

def draw\_triangle(turtle\_obj, x, y, size, color):
    """સમબાજુ ત્રિકોણ દોરે છે"""
    print(f"ત્રિકોણ (\{x\}, \{y\}) પર draw કરી રહ્યા છીએ")
    
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    
    turtle\_obj.begin\_fill()
    for \_ in range(3):
        turtle\_obj.forward(size)
        turtle\_obj.left(120)  \# ત્રિકોણ માટે external angle
    turtle\_obj.end\_fill()

def draw\_star(turtle\_obj, x, y, size, color):
    """પાંચ{-બિંદુવાળો સ્ટાર દોરે છે"""}
    print(f"સ્ટાર (\{x\}, \{y\}) પર draw કરી રહ્યા છીએ")
    
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    
    turtle\_obj.begin\_fill()
    for \_ in range(5):
        turtle\_obj.forward(size)
        turtle\_obj.right(144)  \# 5{-pointed સ્ટાર માટે 144^ turn}
    turtle\_obj.end\_fill()

def draw\_octagon(turtle\_obj, x, y, size, color):
    """નિયમિત અષ્ટકોણ દોરે છે"""
    print(f"અષ્ટકોણ (\{x\}, \{y\}) પર draw કરી રહ્યા છીએ")
    
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    
    turtle\_obj.begin\_fill()
    for \_ in range(8):
        turtle\_obj.forward(size)
        turtle\_obj.right(45)  \# અષ્ટકોણ માટે 360^/8 = 45^
    turtle\_obj.end\_fill()

def add\_labels(turtle\_obj):
    """દરેક આકાર માટે labels ઉમેરે છે"""
    turtle\_obj.color("white")
    
    labels = [
        ({-}250, 30, "ત્રિકોણ{n}3 બાજુઓ{n}120^ turns"),
        (0, 30, "સ્ટાર{n}5 બિંદુઓ{n}144^ turns"), 
        (250, 30, "અષ્ટકોણ{n}8 બાજુઓ{n}45^ turns")
    ]
    
    for x, y, text in labels:
        turtle\_obj.penup()
        turtle\_obj.goto(x, y)
        turtle\_obj.write(text, align="center", font=("Arial", 12, "normal"))

def draw\_advanced\_shapes():
    """Animations અને multiple variations સાથે advanced version"""
    screen = turtle.Screen()
    screen.title("Advanced Geometric Shapes")
    screen.bgcolor("navy")
    screen.setup(1000, 700)
    
    artist = turtle.Turtle()
    artist.speed(8)
    artist.pensize(2)
    
    \# Animated ત્રિકોણ variations
    triangle\_sizes = [40, 60, 80]
    triangle\_colors = ["red", "orange", "yellow"]
    
    for i, (size, color) in enumerate(zip(triangle\_sizes, triangle\_colors)):
        x = {-}300 + i * 30
        y = 200 {-} i * 20
        draw\_triangle(artist, x, y, size, color)
    
    \# Animated સ્ટાર variations
    star\_sizes = [30, 50, 70, 90]
    star\_colors = ["pink", "lightblue", "lightgreen", "gold"]
    
    for i, (size, color) in enumerate(zip(star\_sizes, star\_colors)):
        angle = i * 90
        x = 150 + math.cos(math.radians(angle)) * 80
        y = 100 + math.sin(math.radians(angle)) * 80
        
        artist.penup()
        artist.goto(x, y)
        artist.setheading(angle)
        artist.pendown()
        artist.color(color)
        artist.fillcolor(color)
        
        artist.begin\_fill()
        for \_ in range(5):
            artist.forward(size)
            artist.right(144)
        artist.end\_fill()
    
    \# અષ્ટકોણ pattern
    for i in range(3):
        size = 40 + i * 15
        color\_intensity = 0.3 + i * 0.2
        draw\_octagon(artist, {-}100, {-}100 + i * 80, size, 
                    (color\_intensity, 0, color\_intensity))
    
    \# ગણિતશાસ્ત્રીય માહિતી
    artist.penup()
    artist.goto(0, {-}250)
    artist.color("white")
    artist.write("Geometric Shapes {- ગણિતશાસ્ત્રીય ગુણધર્મો"}, 
                align="center", font=("Arial", 16, "bold"))
    
    artist.goto(0, {-}280)
    artist.write("ત્રિકોણ: કોણોનો સરવાળો = 180^, સ્ટાર: 36^ points, અષ્ટકોણ: સરવાળો = 1080^", 
                align="center", font=("Arial", 12, "normal"))
    
    artist.hideturtle()
    screen.exitonclick()

def calculate\_shape\_properties():
    """ગણિતશાસ્ત્રીય ગુણધર્મો calculate અને display કરે છે"""
    shapes\_info = \{
        "ત્રિકોણ": \{
            "બાજુઓ": 3,
            "આંતરિક\_કોણ": 180 * (3{-}2) / 3,
            "બાહ્ય\_કોણ": 360 / 3,
            "કોણોનો\_સરવાળો": 180 * (3{-}2)
        \,}
        "સ્ટાર (5{-point)"}: \{
            "બિંદુઓ": 5,
            "point\_angle": 36,
            "turn\_angle": 144,
            "કુલ\_rotation": 720
        \,}
        "અષ્ટકોણ": \{
            "બાજુઓ": 8,
            "આંતરિક\_કોણ": 180 * (8{-}2) / 8,
            "બાહ્ય\_કોણ": 360 / 8,
            "કોણોનો\_સરવાળો": 180 * (8{-}2)
        \}
    \}
    
    print("{n}" + "="*50)
    print("GEOMETRIC SHAPES {- ગણિતશાસ્ત્રીય ગુણધર્મો"})
    print("="*50)
    
    for shape, props in shapes\_info.items():
        print(f"{n}\{shape\}:")
        for prop, value in props.items():
            print(f"  \{prop.replace({\_}, { }).title()\}: \{value\}^" if {કોણ} in prop else f"  \{prop.replace({\_}, { }).title()\}: \{value\}")

\# પ્રોગ્રામ્સ run કરો
print("Drawing mode પસંદ કરો:")
print("1. Basic Shapes")
print("2. Advanced Shapes with Variations")

choice = input("પસંદગી દાખલ કરો (1 અથવા 2): ")

if choice == "2":
    draw\_advanced\_shapes()
else:
    draw\_geometric\_shapes()

\# ગણિતશાસ્ત્રીય ગુણધર્મો display કરો
calculate\_shape\_properties()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Angle Calculation}: દરેક shape માટે correct turn angles ની
  calculation જરૂરી
\item
  \textbf{Fill Technique}: begin\_fill() અને end\_fill() વચ્ચે shape
  automatically fill થાય
\item
  \textbf{Mathematical Foundation}: Geometry ના principles આધારે shapes
  construct થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Triangle 120, Star 144, Octagon 45''

\end{mnemonicbox}

\end{document}
