\documentclass{article}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/english-boxes.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Advanced Python Programming (4321602) - Winter 2024 Solution}
\date{January 18, 2025}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{Give the difference between Set and Dictionary in python.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Set vs Dictionary Comparison}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{Set} & \textbf{Dictionary} \\ \hline
Data Storage & Stores unique elements only & Stores key-value pairs \\ \hline
Order & Unordered collection & Ordered (Python 3.7+) \\ \hline
Duplicates & No duplicates allowed & Keys must be unique \\ \hline
Access & Cannot access by index & Access values by keys \\ \hline
Syntax & \code{\{1, 2, 3\}} & \code{\{'key': 'value'\}} \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Set}: Collection of unique, unordered elements
    \item \keyword{Dictionary}: Collection of key-value pairs with unique keys
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Sets are Unique, Dicts have Keys}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Explain List in Python with example.}

\begin{solutionbox}
\keyword{List} is an ordered, mutable collection that can store different data types.

\begin{center}
\captionof{table}{List Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Syntax} & \textbf{Example} \\ \hline
Create & \code{list\_name = []} & \code{fruits = ['apple', 'banana']} \\ \hline
Access & \code{list[index]} & \code{fruits[0]} returns 'apple' \\ \hline
Add & \code{append()} & \code{fruits.append('orange')} \\ \hline
Remove & \code{remove()} & \code{fruits.remove('apple')} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={List Example}]
# Example
numbers = [1, 2, 3, 4, 5]
numbers.append(6)  # [1, 2, 3, 4, 5, 6]
print(numbers[0])  # Output: 1
\end{lstlisting}

\begin{itemize}
    \item \keyword{Ordered}: Elements maintain their position
    \item \keyword{Mutable}: Can be modified after creation
    \item \keyword{Flexible}: Stores any data type
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Lists are Ordered and Modifiable}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{What is Tuple in Python? Write a Python program to swap two tuple values.}

\begin{solutionbox}
\keyword{Tuple} is an ordered, immutable collection that stores multiple items.

\begin{center}
\captionof{table}{Tuple Features}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Property} & \textbf{Description} & \textbf{Example} \\ \hline
Immutable & Cannot change after creation & \code{t = (1, 2, 3)} \\ \hline
Ordered & Elements have defined order & Access by index \\ \hline
Duplicates & Allows duplicate values & \code{(1, 1, 2)} \\ \hline
Indexing & Access elements by position & \code{t[0]} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Program to Swap Tuple Values}]
# Program to swap two tuple values
def swap_tuple_values(tup, pos1, pos2):
    # Convert tuple to list for swapping
    temp_list = list(tup)
    
    # Swap values
    temp_list[pos1], temp_list[pos2] = temp_list[pos2], temp_list[pos1]
    
    # Convert back to tuple
    return tuple(temp_list)

# Example usage
original_tuple = (10, 20, 30, 40, 50)
print("Original tuple:", original_tuple)

# Swap values at positions 1 and 3
swapped_tuple = swap_tuple_values(original_tuple, 1, 3)
print("After swapping:", swapped_tuple)
\end{lstlisting}

\begin{itemize}
    \item \keyword{Immutable}: Cannot modify once created
    \item \keyword{Ordered}: Maintains element sequence
    \item \keyword{Heterogeneous}: Can store different data types
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Tuples are Immutable and Ordered}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{What is Dictionary in Python? Write a Python program to traverse a dictionary using loop.}

\begin{solutionbox}
\keyword{Dictionary} is an unordered collection of key-value pairs with unique keys.

\begin{center}
\captionof{table}{Dictionary Methods}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Method} & \textbf{Purpose} & \textbf{Example} \\ \hline
\code{keys()} & Get all keys & \code{dict.keys()} \\ \hline
\code{values()} & Get all values & \code{dict.values()} \\ \hline
\code{items()} & Get key-value pairs & \code{dict.items()} \\ \hline
\code{get()} & Safe key access & \code{dict.get('key')} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Dictionary Traversal Program}]
# Program to traverse dictionary using loops
student_marks = {
    'Alice': 85,
    'Bob': 92,
    'Charlie': 78,
    'Diana': 96,
    'Eve': 89
}

print("Dictionary Traversal Methods:")
print("-" * 30)

# Method 1: Traverse keys only
print("1. Keys only:")
for key in student_marks:
    print(f"   {key}")

# Method 2: Traverse values only
print("\n2. Values only:")
for value in student_marks.values():
    print(f"   {value}")

# Method 3: Traverse key-value pairs
print("\n3. Key-Value pairs:")
for key, value in student_marks.items():
    print(f"   {key}: {value}")

# Method 4: Using keys() method
print("\n4. Using keys() method:")
for key in student_marks.keys():
    print(f"   {key} scored {student_marks[key]}")
\end{lstlisting}

\begin{itemize}
    \item \keyword{Key-Value storage}: Each key maps to a value
    \item \keyword{Unique keys}: No duplicate keys allowed
    \item \keyword{Fast lookup}: O(1) average time complexity
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Dicts map Keys to Values}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{What is Package? List out advantages of using Package.}

\begin{solutionbox}
\keyword{Package} is a directory containing multiple modules organized together.

\begin{center}
\captionof{table}{Package Advantages}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Advantage} & \textbf{Description} \\ \hline
Organization & Groups related modules together \\ \hline
Namespace & Avoids naming conflicts \\ \hline
Reusability & Code can be reused across projects \\ \hline
Maintainability & Easier to manage large codebases \\ \hline
Distribution & Easy to share and install \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Modular structure}: Better code organization
    \item \keyword{Hierarchical namespace}: Prevents name conflicts
    \item \keyword{Code reuse}: Promotes software reusability
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Packages Organize Related Modules}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Explain any two package import method with example.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Import Methods}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Method} & \textbf{Syntax} & \textbf{Usage} \\ \hline
Normal Import & \code{import package.module} & Access with full path \\ \hline
From Import & \code{from package import module} & Direct module access \\ \hline
Specific Import & \code{from package.module import function} & Import specific items \\ \hline
Wildcard Import & \code{from package import *} & Import all modules \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Package Import Examples}]
# Method 1: Normal Import
import mypackage.calculator
result = mypackage.calculator.add(5, 3)
print(f"Normal import result: {result}")

# Method 2: From Import
from mypackage import calculator
result = calculator.multiply(4, 6)
print(f"From import result: {result}")
\end{lstlisting}

\begin{itemize}
    \item \keyword{Normal import}: Requires full package path
    \item \keyword{From import}: Allows direct module access
    \item \keyword{Specific function import}: Import only needed functions
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Import Normally or From Package}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Explain about intra-package reference with example.}

\begin{solutionbox}
\keyword{Intra-package reference} allows modules within a package to import from each other.

\textbf{Package Structure Diagram:}

\begin{center}
\begin{tikzpicture}[node distance=0.8cm and 1.5cm, auto]
    \node [gtu block] (root) {mypackage/};
    \node [gtu block, below left=of root] (init1) {\_\_init\_\_.py};
    \node [gtu block, below=of root] (math) {math\_ops/};
    \node [gtu block, below right=of root] (utils) {utils/};
    
    \node [gtu block, below left=of math] (init2) {\_\_init\_\_.py};
    \node [gtu block, below=of math] (basic) {basic.py};
    \node [gtu block, below right=of math] (advanced) {advanced.py};
    
    \node [gtu block, below=of utils] (init3) {\_\_init\_\_.py};
    \node [gtu block, below=of init3] (helpers) {helpers.py};
    
    \path [gtu arrow] (root) -- (init1);
    \path [gtu arrow] (root) -- (math);
    \path [gtu arrow] (root) -- (utils);
    \path [gtu arrow] (math) -- (init2);
    \path [gtu arrow] (math) -- (basic);
    \path [gtu arrow] (math) -- (advanced);
    \path [gtu arrow] (utils) -- (init3);
    \path [gtu arrow] (utils) -- (helpers);
\end{tikzpicture}
\captionof{figure}{Package Directory Structure}
\end{center}

\begin{center}
\captionof{table}{Reference Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Type} & \textbf{Syntax} & \textbf{Usage} \\ \hline
Absolute & \code{from mypackage.math\_ops import basic} & Full path from package root \\ \hline
Relative & \code{from . import basic} & Current package \\ \hline
Parent & \code{from .. import utils} & Parent package \\ \hline
Sibling & \code{from ..utils import helpers} & Sibling package \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Intra-package Reference Example}]
# Package structure example
# mypackage/math_ops/advanced.py
from . import basic  # Relative import from same package
from ..utils import helpers  # Import from sibling package

def power_operation(base, exp):
    # Using function from basic module
    if basic.is_valid_number(base) and basic.is_valid_number(exp):
        result = base ** exp
        # Using helper function
        return helpers.format_result(result)
    return None

# mypackage/math_ops/basic.py
def is_valid_number(num):
    return isinstance(num, (int, float))

def add(a, b):
    return a + b

# mypackage/utils/helpers.py
def format_result(value):
    return f"Result: {value:.2f}"
\end{lstlisting}

\begin{itemize}
    \item \keyword{Relative imports}: Use dots (.) for current package
    \item \keyword{Absolute imports}: Full package path
    \item \keyword{Package hierarchy}: Navigate using dot notation
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Dots Navigate Package Levels}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{What is Module? List out advantages of using Module.}

\begin{solutionbox}
\keyword{Module} is a Python file containing definitions, statements, and functions.

\begin{center}
\captionof{table}{Module Advantages}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Advantage} & \textbf{Description} \\ \hline
Code Reusability & Write once, use multiple times \\ \hline
Namespace & Separate namespace for functions \\ \hline
Organization & Better code structure \\ \hline
Maintainability & Easier to debug and update \\ \hline
Collaboration & Multiple developers can work \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Reusable code}: Functions can be imported anywhere
    \item \keyword{Modular design}: Break large programs into smaller parts
    \item \keyword{Easy maintenance}: Changes in one place affect all imports
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Modules Make Code Reusable}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{Explain any two module import method with example.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Module Import Methods}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Method} & \textbf{Syntax} & \textbf{Access Pattern} \\ \hline
Direct Import & \code{import module\_name} & \code{module\_name.function()} \\ \hline
From Import & \code{from module\_name import function} & \code{function()} \\ \hline
Alias Import & \code{import module\_name as alias} & \code{alias.function()} \\ \hline
Wildcard Import & \code{from module\_name import *} & \code{function()} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Module Import Examples}]
# Method 1: Direct Import
import math
result1 = math.sqrt(16)
print(f"Direct import: {result1}")

# Method 2: From Import
from math import pi, sin
result2 = sin(pi/2)
print(f"From import: {result2}")
\end{lstlisting}

\begin{itemize}
    \item \keyword{Direct import}: Access with module name prefix
    \item \keyword{From import}: Direct function access without prefix
    \item \keyword{Namespace control}: Choose appropriate import method
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Import Directly or From Module}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Write a program to define a module to find the area and circumference of a circle.}

\begin{solutionbox}
\begin{lstlisting}[language=Python,caption={Circle Operations Module}]
# circle_operations.py (Module file)
import math

def area(radius):
    """Calculate area of circle"""
    if radius <= 0:
        return 0
    return math.pi * radius * radius

def circumference(radius):
    """Calculate circumference of circle"""
    if radius <= 0:
        return 0
    return 2 * math.pi * radius

def display_info(radius):
    """Display circle information"""
    print(f"Circle with radius: {radius}")
    print(f"Area: {area(radius):.2f}")
    print(f"Circumference: {circumference(radius):.2f}")

# Constants
PI = math.pi

# a) Import the module to another program
# main_program.py
import circle_operations

radius = 5
print("Method 1: Import entire module")
area_result = circle_operations.area(radius)
circumference_result = circle_operations.circumference(radius)

print(f"Area: {area_result:.2f}")
print(f"Circumference: {circumference_result:.2f}")

# b) Import specific function from module
# specific_import.py
from circle_operations import area, circumference

radius = 7
print("\nMethod 2: Import specific functions")
area_result = area(radius)
circumference_result = circumference(radius)

print(f"Area: {area_result:.2f}")
print(f"Circumference: {circumference_result:.2f}")
\end{lstlisting}

\begin{center}
\captionof{table}{Module Features}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Feature} & \textbf{Implementation} \\ \hline
Functions & \code{area()}, \code{circumference()} \\ \hline
Error Handling & Check for negative radius \\ \hline
Constants & PI value \\ \hline
Documentation & Function docstrings \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Module creation}: Save functions in .py file
    \item \keyword{Import flexibility}: Whole module or specific functions
    \item \keyword{Code reuse}: Use same functions in multiple programs
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Modules Contain Reusable Functions}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Explain the types of error in Python.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Python Error Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Error Type} & \textbf{Description} & \textbf{Example} \\ \hline
Syntax Error & Wrong Python syntax & Missing colon \code{:} \\ \hline
Runtime Error & Occurs during execution & Division by zero \\ \hline
Logical Error & Wrong program logic & Incorrect algorithm \\ \hline
Name Error & Undefined variable & Using undeclared variable \\ \hline
Type Error & Wrong data type operation & String + Integer \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Syntax errors}: Detected before program runs
    \item \keyword{Runtime errors}: Occur during program execution
    \item \keyword{Logical errors}: Program runs but gives wrong results
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Syntax, Runtime, Logic Errors}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Explain user-defined exception using raise statement with example.}

\begin{solutionbox}
\keyword{User-defined exceptions} are custom error classes created by programmers.

\begin{center}
\captionof{table}{Exception Components}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Component} & \textbf{Purpose} & \textbf{Example} \\ \hline
Class Definition & Create custom exception & \code{class CustomError(Exception):} \\ \hline
Raise Statement & Trigger the exception & \code{raise CustomError("message")} \\ \hline
Error Message & Describe the problem & Informative text \\ \hline
Exception Handling & Catch custom exception & \code{except CustomError:} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={User-Defined Exception Example}]
# Define custom exception
class AgeValidationError(Exception):
    def __init__(self, age, message="Invalid age provided"):
        self.age = age
        self.message = message
        super().__init__(self.message)

def validate_age(age):
    if age < 0:
        raise AgeValidationError(age, "Age cannot be negative")
    elif age > 150:
        raise AgeValidationError(age, "Age cannot exceed 150")
    else:
        print(f"Valid age: {age}")

# Using the custom exception
try:
    validate_age(-5)
except AgeValidationError as e:
    print(f"Error: {e.message}, Age: {e.age}")
\end{lstlisting}

\begin{itemize}
    \item \keyword{Custom exception class}: Inherits from Exception
    \item \keyword{Raise statement}: Manually trigger exceptions
    \item \keyword{Meaningful messages}: Help debug problems
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Raise Custom Exceptions for Validation}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Explain try-except-finally clause with example.}

\begin{solutionbox}
\keyword{Try-except-finally} provides complete exception handling mechanism.

\begin{center}
\captionof{table}{Exception Handling Blocks}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Block} & \textbf{Purpose} & \textbf{Execution} \\ \hline
try & Code that might raise exception & Always executed first \\ \hline
except & Handle specific exceptions & Only if exception occurs \\ \hline
else & Code when no exception & Only if no exception \\ \hline
finally & Cleanup code & Always executed \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Complete Exception Handling Example}]
# Complete exception handling example
def divide_numbers():
    try:
        print("Starting division operation...")
        
        # Get input from user
        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))
        
        # Perform division
        result = num1 / num2
        
    except ValueError:
        print("Error: Please enter valid numbers only")
        return None
        
    except ZeroDivisionError:
        print("Error: Cannot divide by zero")
        return None
        
    except Exception as e:
        print(f"Unexpected error occurred: {e}")
        return None
        
    else:
        print(f"Division successful: {num1} / {num2} = {result}")
        return result
        
    finally:
        print("Division operation completed")
        print("Cleaning up resources...")

# Example usage
result = divide_numbers()
if result:
    print(f"Final result: {result}")
\end{lstlisting}

\textbf{Exception Handling Flow:}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm and 2cm, auto]
    \node [gtu state] (try) {try block};
    \node [gtu decision, right=of try] (exception) {Exception\\occurred?};
    \node [gtu state, below left=of exception] (except) {except block};
    \node [gtu state, below right=of exception] (else) {else block};
    \node [gtu state, below=2cm of exception] (finally) {finally block};
    \node [gtu state, below=of finally] (end) {End};
    
    \path [gtu arrow] (try) -- (exception);
    \path [gtu arrow] (exception) -- node[above left] {Yes} (except);
    \path [gtu arrow] (exception) -- node[above right] {No} (else);
    \path [gtu arrow] (except) -- (finally);
    \path [gtu arrow] (else) -- (finally);
    \path [gtu arrow] (finally) -- (end);
\end{tikzpicture}
\captionof{figure}{Try-Except-Finally Flow}
\end{center}

\begin{itemize}
    \item \keyword{try}: Contains risky code
    \item \keyword{except}: Handles specific errors
    \item \keyword{finally}: Always executes for cleanup
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Try-Except-Finally Always Cleans}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{What is built-in exception? List out any two with their meaning.}

\begin{solutionbox}
\keyword{Built-in exceptions} are predefined error types in Python.

\begin{center}
\captionof{table}{Built-in Exceptions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Exception} & \textbf{Meaning} & \textbf{Example} \\ \hline
ValueError & Invalid value for correct type & \code{int("abc")} \\ \hline
TypeError & Wrong data type operation & \code{"5" + 5} \\ \hline
IndexError & List index out of range & \code{list[10]} for 5-item list \\ \hline
KeyError & Dictionary key not found & \code{dict["missing\_key"]} \\ \hline
ZeroDivisionError & Division by zero & \code{10 / 0} \\ \hline
\end{tabulary}
\end{center}

\textbf{Two Main Built-in Exceptions:}

\begin{itemize}
    \item \keyword{ValueError}: Occurs when function receives correct type but invalid value
    \item \keyword{TypeError}: Occurs when operation performed on inappropriate data type
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Built-in Exceptions Handle Common Errors}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Explain try-except clause with example.}

\begin{solutionbox}
\keyword{Try-except} handles exceptions that might occur during program execution.

\begin{center}
\captionof{table}{Exception Handling Components}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Component} & \textbf{Purpose} & \textbf{Syntax} \\ \hline
try & Code that might fail & \code{try:} \\ \hline
except & Handle specific exception & \code{except ErrorType:} \\ \hline
Multiple except & Handle different errors & Multiple except blocks \\ \hline
General except & Catch any exception & \code{except:} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Try-Except Example}]
# Example of try-except clause
def safe_division():
    try:
        # Code that might raise exceptions
        dividend = int(input("Enter dividend: "))
        divisor = int(input("Enter divisor: "))
        
        result = dividend / divisor
        print(f"Result: {dividend} / {divisor} = {result}")
        
    except ValueError:
        print("Error: Please enter valid integers only")
        
    except ZeroDivisionError:
        print("Error: Cannot divide by zero")
        
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    
    print("Program continues after exception handling")

# Example usage
safe_division()
\end{lstlisting}

\begin{itemize}
    \item \keyword{try block}: Contains potentially risky code
    \item \keyword{except block}: Handles specific exception types
    \item \keyword{Multiple handlers}: Different exceptions handled differently
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Try Risky Code, Except Handles Errors}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{Write a program to catch on Divide by zero Exception with finally clause.}

\begin{solutionbox}
\begin{lstlisting}[language=Python,caption={Divide by Zero with Finally Clause}]
# Program to handle divide by zero with finally clause
def advanced_calculator():
    """Calculator with comprehensive exception handling"""
    
    try:
        print("=== Advanced Calculator ===")
        print("Enter two numbers for division")
        
        # Input section
        numerator = float(input("Enter numerator: "))
        denominator = float(input("Enter denominator: "))
        
        print(f"\nAttempting to divide {numerator} by {denominator}...")
        
        # Critical operation that might fail
        if denominator == 0:
            raise ZeroDivisionError("Division by zero is not allowed")
        
        result = numerator / denominator
        
        # Success message
        print(f"✓ Division successful!")
        print(f"✓ Result: {numerator} / {denominator} = {result:.4f}")
        
        return result
        
    except ZeroDivisionError as zde:
        print(f"✗ Zero Division Error: {zde}")
        print("✗ Please use a non-zero denominator")
        return None
        
    except ValueError as ve:
        print(f"✗ Value Error: Invalid input provided")
        print("✗ Please enter numeric values only")
        return None
        
    except Exception as e:
        print(f"✗ Unexpected error: {e}")
        return None
        
    finally:
        print("\n" + "="*40)
        print("CLEANUP OPERATIONS:")
        print("- Closing calculator session")
        print("- Saving operation log")
        print("- Releasing memory resources")
        print("- Calculator shutdown complete")
        print("="*40)

# Run the calculator
if __name__ == "__main__":
    result = advanced_calculator()
    
    if result is not None:
        print(f"\nFinal calculated result: {result}")
    else:
        print("\nCalculation failed due to errors")
\end{lstlisting}

\begin{center}
\captionof{table}{Exception Handling Features}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Feature} & \textbf{Implementation} \\ \hline
ZeroDivisionError & Specific handling for division by zero \\ \hline
ValueError & Handle invalid input types \\ \hline
Generic Exception & Catch unexpected errors \\ \hline
Finally Block & Always execute cleanup code \\ \hline
\end{tabulary}
\end{center}

\textbf{Exception Handling Flow:}

\begin{center}
\begin{tikzpicture}[node distance=1.2cm and 1.8cm, auto]
    \node [gtu state] (start) {Start\\Division};
    \node [gtu state, right=of start] (try) {try block};
    \node [gtu decision, right=of try] (exception) {Exception?};
    \node [gtu state, below left=of exception] (zero) {Handle\\ZeroDivision};
    \node [gtu state, below=of exception] (value) {Handle\\ValueError};
    \node [gtu state, below right=of exception] (other) {Handle\\Generic};
    \node [gtu state, above right=of exception] (success) {Success\\Result};
    \node [gtu state, below=2.5cm of exception] (finally) {finally block};
    \node [gtu state, below=of finally] (end) {End};
    
    \path [gtu arrow] (start) -- (try);
    \path [gtu arrow] (try) -- (exception);
    \path [gtu arrow] (exception) -- node[left] {ZeroDivisionError} (zero);
    \path [gtu arrow] (exception) -- node[right] {ValueError} (value);
    \path [gtu arrow] (exception) -- node[right] {Other} (other);
    \path [gtu arrow] (exception) -- node[above] {None} (success);
    \path [gtu arrow] (zero) -- (finally);
    \path [gtu arrow] (value) -- (finally);
    \path [gtu arrow] (other) -- (finally);
    \path [gtu arrow] (success) -- (finally);
    \path [gtu arrow] (finally) -- (end);
\end{tikzpicture}
\captionof{figure}{Divide by Zero Exception Handling Flow}
\end{center}

\begin{itemize}
    \item \keyword{Specific exception handling}: ZeroDivisionError caught separately
    \item \keyword{Finally clause}: Always executes for cleanup
    \item \keyword{Resource management}: Proper cleanup regardless of errors
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Finally Always Cleans Up Resources}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Define: File, Binary File, Text File}

\begin{solutionbox}
\begin{center}
\captionof{table}{File Definitions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Term} & \textbf{Definition} & \textbf{Example} \\ \hline
File & Named storage location on disk & document.txt, image.jpg \\ \hline
Binary File & Contains non-text data in binary format & .exe, .jpg, .mp3, .pdf \\ \hline
Text File & Contains human-readable text characters & .txt, .py, .html, .csv \\ \hline
\end{tabulary}
\end{center}

\textbf{Detailed Definitions:}

\begin{itemize}
    \item \keyword{File}: A collection of data stored on storage device with a unique name
    \item \keyword{Binary File}: Stores data in binary format (0s and 1s), not human-readable
    \item \keyword{Text File}: Contains ASCII or Unicode characters, human-readable format
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Files store data, Binary=Machine, Text=Human}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Explain write() and writelines() function with example.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Write Functions}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Function} & \textbf{Purpose} & \textbf{Parameter} & \textbf{Usage} \\ \hline
\code{write()} & Write single string & String & \code{file.write("Hello")} \\ \hline
\code{writelines()} & Write list of strings & List/Sequence & \code{file.writelines(["line1", "line2"])} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Write Functions Example}]
# Example demonstrating write() and writelines()
def demonstrate_write_functions():
    
    # Using write() function
    with open("write_demo.txt", "w") as file:
        file.write("Hello World!\n")
        file.write("This is line 2\n")
        file.write("This is line 3\n")
    
    # Using writelines() function
    lines = [
        "First line using writelines\n",
        "Second line using writelines\n", 
        "Third line using writelines\n"
    ]
    
    with open("writelines_demo.txt", "w") as file:
        file.writelines(lines)
    
    print("Files created successfully!")

# Run the demonstration
demonstrate_write_functions()
\end{lstlisting}

\textbf{Key Differences:}

\begin{itemize}
    \item \keyword{write()}: Writes one string at a time
    \item \keyword{writelines()}: Writes multiple strings from a sequence
    \item \keyword{Newlines}: Must be added manually with \code{\textbackslash n}
    \item \keyword{Return value}: Both return number of characters written
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{write() Single, writelines() Multiple}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Explain tell() and seek() function with example.}

\begin{solutionbox}
\keyword{File pointer functions} control position within a file for reading/writing.

\begin{center}
\captionof{table}{Position Functions}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Function} & \textbf{Purpose} & \textbf{Return/Parameter} & \textbf{Usage} \\ \hline
\code{tell()} & Get current position & Returns current byte position & \code{pos = file.tell()} \\ \hline
\code{seek(offset, whence)} & Move to specific position & offset: bytes, whence: reference & \code{file.seek(10, 0)} \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\captionof{table}{Seek Whence Values}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Value} & \textbf{Reference Point} & \textbf{Description} \\ \hline
0 & Beginning of file & Absolute positioning \\ \hline
1 & Current position & Relative to current \\ \hline
2 & End of file & Relative to end \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={tell() and seek() Example}]
# Complete example of tell() and seek() functions
def demonstrate_file_positioning():
    
    # Create a sample file
    sample_text = "Hello World! This is a sample file for demonstrating tell() and seek() functions."
    
    with open("position_demo.txt", "w") as file:
        file.write(sample_text)
    
    # Demonstrate tell() and seek()
    with open("position_demo.txt", "r") as file:
        
        # Initial position
        print(f"1. Initial position: {file.tell()}")
        
        # Read first 5 characters
        data1 = file.read(5)
        print(f"2. Read '{data1}', current position: {file.tell()}")
        
        # Move to position 15
        file.seek(15)
        print(f"3. After seek(15), position: {file.tell()}")
        
        # Read next 10 characters
        data2 = file.read(10)
        print(f"4. Read '{data2}', current position: {file.tell()}")
        
        # Move to beginning using seek(0, 0)
        file.seek(0, 0)
        print(f"5. After seek(0,0), position: {file.tell()}")
        
        # Move to end using seek(0, 2)
        file.seek(0, 2)
        print(f"6. After seek(0,2), position: {file.tell()}")
        
        # Move backward from current position
        file.seek(-10, 1)
        print(f"7. After seek(-10,1), position: {file.tell()}")
        
        # Read remaining content
        remaining = file.read()
        print(f"8. Remaining content: '{remaining}'")

# Run demonstration
demonstrate_file_positioning()
\end{lstlisting}

\textbf{Position Control Flow:}

\begin{center}
\begin{tikzpicture}[node distance=1.2cm and 1.5cm, auto]
    \node [gtu state] (start) {File\\Start};
    \node [gtu state, right=of start] (tell0) {tell(): 0};
    \node [gtu state, right=of tell0] (read5) {read(5)};
    \node [gtu state, right=of read5] (tell5) {tell(): 5};
    \node [gtu state, below=of tell5] (seek15) {seek(15)};
    \node [gtu state, left=of seek15] (tell15) {tell(): 15};
    \node [gtu state, left=of tell15] (seek02) {seek(0,2)};
    \node [gtu state, left=of seek02] (end) {tell():\\End};
    
    \path [gtu arrow] (start) -- (tell0);
    \path [gtu arrow] (tell0) -- (read5);
    \path [gtu arrow] (read5) -- (tell5);
    \path [gtu arrow] (tell5) -- (seek15);
    \path [gtu arrow] (seek15) -- (tell15);
    \path [gtu arrow] (tell15) -- (seek02);
    \path [gtu arrow] (seek02) -- (end);
\end{tikzpicture}
\captionof{figure}{File Position Control Flow}
\end{center}

\begin{itemize}
    \item \keyword{tell()}: Returns current byte position in file
    \item \keyword{seek()}: Moves file pointer to specified position
    \item \keyword{Positioning}: Essential for random file access
    \item \keyword{Binary mode}: Works with byte positions
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{tell() Position, seek() Movement}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{What is Absolute and Relative file path?}

\begin{solutionbox}
\begin{center}
\captionof{table}{Path Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Path Type} & \textbf{Description} & \textbf{Example} \\ \hline
Absolute Path & Complete path from root directory & \code{/home/user/documents/file.txt} \\ \hline
Relative Path & Path relative to current directory & \code{../documents/file.txt} \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\captionof{table}{Path Symbols}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Symbol} & \textbf{Meaning} & \textbf{Example} \\ \hline
\code{/} & Root directory (Linux/Mac) & \code{/home/user/} \\ \hline
\code{C:\textbackslash} & Drive letter (Windows) & \code{C:\textbackslash Users\textbackslash Documents\textbackslash} \\ \hline
\code{.} & Current directory & \code{./file.txt} \\ \hline
\code{..} & Parent directory & \code{../folder/file.txt} \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Absolute}: Complete path from system root
    \item \keyword{Relative}: Path from current working directory
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Absolute from Root, Relative from Current}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Explain about various mode to open binary and text file.}

\begin{solutionbox}
\begin{center}
\captionof{table}{File Opening Modes}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Mode} & \textbf{Type} & \textbf{Purpose} & \textbf{File Pointer} \\ \hline
\code{'r'} & Text & Read only & Beginning \\ \hline
\code{'w'} & Text & Write (overwrites) & Beginning \\ \hline
\code{'a'} & Text & Append & End \\ \hline
\code{'rb'} & Binary & Read binary & Beginning \\ \hline
\code{'wb'} & Binary & Write binary & Beginning \\ \hline
\code{'ab'} & Binary & Append binary & End \\ \hline
\code{'r+'} & Text & Read and write & Beginning \\ \hline
\code{'w+'} & Text & Write and read & Beginning \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={File Modes Example}]
# Examples of different file modes
def demonstrate_file_modes():
    
    # Text file modes
    with open("text_file.txt", "w") as f:  # Write mode
        f.write("Hello World")
    
    with open("text_file.txt", "r") as f:  # Read mode
        content = f.read()
        print(f"Text content: {content}")
    
    # Binary file modes
    data = b"Binary data example"
    with open("binary_file.bin", "wb") as f:  # Write binary
        f.write(data)
    
    with open("binary_file.bin", "rb") as f:  # Read binary
        binary_content = f.read()
        print(f"Binary content: {binary_content}")

demonstrate_file_modes()
\end{lstlisting}

\begin{itemize}
    \item \keyword{Text modes}: Handle string data with encoding
    \item \keyword{Binary modes}: Handle raw bytes without encoding
    \item \keyword{Plus modes}: Allow both reading and writing
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Text for Strings, Binary for Bytes}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{Write a Python program to write student's subject record like branch name, semester, subject code and subject name in the binary file.}

\begin{solutionbox}
\begin{lstlisting}[language=Python,caption={Binary File Student Records}]
import pickle
import os

class StudentSubjectRecord:
    """Class to handle student subject records"""
    
    def __init__(self, branch_name, semester, subject_code, subject_name):
        self.branch_name = branch_name
        self.semester = semester
        self.subject_code = subject_code
        self.subject_name = subject_name
    
    def __str__(self):
        return f"Branch: {self.branch_name}, Semester: {self.semester}, Code: {self.subject_code}, Subject: {self.subject_name}"

def write_student_records():
    """Write student records to binary file"""
    
    # Sample student records
    records = [
        StudentSubjectRecord("Information Technology", 2, "4321602", "Advanced Python Programming"),
        StudentSubjectRecord("Information Technology", 2, "4321601", "Database Management System"),
        StudentSubjectRecord("Computer Engineering", 3, "4330701", "Data Structure"),
        StudentSubjectRecord("Information Technology", 2, "4321603", "Web Development"),
        StudentSubjectRecord("Computer Engineering", 3, "4330702", "Computer Networks")
    ]
    
    # Write records to binary file using pickle
    try:
        with open("student_records.bin", "wb") as binary_file:
            pickle.dump(records, binary_file)
        
        print("✓ Student records written to binary file successfully!")
        print(f"✓ Total records written: {len(records)}")
        
    except Exception as e:
        print(f"✗ Error writing to binary file: {e}")

def read_student_records():
    """Read student records from binary file"""
    
    try:
        if not os.path.exists("student_records.bin"):
            print("✗ Binary file not found!")
            return
        
        with open("student_records.bin", "rb") as binary_file:
            records = pickle.load(binary_file)
        
        print("\n" + "="*60)
        print("STUDENT SUBJECT RECORDS FROM BINARY FILE")
        print("="*60)
        
        for i, record in enumerate(records, 1):
            print(f"{i}. {record}")
        
        print("="*60)
        print(f"Total records read: {len(records)}")
        
    except Exception as e:
        print(f"✗ Error reading from binary file: {e}")

# Main program execution
def main():
    """Main function to demonstrate binary file operations"""
    
    print("=== STUDENT SUBJECT RECORD MANAGEMENT ===\n")
    
    # Write initial records
    print("1. Writing student records to binary file...")
    write_student_records()
    
    # Read and display records
    print("\n2. Reading records from binary file...")
    read_student_records()

# Execute the program
if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{center}
\captionof{table}{Binary File Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Method} & \textbf{Purpose} \\ \hline
Write & \code{pickle.dump()} & Serialize objects to binary \\ \hline
Read & \code{pickle.load()} & Deserialize objects from binary \\ \hline
Append & Read + Add + Write & Add new records \\ \hline
Search & Filter loaded data & Find specific records \\ \hline
\end{tabulary}
\end{center}

\textbf{Binary File Data Flow:}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu block] (records) {Student\\Records};
    \node [gtu block, right=of records] (dump) {pickle.dump()};
    \node [gtu block, right=of dump] (binfile) {Binary File\\(.bin)};
    \node [gtu block, right=of binfile] (load) {pickle.load()};
    \node [gtu block, right=of load] (objects) {Python\\Objects};
    
    \path [gtu arrow] (records) -- (dump);
    \path [gtu arrow] (dump) -- (binfile);
    \path [gtu arrow] (binfile) -- (load);
    \path [gtu arrow] (load) -- (objects);
\end{tikzpicture}
\captionof{figure}{Binary File Serialization Flow}
\end{center}

\begin{itemize}
    \item \keyword{Binary storage}: Uses pickle for object serialization
    \item \keyword{Efficient storage}: Compact binary format
    \item \keyword{Object preservation}: Maintains data structure integrity
    \item \keyword{Cross-platform}: Works on different operating systems
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Pickle Preserves Python Objects}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{Define: GUI, CLI}

\begin{solutionbox}
\begin{center}
\captionof{table}{Interface Definitions}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Term} & \textbf{Full Form} & \textbf{Description} & \textbf{Example} \\ \hline
GUI & Graphical User Interface & Visual interface with windows, buttons, icons & Windows, Mac desktop \\ \hline
CLI & Command Line Interface & Text-based interface using commands & Terminal, Command Prompt \\ \hline
\end{tabulary}
\end{center}

\textbf{Key Differences:}

\begin{itemize}
    \item \keyword{GUI}: User-friendly, mouse-driven, visual elements
    \item \keyword{CLI}: Text-based, keyboard-driven, command syntax
    \item \keyword{Interaction}: GUI uses clicks, CLI uses typed commands
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{GUI Graphics, CLI Commands}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Write a Python program to draw square shape using for and while loop using Turtle.}

\begin{solutionbox}
\begin{lstlisting}[language=Python,caption={Square Drawing with Loops}]
import turtle

def draw_square_with_for_loop():
    """Draw square using for loop"""
    
    # Setup turtle
    screen = turtle.Screen()
    screen.bgcolor("white")
    square_turtle = turtle.Turtle()
    square_turtle.color("blue")
    square_turtle.pensize(3)
    
    # Draw square using for loop
    print("Drawing square with for loop...")
    side_length = 100
    
    for i in range(4):
        square_turtle.forward(side_length)
        square_turtle.right(90)
    
    square_turtle.penup()
    square_turtle.goto(150, 0)
    square_turtle.pendown()
    
    return square_turtle

def draw_square_with_while_loop(turtle_obj):
    """Draw square using while loop"""
    
    # Change color for second square
    turtle_obj.color("red")
    
    # Draw square using while loop
    print("Drawing square with while loop...")
    side_length = 100
    sides_drawn = 0
    
    while sides_drawn < 4:
        turtle_obj.forward(side_length)
        turtle_obj.right(90)
        sides_drawn += 1
    
    # Move turtle to center for text
    turtle_obj.penup()
    turtle_obj.goto(-50, -150)
    turtle_obj.write("Blue: for loop, Red: while loop", 
                    font=("Arial", 12, "normal"))

# Main execution
def main():
    # Draw squares
    turtle_obj = draw_square_with_for_loop()
    draw_square_with_while_loop(turtle_obj)
    
    # Keep window open
    turtle.Screen().exitonclick()

# Run the program
main()
\end{lstlisting}

\begin{center}
\captionof{table}{Loop Comparison}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Loop Type} & \textbf{Structure} & \textbf{Usage} & \textbf{Control} \\ \hline
for loop & \code{for i in range(4):} & Known iterations & Counter-based \\ \hline
while loop & \code{while condition:} & Conditional iterations & Condition-based \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{for loop}: Best for known number of iterations
    \item \keyword{while loop}: Best for condition-based repetition
    \item \keyword{Both achieve}: Same square drawing result
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{For Count, While Condition}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Write a Python program to draw a chessboard using Turtle.}

\begin{solutionbox}
\begin{lstlisting}[language=Python,caption={Chessboard Drawing Program}]
import turtle

def setup_chessboard():
    """Setup turtle screen and properties for chessboard"""
    
    screen = turtle.Screen()
    screen.bgcolor("white")
    screen.title("Chessboard using Python Turtle")
    screen.setup(width=600, height=600)
    
    # Create turtle for drawing
    chess_turtle = turtle.Turtle()
    chess_turtle.speed(0)  # Fastest speed
    chess_turtle.penup()
    
    return screen, chess_turtle

def draw_square(turtle_obj, size, fill_color):
    """Draw a single square with given color"""
    
    turtle_obj.pendown()
    turtle_obj.fillcolor(fill_color)
    turtle_obj.begin_fill()
    
    # Draw square
    for _ in range(4):
        turtle_obj.forward(size)
        turtle_obj.right(90)
    
    turtle_obj.end_fill()
    turtle_obj.penup()

def draw_chessboard():
    """Draw complete 8x8 chessboard"""
    
    screen, chess_turtle = setup_chessboard()
    
    # Chessboard parameters
    square_size = 40
    board_size = 8
    start_x = -160
    start_y = 160
    
    print("Drawing chessboard...")
    
    # Draw the board
    for row in range(board_size):
        for col in range(board_size):
            
            # Calculate position
            x = start_x + (col * square_size)
            y = start_y - (row * square_size)
            
            # Move turtle to position
            chess_turtle.goto(x, y)
            
            # Determine square color (alternating pattern)
            if (row + col) % 2 == 0:
                color = "white"
            else:
                color = "black"
            
            # Draw the square
            draw_square(chess_turtle, square_size, color)
    
    # Add title
    chess_turtle.goto(0, start_y + 30)
    chess_turtle.write("Python Turtle Chessboard", align="center", 
                      font=("Arial", 16, "bold"))
    
    print("Chessboard created successfully!")
    return screen

# Main execution
def main():
    """Main function to create chessboard"""
    
    screen = draw_chessboard()
    print("Click on the screen to close the window.")
    screen.exitonclick()

# Run the program
if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{center}
\captionof{table}{Chessboard Components}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Component} & \textbf{Implementation} & \textbf{Purpose} \\ \hline
Squares & 8x8 grid alternating colors & Main board pattern \\ \hline
Colors & Black and white alternating & Traditional chess pattern \\ \hline
Pattern Logic & \code{(row + col) \% 2} & Determine square color \\ \hline
Loop Structure & Nested for loops & Iterate through grid \\ \hline
\end{tabulary}
\end{center}

\textbf{Chessboard Pattern Logic:}

\begin{center}
\begin{tikzpicture}[node distance=1.2cm and 1.5cm, auto]
    \node [gtu state] (start) {Start\\Row 0};
    \node [gtu block, right=of start] (row) {For each\\row};
    \node [gtu block, right=of row] (col) {For each\\column};
    \node [gtu decision, right=of col] (check) {(row + col)\\even?};
    \node [gtu state, below left=of check] (white) {White\\Square};
    \node [gtu state, below right=of check] (black) {Black\\Sq uare};
    \node [gtu state, below=1.5cm of check] (next) {Next\\Column};
    \node [gtu state, below=of next] (complete) {Complete\\Board};
    
    \path [gtu arrow] (start) -- (row);
    \path [gtu arrow] (row) -- (col);
    \path [gtu arrow] (col) -- (check);
    \path [gtu arrow] (check) -- node[left] {Yes} (white);
    \path [gtu arrow] (check) -- node[right] {No} (black);
    \path [gtu arrow] (white) -- (next);
    \path [gtu arrow] (black) -- (next);
    \path [gtu arrow] (next) -- node[right] {Continue} (col);
    \path [gtu arrow] (row) -- node[below] {All rows done} (complete);
\end{tikzpicture}
\captionof{figure}{Chessboard Pattern Algorithm}
\end{center}

\begin{itemize}
    \item \keyword{Alternating pattern}: (row + col) \% 2 determines color
    \item \keyword{Grid system}: 8x8 squares with precise positioning
    \item \keyword{Scalable design}: Easy to modify square size
    \item \keyword{Nested loops}: Row and column iteration
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Alternate Colors in Grid Pattern}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{How many types of shapes in turtle? Explain any one shape with suitable example.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Turtle Shapes}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Shape Type} & \textbf{Examples} & \textbf{Method} \\ \hline
Basic Shapes & Circle, Square, Triangle & Built-in functions \\ \hline
Line Patterns & Straight lines, Curves & \code{forward()}, \code{backward()} \\ \hline
Polygons & Pentagon, Hexagon, Octagon & Loop with angles \\ \hline
Complex Shapes & Stars, Spirals, Fractals & Mathematical patterns \\ \hline
Custom Shapes & User-defined patterns & Combination of moves \\ \hline
\end{tabulary}
\end{center}

\textbf{Circle Shape Example:}

\begin{lstlisting}[language=Python,caption={Circle Example}]
import turtle

def draw_circle_example():
    screen = turtle.Screen()
    circle_turtle = turtle.Turtle()
    
    # Draw circle with radius 50
    circle_turtle.circle(50)
    
    screen.exitonclick()

draw_circle_example()
\end{lstlisting}

\begin{itemize}
    \item \keyword{Built-in shapes}: Circle, square, triangle readily available
    \item \keyword{Custom shapes}: Created using movement combinations
    \item \keyword{Mathematical shapes}: Use geometry for precise drawing
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Turtle Draws Many Shape Types}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{Explain about four basic methods of Turtle module.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Basic Turtle Methods}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Method} & \textbf{Purpose} & \textbf{Parameters} & \textbf{Example} \\ \hline
\code{forward(distance)} & Move turtle forward & distance in pixels & \code{turtle.forward(100)} \\ \hline
\code{backward(distance)} & Move turtle backward & distance in pixels & \code{turtle.backward(50)} \\ \hline
\code{right(angle)} & Turn turtle right & angle in degrees & \code{turtle.right(90)} \\ \hline
\code{left(angle)} & Turn turtle left & angle in degrees & \code{turtle.left(45)} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python,caption={Basic Methods Example}]
import turtle

def demonstrate_basic_methods():
    # Create turtle
    demo_turtle = turtle.Turtle()
    
    # 1. Forward movement
    demo_turtle.forward(100)  # Move 100 pixels forward
    
    # 2. Right turn
    demo_turtle.right(90)     # Turn 90 degrees right
    
    # 3. Backward movement  
    demo_turtle.backward(50)  # Move 50 pixels backward
    
    # 4. Left turn
    demo_turtle.left(135)     # Turn 135 degrees left
    
    turtle.done()

demonstrate_basic_methods()
\end{lstlisting}

\begin{itemize}
    \item \keyword{Movement methods}: \code{forward()} and \code{backward()} for distance
    \item \keyword{Rotation methods}: \code{right()} and \code{left()} for direction changes
    \item \keyword{Coordinate system}: Based on current turtle position and heading
    \item \keyword{Angle measurement}: Degrees (0-360)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Forward, Backward, Right, Left Basics}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{Write a Python program to draw square, rectangle, and circle using Turtle.}

\begin{solutionbox}
\begin{lstlisting}[language=Python,caption={Multiple Shapes Drawing}]
import turtle
import math

def setup_drawing_environment():
    """Setup turtle screen and drawing environment"""
    
    screen = turtle.Screen()
    screen.bgcolor("lightblue")
    screen.title("Drawing Shapes: Square, Rectangle, Circle")
    screen.setup(width=800, height=600)
    
    # Create main drawing turtle
    shape_turtle = turtle.Turtle()
    shape_turtle.speed(3)
    shape_turtle.pensize(2)
    
    return screen, shape_turtle

def draw_square(turtle_obj, size, color, position):
    """Draw a square with given size and color"""
    
    x, y = position
    turtle_obj.penup()
    turtle_obj.goto(x, y)
    turtle_obj.pendown()
    
    turtle_obj.color(color)
    turtle_obj.fillcolor(color)
    turtle_obj.begin_fill()
    
    # Draw square using 4 equal sides
    for _ in range(4):
        turtle_obj.forward(size)
        turtle_obj.right(90)
    
    turtle_obj.end_fill()
    
    # Add label
    turtle_obj.penup()
    turtle_obj.goto(x + size//2, y - 30)
    turtle_obj.color("black")
    turtle_obj.write(f"Square ({size}x{size})", align="center", 
                    font=("Arial", 10, "bold"))

def draw_rectangle(turtle_obj, width, height, color, position):
    """Draw a rectangle with given dimensions and color"""
    
    x, y = position
    turtle_obj.penup()
    turtle_obj.goto(x, y)
    turtle_obj.pendown()
    
    turtle_obj.color(color)
    turtle_obj.fillcolor(color)
    turtle_obj.begin_fill()
    
    # Draw rectangle with alternating width and height
    for _ in range(2):
        turtle_obj.forward(width)
        turtle_obj.right(90)
        turtle_obj.forward(height)
        turtle_obj.right(90)
    
    turtle_obj.end_fill()
    
    # Add label
    turtle_obj.penup()
    turtle_obj.goto(x + width//2, y - height - 20)
    turtle_obj.color("black")
    turtle_obj.write(f"Rectangle ({width}x{height})", align="center", 
                    font=("Arial", 10, "bold"))

def draw_circle(turtle_obj, radius, color, position):
    """Draw a circle with given radius and color"""
    
    x, y = position
    turtle_obj.penup()
    turtle_obj.goto(x, y - radius)  # Position at bottom of circle
    turtle_obj.pendown()
    
    turtle_obj.color(color)
    turtle_obj.fillcolor(color)
    turtle_obj.begin_fill()
    
    # Draw circle
    turtle_obj.circle(radius)
    
    turtle_obj.end_fill()
    
    # Add label with area calculation
    area = math.pi * radius * radius
    turtle_obj.penup()
    turtle_obj.goto(x, y - radius - 30)
    turtle_obj.color("black")
    turtle_obj.write(f"Circle (r={radius}, area={area:.1f})", align="center", 
                    font=("Arial", 10, "bold"))

def draw_all_shapes():
    """Main function to draw all three shapes"""
    
    screen, shape_turtle = setup_drawing_environment()
    
    print("Drawing geometric shapes...")
    
    # Draw square
    print("1. Drawing square...")
    draw_square(shape_turtle, 80, "red", (-300, 100))
    
    # Draw rectangle  
    print("2. Drawing rectangle...")
    draw_rectangle(shape_turtle, 120, 80, "green", (-50, 100))
    
    # Draw circle
    print("3. Drawing circle...")
    draw_circle(shape_turtle, 60, "blue", (200, 100))
    
    # Add title
    shape_turtle.penup()
    shape_turtle.goto(0, 200)
    shape_turtle.color("purple")
    shape_turtle.write("Python Turtle Shapes", align="center", 
                    font=("Arial", 18, "bold"))
    
    print("All shapes drawn successfully!")
    return screen

# Main execution
def main():
    screen = draw_all_shapes()
    print("\nClick on the screen to close the window.")
    screen.exitonclick()

# Run the program
if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{center}
\captionof{table}{Shape Characteristics}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Shape} & \textbf{Sides} & \textbf{Properties} & \textbf{Area Formula} \\ \hline
Square & 4 equal & All angles 90° & side² \\ \hline
Rectangle & 4 (2 pairs) & Opposite sides equal & length × width \\ \hline
Circle & 0 (curved) & All points equidistant & π × radius² \\ \hline
\end{tabulary}
\end{center}

\textbf{Shape Drawing Process:}

\begin{center}
\begin{tikzpicture}[node distance=1.2cm, auto]
    \node [gtu state] (start) {Start\\Drawing};
    \node [gtu state, right=of start] (setup) {Setup\\Turtle};
    \node [gtu state, right=of setup] (square) {Draw\\Square};
    \node [gtu state, right=of square] (rect) {Draw\\Rectangle};
    \node [gtu state, below=of rect] (circle) {Draw\\Circle};
    \node [gtu state, left=of circle] (labels) {Add\\Labels};
    \node [gtu state, left=of labels] (info) {Display\\Information};
    \node [gtu state, left=of info] (complete) {Complete};
    
    \path [gtu arrow] (start) -- (setup);
    \path [gtu arrow] (setup) -- (square);
    \path [gtu arrow] (square) -- (rect);
    \path [gtu arrow] (rect) -- (circle);
    \path [gtu arrow] (circle) -- (labels);
    \path [gtu arrow] (labels) -- (info);
    \path [gtu arrow] (info) -- (complete);
\end{tikzpicture}
\captionof{figure}{Shape Drawing Process Flow}
\end{center}

\begin{itemize}
    \item \keyword{Geometric accuracy}: Precise angle and distance measurements
    \item \keyword{Visual appeal}: Different colors and filled shapes
    \item \keyword{Educational value}: Shows formulas
    \item \keyword{Mathematical calculations}: Area formulas included
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Square Equal, Rectangle Opposite, Circle Round}
\end{mnemonicbox}

\end{document}
