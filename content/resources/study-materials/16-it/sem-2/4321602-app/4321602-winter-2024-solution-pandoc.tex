\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4321602 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Give the difference between Set and Dictionary in python.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3421}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4211}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Feature}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Set}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Dictionary}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Data Storage} & Stores unique elements only & Stores key-value
pairs \\
\textbf{Order} & Unordered collection & Ordered (Python 3.7+) \\
\textbf{Duplicates} & No duplicates allowed & Keys must be unique \\
\textbf{Access} & Cannot access by index & Access values by keys \\
\textbf{Syntax} & \texttt{\{1,\ 2,\ 3\}} &
\texttt{\{\textquotesingle{}key\textquotesingle{}:\ \textquotesingle{}value\textquotesingle{}\}} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Set}: Collection of unique, unordered elements
\item
  \textbf{Dictionary}: Collection of key-value pairs with unique keys
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Sets are Unique, Dicts have Keys''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Explain List in Python with example.}

\begin{solutionbox}

\textbf{List} is an ordered, mutable collection that can store different
data types.

\textbf{Table of List Operations:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Operation} & \textbf{Syntax} & \textbf{Example} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Create} & \texttt{list\_name\ =\ []} &
\texttt{fruits\ =\ [\textquotesingle{}apple\textquotesingle{},\ \textquotesingle{}banana\textquotesingle{}]} \\
\textbf{Access} & \texttt{list[index]} & \texttt{fruits[0]}
returns `apple' \\
\textbf{Add} & \texttt{append()} &
\texttt{fruits.append(\textquotesingle{}orange\textquotesingle{})} \\
\textbf{Remove} & \texttt{remove()} &
\texttt{fruits.remove(\textquotesingle{}apple\textquotesingle{})} \\
\end{longtable}
}

\begin{verbatim}
\# Example
numbers = [1, 2, 3, 4, 5]
numbers.append(6)  \# [1, 2, 3, 4, 5, 6]
print(numbers[0])  \# Output: 1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Ordered}: Elements maintain their position
\item
  \textbf{Mutable}: Can be modified after creation
\item
  \textbf{Flexible}: Stores any data type
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Lists are Ordered and Modifiable''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{What is Tuple in Python? Write a Python program to swap two
tuple values.}

\begin{solutionbox}

\textbf{Tuple} is an ordered, immutable collection that stores multiple
items.

\textbf{Table of Tuple Features:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Property} & \textbf{Description} & \textbf{Example} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Immutable} & Cannot change after creation &
\texttt{t\ =\ (1,\ 2,\ 3)} \\
\textbf{Ordered} & Elements have defined order & Access by index \\
\textbf{Duplicates} & Allows duplicate values & \texttt{(1,\ 1,\ 2)} \\
\textbf{Indexing} & Access elements by position & \texttt{t[0]} \\
\end{longtable}
}

\begin{verbatim}
\# Program to swap two tuple values
def swap\_tuple\_values(tup, pos1, pos2):
    \# Convert tuple to list for swapping
    temp\_list = list(tup)
    
    \# Swap values
    temp\_list[pos1], temp\_list[pos2] = temp\_list[pos2], temp\_list[pos1]
    
    \# Convert back to tuple
    return tuple(temp\_list)

\# Example usage
original\_tuple = (10, 20, 30, 40, 50)
print("Original tuple:", original\_tuple)

\# Swap values at positions 1 and 3
swapped\_tuple = swap\_tuple\_values(original\_tuple, 1, 3)
print("After swapping:", swapped\_tuple)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Immutable}: Cannot modify once created
\item
  \textbf{Ordered}: Maintains element sequence
\item
  \textbf{Heterogeneous}: Can store different data types
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Tuples are Immutable and Ordered''

\end{mnemonicbox}
\subsection*{Question 1(c OR) [7
marks]}\label{question-1c-or-7-marks}

\textbf{What is Dictionary in Python? Write a Python program to traverse
a dictionary using loop.}

\begin{solutionbox}

\textbf{Dictionary} is an unordered collection of key-value pairs with
unique keys.

\textbf{Table of Dictionary Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Method} & \textbf{Purpose} & \textbf{Example} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{keys()} & Get all keys & \texttt{dict.keys()} \\
\textbf{values()} & Get all values & \texttt{dict.values()} \\
\textbf{items()} & Get key-value pairs & \texttt{dict.items()} \\
\textbf{get()} & Safe key access &
\texttt{dict.get(\textquotesingle{}key\textquotesingle{})} \\
\end{longtable}
}

\begin{verbatim}
\# Program to traverse dictionary using loops
student\_marks = \{
    {Alice}: 85,
    {Bob}: 92,
    {Charlie}: 78,
    {Diana}: 96,
    {Eve}: 89
\}

print("Dictionary Traversal Methods:")
print("{-"} * 30)

\# Method 1: Traverse keys only
print("1. Keys only:")
for key in student\_marks:
    print(f"   \{key\}")

\# Method 2: Traverse values only
print("{n}2. Values only:")
for value in student\_marks.values():
    print(f"   \{value\}")

\# Method 3: Traverse key{-value pairs}
print("{n}3. Key{-Value pairs:"})
for key, value in student\_marks.items():
    print(f"   \{key\}: \{value\}")

\# Method 4: Using keys() method
print("{n}4. Using keys() method:")
for key in student\_marks.keys():
    print(f"   \{key\} scored \{student\_marks[key]\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Key-Value storage}: Each key maps to a value
\item
  \textbf{Unique keys}: No duplicate keys allowed
\item
  \textbf{Fast lookup}: O(1) average time complexity
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dicts map Keys to Values''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{What is Package? List out advantages of using Package.}

\begin{solutionbox}

\textbf{Package} is a directory containing multiple modules organized
together.

\textbf{Table of Package Advantages:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Advantage} & \textbf{Description} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Organization} & Groups related modules together \\
\textbf{Namespace} & Avoids naming conflicts \\
\textbf{Reusability} & Code can be reused across projects \\
\textbf{Maintainability} & Easier to manage large codebases \\
\textbf{Distribution} & Easy to share and install \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Modular structure}: Better code organization
\item
  \textbf{Hierarchical namespace}: Prevents name conflicts
\item
  \textbf{Code reuse}: Promotes software reusability
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Packages Organize Related Modules''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Explain any two package import method with example.}

\begin{solutionbox}

\textbf{Table of Import Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3429}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3429}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3143}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Method}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Syntax}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Usage}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Normal Import} & \texttt{import\ package.module} & Access with
full path \\
\textbf{From Import} & \texttt{from\ package\ import\ module} & Direct
module access \\
\textbf{Specific Import} &
\texttt{from\ package.module\ import\ function} & Import specific
items \\
\textbf{Wildcard Import} & \texttt{from\ package\ import\ *} & Import
all modules \\
\end{longtable}
}

\begin{verbatim}
\# Method 1: Normal Import
import mypackage.calculator
result = mypackage.calculator.add(5, 3)
print(f"Normal import result: \{result\}")

\# Method 2: From Import
from mypackage import calculator
result = calculator.multiply(4, 6)
print(f"From import result: \{result\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Normal import}: Requires full package path
\item
  \textbf{From import}: Allows direct module access
\item
  \textbf{Specific function import}: Import only needed functions
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Import Normally or From Package''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Explain about intra-package reference with example.}

\begin{solutionbox}

\textbf{Intra-package reference} allows modules within a package to
import from each other.

\textbf{Diagram of Package Structure:}

\begin{verbatim}
mypackage/
├── \_\_init\_\_.py
├── math\_ops/
│   ├── \_\_init\_\_.py
│   ├── basic.py
│   └── advanced.py
└── utils/
    ├── \_\_init\_\_.py
    └── helpers.py
\end{verbatim}

\textbf{Table of Reference Types:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3030}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Type}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Syntax}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Usage}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Absolute} & \texttt{from\ mypackage.math\_ops\ import\ basic} &
Full path from package root \\
\textbf{Relative} & \texttt{from\ .\ import\ basic} & Current package \\
\textbf{Parent} & \texttt{from\ ..\ import\ utils} & Parent package \\
\textbf{Sibling} & \texttt{from\ ..utils\ import\ helpers} & Sibling
package \\
\end{longtable}
}

\begin{verbatim}
\# Package structure example
\# mypackage/math\_ops/advanced.py
from . import basic  \# Relative import from same package
from ..utils import helpers  \# Import from sibling package

def power\_operation(base, exp):
    \# Using function from basic module
    if basic.is\_valid\_number(base) and basic.is\_valid\_number(exp):
        result = base ** exp
        \# Using helper function
        return helpers.format\_result(result)
    return None

\# mypackage/math\_ops/basic.py
def is\_valid\_number(num):
    return isinstance(num, (int, float))

def add(a, b):
    return a + b

\# mypackage/utils/helpers.py
def format\_result(value):
    return f"Result: \{value:.2f\}"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Relative imports}: Use dots (.) for current package
\item
  \textbf{Absolute imports}: Full package path
\item
  \textbf{Package hierarchy}: Navigate using dot notation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dots Navigate Package Levels''

\end{mnemonicbox}
\subsection*{Question 2(a OR) [3
marks]}\label{question-2a-or-3-marks}

\textbf{What is Module? List out advantages of using Module.}

\begin{solutionbox}

\textbf{Module} is a Python file containing definitions, statements, and
functions.

\textbf{Table of Module Advantages:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Advantage} & \textbf{Description} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Code Reusability} & Write once, use multiple times \\
\textbf{Namespace} & Separate namespace for functions \\
\textbf{Organization} & Better code structure \\
\textbf{Maintainability} & Easier to debug and update \\
\textbf{Collaboration} & Multiple developers can work \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Reusable code}: Functions can be imported anywhere
\item
  \textbf{Modular design}: Break large programs into smaller parts
\item
  \textbf{Easy maintenance}: Changes in one place affect all imports
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Modules Make Code Reusable''

\end{mnemonicbox}
\subsection*{Question 2(b OR) [4
marks]}\label{question-2b-or-4-marks}

\textbf{Explain any two module import method with example.}

\begin{solutionbox}

\textbf{Table of Module Import Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2791}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2791}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4419}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Method}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Syntax}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Access Pattern}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Direct Import} & \texttt{import\ module\_name} &
\texttt{module\_name.function()} \\
\textbf{From Import} & \texttt{from\ module\_name\ import\ function} &
\texttt{function()} \\
\textbf{Alias Import} & \texttt{import\ module\_name\ as\ alias} &
\texttt{alias.function()} \\
\textbf{Wildcard Import} & \texttt{from\ module\_name\ import\ *} &
\texttt{function()} \\
\end{longtable}
}

\begin{verbatim}
\# Method 1: Direct Import
import math
result1 = math.sqrt(16)
print(f"Direct import: \{result1\}")

\# Method 2: From Import
from math import pi, sin
result2 = sin(pi/2)
print(f"From import: \{result2\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Direct import}: Access with module name prefix
\item
  \textbf{From import}: Direct function access without prefix
\item
  \textbf{Namespace control}: Choose appropriate import method
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Import Directly or From Module''

\end{mnemonicbox}
\subsection*{Question 2(c OR) [7
marks]}\label{question-2c-or-7-marks}

\textbf{Write a program to define a module to find the area and
circumference of a circle.}

\begin{solutionbox}

\begin{verbatim}
\# circle\_operations.py (Module file)
import math

def area(radius):
    """Calculate area of circle"""
    if radius {=} 0:
        return 0
    return math.pi * radius * radius

def circumference(radius):
    """Calculate circumference of circle"""
    if radius {=} 0:
        return 0
    return 2 * math.pi * radius

def display\_info(radius):
    """Display circle information"""
    print(f"Circle with radius: \{radius\}")
    print(f"Area: \{area(radius):.2f\}")
    print(f"Circumference: \{circumference(radius):.2f\}")

\# Constants
PI = math.pi

\# a) Import the module to another program
\# main\_program.py
import circle\_operations

radius = 5
print("Method 1: Import entire module")
area\_result = circle\_operations.area(radius)
circumference\_result = circle\_operations.circumference(radius)

print(f"Area: \{area\_result:.2f\}")
print(f"Circumference: \{circumference\_result:.2f\}")

\# b) Import specific function from module
\# specific\_import.py
from circle\_operations import area, circumference

radius = 7
print("{n}Method 2: Import specific functions")
area\_result = area(radius)
circumference\_result = circumference(radius)

print(f"Area: \{area\_result:.2f\}")
print(f"Circumference: \{circumference\_result:.2f\}")
\end{verbatim}

\textbf{Table of Module Features:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Feature} & \textbf{Implementation} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Functions} & area(), circumference() \\
\textbf{Error Handling} & Check for negative radius \\
\textbf{Constants} & PI value \\
\textbf{Documentation} & Function docstrings \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Module creation}: Save functions in .py file
\item
  \textbf{Import flexibility}: Whole module or specific functions
\item
  \textbf{Code reuse}: Use same functions in multiple programs
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Modules Contain Reusable Functions''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Explain the types of error in Python.}

\begin{solutionbox}

\textbf{Table of Python Error Types:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Error Type} & \textbf{Description} & \textbf{Example} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Syntax Error} & Wrong Python syntax & Missing colon
\texttt{:} \\
\textbf{Runtime Error} & Occurs during execution & Division by zero \\
\textbf{Logical Error} & Wrong program logic & Incorrect algorithm \\
\textbf{Name Error} & Undefined variable & Using undeclared variable \\
\textbf{Type Error} & Wrong data type operation & String + Integer \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Syntax errors}: Detected before program runs
\item
  \textbf{Runtime errors}: Occur during program execution
\item
  \textbf{Logical errors}: Program runs but gives wrong results
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Syntax, Runtime, Logic Errors''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Explain user-defined exception using raise statement with
example.}

\begin{solutionbox}

\textbf{User-defined exceptions} are custom error classes created by
programmers.

\textbf{Table of Exception Components:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3659}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3171}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3171}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Component}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Purpose}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Example}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Class Definition} & Create custom exception &
\texttt{class\ CustomError(Exception):} \\
\textbf{Raise Statement} & Trigger the exception &
\texttt{raise\ CustomError("message")} \\
\textbf{Error Message} & Describe the problem & Informative text \\
\textbf{Exception Handling} & Catch custom exception &
\texttt{except\ CustomError:} \\
\end{longtable}
}

\begin{verbatim}
\# Define custom exception
class AgeValidationError(Exception):
    def \_\_init\_\_(self, age, message="Invalid age provided"):
        self.age = age
        self.message = message
        super().\_\_init\_\_(self.message)

def validate\_age(age):
    if age {} 0:
        raise AgeValidationError(age, "Age cannot be negative")
    elif age {} 150:
        raise AgeValidationError(age, "Age cannot exceed 150")
    else:
        print(f"Valid age: \{age\}")

\# Using the custom exception
try:
    validate\_age({-}5)
except AgeValidationError as e:
    print(f"Error: \{e.message\}, Age: \{e.age\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Custom exception class}: Inherits from Exception
\item
  \textbf{Raise statement}: Manually trigger exceptions
\item
  \textbf{Meaningful messages}: Help debug problems
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Raise Custom Exceptions for Validation''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Explain try-except-finally clause with example.}

\begin{solutionbox}

\textbf{Try-except-finally} provides complete exception handling
mechanism.

\textbf{Table of Exception Handling Blocks:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Block} & \textbf{Purpose} & \textbf{Execution} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & Code that might raise exception & Always executed
first \\
\textbf{except} & Handle specific exceptions & Only if exception
occurs \\
\textbf{else} & Code when no exception & Only if no exception \\
\textbf{finally} & Cleanup code & Always executed \\
\end{longtable}
}

\begin{verbatim}
\# Complete exception handling example
def divide\_numbers():
    try:
        print("Starting division operation...")
        
        \# Get input from user
        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))
        
        \# Perform division
        result = num1 / num2
        
    except ValueError:
        print("Error: Please enter valid numbers only")
        return None
        
    except ZeroDivisionError:
        print("Error: Cannot divide by zero")
        return None
        
    except Exception as e:
        print(f"Unexpected error occurred: \{e\}")
        return None
        
    else:
        print(f"Division successful: \{num1\}  \{num2\} = \{result\}")
        return result
        
    finally:
        print("Division operation completed")
        print("Cleaning up resources...")

\# Example usage
result = divide\_numbers()
if result:
    print(f"Final result: \{result\}")
\end{verbatim}

\textbf{Flow Diagram:}

\begin{verbatim}
flowchart LR
    A[try block] {-{-} B\{Exception occurred?\}}
    B {-{-}|Yes| C[except block]}
    B {-{-}|No| D[else block]}
    C {-{-} E[finally block]}
    D {-{-} E}
    E {-{-} F[End]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{try}: Contains risky code
\item
  \textbf{except}: Handles specific errors
\item
  \textbf{finally}: Always executes for cleanup
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try-Except-Finally Always Cleans''

\end{mnemonicbox}
\subsection*{Question 3(a OR) [3
marks]}\label{question-3a-or-3-marks}

\textbf{What is built-in exception? List out any two with their
meaning.}

\begin{solutionbox}

\textbf{Built-in exceptions} are predefined error types in Python.

\textbf{Table of Built-in Exceptions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3659}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3171}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3171}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Exception}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Meaning}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Example}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ValueError} & Invalid value for correct type &
\texttt{int("abc")} \\
\textbf{TypeError} & Wrong data type operation & \texttt{"5"\ +\ 5} \\
\textbf{IndexError} & List index out of range & \texttt{list[10]}
for 5-item list \\
\textbf{KeyError} & Dictionary key not found &
\texttt{dict["missing\_key"]} \\
\textbf{ZeroDivisionError} & Division by zero & \texttt{10\ /\ 0} \\
\end{longtable}
}

\textbf{Two Main Built-in Exceptions:}

\begin{itemize}
\tightlist
\item
  \textbf{ValueError}: Occurs when function receives correct type but
  invalid value
\item
  \textbf{TypeError}: Occurs when operation performed on inappropriate
  data type
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Built-in Exceptions Handle Common Errors''

\end{mnemonicbox}
\subsection*{Question 3(b OR) [4
marks]}\label{question-3b-or-4-marks}

\textbf{Explain try-except clause with example.}

\begin{solutionbox}

\textbf{Try-except} handles exceptions that might occur during program
execution.

\textbf{Table of Exception Handling:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3750}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3250}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Component}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Purpose}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Syntax}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & Code that might fail & \texttt{try:} \\
\textbf{except} & Handle specific exception &
\texttt{except\ ErrorType:} \\
\textbf{Multiple except} & Handle different errors & Multiple except
blocks \\
\textbf{General except} & Catch any exception & \texttt{except:} \\
\end{longtable}
}

\begin{verbatim}
\# Example of try{-except clause}
def safe\_division():
    try:
        \# Code that might raise exceptions
        dividend = int(input("Enter dividend: "))
        divisor = int(input("Enter divisor: "))
        
        result = dividend / divisor
        print(f"Result: \{dividend\}  \{divisor\} = \{result\}")
        
    except ValueError:
        print("Error: Please enter valid integers only")
        
    except ZeroDivisionError:
        print("Error: Cannot divide by zero")
        
    except Exception as e:
        print(f"An unexpected error occurred: \{e\}")
    
    print("Program continues after exception handling")

\# Example usage
safe\_division()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{try block}: Contains potentially risky code
\item
  \textbf{except block}: Handles specific exception types
\item
  \textbf{Multiple handlers}: Different exceptions handled differently
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try Risky Code, Except Handles Errors''

\end{mnemonicbox}
\subsection*{Question 3(c OR) [7
marks]}\label{question-3c-or-7-marks}

\textbf{Write a program to catch on Divide by zero Exception with
finally clause.}

\begin{solutionbox}

\begin{verbatim}
\# Program to handle divide by zero with finally clause
def advanced\_calculator():
    """Calculator with comprehensive exception handling"""
    
    try:
        print("=== Advanced Calculator ===")
        print("Enter two numbers for division")
        
        \# Input section
        numerator = float(input("Enter numerator: "))
        denominator = float(input("Enter denominator: "))
        
        print(f"{n}Attempting to divide \{numerator\} by \{denominator\}...")
        
        \# Critical operation that might fail
        if denominator == 0:
            raise ZeroDivisionError("Division by zero is not allowed")
        
        result = numerator / denominator
        
        \# Success message
        print(f"✓ Division successful!")
        print(f"✓ Result: \{numerator\}  \{denominator\} = \{result:.4f\}")
        
        return result
        
    except ZeroDivisionError as zde:
        print(f"✗ Zero Division Error: \{zde\}")
        print("✗ Please use a non{-zero denominator"})
        return None
        
    except ValueError as ve:
        print(f"✗ Value Error: Invalid input provided")
        print("✗ Please enter numeric values only")
        return None
        
    except Exception as e:
        print(f"✗ Unexpected error: \{e\}")
        return None
        
    finally:
        print("{n}" + "="*40)
        print("CLEANUP OPERATIONS:")
        print("{- Closing calculator session"})
        print("{- Saving operation log"})
        print("{- Releasing memory resources"})
        print("{- Calculator shutdown complete"})
        print("="*40)

\# Example usage with multiple test cases
def test\_calculator():
    """Test the calculator with different scenarios"""
    
    test\_cases = [
        (10, 2),    \# Normal division
        (15, 0),    \# Zero division
        (7, 3),     \# Normal division with decimal
    ]
    
    for i, (num, den) in enumerate(test\_cases, 1):
        print(f"{n}{-{-}{-} Test Case }\{i\} {-{-}{-}"})
        print(f"Testing: \{num\}  \{den\}")
        
        \# Simulate user input (in real scenario, this would be interactive)
        \# This is just for demonstration
        print(f"Simulating division of \{num\} by \{den\}")
        
        try:
            if den == 0:
                raise ZeroDivisionError("Cannot divide by zero")
            result = num / den
            print(f"Result: \{result\}")
        except ZeroDivisionError as e:
            print(f"Error caught: \{e\}")
        finally:
            print("Test case completed")

\# Run the calculator
if \_\_name\_\_ == "\_\_main\_\_":
    result = advanced\_calculator()
    
    if result is not None:
        print(f"{n}Final calculated result: \{result\}")
    else:
        print("{n}Calculation failed due to errors")
\end{verbatim}

\textbf{Table of Exception Handling Features:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\textbf{Feature} & \textbf{Implementation} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ZeroDivisionError} & Specific handling for division by zero \\
\textbf{ValueError} & Handle invalid input types \\
\textbf{Generic Exception} & Catch unexpected errors \\
\textbf{Finally Block} & Always execute cleanup code \\
\end{longtable}
}

\textbf{Exception Handling Flow:}

\begin{verbatim}
flowchart LR
    A[Start Division] {-{-} B[try block]}
    B {-{-} C\{Exception?\}}
    C {-{-}|ZeroDivisionError| D[Handle Zero Division]}
    C {-{-}|ValueError| E[Handle Invalid Input]}
    C {-{-}|Other| F[Handle Generic Error]}
    C {-{-}|None| G[Success Result]}
    D {-{-} H[finally block]}
    E {-{-} H}
    F {-{-} H}
    G {-{-} H}
    H {-{-} I[End Program]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Specific exception handling}: ZeroDivisionError caught
  separately
\item
  \textbf{Finally clause}: Always executes for cleanup
\item
  \textbf{Resource management}: Proper cleanup regardless of errors
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Finally Always Cleans Up Resources''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Define: File, Binary File, Text File}

\begin{solutionbox}

\textbf{Table of File Definitions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2564}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4103}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Term}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Definition}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Example}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{File} & Named storage location on disk & document.txt,
image.jpg \\
\textbf{Binary File} & Contains non-text data in binary format & .exe,
.jpg, .mp3, .pdf \\
\textbf{Text File} & Contains human-readable text characters & .txt,
.py, .html, .csv \\
\end{longtable}
}

\textbf{Detailed Definitions:}

\begin{itemize}
\tightlist
\item
  \textbf{File}: A collection of data stored on storage device with a
  unique name
\item
  \textbf{Binary File}: Stores data in binary format (0s and 1s), not
  human-readable
\item
  \textbf{Text File}: Contains ASCII or Unicode characters,
  human-readable format
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Files store data, Binary=Machine, Text=Human''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Explain write() and writelines() function with example.}

\begin{solutionbox}

\textbf{Table of Write Functions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2642}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2453}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2830}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2075}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Function}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Purpose}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Parameter}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Usage}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{write()} & Write single string & String &
\texttt{file.write("Hello")} \\
\textbf{writelines()} & Write list of strings & List/Sequence &
\texttt{file.writelines(["line1",\ "line2"])} \\
\end{longtable}
}

\begin{verbatim}
\# Example demonstrating write() and writelines()
def demonstrate\_write\_functions():
    
    \# Using write() function
    with open("write\_demo.txt", "w") as file:
        file.write("Hello World!{n}")
        file.write("This is line 2{n}")
        file.write("This is line 3{n}")
    
    \# Using writelines() function
    lines = [
        "First line using writelines{n}",
        "Second line using writelines{n}", 
        "Third line using writelines{n}"
    ]
    
    with open("writelines\_demo.txt", "w") as file:
        file.writelines(lines)
    
    print("Files created successfully!")

\# Run the demonstration
demonstrate\_write\_functions()
\end{verbatim}

\textbf{Key Differences:}

\begin{itemize}
\tightlist
\item
  \textbf{write()}: Writes one string at a time
\item
  \textbf{writelines()}: Writes multiple strings from a sequence
\item
  \textbf{Newlines}: Must be added manually with
  \texttt{\textbackslash{}n}
\item
  \textbf{Return value}: Both return number of characters written
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``write() Single, writelines() Multiple''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Explain tell() and seek() function with example.}

\begin{solutionbox}

\textbf{File pointer functions} control position within a file for
reading/writing.

\textbf{Table of Position Functions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2373}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2203}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3559}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1864}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Function}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Purpose}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Return/Parameter}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Usage}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{tell()} & Get current position & Returns current byte position &
\texttt{pos\ =\ file.tell()} \\
\textbf{seek(offset, whence)} & Move to specific position & offset:
bytes, whence: reference & \texttt{file.seek(10,\ 0)} \\
\end{longtable}
}

\textbf{Seek Whence Values:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Value} & \textbf{Reference Point} & \textbf{Description} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{0} & Beginning of file & Absolute positioning \\
\textbf{1} & Current position & Relative to current \\
\textbf{2} & End of file & Relative to end \\
\end{longtable}
}

\begin{verbatim}
\# Complete example of tell() and seek() functions
def demonstrate\_file\_positioning():
    
    \# Create a sample file
    sample\_text = "Hello World! This is a sample file for demonstrating tell() and seek() functions."
    
    with open("position\_demo.txt", "w") as file:
        file.write(sample\_text)
    
    \# Demonstrate tell() and seek()
    with open("position\_demo.txt", "r") as file:
        
        \# Initial position
        print(f"1. Initial position: \{file.tell()\}")
        
        \# Read first 5 characters
        data1 = file.read(5)
        print(f"2. Read {}\{data1\}{, current position: }\{file.tell()\}")
        
        \# Move to position 15
        file.seek(15)
        print(f"3. After seek(15), position: \{file.tell()\}")
        
        \# Read next 10 characters
        data2 = file.read(10)
        print(f"4. Read {}\{data2\}{, current position: }\{file.tell()\}")
        
        \# Move to beginning using seek(0, 0)
        file.seek(0, 0)
        print(f"5. After seek(0,0), position: \{file.tell()\}")
        
        \# Move to end using seek(0, 2)
        file.seek(0, 2)
        print(f"6. After seek(0,2), position: \{file.tell()\}")
        
        \# Move backward from current position
        file.seek({-}10, 1)
        print(f"7. After seek({-10,1), position: }\{file.tell()\}")
        
        \# Read remaining content
        remaining = file.read()
        print(f"8. Remaining content: {}\{remaining\}{"})

\# Example with binary file
def binary\_file\_positioning():
    
    \# Create binary file
    data = b"Binary file positioning example"
    
    with open("binary\_demo.bin", "wb") as file:
        file.write(data)
    
    \# Read with positioning
    with open("binary\_demo.bin", "rb") as file:
        print(f"{n}Binary file position: \{file.tell()\}")
        
        \# Read first 6 bytes
        chunk1 = file.read(6)
        print(f"Read: \{chunk1\}, position: \{file.tell()\}")
        
        \# Jump to position 20
        file.seek(20)
        chunk2 = file.read(7)
        print(f"Read: \{chunk2\}, position: \{file.tell()\}")

\# Run demonstrations
demonstrate\_file\_positioning()
binary\_file\_positioning()
\end{verbatim}

\textbf{Position Control Diagram:}

\begin{verbatim}
flowchart LR
    A[File Start] {-{-} B["tell(): 0"]}
    B {-{-} C["read(5)"]}
    C {-{-} D["tell(): 5"]}
    D {-{-} E["seek(15)"]}
    E {-{-} F["tell(): 15"]}
    F {-{-} G["seek(0,2)"]}
    G {-{-} H["tell(): End"]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{tell()}: Returns current byte position in file
\item
  \textbf{seek()}: Moves file pointer to specified position
\item
  \textbf{Positioning}: Essential for random file access
\item
  \textbf{Binary mode}: Works with byte positions
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``tell() Position, seek() Movement''

\end{mnemonicbox}
\subsection*{Question 4(a OR) [3
marks]}\label{question-4a-or-3-marks}

\textbf{What is Absolute and Relative file path?}

\begin{solutionbox}

\textbf{Table of Path Types:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3778}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2889}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Path Type}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Example}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Absolute Path} & Complete path from root directory &
\texttt{/home/user/documents/file.txt} \\
\textbf{Relative Path} & Path relative to current directory &
\texttt{../documents/file.txt} \\
\end{longtable}
}

\textbf{Path Symbols:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Symbol} & \textbf{Meaning} & \textbf{Example} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{/} & Root directory (Linux/Mac) & \texttt{/home/user/} \\
\textbf{C:\textbackslash{}} & Drive letter (Windows) &
\texttt{C:\textbackslash{}\textbackslash{}Users\textbackslash{}\textbackslash{}Documents\textbackslash{}\textbackslash{}} \\
\textbf{.} & Current directory & \texttt{./file.txt} \\
\textbf{..} & Parent directory & \texttt{../folder/file.txt} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Absolute}: Complete path from system root
\item
  \textbf{Relative}: Path from current working directory
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Absolute from Root, Relative from Current''

\end{mnemonicbox}
\subsection*{Question 4(b OR) [4
marks]}\label{question-4b-or-4-marks}

\textbf{Explain about various mode to open binary and text file.}

\begin{solutionbox}

\textbf{Table of File Opening Modes:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\textbf{Mode} & \textbf{Type} & \textbf{Purpose} & \textbf{File
Pointer} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{`r'} & Text & Read only & Beginning \\
\textbf{`w'} & Text & Write (overwrites) & Beginning \\
\textbf{`a'} & Text & Append & End \\
\textbf{`rb'} & Binary & Read binary & Beginning \\
\textbf{`wb'} & Binary & Write binary & Beginning \\
\textbf{`ab'} & Binary & Append binary & End \\
\textbf{`r+'} & Text & Read and write & Beginning \\
\textbf{`w+'} & Text & Write and read & Beginning \\
\end{longtable}
}

\begin{verbatim}
\# Examples of different file modes
def demonstrate\_file\_modes():
    
    \# Text file modes
    with open("text\_file.txt", "w") as f:  \# Write mode
        f.write("Hello World")
    
    with open("text\_file.txt", "r") as f:  \# Read mode
        content = f.read()
        print(f"Text content: \{content\}")
    
    \# Binary file modes
    data = b"Binary data example"
    with open("binary\_file.bin", "wb") as f:  \# Write binary
        f.write(data)
    
    with open("binary\_file.bin", "rb") as f:  \# Read binary
        binary\_content = f.read()
        print(f"Binary content: \{binary\_content\}")

demonstrate\_file\_modes()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Text modes}: Handle string data with encoding
\item
  \textbf{Binary modes}: Handle raw bytes without encoding
\item
  \textbf{Plus modes}: Allow both reading and writing
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Text for Strings, Binary for Bytes''

\end{mnemonicbox}
\subsection*{Question 4(c OR) [7
marks]}\label{question-4c-or-7-marks}

\textbf{Write a Python program to write student's subject record like
branch name, semester, subject code and subject name in the binary
file.}

\begin{solutionbox}

\begin{verbatim}
import pickle
import os

class StudentSubjectRecord:
    """Class to handle student subject records"""
    
    def \_\_init\_\_(self, branch\_name, semester, subject\_code, subject\_name):
        self.branch\_name = branch\_name
        self.semester = semester
        self.subject\_code = subject\_code
        self.subject\_name = subject\_name
    
    def \_\_str\_\_(self):
        return f"Branch: \{self.branch\_name\}, Semester: \{self.semester\}, Code: \{self.subject\_code\}, Subject: \{self.subject\_name\}"

def write\_student\_records():
    """Write student records to binary file"""
    
    \# Sample student records
    records = [
        StudentSubjectRecord("Information Technology", 2, "4321602", "Advanced Python Programming"),
        StudentSubjectRecord("Information Technology", 2, "4321601", "Database Management System"),
        StudentSubjectRecord("Computer Engineering", 3, "4330701", "Data Structure"),
        StudentSubjectRecord("Information Technology", 2, "4321603", "Web Development"),
        StudentSubjectRecord("Computer Engineering", 3, "4330702", "Computer Networks")
    ]
    
    \# Write records to binary file using pickle
    try:
        with open("student\_records.bin", "wb") as binary\_file:
            pickle.dump(records, binary\_file)
        
        print("✓ Student records written to binary file successfully!")
        print(f"✓ Total records written: \{len(records)\}")
        
    except Exception as e:
        print(f"✗ Error writing to binary file: \{e\}")

def read\_student\_records():
    """Read student records from binary file"""
    
    try:
        if not os.path.exists("student\_records.bin"):
            print("✗ Binary file not found!")
            return
        
        with open("student\_records.bin", "rb") as binary\_file:
            records = pickle.load(binary\_file)
        
        print("{n}" + "="*60)
        print("STUDENT SUBJECT RECORDS FROM BINARY FILE")
        print("="*60)
        
        for i, record in enumerate(records, 1):
            print(f"\{i\}. \{record\}")
        
        print("="*60)
        print(f"Total records read: \{len(records)\}")
        
    except Exception as e:
        print(f"✗ Error reading from binary file: \{e\}")

def add\_new\_record():
    """Add new student record to existing binary file"""
    
    try:
        \# Read existing records
        records = []
        if os.path.exists("student\_records.bin"):
            with open("student\_records.bin", "rb") as binary\_file:
                records = pickle.load(binary\_file)
        
        \# Get new record details
        print("{n}Enter new student record details:")
        branch = input("Branch Name: ")
        semester = int(input("Semester: "))
        code = input("Subject Code: ")
        subject = input("Subject Name: ")
        
        \# Create new record
        new\_record = StudentSubjectRecord(branch, semester, code, subject)
        records.append(new\_record)
        
        \# Write back to file
        with open("student\_records.bin", "wb") as binary\_file:
            pickle.dump(records, binary\_file)
        
        print("✓ New record added successfully!")
        
    except Exception as e:
        print(f"✗ Error adding new record: \{e\}")

def search\_records\_by\_branch(branch\_name):
    """Search records by branch name"""
    
    try:
        if not os.path.exists("student\_records.bin"):
            print("✗ Binary file not found!")
            return
        
        with open("student\_records.bin", "rb") as binary\_file:
            records = pickle.load(binary\_file)
        
        \# Filter records by branch
        filtered\_records = [record for record in records 
                          if record.branch\_name.lower() == branch\_name.lower()]
        
        if filtered\_records:
            print(f"{n}Records for \{branch\_name\}:")
            print("{-"} * 40)
            for record in filtered\_records:
                print(f"  \{record\}")
        else:
            print(f"No records found for branch: \{branch\_name\}")
            
    except Exception as e:
        print(f"✗ Error searching records: \{e\}")

\# Main program execution
def main():
    """Main function to demonstrate binary file operations"""
    
    print("=== STUDENT SUBJECT RECORD MANAGEMENT ==={n}")
    
    \# Write initial records
    print("1. Writing student records to binary file...")
    write\_student\_records()
    
    \# Read and display records
    print("{n}2. Reading records from binary file...")
    read\_student\_records()
    
    \# Search by branch
    print("{n}3. Searching records by branch...")
    search\_records\_by\_branch("Information Technology")
    
    \# Display file information
    if os.path.exists("student\_records.bin"):
        file\_size = os.path.getsize("student\_records.bin")
        print(f"{n}Binary file size: \{file\_size\} bytes")

\# Execute the program
if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\textbf{Table of Binary File Operations:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Operation} & \textbf{Method} & \textbf{Purpose} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Write} & \texttt{pickle.dump()} & Serialize objects to binary \\
\textbf{Read} & \texttt{pickle.load()} & Deserialize objects from
binary \\
\textbf{Append} & Read + Add + Write & Add new records \\
\textbf{Search} & Filter loaded data & Find specific records \\
\end{longtable}
}

\textbf{Binary File Structure:}

\begin{verbatim}
flowchart LR
    A[Student Records] {-{-} B["pickle.dump()"]}
    B {-{-} C[Binary File .bin]}
    C {-{-} D["pickle.load()"]}
    D {-{-} E[Python Objects]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Binary storage}: Uses pickle for object serialization
\item
  \textbf{Efficient storage}: Compact binary format
\item
  \textbf{Object preservation}: Maintains data structure integrity
\item
  \textbf{Cross-platform}: Works on different operating systems
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Pickle Preserves Python Objects''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Define: GUI, CLI}

\begin{solutionbox}

\textbf{Table of Interface Definitions:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1818}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3091}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2364}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Term}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Full Form}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Description}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Example}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{GUI} & Graphical User Interface & Visual interface with windows,
buttons, icons & Windows, Mac desktop \\
\textbf{CLI} & Command Line Interface & Text-based interface using
commands & Terminal, Command Prompt \\
\end{longtable}
}

\textbf{Key Differences:}

\begin{itemize}
\tightlist
\item
  \textbf{GUI}: User-friendly, mouse-driven, visual elements
\item
  \textbf{CLI}: Text-based, keyboard-driven, command syntax
\item
  \textbf{Interaction}: GUI uses clicks, CLI uses typed commands
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``GUI Graphics, CLI Commands''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Write a Python program to draw square shape using for and while
loop using Turtle.}

\begin{solutionbox}

\begin{verbatim}
import turtle

def draw\_square\_with\_for\_loop():
    """Draw square using for loop"""
    
    \# Setup turtle
    screen = turtle.Screen()
    screen.bgcolor("white")
    square\_turtle = turtle.Turtle()
    square\_turtle.color("blue")
    square\_turtle.pensize(3)
    
    \# Draw square using for loop
    print("Drawing square with for loop...")
    side\_length = 100
    
    for i in range(4):
        square\_turtle.forward(side\_length)
        square\_turtle.right(90)
    
    square\_turtle.penup()
    square\_turtle.goto(150, 0)
    square\_turtle.pendown()
    
    return square\_turtle

def draw\_square\_with\_while\_loop(turtle\_obj):
    """Draw square using while loop"""
    
    \# Change color for second square
    turtle\_obj.color("red")
    
    \# Draw square using while loop
    print("Drawing square with while loop...")
    side\_length = 100
    sides\_drawn = 0
    
    while sides\_drawn {} 4:
        turtle\_obj.forward(side\_length)
        turtle\_obj.right(90)
        sides\_drawn += 1
    
    \# Move turtle to center for text
    turtle\_obj.penup()
    turtle\_obj.goto({-}50, {-}150)
    turtle\_obj.write("Blue: for loop, Red: while loop", 
                    font=("Arial", 12, "normal"))

\# Main execution
def main():
    \# Draw squares
    turtle\_obj = draw\_square\_with\_for\_loop()
    draw\_square\_with\_while\_loop(turtle\_obj)
    
    \# Keep window open
    turtle.Screen().exitonclick()

\# Run the program
main()
\end{verbatim}

\textbf{Table of Loop Comparison:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2778}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2778}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2037}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2407}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Loop Type}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Structure}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Usage}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Control}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{for loop} & \texttt{for\ i\ in\ range(4):} & Known iterations &
Counter-based \\
\textbf{while loop} & \texttt{while\ condition:} & Conditional
iterations & Condition-based \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{for loop}: Best for known number of iterations
\item
  \textbf{while loop}: Best for condition-based repetition
\item
  \textbf{Both achieve}: Same square drawing result
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``For Count, While Condition''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Write a Python program to draw a chessboard using Turtle.}

\begin{solutionbox}

\begin{verbatim}
import turtle

def setup\_chessboard():
    """Setup turtle screen and properties for chessboard"""
    
    screen = turtle.Screen()
    screen.bgcolor("white")
    screen.title("Chessboard using Python Turtle")
    screen.setup(width=600, height=600)
    
    \# Create turtle for drawing
    chess\_turtle = turtle.Turtle()
    chess\_turtle.speed(0)  \# Fastest speed
    chess\_turtle.penup()
    
    return screen, chess\_turtle

def draw\_square(turtle\_obj, size, fill\_color):
    """Draw a single square with given color"""
    
    turtle\_obj.pendown()
    turtle\_obj.fillcolor(fill\_color)
    turtle\_obj.begin\_fill()
    
    \# Draw square
    for \_ in range(4):
        turtle\_obj.forward(size)
        turtle\_obj.right(90)
    
    turtle\_obj.end\_fill()
    turtle\_obj.penup()

def draw\_chessboard():
    """Draw complete 8x8 chessboard"""
    
    screen, chess\_turtle = setup\_chessboard()
    
    \# Chessboard parameters
    square\_size = 40
    board\_size = 8
    start\_x = {-}160
    start\_y = 160
    
    print("Drawing chessboard...")
    
    \# Draw the board
    for row in range(board\_size):
        for col in range(board\_size):
            
            \# Calculate position
            x = start\_x + (col * square\_size)
            y = start\_y {-} (row * square\_size)
            
            \# Move turtle to position
            chess\_turtle.goto(x, y)
            
            \# Determine square color (alternating pattern)
            if (row + col) \% 2 == 0:
                color = "white"
            else:
                color = "black"
            
            \# Draw the square
            draw\_square(chess\_turtle, square\_size, color)
    
    \# Add border around chessboard
    draw\_border(chess\_turtle, start\_x, start\_y, square\_size, board\_size)
    
    \# Add labels
    add\_chessboard\_labels(chess\_turtle, start\_x, start\_y, square\_size, board\_size)
    
    return screen

def draw\_border(turtle\_obj, start\_x, start\_y, square\_size, board\_size):
    """Draw border around the chessboard"""
    
    turtle\_obj.goto(start\_x {-} 5, start\_y + 5)
    turtle\_obj.pencolor("brown")
    turtle\_obj.pensize(3)
    turtle\_obj.pendown()
    
    \# Draw border rectangle
    border\_width = board\_size * square\_size + 10
    border\_height = board\_size * square\_size + 10
    
    for \_ in range(2):
        turtle\_obj.forward(border\_width)
        turtle\_obj.right(90)
        turtle\_obj.forward(border\_height)
        turtle\_obj.right(90)
    
    turtle\_obj.penup()
    turtle\_obj.pensize(1)
    turtle\_obj.pencolor("black")

def add\_chessboard\_labels(turtle\_obj, start\_x, start\_y, square\_size, board\_size):
    """Add row and column labels to chessboard"""
    
    turtle\_obj.color("blue")
    
    \# Column labels (A{-H)}
    columns = [{A}, {B}, {C}, {D}, {E}, {F}, {G}, {H}]
    for i, letter in enumerate(columns):
        x = start\_x + (i * square\_size) + (square\_size // 2)
        y = start\_y {-} (board\_size * square\_size) {-} 20
        turtle\_obj.goto(x, y)
        turtle\_obj.write(letter, align="center", font=("Arial", 12, "bold"))
    
    \# Row labels (1{-8)}
    for i in range(board\_size):
        x = start\_x {-} 20
        y = start\_y {-} (i * square\_size) {-} (square\_size // 2)
        turtle\_obj.goto(x, y)
        turtle\_obj.write(str(8{-}i), align="center", font=("Arial", 12, "bold"))
    
    \# Title
    turtle\_obj.goto(0, start\_y + 30)
    turtle\_obj.write("Python Turtle Chessboard", align="center", 
                    font=("Arial", 16, "bold"))

def draw\_enhanced\_chessboard\_with\_pieces():
    """Enhanced version with some chess piece indicators"""
    
    screen = draw\_chessboard()
    
    \# Create new turtle for pieces
    piece\_turtle = turtle.Turtle()
    piece\_turtle.speed(0)
    piece\_turtle.penup()
    
    \# Add some piece symbols (simplified)
    pieces = [
        ({-}120, 120, "♜"), ({-}80, 120, "♞"), ({-}40, 120, "♝"), (0, 120, "♛"),
        ({-}120, {-}120, "♖"), ({-}80, {-}120, "♘"), ({-}40, {-}120, "♗"), (0, {-}120, "♕")
    ]
    
    piece\_turtle.color("red")
    for x, y, symbol in pieces:
        piece\_turtle.goto(x, y)
        piece\_turtle.write(symbol, align="center", font=("Arial", 20, "normal"))
    
    piece\_turtle.hideturtle()
    
    \# Display statistics
    total\_squares = 64
    black\_squares = 32
    white\_squares = 32
    
    piece\_turtle.goto(0, {-}200)
    piece\_turtle.color("green")
    piece\_turtle.write(f"Chessboard: \{total\_squares\} squares (\{black\_squares\} black, \{white\_squares\} white)", 
                      align="center", font=("Arial", 12, "normal"))
    
    return screen

\# Main execution
def main():
    """Main function to create chessboard"""
    
    print("Creating chessboard with Python Turtle...")
    screen = draw\_enhanced\_chessboard\_with\_pieces()
    
    print("Chessboard created successfully!")
    print("Click on the screen to close the window.")
    
    \# Keep window open until clicked
    screen.exitonclick()

\# Run the program
if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\textbf{Table of Chessboard Components:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\textbf{Component} & \textbf{Implementation} & \textbf{Purpose} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Squares} & 8x8 grid alternating colors & Main board pattern \\
\textbf{Colors} & Black and white alternating & Traditional chess
pattern \\
\textbf{Border} & Brown rectangle outline & Frame the board \\
\textbf{Labels} & A-H columns, 1-8 rows & Chess notation \\
\textbf{Pieces} & Unicode chess symbols & Sample piece placement \\
\end{longtable}
}

\textbf{Chessboard Pattern Logic:}

\begin{verbatim}
flowchart LR
    A[Start Row 0] {-{-} B\{For each row\}}
    B {-{-} C\{For each column\}}
    C {-{-} D\{row + col even?\}}
    D {-{-}|Yes| E[White Square]}
    D {-{-}|No| F[Black Square]}
    E {-{-} G[Next Column]}
    F {-{-} G}
    G {-{-} C}
    C {-{-}|Row Complete| H[Next Row]}
    H {-{-} B}
    B {-{-}|All Rows Done| I[Complete Board]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Alternating pattern}: (row + col) \% 2 determines color
\item
  \textbf{Grid system}: 8x8 squares with precise positioning
\item
  \textbf{Visual enhancements}: Border, labels, and sample pieces
\item
  \textbf{Scalable design}: Easy to modify square size
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Alternate Colors in Grid Pattern''

\end{mnemonicbox}
\subsection*{Question 5(a OR) [3
marks]}\label{question-5a-or-3-marks}

\textbf{How many types of shapes in turtle? Explain any one shape with
suitable example.}

\begin{solutionbox}

\textbf{Table of Turtle Shapes:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3810}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Shape Type}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Examples}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Method}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Basic Shapes} & Circle, Square, Triangle & Built-in functions \\
\textbf{Line Patterns} & Straight lines, Curves & forward(),
backward() \\
\textbf{Polygons} & Pentagon, Hexagon, Octagon & Loop with angles \\
\textbf{Complex Shapes} & Stars, Spirals, Fractals & Mathematical
patterns \\
\textbf{Custom Shapes} & User-defined patterns & Combination of moves \\
\end{longtable}
}

\textbf{Circle Shape Example:}

\begin{verbatim}
import turtle

def draw\_circle\_example():
    screen = turtle.Screen()
    circle\_turtle = turtle.Turtle()
    
    \# Draw circle with radius 50
    circle\_turtle.circle(50)
    
    screen.exitonclick()

draw\_circle\_example()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Built-in shapes}: Circle, square, triangle readily available
\item
  \textbf{Custom shapes}: Created using movement combinations
\item
  \textbf{Mathematical shapes}: Use geometry for precise drawing
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Turtle Draws Many Shape Types''

\end{mnemonicbox}
\subsection*{Question 5(b OR) [4
marks]}\label{question-5b-or-4-marks}

\textbf{Explain about four basic methods of Turtle module.}

\begin{solutionbox}

\textbf{Table of Basic Turtle Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2407}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2963}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2407}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
\textbf{Method}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Purpose}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Parameters}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\textbf{Example}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{forward(distance)} & Move turtle forward & distance in pixels &
\texttt{turtle.forward(100)} \\
\textbf{backward(distance)} & Move turtle backward & distance in pixels
& \texttt{turtle.backward(50)} \\
\textbf{right(angle)} & Turn turtle right & angle in degrees &
\texttt{turtle.right(90)} \\
\textbf{left(angle)} & Turn turtle left & angle in degrees &
\texttt{turtle.left(45)} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_basic\_methods():
    \# Create turtle
    demo\_turtle = turtle.Turtle()
    
    \# 1. Forward movement
    demo\_turtle.forward(100)  \# Move 100 pixels forward
    
    \# 2. Right turn
    demo\_turtle.right(90)     \# Turn 90 degrees right
    
    \# 3. Backward movement  
    demo\_turtle.backward(50)  \# Move 50 pixels backward
    
    \# 4. Left turn
    demo\_turtle.left(135)     \# Turn 135 degrees left
    
    turtle.done()

demonstrate\_basic\_methods()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Movement methods}: forward() and backward() for distance
\item
  \textbf{Rotation methods}: right() and left() for direction changes
\item
  \textbf{Coordinate system}: Based on current turtle position and
  heading
\item
  \textbf{Angle measurement}: Degrees (0-360)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Forward, Backward, Right, Left Basics''

\end{mnemonicbox}
\subsection*{Question 5(c OR) [7
marks]}\label{question-5c-or-7-marks}

\textbf{Write a Python program to draw square, rectangle, and circle
using Turtle.}

\begin{solutionbox}

\begin{verbatim}
import turtle
import math

def setup\_drawing\_environment():
    """Setup turtle screen and drawing environment"""
    
    screen = turtle.Screen()
    screen.bgcolor("lightblue")
    screen.title("Drawing Shapes: Square, Rectangle, Circle")
    screen.setup(width=800, height=600)
    
    \# Create main drawing turtle
    shape\_turtle = turtle.Turtle()
    shape\_turtle.speed(3)
    shape\_turtle.pensize(2)
    
    return screen, shape\_turtle

def draw\_square(turtle\_obj, size, color, position):
    """Draw a square with given size and color"""
    
    x, y = position
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    turtle\_obj.begin\_fill()
    
    \# Draw square using 4 equal sides
    for \_ in range(4):
        turtle\_obj.forward(size)
        turtle\_obj.right(90)
    
    turtle\_obj.end\_fill()
    
    \# Add label
    turtle\_obj.penup()
    turtle\_obj.goto(x + size//2, y {-} 30)
    turtle\_obj.color("black")
    turtle\_obj.write(f"Square (\{size\}x\{size\})", align="center", 
                    font=("Arial", 10, "bold"))

def draw\_rectangle(turtle\_obj, width, height, color, position):
    """Draw a rectangle with given dimensions and color"""
    
    x, y = position
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    turtle\_obj.begin\_fill()
    
    \# Draw rectangle with alternating width and height
    for \_ in range(2):
        turtle\_obj.forward(width)
        turtle\_obj.right(90)
        turtle\_obj.forward(height)
        turtle\_obj.right(90)
    
    turtle\_obj.end\_fill()
    
    \# Add label
    turtle\_obj.penup()
    turtle\_obj.goto(x + width//2, y {-} height {-} 20)
    turtle\_obj.color("black")
    turtle\_obj.write(f"Rectangle (\{width\}x\{height\})", align="center", 
                    font=("Arial", 10, "bold"))

def draw\_circle(turtle\_obj, radius, color, position):
    """Draw a circle with given radius and color"""
    
    x, y = position
    turtle\_obj.penup()
    turtle\_obj.goto(x, y {-} radius)  \# Position at bottom of circle
    turtle\_obj.pendown()
    
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    turtle\_obj.begin\_fill()
    
    \# Draw circle
    turtle\_obj.circle(radius)
    
    turtle\_obj.end\_fill()
    
    \# Add label with area calculation
    area = math.pi * radius * radius
    turtle\_obj.penup()
    turtle\_obj.goto(x, y {-} radius {-} 30)
    turtle\_obj.color("black")
    turtle\_obj.write(f"Circle (r=\{radius\}, area=\{area:.1f\})", align="center", 
                    font=("Arial", 10, "bold"))

def draw\_all\_shapes():
    """Main function to draw all three shapes"""
    
    screen, shape\_turtle = setup\_drawing\_environment()
    
    print("Drawing geometric shapes...")
    
    \# Draw square
    print("1. Drawing square...")
    draw\_square(shape\_turtle, 80, "red", ({-}300, 100))
    
    \# Draw rectangle  
    print("2. Drawing rectangle...")
    draw\_rectangle(shape\_turtle, 120, 80, "green", ({-}50, 100))
    
    \# Draw circle
    print("3. Drawing circle...")
    draw\_circle(shape\_turtle, 60, "blue", (200, 100))
    
    \# Add title and information
    add\_shape\_information(shape\_turtle)
    
    print("All shapes drawn successfully!")
    return screen

def add\_shape\_information(turtle\_obj):
    """Add title and shape information"""
    
    \# Title
    turtle\_obj.penup()
    turtle\_obj.goto(0, 200)
    turtle\_obj.color("purple")
    turtle\_obj.write("Python Turtle Shapes", align="center", 
                    font=("Arial", 18, "bold"))
    
    \# Shape properties table
    turtle\_obj.goto({-}350, {-}50)
    turtle\_obj.color("black")
    turtle\_obj.write("Shape Properties:", font=("Arial", 12, "bold"))
    
    properties = [
        "• Square: 4 equal sides, 4 right angles",
        "• Rectangle: 4 sides, opposite sides equal", 
        "• Circle: All points equidistant from center"
    ]
    
    for i, prop in enumerate(properties):
        turtle\_obj.goto({-}350, {-}80 {-} (i * 20))
        turtle\_obj.write(prop, font=("Arial", 10, "normal"))
    
    \# Mathematical formulas
    turtle\_obj.goto({-}350, {-}170)
    turtle\_obj.color("blue")
    turtle\_obj.write("Formulas:", font=("Arial", 12, "bold"))
    
    formulas = [
        "• Square area: side^{2"},
        "• Rectangle area: length  width",
        "• Circle area: π  radius^{2"}
    ]
    
    for i, formula in enumerate(formulas):
        turtle\_obj.goto({-}350, {-}200 {-} (i * 20))
        turtle\_obj.write(formula, font=("Arial", 10, "normal"))

def interactive\_shape\_drawer():
    """Enhanced version with user interaction"""
    
    screen, shape\_turtle = setup\_drawing\_environment()
    
    \# Get user preferences
    print("{n}=== Interactive Shape Drawer ===")
    
    try:
        \# Square parameters
        square\_size = int(input("Enter square size (50{-100): "}) or "80")
        square\_color = input("Enter square color (red/blue/green): ") or "red"
        
        \# Rectangle parameters  
        rect\_width = int(input("Enter rectangle width (80{-150): "}) or "120")
        rect\_height = int(input("Enter rectangle height (60{-100): "}) or "80")
        rect\_color = input("Enter rectangle color: ") or "green"
        
        \# Circle parameters
        circle\_radius = int(input("Enter circle radius (40{-80): "}) or "60")
        circle\_color = input("Enter circle color: ") or "blue"
        
        \# Draw shapes with user parameters
        draw\_square(shape\_turtle, square\_size, square\_color, ({-}300, 100))
        draw\_rectangle(shape\_turtle, rect\_width, rect\_height, rect\_color, ({-}50, 100))
        draw\_circle(shape\_turtle, circle\_radius, circle\_color, (200, 100))
        
        add\_shape\_information(shape\_turtle)
        
    except ValueError:
        print("Invalid input! Using default values...")
        return draw\_all\_shapes()
    
    return screen

\# Main execution
def main():
    """Main function with options"""
    
    print("Choose drawing mode:")
    print("1. Default shapes")
    print("2. Interactive mode")
    
    choice = input("Enter choice (1 or 2): ").strip()
    
    if choice == "2":
        screen = interactive\_shape\_drawer()
    else:
        screen = draw\_all\_shapes()
    
    print("{n}Click on the screen to close the window.")
    screen.exitonclick()

\# Run the program
if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\textbf{Table of Shape Characteristics:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\textbf{Shape} & \textbf{Sides} & \textbf{Properties} & \textbf{Area
Formula} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Square} & 4 equal & All angles 90^\circ & side^{2} \\
\textbf{Rectangle} & 4 (2 pairs) & Opposite sides equal & length \times
width \\
\textbf{Circle} & 0 (curved) & All points equidistant & π \times radius^{2} \\
\end{longtable}
}

\textbf{Shape Drawing Process:}

\begin{verbatim}
flowchart LR
    A[Start Drawing] {-{-} B[Setup Turtle]}
    B {-{-} C[Draw Square]}
    C {-{-} D[Draw Rectangle] }
    D {-{-} E[Draw Circle]}
    E {-{-} F[Add Labels]}
    F {-{-} G[Display Information]}
    G {-{-} H[Complete]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Geometric accuracy}: Precise angle and distance measurements
\item
  \textbf{Visual appeal}: Different colors and filled shapes
\item
  \textbf{Educational value}: Shows formulas
\item
  \textbf{Mathematical calculations}: Area formulas included
\item
  \textbf{Interactive features}: User can customize parameters
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Square Equal, Rectangle Opposite, Circle Round''

\end{mnemonicbox}

\end{document}
