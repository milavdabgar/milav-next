\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4321602 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{What is Dictionary? Explain with example.}

\begin{solutionbox}

Dictionary એ Python માં key-value pairs નો collection છે જે mutable અને
ordered હોય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Dictionary Properties}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Property & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mutable} & Values ને change કરી શકાય છે \\
\textbf{Ordered} & Python 3.7+ માં insertion order maintain રહે છે \\
\textbf{Indexed} & Keys દ્વારા access કરાય છે \\
\textbf{No Duplicates} & Duplicate keys allow નથી \\
\end{longtable}
}

\begin{verbatim}
\# Dictionary Example
student = \{
    "name": "Raj",
    "age": 20,
    "course": "IT"
\}
print(student["name"])  \# Output: Raj
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Key-Value Structure}: દરેક element માં key અને value હોય છે
\item
  \textbf{Fast Access}: O(1) time complexity માં data access
\item
  \textbf{Dynamic Size}: Runtime માં size વધારી-ઘટાડી શકાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dictionary = Key Value Treasure''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Explain Tuple Built-in functions and methods.}

\begin{solutionbox}

Tuple માં limited built-in methods છે કારણ કે તે immutable છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Tuple Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{count()} & Element ની frequency return કરે છે &
\texttt{t.count(5)} \\
\textbf{index()} & Element નું first index return કરે છે &
\texttt{t.index(\textquotesingle{}a\textquotesingle{})} \\
\textbf{len()} & Tuple નું length return કરે છે & \texttt{len(t)} \\
\textbf{max()} & Maximum value return કરે છે & \texttt{max(t)} \\
\textbf{min()} & Minimum value return કરે છે & \texttt{min(t)} \\
\end{longtable}
}

\begin{verbatim}
\# Tuple Methods Example
numbers = (1, 2, 3, 2, 4, 2)
print(numbers.count(2))     \# Output: 3
print(numbers.index(3))     \# Output: 2
print(len(numbers))         \# Output: 6
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Immutable Nature}: Methods tuple ને modify નથી કરતા
\item
  \textbf{Return Values}: બધા methods નવી values return કરે છે
\item
  \textbf{Type Conversion}: tuple() function થી list ને tuple માં convert
  કરી શકાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Count Index Length Max Min''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Write a python program to demonstrate set operations.}

\begin{solutionbox}

Set operations mathematics ના set theory પર આધારિત છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Set Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2750}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3250}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Symbol
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Union} & \texttt{\textbackslash{}\textbar{}} & \texttt{union()}
& બન્ને sets ના elements \\
\textbf{Intersection} & \texttt{\&} & \texttt{intersection()} & Common
elements \\
\textbf{Difference} & \texttt{-} & \texttt{difference()} & First set
માંથી second ને minus \\
\textbf{Symmetric Difference} & \texttt{\^{}} &
\texttt{symmetric\_difference()} & Unique elements only \\
\end{longtable}
}

\begin{verbatim}
\# Set Operations Program
set1 = \{1, 2, 3, 4, 5\}
set2 = \{4, 5, 6, 7, 8\}

print("Set 1:", set1)
print("Set 2:", set2)

\# Union Operation
union\_result = set1 | set2
print("Union:", union\_result)

\# Intersection Operation  
intersection\_result = set1 \& set2
print("Intersection:", intersection\_result)

\# Difference Operation
difference\_result = set1 {-} set2
print("Difference:", difference\_result)

\# Symmetric Difference
sym\_diff\_result = set1 \^{} set2
print("Symmetric Difference:", sym\_diff\_result)

\# Subset and Superset
set3 = \{1, 2\}
print("Is set3 subset of set1?", set3.issubset(set1))
print("Is set1 superset of set3?", set1.issuperset(set3))
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Mathematical Operations}: Set theory ના operations implement
  કરે છે
\item
  \textbf{Efficient Processing}: Duplicate elements automatically remove
  થાય છે
\item
  \textbf{Boolean Results}: Subset/superset operations boolean return કરે
  છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Union Intersection Difference Symmetric''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c OR) [7
marks]}\label{question-1c-or-7-marks}

\textbf{Write a python program to demonstrate the dictionaries functions
and operations.}

\begin{solutionbox}

Dictionary operations data manipulation માટે powerful tools પ્રદાન કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Dictionary Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{keys()} & બધી keys return કરે છે & \texttt{dict.keys()} \\
\textbf{values()} & બધા values return કરે છે & \texttt{dict.values()} \\
\textbf{items()} & Key-value pairs return કરે છે &
\texttt{dict.items()} \\
\textbf{get()} & Safe value retrieval &
\texttt{dict.get(\textquotesingle{}key\textquotesingle{})} \\
\textbf{update()} & Dictionary merge કરે છે & \texttt{dict.update()} \\
\end{longtable}
}

\begin{verbatim}
\# Dictionary Operations Program
student\_data = \{
    "name": "Amit",
    "age": 21,
    "course": "IT",
    "semester": 2
\}

print("Original Dictionary:", student\_data)

\# Accessing values
print("Student Name:", student\_data.get("name"))
print("Student Age:", student\_data["age"])

\# Adding new key{-value pair}
student\_data["city"] = "Ahmedabad"
print("After adding city:", student\_data)

\# Updating existing value
student\_data.update(\{"age": 22, "semester": 3\)}
print("After update:", student\_data)

\# Dictionary methods
print("Keys:", list(student\_data.keys()))
print("Values:", list(student\_data.values()))
print("Items:", list(student\_data.items()))

\# Removing elements
removed\_value = student\_data.pop("semester")
print("Removed value:", removed\_value)
print("Final Dictionary:", student\_data)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Dynamic Operations}: Runtime માં keys અને values add/remove કરી
  શકાય
\item
  \textbf{Safe Access}: get() method KeyError prevent કરે છે
\item
  \textbf{Iteration Support}: keys(), values(), items() methods loop માટે
  useful
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Get Keys Values Items Update Pop''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Distinguish between Tuple and List in Python.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Tuple vs List Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Tuple & List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mutability} & Immutable (cannot change) & Mutable (can
change) \\
\textbf{Syntax} & Parentheses \texttt{()} & Square brackets
\texttt{[]} \\
\textbf{Performance} & Faster & Slower \\
\textbf{Memory} & Less memory & More memory \\
\textbf{Methods} & Limited (count, index) & Many methods available \\
\textbf{Use Case} & Fixed data & Dynamic data \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Immutable Nature}: Tuple એકવાર create થયા પછી change થઈ શકતું
  નથી
\item
  \textbf{Performance}: Tuple operations list કરતાં fast છે
\item
  \textbf{Memory Efficient}: Tuple ઓછી memory વાપરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Tuple Tight, List Light''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{What is the dir() function in python? Explain with example.}

\begin{solutionbox}

dir() function એ built-in function છે જે object ના attributes અને methods
ની list return કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{dir() Function Features}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Object Inspection} & Object ના attributes show કરે છે \\
\textbf{Method Discovery} & Available methods list કરે છે \\
\textbf{Namespace Exploration} & Current namespace ના variables show કરે
છે \\
\textbf{Module Analysis} & Module ના contents explore કરે છે \\
\end{longtable}
}

\begin{verbatim}
\# dir() Function Example
\# For string object
text = "Hello"
string\_methods = dir(text)
print("String methods:", string\_methods[:5])

\# For list object  
my\_list = [1, 2, 3]
list\_methods = dir(my\_list)
print("List methods:", [m for m in list\_methods if not m.startswith({\_})][:5])

\# For current namespace
print("Current namespace:", dir()[:3])

\# For built{-in functions}
import math
print("Math module:", dir(math)[:5])
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Interactive Development}: Objects ના capabilities જાણવા માટે
  useful
\item
  \textbf{Debugging Tool}: Available methods quickly identify કરવા માટે
\item
  \textbf{Learning Aid}: New libraries explore કરવા માટે helpful
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dir = Directory of Methods''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Write a program to define a module to find the area and
circumference of a circle. Import module to another program.}

\begin{solutionbox}

Module approach code reusability અને organization improve કરે છે.

\textbf{Diagram: Module Structure}

\begin{verbatim}
┌─────────────────┐    ┌─────────────────┐
│   circle.py     │    │   main.py       │
│   (Module)      │    │   (Main Program)│
├─────────────────┤    ├─────────────────┤
│ • area()        │───▶│ import circle   │
│ • circumference │    │ use functions   │
│ • PI constant   │    │                 │
└─────────────────┘    └─────────────────┘
\end{verbatim}

\textbf{File 1: circle.py (Module)}

\begin{verbatim}
\# circle.py {- Circle calculation module}
import math

\# Constants
PI = math.pi

def area(radius):
    """Calculate area of circle"""
    if radius {} 0:
        return "Radius cannot be negative"
    return PI * radius * radius

def circumference(radius):
    """Calculate circumference of circle"""
    if radius {} 0:
        return "Radius cannot be negative"
    return 2 * PI * radius

def display\_info():
    """Display module information"""
    print("Circle Module {- Version 1.0"})
    print("Functions: area(), circumference()")
\end{verbatim}

\textbf{File 2: main.py (Main Program)}

\begin{verbatim}
\# main.py {- Main program using circle module}
import circle

\# Get radius from user
radius = float(input("Enter radius: "))

\# Calculate using module functions
circle\_area = circle.area(radius)
circle\_circumference = circle.circumference(radius)

\# Display results
print(f"Circle with radius \{radius\}:")
print(f"Area: \{circle\_area:.2f\}")
print(f"Circumference: \{circle\_circumference:.2f\}")

\# Display module info
circle.display\_info()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Modular Design}: Functions ને separate file માં organize કરે છે
\item
  \textbf{Reusability}: Module ને multiple programs માં use કરી શકાય
\item
  \textbf{Namespace Management}: Module prefix થી function access કરાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Import Calculate Display''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(a OR) [3
marks]}\label{question-2a-or-3-marks}

\textbf{Explain Nested Tuple with example.}

\begin{solutionbox}

Nested Tuple એ tuple અંદર બીજા tuples હોય છે, જે hierarchical data
structure બનાવે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Nested Tuple Features}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Multi-dimensional} & 2D અથવા 3D data structure \\
\textbf{Immutable} & બધા levels પર immutable \\
\textbf{Indexing} & Multiple square brackets વાપરીને access \\
\textbf{Heterogeneous} & Different data types store કરી શકાય \\
\end{longtable}
}

\begin{verbatim}
\# Nested Tuple Example
student\_records = (
    ("Raj", 20, ("IT", 2)),
    ("Priya", 19, ("CS", 1)), 
    ("Amit", 21, ("IT", 3))
)

\# Accessing nested elements
print("First student:", student\_records[0])
print("First student name:", student\_records[0][0])
print("First student course:", student\_records[0][2][0])

\# Iterating through nested tuple
for student in student\_records:
    name, age, (course, semester) = student
    print(f"\{name\} {- Age: }\{age\}, Course: \{course\}, Sem: \{semester\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Data Organization}: Related data ને group કરવા માટે useful
\item
  \textbf{Immutable Structure}: એકવાર create થયા પછી structure change થઈ
  શકતું નથી
\item
  \textbf{Efficient Access}: Index-based fast access
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Nested = Tuple Inside Tuple''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(b OR) [4
marks]}\label{question-2b-or-4-marks}

\textbf{What is PIP? Write the syntax to install and uninstall python
packages.}

\begin{solutionbox}

PIP (Pip Installs Packages) એ Python package installer છે જે PyPI થી
packages download અને install કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{PIP Commands}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Install} & \texttt{pip\ install\ package\_name} & Package
install કરે છે \\
\textbf{Uninstall} & \texttt{pip\ uninstall\ package\_name} & Package
remove કરે છે \\
\textbf{List} & \texttt{pip\ list} & Installed packages show કરે છે \\
\textbf{Show} & \texttt{pip\ show\ package\_name} & Package info display
કરે છે \\
\textbf{Upgrade} & \texttt{pip\ install\ -\/-upgrade\ package\_name} &
Package update કરે છે \\
\end{longtable}
}

\begin{verbatim}
\# PIP Command Examples (Terminal/Command Prompt માં run કરવા)

\# Install a package
\# pip install requests

\# Install specific version
\# pip install Django==3.2.0

\# Uninstall a package  
\# pip uninstall numpy

\# List all installed packages
\# pip list

\# Show package information
\# pip show matplotlib

\# Upgrade a package
\# pip install {-{-}upgrade pandas}

\# Install from requirements file
\# pip install {-r requirements.txt}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Package Management}: Third-party libraries easily manage કરી
  શકાય
\item
  \textbf{Version Control}: Specific versions install કરી શકાય
\item
  \textbf{Dependency Resolution}: Required dependencies automatically
  install થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PIP = Package Install Python''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(c OR) [7
marks]}\label{question-2c-or-7-marks}

\textbf{Explain different ways of importing package. How are modules and
packages connected to each other?}

\begin{solutionbox}

Python માં imports ના વિવિધ ways છે જે code organization અને namespace
management માટે important છે.

\textbf{Diagram: Package Structure}

\begin{verbatim}
MyPackage/
├── \_\_init\_\_.py
├── module1.py
├── module2.py
└── subpackage/
    ├── \_\_init\_\_.py
    └── module3.py
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Import Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3478}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3478}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Usage
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Basic Import} & \texttt{import\ module} & Full module name
required \\
\textbf{From Import} & \texttt{from\ module\ import\ function} & Direct
function access \\
\textbf{Alias Import} & \texttt{import\ module\ as\ alias} & Short name
for module \\
\textbf{Star Import} & \texttt{from\ module\ import\ *} & Import all
functions \\
\textbf{Package Import} & \texttt{from\ package\ import\ module} &
Import from package \\
\end{longtable}
}

\begin{verbatim}
\# Different Import Ways

\# 1. Basic Import
import math
result = math.sqrt(16)

\# 2. From Import
from math import sqrt, pi
result = sqrt(16)
area = pi * 5 * 5

\# 3. Alias Import
import numpy as np
array = np.array([1, 2, 3])

\# 4. Star Import (not recommended)
from math import *
result = cos(0)

\# 5. Package Import
from mypackage import module1
from mypackage.subpackage import module3

\# 6. Relative Import (within package)
\# from . import module1
\# from ..parent\_module import function
\end{verbatim}

\textbf{Module-Package Connection:}

\begin{itemize}
\tightlist
\item
  \textbf{Modules}: Single .py files containing Python code
\item
  \textbf{Packages}: Directories containing multiple modules with
  \_\_init\_\_.py
\item
  \textbf{Namespace}: Packages create hierarchical namespace structure
\item
  \textbf{\textbf{init}.py}: Makes directory a package and controls
  imports
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Import From As Star Package''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Describe Runtime Error and Syntax Error. Explain with example.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Error Types Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Error Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When Occurs
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Detection
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Syntax Error} & Code parsing time & Before execution & Missing
colon, brackets \\
\textbf{Runtime Error} & During execution & While running & Division by
zero, file not found \\
\textbf{Logic Error} & Always & After execution & Wrong calculation
logic \\
\end{longtable}
}

\begin{verbatim}
\# Syntax Error Example
\# print("Hello World"  \# Missing closing parenthesis
\# SyntaxError: unexpected EOF while parsing

\# Runtime Error Examples
try:
    \# ZeroDivisionError
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")

try:
    \# FileNotFoundError  
    file = open("nonexistent.txt", "r")
except FileNotFoundError:
    print("File not found")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Syntax Errors}: Code run થવા પહેલા જ detect થાય છે
\item
  \textbf{Runtime Errors}: Program execution દરમિયાન થાય છે
\item
  \textbf{Prevention}: Exception handling runtime errors ને handle કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Syntax Before, Runtime During''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{What is Exception handling in Python? Explain with example.}

\begin{solutionbox}

Exception handling એ mechanism છે જે runtime errors ને gracefully handle કરે
છે અને program crash થવાથી prevent કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Exception Handling Keywords}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Keyword & Purpose & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & Exception માં થઈ શકે એવો code & Risk code block \\
\textbf{except} & Exception handle કરવા માટે & Error handling block \\
\textbf{finally} & હંમેશા execute થાય & Cleanup code \\
\textbf{else} & Exception ન આવે તો & Success code block \\
\textbf{raise} & Manual exception raise કરવા & Custom error throwing \\
\end{longtable}
}

\begin{verbatim}
\# Exception Handling Example
def safe\_division(a, b):
    try:
        \# Code that might raise exception
        result = a / b
        print(f"Division successful: \{result\}")
        
    except ZeroDivisionError:
        \# Handle specific exception
        print("Error: Cannot divide by zero")
        result = None
        
    except TypeError:
        \# Handle type errors
        print("Error: Invalid data types")
        result = None
        
    else:
        \# Executes if no exception
        print("Division completed successfully")
        
    finally:
        \# Always executes
        print("Division operation finished")
        
    return result

\# Test the function
safe\_division(10, 2)   \# Normal case
safe\_division(10, 0)   \# Zero division
safe\_division(10, "a") \# Type error
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Error Prevention}: Program crash થવાથી prevent કરે છે
\item
  \textbf{Graceful Handling}: User-friendly error messages provide કરે છે
\item
  \textbf{Resource Management}: finally block માં cleanup operations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try Except Finally Else Raise''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Create a function for division of two numbers, if the value of
any argument is non-integer then raise the error or if second argument
is 0 then raise the error.}

\begin{solutionbox}

Custom exception handling function બનાવવું validation અને error control માટે
important છે.

\textbf{Diagram: Function Flow}

\begin{verbatim}
flowchart LR
    A[Input Numbers] {-{-} B\{Are both integers?\}}
    B {-{-}|No| C[Raise TypeError]}
    B {-{-}|Yes| D\{Is second number 0?\}}
    D {-{-}|Yes| E[Raise ZeroDivisionError]}
    D {-{-}|No| F[Perform Division]}
    F {-{-} G[Return Result]}
    C {-{-} H[Handle Error]}
    E {-{-} H}
    H {-{-} I[End]}
    G {-{-} I}
\end{verbatim}

\begin{verbatim}
def safe\_integer\_division(num1, num2):
    """
    Divide two numbers with validation
    Raises TypeError if arguments are not integers
    Raises ZeroDivisionError if second argument is 0
    """
    
    \# Check if both arguments are integers
    if not isinstance(num1, int):
        raise TypeError(f"First argument must be integer, got \{type(num1).\_\_name\_\_\}")
    
    if not isinstance(num2, int):
        raise TypeError(f"Second argument must be integer, got \{type(num2).\_\_name\_\_\}")
    
    \# Check for zero division
    if num2 == 0:
        raise ZeroDivisionError("Cannot divide by zero")
    
    \# Perform division
    result = num1 / num2
    return result

\# Test the function with different cases
def test\_division():
    test\_cases = [
        (10, 2),      \# Valid case
        (15, 3),      \# Valid case  
        (10, 0),      \# Zero division error
        (10.5, 2),    \# Non{-integer first argument}
        (10, 2.5),    \# Non{-integer second argument}
        ("10", 2),    \# String argument
    ]
    
    for num1, num2 in test\_cases:
        try:
            result = safe\_integer\_division(num1, num2)
            print(f"\{num1\}  \{num2\} = \{result\}")
            
        except TypeError as e:
            print(f"Type Error: \{e\}")
            
        except ZeroDivisionError as e:
            print(f"Zero Division Error: \{e\}")
            
        except Exception as e:
            print(f"Unexpected Error: \{e\}")
        
        print("{-"} * 40)

\# Run tests
test\_division()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Input Validation}: Arguments ના type અને value check કરે છે
\item
  \textbf{Custom Errors}: Specific exceptions raise કરે છે
\item
  \textbf{Error Messages}: Clear અને descriptive error messages
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Validate Type, Check Zero, Divide Safe''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(a OR) [3
marks]}\label{question-3a-or-3-marks}

\textbf{Describe any five built-in exceptions in Python.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Built-in Exceptions}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4074}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2593}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Exception
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Cause
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ValueError} & Invalid value for operation &
\texttt{int("abc")} \\
\textbf{TypeError} & Wrong data type & \texttt{"hello"\ +\ 5} \\
\textbf{IndexError} & Index out of range & \texttt{list[10]} when
list has 5 elements \\
\textbf{KeyError} & Dictionary key not found &
\texttt{dict["nonexistent"]} \\
\textbf{FileNotFoundError} & File does not exist &
\texttt{open("missing.txt")} \\
\end{longtable}
}

\begin{verbatim}
\# Built{-in Exceptions Examples}

\# 1. ValueError
try:
    number = int("not\_a\_number")
except ValueError:
    print("ValueError: Invalid conversion")

\# 2. TypeError  
try:
    result = "Hello" + 5
except TypeError:
    print("TypeError: Cannot add string and integer")

\# 3. IndexError
try:
    my\_list = [1, 2, 3]
    value = my\_list[5]
except IndexError:
    print("IndexError: List index out of range")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Automatic Detection}: Python automatically raises these
  exceptions
\item
  \textbf{Specific Handling}: દરેક exception નો specific purpose છે
\item
  \textbf{Inheritance}: બધા exceptions BaseException class થી inherit
  થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Value Type Index Key File''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(b OR) [4
marks]}\label{question-3b-or-4-marks}

\textbf{Explain try, except and finally terms with syntax.}

\begin{solutionbox}

Exception handling ના blocks નો specific purpose અને execution order છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Exception Handling Blocks}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Block & Purpose & Execution & Mandatory \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{try} & Risky code & First & Yes \\
\textbf{except} & Error handling & If exception occurs & At least one \\
\textbf{else} & Success code & If no exception & No \\
\textbf{finally} & Cleanup code & Always & No \\
\end{longtable}
}

\textbf{Syntax Structure:}

\begin{verbatim}
try:
    \# Code that might raise exception
    risky\_code()
except ExceptionType1:
    \# Handle specific exception
    handle\_error1()
except ExceptionType2:
    \# Handle another exception
    handle\_error2()
else:
    \# Code runs if no exception
    success\_code()
finally:
    \# Code always runs
    cleanup\_code()
\end{verbatim}

\textbf{Practical Example:}

\begin{verbatim}
def file\_operation(filename):
    file\_handle = None
    try:
        \# Risky operation
        file\_handle = open(filename, {r})
        content = file\_handle.read()
        print("File read successfully")
        
    except FileNotFoundError:
        print("File not found error")
        
    except PermissionError:
        print("Permission denied")
        
    else:
        print("File operation completed successfully")
        
    finally:
        \# Cleanup {- always executes}
        if file\_handle:
            file\_handle.close()
            print("File closed")

\# Test the function
file\_operation("test.txt")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Exception Flow}: try \rightarrow except/else \rightarrow finally
\item
  \textbf{Multiple Handlers}: Multiple except blocks allowed
\item
  \textbf{Guaranteed Execution}: finally block હંમેશા run થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Try Exception Else Finally''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(c OR) [7
marks]}\label{question-3c-or-7-marks}

\textbf{Write a user defined exception that could be raised when the
text entered by a user consists of less than 10 characters.}

\begin{solutionbox}

User-defined exceptions custom validation logic implement કરવા માટે
powerful tool છે.

\textbf{Diagram: Custom Exception Flow}

\begin{verbatim}
flowchart LR
    A[User Input] {-{-} B\{Length = 10?\}}
    B {-{-}|No| C[Raise ShortTextError]}
    B {-{-}|Yes| D[Process Text]}
    C {-{-} E[Display Error Message]}
    D {-{-} F[Success Operation]}
    E {-{-} G[Ask for New Input]}
    F {-{-} H[End]}
    G {-{-} A}
\end{verbatim}

\begin{verbatim}
\# User{-defined Exception Class}
class ShortTextError(Exception):
    """Custom exception for text that is too short"""
    
    def \_\_init\_\_(self, text\_length, minimum\_length=10):
        self.text\_length = text\_length
        self.minimum\_length = minimum\_length
        message = f"Text is too short! Length: \{text\_length\}, Required: \{minimum\_length\}"
        super().\_\_init\_\_(message)

def validate\_text\_length(text):
    """
    Validate text length and raise exception if too short
    """
    if len(text) {} 10:
        raise ShortTextError(len(text))
    return True

def process\_user\_text(text):
    """
    Process text after validation
    """
    try:
        validate\_text\_length(text)
        print(f"✓ Text accepted: {}\{text\}{"})
        print(f"Text length: \{len(text)\} characters")
        return text.upper()  \# Process the text
        
    except ShortTextError as e:
        print(f"❌ \{e\}")
        return None

def interactive\_text\_input():
    """
    Interactive function to get valid text from user
    """
    while True:
        try:
            user\_input = input("Enter text (minimum 10 characters): ")
            
            \# Validate text length
            if len(user\_input) {} 10:
                raise ShortTextError(len(user\_input))
                
            print(f"✓ Valid text entered: {}\{user\_input\}{"})
            break
            
        except ShortTextError as e:
            print(f"❌ Error: \{e\}")
            retry = input("Try again? (y/n): ")
            if retry.lower() != {y}:
                print("Operation cancelled.")
                break

\# Test different scenarios
def test\_custom\_exception():
    test\_texts = [
        "Hi",                    \# Too short (2 chars)
        "Hello",                 \# Too short (5 chars)  
        "Short",                 \# Too short (5 chars)
        "This is valid text",    \# Valid (19 chars)
        "Perfect length text"    \# Valid (20 chars)
    ]
    
    print("Testing Custom Exception:")
    print("=" * 40)
    
    for text in test\_texts:
        result = process\_user\_text(text)
        if result:
            print(f"Processed: \{result\}")
        print("{-"} * 30)

\# Run tests
test\_custom\_exception()

\# Uncomment to test interactive input
\# interactive\_text\_input()
\end{verbatim}

\textbf{Additional Features:}

\begin{verbatim}
\# Enhanced Custom Exception with more features
class TextValidationError(Exception):
    """Enhanced text validation exception"""
    
    def \_\_init\_\_(self, text, error\_type, details=None):
        self.text = text
        self.error\_type = error\_type
        self.details = details
        
        if error\_type == "short":
            message = f"Text too short: \{len(text)\} chars (min: 10)"
        elif error\_type == "empty":
            message = "Text cannot be empty"
        elif error\_type == "spaces":
            message = "Text contains only spaces"
        else:
            message = f"Text validation failed: \{error\_type\}"
            
        super().\_\_init\_\_(message)

def advanced\_text\_validation(text):
    """Advanced text validation with multiple checks"""
    if not text:
        raise TextValidationError(text, "empty")
    
    if text.isspace():
        raise TextValidationError(text, "spaces")
        
    if len(text.strip()) {} 10:
        raise TextValidationError(text, "short")
    
    return True
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Custom Logic}: Application-specific validation rules implement
  કરી શકાય
\item
  \textbf{Inheritance}: Exception class ને inherit કરીને custom exceptions
  બનાવાય
\item
  \textbf{Detailed Information}: Exception object માં additional data
  store કરી શકાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Custom Exception = Class Inherit Raise''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Write five points on difference between Text File and Binary
File.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Text File vs Binary File}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3939}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Text File
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Binary File
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Content} & Human-readable characters & Binary data (0s and
1s) \\
\textbf{Encoding} & Character encoding (UTF-8, ASCII) & No character
encoding \\
\textbf{Opening Mode} & `r', `w', `a' & `rb', `wb', `ab' \\
\textbf{File Size} & Generally larger & Generally smaller \\
\textbf{Platform} & Platform dependent & Platform independent \\
\end{longtable}
}

\begin{verbatim}
\# Text vs Binary File Examples
\# Text file example
with open("sample.txt", "w") as f:
    f.write("Hello World")

\# Binary file example  
with open("sample.bin", "wb") as f:
    f.write(b{}{x48x65x6cx6cx6f}{})
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Readability}: Text files editor માં read કરી શકાય, binary files
  special software જોઈએ
\item
  \textbf{Portability}: Binary files different platforms પર easily
  transfer થાય
\item
  \textbf{Processing}: Text files string operations માટે, binary files
  exact data storage માટે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Text Human, Binary Machine''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Write a program to read the data from a file and separate the
uppercase character and lowercase character into two separate files.}

\begin{solutionbox}

File processing માં character-based operations common requirements છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{File Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3929}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Read} & \texttt{read()} & Complete file content \\
\textbf{Write} & \texttt{write()} & Write string to file \\
\textbf{Character Check} & \texttt{isupper()}, \texttt{islower()} &
Character case detection \\
\textbf{File Handling} & \texttt{with\ open()} & Safe file operations \\
\end{longtable}
}

\begin{verbatim}
def separate\_case\_characters(input\_file, upper\_file, lower\_file):
    """
    Read file and separate uppercase/lowercase characters
    """
    try:
        \# Read from input file
        with open(input\_file, {r}) as infile:
            content = infile.read()
        
        \# Separate characters
        uppercase\_chars = ""
        lowercase\_chars = ""
        
        for char in content:
            if char.isupper():
                uppercase\_chars += char
            elif char.islower():
                lowercase\_chars += char
        
        \# Write to uppercase file
        with open(upper\_file, {w}) as upfile:
            upfile.write(uppercase\_chars)
        
        \# Write to lowercase file  
        with open(lower\_file, {w}) as lowfile:
            lowfile.write(lowercase\_chars)
        
        print(f"✓ Characters separated successfully!")
        print(f"Uppercase characters: \{len(uppercase\_chars)\}")
        print(f"Lowercase characters: \{len(lowercase\_chars)\}")
        
    except FileNotFoundError:
        print(f"Error: File {}\{input\_file\}{ not found"})
    except Exception as e:
        print(f"Error: \{e\}")

\# Create sample input file
def create\_sample\_file():
    sample\_text = """Hello World! This is a SAMPLE Text file.
It contains UPPERCASE and lowercase Characters.
Python Programming is FUN and Educational."""
    
    with open("input.txt", "w") as f:
        f.write(sample\_text)
    print("Sample input file created: input.txt")

\# Main execution
create\_sample\_file()
separate\_case\_characters("input.txt", "uppercase.txt", "lowercase.txt")

\# Display results
print("{n}File Contents:")
print("{-"} * 30)

try:
    with open("uppercase.txt", "r") as f:
        print(f"Uppercase file: \{f.read()\}")
    
    with open("lowercase.txt", "r") as f:
        print(f"Lowercase file: \{f.read()\}")
except FileNotFoundError:
    print("Output files not found")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Character Processing}: દરેક character ની case individually
  check કરાય છે
\item
  \textbf{File Safety}: with statement automatic file closing ensure કરે
  છે
\item
  \textbf{Error Handling}: File operations માં proper exception handling
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read Separate Write''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Describe dump() and load() method. Explain with example.}

\begin{solutionbox}

dump() અને load() methods pickle module ના part છે જે object serialization
માટે વાપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Pickle Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1951}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2195}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2683}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3171}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
File Mode
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{dump()} & Serialize object to file & `wb' & Object ને binary file
માં store કરે \\
\textbf{load()} & Deserialize object from file & `rb' & File માંથી object
retrieve કરે \\
\textbf{dumps()} & Serialize to bytes & N/A & Object ને bytes માં convert
કરે \\
\textbf{loads()} & Deserialize from bytes & N/A & Bytes માંથી object
બનાવે \\
\end{longtable}
}

\textbf{Diagram: Serialization Process}

\begin{verbatim}
flowchart LR
    A[Python Object] {-{-}|"dump()"| B[Binary File]}
    B {-{-}|"load()"| C[Python Object]}
    A {-{-}|"dumps()"| D[Bytes String]}
    D {-{-}|"loads()"| C}
\end{verbatim}

\begin{verbatim}
import pickle

\# Example with different data types
def demonstrate\_pickle():
    \# Sample data to serialize
    student\_data = \{
        {name}: {Raj Patel},
        {age}: 20,
        {grades}: [85, 92, 78, 96],
        {subjects}: ({Math}, {Python}, {Database}),
        {is\_active}: True
    \}
    
    class Student:
        def \_\_init\_\_(self, name, roll\_no):
            self.name = name
            self.roll\_no = roll\_no
        
        def \_\_str\_\_(self):
            return f"Student: \{self.name\} (Roll: \{self.roll\_no\})"
    
    \# Create objects
    student\_obj = Student("Priya Shah", 101)
    data\_list = [student\_data, student\_obj, [1, 2, 3, 4, 5]]
    
    \# DUMP {- Serialize objects to file}
    print("=== DUMP Operation ===")
    try:
        with open({student\_data.pkl}, {wb}) as f:
            pickle.dump(data\_list, f)
        print("✓ Data successfully dumped to student\_data.pkl")
        
        \# Also demonstrate dumps()
        serialized\_bytes = pickle.dumps(student\_data)
        print(f"✓ Data serialized to bytes: \{len(serialized\_bytes)\} bytes")
        
    except Exception as e:
        print(f"❌ Dump error: \{e\}")
    
    \# LOAD {- Deserialize objects from file  }
    print("{n}=== LOAD Operation ===")
    try:
        with open({student\_data.pkl}, {rb}) as f:
            loaded\_data = pickle.load(f)
        
        print("✓ Data successfully loaded from student\_data.pkl")
        print("{n}Loaded Data:")
        print("{-"} * 20)
        
        \# Display loaded data
        for i, item in enumerate(loaded\_data):
            print(f"Item \{i+1\}: \{item\}")
            print(f"Type: \{type(item)\}")
            print()
        
        \# Also demonstrate loads()
        deserialized\_data = pickle.loads(serialized\_bytes)
        print(f"✓ Data deserialized from bytes: \{deserialized\_data\}")
        
    except FileNotFoundError:
        print("❌ Pickle file not found")
    except Exception as e:
        print(f"❌ Load error: \{e\}")

\# Advanced example with custom class
def advanced\_pickle\_example():
    class BankAccount:
        def \_\_init\_\_(self, account\_no, holder\_name, balance):
            self.account\_no = account\_no
            self.holder\_name = holder\_name
            self.balance = balance
            self.transactions = []
        
        def deposit(self, amount):
            self.balance += amount
            self.transactions.append(f"Deposit: +\{amount\}")
        
        def withdraw(self, amount):
            if self.balance {=} amount:
                self.balance {-=} amount
                self.transactions.append(f"Withdraw: {-}\{amount\}")
            else:
                print("Insufficient balance")
        
        def \_\_str\_\_(self):
            return f"Account \{self.account\_no\}: \{self.holder\_name\} {- Balance: ₹}\{self.balance\}"
    
    \# Create and use account
    account = BankAccount("12345", "Amit Kumar", 5000)
    account.deposit(1500)
    account.withdraw(800)
    
    print("=== Advanced Pickle Example ===")
    print(f"Original: \{account\}")
    print(f"Transactions: \{account.transactions\}")
    
    \# Serialize account object
    with open({bank\_account.pkl}, {wb}) as f:
        pickle.dump(account, f)
    
    \# Load account object
    with open({bank\_account.pkl}, {rb}) as f:
        loaded\_account = pickle.load(f)
    
    print(f"Loaded: \{loaded\_account\}")
    print(f"Loaded transactions: \{loaded\_account.transactions\}")
    
    \# Verify object functionality
    loaded\_account.deposit(200)
    print(f"After new deposit: \{loaded\_account\}")

\# Run demonstrations
demonstrate\_pickle()
print("{n}" + "="*50 + "{n}")
advanced\_pickle\_example()
\end{verbatim}

\textbf{Benefits and Limitations:}

\begin{verbatim}
\# Benefits
benefits = [
    "Complete object state preservation",
    "Works with complex nested objects", 
    "Maintains object relationships",
    "Fast serialization/deserialization"
]

\# Limitations  
limitations = [
    "Python{-specific format"},
    "Security risks with untrusted data",
    "Version compatibility issues",
    "Not human{-readable"}
]

print("Benefits:", benefits)
print("Limitations:", limitations)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Object Persistence}: Python objects ને file માં permanently
  store કરી શકાય
\item
  \textbf{Complete State}: Object ની complete state including methods
  preserve થાય છે
\item
  \textbf{Binary Format}: Efficient storage પણ human-readable નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Dump Store, Load Restore''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(a OR) [3
marks]}\label{question-4a-or-3-marks}

\textbf{List different types of file modes provided by python for file
operations and explain their uses.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Python File Modes}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1395}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1395}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3023}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4186}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Mode
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pointer Position
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{`r'} & Text Read & Read only, file must exist & Beginning \\
\textbf{`w'} & Text Write & Write only, creates/overwrites &
Beginning \\
\textbf{`a'} & Text Append & Write only, creates if not exist & End \\
\textbf{`x'} & Text Create & Create new file, fails if exists &
Beginning \\
\textbf{`rb'} & Binary Read & Read binary data & Beginning \\
\textbf{`wb'} & Binary Write & Write binary data & Beginning \\
\textbf{`ab'} & Binary Append & Append binary data & End \\
\textbf{`r+'} & Text Read/Write & Read and write, file must exist &
Beginning \\
\textbf{`w+'} & Text Write/Read & Write and read, creates/overwrites &
Beginning \\
\end{longtable}
}

\begin{verbatim}
\# File Modes Examples
import os

\# Create sample file for demonstration
with open({demo.txt}, {w}) as f:
    f.write("Original content{n}Line 2{n}Line 3")

\# Read mode ({r)}
with open({demo.txt}, {r}) as f:
    content = f.read()
    print("Read mode:", content)

\# Append mode ({a)  }
with open({demo.txt}, {a}) as f:
    f.write("{n}Appended line")

\# Read+Write mode ({r+)}
with open({demo.txt}, {r+}) as f:
    f.seek(0)  \# Go to beginning
    f.write("Modified")

print("File modes demonstrated successfully")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Safety}: `x' mode prevents accidental file overwriting
\item
  \textbf{Efficiency}: Binary modes faster for non-text data
\item
  \textbf{Flexibility}: Combined modes allow both read and write
  operations
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read Write Append Create Binary Plus''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(b OR) [4
marks]}\label{question-4b-or-4-marks}

\textbf{Describe readline() and writeline() functions of the file.}

\begin{solutionbox}

\textbf{Note}: Python માં \texttt{writeline()} function exist નથી.
Correct function \texttt{writelines()} છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Line-based File Functions}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2564}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1795}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Return Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Usage
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{readline()} & Read single line & String & Sequential line
reading \\
\textbf{readlines()} & Read all lines & List of strings & Complete file
as list \\
\textbf{writelines()} & Write multiple lines & None & Write list of
strings \\
\textbf{write()} & Write single string & Number of chars & Basic
writing \\
\end{longtable}
}

\begin{verbatim}
def demonstrate\_line\_functions():
    \# Create sample file with multiple lines
    lines\_to\_write = [
        "First line of text{n}",
        "Second line of text{n}", 
        "Third line of text{n}",
        "Fourth line without newline"
    ]
    
    print("=== WRITELINES() Demonstration ===")
    \# Write multiple lines using writelines()
    with open({sample\_lines.txt}, {w}) as f:
        f.writelines(lines\_to\_write)
    print("✓ Multiple lines written using writelines()")
    
    print("{n}=== READLINE() Demonstration ===")
    \# Read lines one by one using readline()
    with open({sample\_lines.txt}, {r}) as f:
        line\_count = 0
        while True:
            line = f.readline()
            if not line:  \# End of file
                break
            line\_count += 1
            print(f"Line \{line\_count\}: \{line.strip()\}")
    
    print(f"Total lines read: \{line\_count\}")
    
    print("{n}=== READLINES() Demonstration ===")
    \# Read all lines at once using readlines()
    with open({sample\_lines.txt}, {r}) as f:
        all\_lines = f.readlines()
    
    print("All lines as list:")
    for i, line in enumerate(all\_lines, 1):
        print(f"  [\{i\}] \{repr(line)\}")
    
    \# Practical example: Processing file line by line
    print("{n}=== Practical Example ===")
    student\_data = [
        "Raj,20,IT{n}",
        "Priya,19,CS{n}", 
        "Amit,21,EC{n}",
        "Sneha,20,IT{n}"
    ]
    
    \# Write student data
    with open({students.txt}, {w}) as f:
        f.writelines(student\_data)
    
    \# Read and process line by line
    print("Student Information:")
    with open({students.txt}, {r}) as f:
        while True:
            line = f.readline()
            if not line:
                break
            
            \# Process each line
            parts = line.strip().split({,})
            if len(parts) == 3:
                name, age, course = parts
                print(f"  \{name\} (Age: \{age\}, Course: \{course\})")

\# Run demonstration
demonstrate\_line\_functions()

\# File pointer behavior example
def file\_pointer\_demo():
    print("{n}=== File Pointer Behavior ===")
    
    with open({sample\_lines.txt}, {r}) as f:
        print(f"Initial position: \{f.tell()\}")
        
        line1 = f.readline()
        print(f"After readline(): position \{f.tell()\}")
        print(f"Read: \{repr(line1)\}")
        
        line2 = f.readline()  
        print(f"After second readline(): position \{f.tell()\}")
        print(f"Read: \{repr(line2)\}")

file\_pointer\_demo()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Sequential Access}: readline() sequential manner માં lines read
  કરે છે
\item
  \textbf{Memory Efficient}: Large files માટે readline() memory-efficient
  છે
\item
  \textbf{List Operations}: writelines() list of strings ને efficiently
  write કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Read Line, Write Lines''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(c OR) [7
marks]}\label{question-4c-or-7-marks}

\textbf{Write a python program to demonstrate seek() and tell()
methods.}

\begin{solutionbox}

seek() અને tell() methods file pointer manipulation માટે વાપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{File Pointer Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Method & Purpose & Parameters & Return Value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{tell()} & Current position & None & Integer (byte position) \\
\textbf{seek()} & Move pointer & offset, whence & New position \\
\textbf{whence=0} & From beginning & Default & Absolute position \\
\textbf{whence=1} & From current & Relative & Current + offset \\
\textbf{whence=2} & From end & End relative & End + offset \\
\end{longtable}
}

\textbf{Diagram: File Pointer Movement}

\begin{verbatim}
File: "Hello World"
      \^{             \^{}         \^{}}
   Position 0   Position 6  Position 11 (EOF)
   
seek(0)    {- Move to beginning}
seek(6)    {- Move to position 6  }
seek({-5,2) {-} Move 5 positions before end}
\end{verbatim}

\begin{verbatim}
def demonstrate\_seek\_tell():
    \# Create sample file with known content
    sample\_text = "Hello Python Programming World!"
    
    with open({pointer\_demo.txt}, {w}) as f:
        f.write(sample\_text)
    
    print("=== File Pointer Demonstration ===")
    print(f"File content: {}\{sample\_text\}{"})
    print(f"File length: \{len(sample\_text)\} characters")
    print()
    
    with open({pointer\_demo.txt}, {r}) as f:
        \# Initial position
        print(f"1. Initial position: \{f.tell()\}")
        
        \# Read some characters
        first\_part = f.read(5)  \# Read "Hello"
        print(f"2. After reading {}\{first\_part\}{: position }\{f.tell()\}")
        
        \# Move to specific position
        f.seek(6)  \# Move to position 6 (start of "Python")
        print(f"3. After seek(6): position \{f.tell()\}")
        
        \# Read from new position
        next\_part = f.read(6)  \# Read "Python"
        print(f"4. Read {}\{next\_part\}{: position }\{f.tell()\}")
        
        \# Move relative to current position (only in binary mode for positive offset)
        \# Let{s demonstrate absolute positioning}
        f.seek(0)  \# Go to beginning
        print(f"5. After seek(0): position \{f.tell()\}")
        
        \# Move to end of file
        f.seek(0, 2)  \# 0 offset from end (position 2 = end)
        print(f"6. After seek(0,2) {- end of file: position }\{f.tell()\}")
        
        \# Move backwards from end
        f.seek({-}6, 2)  \# 6 positions before end
        print(f"7. After seek({-6,2): position }\{f.tell()\}")
        
        \# Read remaining content
        remaining = f.read()
        print(f"8. Read remaining {}\{remaining\}{: position }\{f.tell()\}")

def practical\_seek\_tell\_example():
    print("{n}=== Practical Example: File Editor Simulation ===")
    
    \# Create a file with structured data
    data\_lines = [
        "NAME:John Doe{n}",
        "AGE:25{n}", 
        "CITY:Mumbai{n}",
        "PHONE:9876543210{n}",
        "EMAIL:john@example.com{n}"
    ]
    
    with open({person\_data.txt}, {w}) as f:
        f.writelines(data\_lines)
    
    \# Demonstrate finding and modifying specific data
    with open({person\_data.txt}, {r+}) as f:  \# Read+Write mode
        \# Find and display all positions
        positions = \{\}
        
        while True:
            pos = f.tell()
            line = f.readline()
            if not line:
                break
            
            field = line.split({:})[0]
            positions[field] = pos
            print(f"Field {}\{field\}{ starts at position }\{pos\}")
        
        print(f"{n}File positions: \{positions\}")
        
        \# Modify specific field (AGE)
        if {AGE} in positions:
            f.seek(positions[{AGE}])
            print(f"{n}Moving to AGE field at position \{f.tell()\}")
            
            \# Read current line
            current\_line = f.readline()
            print(f"Current line: \{current\_line.strip()\}")
            
            \# Calculate position to overwrite
            f.seek(positions[{AGE}])
            new\_age\_line = "AGE:26{n}"  \# Same length as original
            f.write(new\_age\_line)
            print(f"Updated AGE field")
    
    \# Verify changes
    print("{n}Updated file content:")
    with open({person\_data.txt}, {r}) as f:
        print(f.read())

def binary\_seek\_tell\_demo():
    print("{n}=== Binary File Seek/Tell Demo ===")
    
    \# Create binary file
    binary\_data = b{}{x48x65x6cx6cx6fx20x57x6fx72x6cx64}{}  \# "Hello World"
    
    with open({binary\_demo.bin}, {wb}) as f:
        f.write(binary\_data)
    
    with open({binary\_demo.bin}, {rb}) as f:
        print(f"Binary file size: \{len(binary\_data)\} bytes")
        
        \# Demonstrate all seek modes in binary
        print(f"Initial position: \{f.tell()\}")
        
        \# Read first 5 bytes
        first\_bytes = f.read(5)
        print(f"Read first 5 bytes: \{first\_bytes\} at position \{f.tell()\}")
        
        \# Seek relative to current position (works in binary mode)
        f.seek(1, 1)  \# Move 1 byte forward from current
        print(f"After seek(1,1): position \{f.tell()\}")
        
        \# Seek from end
        f.seek({-}3, 2)  \# 3 bytes before end
        print(f"After seek({-3,2): position }\{f.tell()\}")
        
        \# Read remaining
        remaining\_bytes = f.read()
        print(f"Remaining bytes: \{remaining\_bytes\}")

\# Run all demonstrations
demonstrate\_seek\_tell()
practical\_seek\_tell\_example()
binary\_seek\_tell\_demo()

\# Cleanup
import os
try:
    os.remove({pointer\_demo.txt})
    os.remove({person\_data.txt}) 
    os.remove({binary\_demo.bin})
    print("{n}Demo files cleaned up")
except:
    pass
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{File Navigation}: seek() arbitrary position પર move કરવા માટે
  વાપરાય છે
\item
  \textbf{Position Tracking}: tell() current position track કરવા માટે
  useful છે
\item
  \textbf{File Editing}: Specific locations પર data modify કરવા માટે જરૂરી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Tell Position, Seek Destination''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Draw Circle and rectangle shapes using Turtle and fill them with
red color.}

\begin{solutionbox}

Turtle graphics module માં shapes draw કરવા અને fill કરવા માટે specific
methods છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Turtle Shape Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & Purpose & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{circle()} & Draw circle & \texttt{turtle.circle(50)} \\
\textbf{forward()} & Move forward & \texttt{turtle.forward(100)} \\
\textbf{right()} & Turn right & \texttt{turtle.right(90)} \\
\textbf{begin\_fill()} & Start filling &
\texttt{turtle.begin\_fill()} \\
\textbf{end\_fill()} & End filling & \texttt{turtle.end\_fill()} \\
\textbf{fillcolor()} & Set fill color &
\texttt{turtle.fillcolor("red")} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def draw\_filled\_shapes():
    \# Create screen and turtle
    screen = turtle.Screen()
    screen.title("Filled Shapes with Turtle")
    screen.bgcolor("white")
    screen.setup(800, 600)
    
    \# Create turtle object
    painter = turtle.Turtle()
    painter.speed(3)
    
    \# Draw filled circle
    print("Drawing filled circle...")
    painter.penup()
    painter.goto({-}150, 0)  \# Move to left side
    painter.pendown()
    
    painter.fillcolor("red")
    painter.begin\_fill()
    painter.circle(80)  \# Radius = 80
    painter.end\_fill()
    
    \# Draw filled rectangle
    print("Drawing filled rectangle...")
    painter.penup()
    painter.goto(50, 50)  \# Move to right side
    painter.pendown()
    
    painter.fillcolor("red")
    painter.begin\_fill()
    
    \# Draw rectangle (100x80)
    for \_ in range(2):
        painter.forward(100)
        painter.right(90)
        painter.forward(80)
        painter.right(90)
    
    painter.end\_fill()
    
    \# Add labels
    painter.penup()
    painter.goto({-}150, {-}120)
    painter.write("Red Circle", align="center", font=("Arial", 14, "normal"))
    
    painter.goto(100, {-}50)
    painter.write("Red Rectangle", align="center", font=("Arial", 14, "normal"))
    
    \# Hide turtle and display result
    painter.hideturtle()
    print("Shapes drawn successfully!")
    
    \# Keep window open
    screen.exitonclick()

\# Run the program
draw\_filled\_shapes()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Fill Process}: begin\_fill() અને end\_fill() વચ્ચે drawn shape
  automatically fill થાય છે
\item
  \textbf{Color Setting}: fillcolor() method fill color set કરે છે
\item
  \textbf{Shape Drawing}: Geometric shapes માટે specific turtle movements
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Begin Fill Draw End''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Explain the various inbuilt methods to change the direction of
the Turtle.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Turtle Direction Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1905}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3095}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2143}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Parameters
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{right()} & angle & Turn right by degrees &
\texttt{turtle.right(90)} \\
\textbf{left()} & angle & Turn left by degrees &
\texttt{turtle.left(45)} \\
\textbf{setheading()} & angle & Set absolute direction &
\texttt{turtle.setheading(0)} \\
\textbf{towards()} & x, y & Point towards coordinates &
\texttt{turtle.towards(100,\ 50)} \\
\textbf{home()} & none & Return to center, face east &
\texttt{turtle.home()} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_direction\_methods():
    screen = turtle.Screen()
    screen.setup(600, 600)
    screen.title("Turtle Direction Methods")
    
    t = turtle.Turtle()
    t.speed(2)
    t.shape("turtle")
    
    \# 1. right() method
    t.write("1. right(90)", font=("Arial", 10, "normal"))
    t.forward(50)
    t.right(90)
    t.forward(50)
    
    \# 2. left() method  
    t.penup()
    t.goto({-}100, 100)
    t.pendown()
    t.write("2. left(45)", font=("Arial", 10, "normal"))
    t.forward(50)
    t.left(45)
    t.forward(50)
    
    \# 3. setheading() method
    t.penup()
    t.goto(100, 100)
    t.pendown()
    t.write("3. setheading(180)", font=("Arial", 10, "normal"))
    t.setheading(180)  \# Face west
    t.forward(50)
    
    \# 4. towards() method
    t.penup()
    t.goto({-}100, {-}100)
    t.pendown()
    target\_x, target\_y = 100, {-}100
    t.write("4. towards(100,{-100)"}, font=("Arial", 10, "normal"))
    angle = t.towards(target\_x, target\_y)
    t.setheading(angle)
    t.goto(target\_x, target\_y)
    
    \# 5. home() method
    t.write("5. home()", font=("Arial", 10, "normal"))
    t.home()  \# Return to center and face east
    
    t.hideturtle()
    screen.exitonclick()

demonstrate\_direction\_methods()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Relative Turns}: right() અને left() current direction થી
  relative turn
\item
  \textbf{Absolute Direction}: setheading() absolute compass direction
  set કરે
\item
  \textbf{Smart Pointing}: towards() specific coordinates તરફ point કરે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Right Left Set Towards Home''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Write a python program to draw a rainbow using Turtle.}

\begin{solutionbox}

Rainbow drawing માં multiple colored arcs અને proper positioning જરૂરી છે.

\textbf{Diagram: Rainbow Structure}

\begin{verbatim}
    Red (outer)
   Orange  
  Yellow
 Green
Blue
Indigo
Violet (inner)
\end{verbatim}

\begin{verbatim}
import turtle

def draw\_rainbow():
    \# Screen setup
    screen = turtle.Screen()
    screen.title("Beautiful Rainbow")
    screen.bgcolor("lightblue")
    screen.setup(800, 600)
    
    \# Turtle setup
    rainbow\_turtle = turtle.Turtle()
    rainbow\_turtle.speed(8)
    rainbow\_turtle.pensize(8)
    
    \# Rainbow colors (ROYGBIV)
    colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"]
    
    \# Rainbow parameters
    start\_radius = 200
    radius\_decrease = 15
    start\_y = {-}150
    
    print("Drawing rainbow...")
    
    \# Draw each color arc
    for i, color in enumerate(colors):
        \# Set color
        rainbow\_turtle.pencolor(color)
        
        \# Calculate current radius
        current\_radius = start\_radius {-} (i * radius\_decrease)
        
        \# Position turtle for semi{-circle}
        rainbow\_turtle.penup()
        rainbow\_turtle.goto({-}current\_radius, start\_y)
        rainbow\_turtle.pendown()
        rainbow\_turtle.setheading(0)  \# Face east
        
        \# Draw semi{-circle (180 degrees)}
        rainbow\_turtle.circle(current\_radius, 180)
        
        print(f"Drew \{color\} arc with radius \{current\_radius\}")
    
    \# Add clouds at ends
    draw\_clouds(rainbow\_turtle)
    
    \# Add sun
    draw\_sun(rainbow\_turtle)
    
    \# Add text
    rainbow\_turtle.penup()
    rainbow\_turtle.goto(0, {-}250)
    rainbow\_turtle.pencolor("black")
    rainbow\_turtle.write("🌈 Beautiful Rainbow 🌈", align="center", 
                        font=("Arial", 16, "bold"))
    
    rainbow\_turtle.hideturtle()
    print("Rainbow completed!")
    
    screen.exitonclick()

def draw\_clouds(turtle\_obj):
    """Draw clouds at both ends of rainbow"""
    turtle\_obj.pensize(3)
    turtle\_obj.pencolor("white")
    turtle\_obj.fillcolor("lightgray")
    
    \# Left cloud
    cloud\_positions = [({-}250, {-}100), (250, {-}100)]
    
    for x, y in cloud\_positions:
        turtle\_obj.penup()
        turtle\_obj.goto(x, y)
        turtle\_obj.pendown()
        \# Draw cloud using multiple circles
        turtle\_obj.begin\_fill()
        for i in range(3):
            turtle\_obj.circle(20)
            turtle\_obj.left(120)
        turtle\_obj.end\_fill()

def draw\_sun(turtle\_obj):
    """Draw sun in corner"""
    turtle\_obj.penup()
    turtle\_obj.goto(300, 200)
    turtle\_obj.pendown()
    turtle\_obj.pencolor("orange")
    turtle\_obj.fillcolor("yellow")
    
    \# Draw sun body
    turtle\_obj.begin\_fill()
    turtle\_obj.circle(30)
    turtle\_obj.end\_fill()
    
    \# Draw sun rays
    turtle\_obj.pensize(2)
    for angle in range(0, 360, 45):
        turtle\_obj.setheading(angle)
        turtle\_obj.forward(45)
        turtle\_obj.backward(45)

\# Alternative rainbow with gradient effect
def draw\_gradient\_rainbow():
    screen = turtle.Screen()
    screen.title("Gradient Rainbow")
    screen.bgcolor("skyblue")
    screen.setup(800, 600)
    
    t = turtle.Turtle()
    t.speed(0)
    t.pensize(5)
    
    \# Color variations for gradient effect
    rainbow\_colors = [
        "\#FF0000", "\#FF4500", "\#FFD700", "\#32CD32", 
        "\#0000FF", "\#4B0082", "\#8B00FF"
    ]
    
    \# Draw rainbow with varying thickness
    for i, color in enumerate(rainbow\_colors):
        t.pencolor(color)
        t.pensize(12 {-} i)  \# Decreasing thickness
        
        radius = 150 {-} (i * 10)
        t.penup()
        t.goto({-}radius, {-}100)
        t.pendown()
        t.setheading(0)
        t.circle(radius, 180)
    
    t.hideturtle()
    screen.exitonclick()

\# Run the rainbow programs
print("Choose rainbow type:")
print("1. Standard Rainbow")
print("2. Gradient Rainbow")

choice = input("Enter choice (1 or 2): ")
if choice == "2":
    draw\_gradient\_rainbow()
else:
    draw\_rainbow()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Color Sequence}: ROYGBIV (Red Orange Yellow Green Blue Indigo
  Violet) નો proper order
\item
  \textbf{Radius Management}: દરેક arc નો radius gradually decrease કરાય
  છે
\item
  \textbf{Positioning}: Proper positioning માટે penup/pendown અને goto
  methods
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ROYGBIV Arc Radius Position''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(a OR) [3
marks]}\label{question-5a-or-3-marks}

\textbf{Draw a diagram of turtle screen and explain all 4 quadrants of x
and y coordinates.}

\begin{solutionbox}

\textbf{Diagram: Turtle Coordinate System}

\begin{verbatim}
                    +Y
                    |
                    |
        II          |          I
    ({-x,+y)         |      (+x,+y)}
                    |
{-X {-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-}|{-}{-}{-}{-}{-} +X}
       {-200  {-}100   0   100  200}
                    |
        III         |         IV  
    ({-x,{-}y)         |      (+x,{-}y)}
                    |
                    |
                   {-Y}
                   
Default Screen: 400x300 pixels
Center: (0, 0)
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Coordinate Quadrants}
\vspace{-10pt}
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Quadrant & X Value & Y Value & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{I} & Positive (+) & Positive (+) & Top-right & (100, 50) \\
\textbf{II} & Negative (-) & Positive (+) & Top-left & (-100, 50) \\
\textbf{III} & Negative (-) & Negative (-) & Bottom-left & (-100,
-50) \\
\textbf{IV} & Positive (+) & Negative (-) & Bottom-right & (100, -50) \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_coordinate\_system():
    screen = turtle.Screen()
    screen.title("Turtle Coordinate System")
    screen.setup(600, 500)
    screen.bgcolor("white")
    
    t = turtle.Turtle()
    t.speed(3)
    t.shape("turtle")
    
    \# Draw coordinate axes
    t.pencolor("gray")
    t.pensize(2)
    
    \# X{-axis}
    t.penup()
    t.goto({-}250, 0)
    t.pendown()
    t.goto(250, 0)
    
    \# Y{-axis}
    t.penup()
    t.goto(0, {-}200)
    t.pendown()
    t.goto(0, 200)
    
    \# Mark center
    t.penup()
    t.goto(0, 0)
    t.dot(8, "red")
    t.write("(0,0)", font=("Arial", 12, "normal"))
    
    \# Demonstrate each quadrant
    quadrants = [
        (100, 100, "I", "red"),     \# Quadrant I
        ({-}100, 100, "II", "blue"),  \# Quadrant II  
        ({-}100, {-}100, "III", "green"), \# Quadrant III
        (100, {-}100, "IV", "orange")   \# Quadrant IV
    ]
    
    for x, y, quad\_name, color in quadrants:
        t.pencolor(color)
        t.penup()
        t.goto(x, y)
        t.pendown()
        t.dot(10, color)
        t.write(f"Q\{quad\_name\}{n}(\{x\},\{y\})", align="center", 
                font=("Arial", 10, "bold"))
    
    t.hideturtle()
    screen.exitonclick()

demonstrate\_coordinate\_system()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Origin}: (0,0) screen ના center પર આવેલું છે
\item
  \textbf{Positive Direction}: X-axis right તરફ, Y-axis up તરફ positive
\item
  \textbf{Navigation}: goto(x, y) method specific coordinates પર move કરે
  છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Right Up Positive, Left Down Negative''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(b OR) [4
marks]}\label{question-5b-or-4-marks}

\textbf{Describe various turtle screen methods to change the background
color, title, screensize and shapesize.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Turtle Screen Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2105}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3158}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2368}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Parameters
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{bgcolor()} & Set background color & color name/hex &
\texttt{screen.bgcolor("blue")} \\
\textbf{title()} & Set window title & string &
\texttt{screen.title("My\ Program")} \\
\textbf{setup()} & Set screen size & width, height &
\texttt{screen.setup(800,\ 600)} \\
\textbf{screensize()} & Set canvas size & width, height &
\texttt{screen.screensize(400,\ 300)} \\
\textbf{shapesize()} & Set turtle size & stretch\_wid, stretch\_len &
\texttt{turtle.shapesize(2,\ 3)} \\
\end{longtable}
}

\begin{verbatim}
import turtle

def demonstrate\_screen\_methods():
    \# Create screen object
    screen = turtle.Screen()
    
    \# 1. Title Method
    screen.title("Screen Methods Demonstration")
    print("✓ Title set to: {Screen Methods Demonstration"})
    
    \# 2. Background Color Method
    screen.bgcolor("lightgreen")
    print("✓ Background color set to: lightgreen")
    
    \# 3. Setup Method (window size)
    screen.setup(width=800, height=600)
    print("✓ Window size set to: 800x600 pixels")
    
    \# 4. Screen Size Method (canvas size)
    screen.screensize(canvwidth=400, canvheight=300)
    print("✓ Canvas size set to: 400x300")
    
    \# Create turtle to demonstrate shapesize
    demo\_turtle = turtle.Turtle()
    demo\_turtle.speed(3)
    
    \# 5. Shape Size Method
    demo\_turtle.shape("turtle")
    demo\_turtle.shapesize(stretch\_wid=3, stretch\_len=2, outline=3)
    print("✓ Turtle shape size: width=3x, length=2x, outline=3")
    
    \# Demonstrate different background colors
    colors = ["lightblue", "lightyellow", "lightpink", "lightcoral"]
    
    for i, color in enumerate(colors):
        screen.bgcolor(color)
        demo\_turtle.write(f"Background: \{color\}", 
                         font=("Arial", 14, "normal"))
        demo\_turtle.forward(50)
        demo\_turtle.right(90)
        screen.ontimer(lambda: None, 1000)  \# Wait 1 second
    
    \# Reset to final state
    screen.bgcolor("white")
    demo\_turtle.penup()
    demo\_turtle.goto(0, {-}50)
    demo\_turtle.write("Screen Methods Demo Complete!", 
                     align="center", font=("Arial", 16, "bold"))
    
    demo\_turtle.hideturtle()
    screen.exitonclick()

def advanced\_screen\_customization():
    """Advanced screen customization example"""
    screen = turtle.Screen()
    
    \# Advanced setup with all parameters
    screen.setup(width=0.8, height=0.8, startx=100, starty=50)
    screen.title("🐢 Advanced Turtle Graphics 🐢")
    screen.bgcolor("\#2E8B57")  \# Sea Green
    
    \# Custom color palette
    screen.colormode(255)  \# Enable RGB mode
    
    \# Create multiple turtles with different sizes
    turtles = []
    shapes = ["turtle", "circle", "square", "triangle"]
    sizes = [(1, 1), (2, 1), (1, 2), (3, 3)]
    colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0)]
    
    for i in range(4):
        t = turtle.Turtle()
        t.shape(shapes[i])
        t.shapesize(sizes[i][0], sizes[i][1])
        t.color(colors[i])
        t.penup()
        t.goto({-}150 + i*100, 0)
        turtles.append(t)
        
        \# Label each turtle
        t.write(f"\{shapes[i]\}{n}\{sizes[i]\}", 
               align="center", font=("Arial", 10, "normal"))
    
    \# Add instructions
    instruction\_turtle = turtle.Turtle()
    instruction\_turtle.hideturtle()
    instruction\_turtle.penup()
    instruction\_turtle.goto(0, {-}100)
    instruction\_turtle.color("white")
    instruction\_turtle.write("Different turtle shapes and sizes", 
                           align="center", font=("Arial", 16, "bold"))
    
    screen.exitonclick()

\# Run demonstrations
print("Running Screen Methods Demo...")
demonstrate\_screen\_methods()

print("{n}Running Advanced Customization...")
advanced\_screen\_customization()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Window vs Canvas}: setup() window size, screensize() canvas
  size control કરે છે
\item
  \textbf{Color Modes}: bgcolor() color names અથવા hex values accept કરે
  છે
\item
  \textbf{Shape Scaling}: shapesize() turtle appearance ને scale કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Title Background Setup Size Shape''

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(c OR) [7
marks]}\label{question-5c-or-7-marks}

\textbf{Write a python program to draw a star, triangle and octagon
using turtle.}

\begin{solutionbox}

Geometric shapes drawing માં angles અને sides ની proper calculation જરૂરી
છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Shape Properties}
\vspace{-10pt}
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
Shape & Sides & External Angle & Internal Angle & Turn Angle \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Triangle} & 3 & 120^\circ & 60^\circ & 120^\circ \\
\textbf{Star (5-point)} & 5 & 144^\circ & 36^\circ & 144^\circ \\
\textbf{Octagon} & 8 & 45^\circ & 135^\circ & 45^\circ \\
\end{longtable}
}

\textbf{Diagram: Shape Construction}

\begin{verbatim}
Triangle:        Star:           Octagon:
   /{             *              /‾‾‾}
  /  {           /             /     }
 /\_\_\_\_{         /             |       |}
               *     *          {     /}
                {   /            \_\_\_/}
                 { /}
                  *
\end{verbatim}

\begin{verbatim}
import turtle
import math

def draw\_geometric\_shapes():
    \# Screen setup
    screen = turtle.Screen()
    screen.title("Geometric Shapes: Star, Triangle, Octagon")
    screen.bgcolor("black")
    screen.setup(900, 600)
    
    \# Turtle setup
    artist = turtle.Turtle()
    artist.speed(6)
    artist.pensize(3)
    
    \# Shape 1: Triangle
    draw\_triangle(artist, {-}250, 100, 80, "cyan")
    
    \# Shape 2: Five{-pointed Star  }
    draw\_star(artist, 0, 100, 80, "yellow")
    
    \# Shape 3: Octagon
    draw\_octagon(artist, 250, 100, 60, "magenta")
    
    \# Add labels
    add\_labels(artist)
    
    artist.hideturtle()
    print("All shapes drawn successfully!")
    screen.exitonclick()

def draw\_triangle(turtle\_obj, x, y, size, color):
    """Draw an equilateral triangle"""
    print(f"Drawing triangle at (\{x\}, \{y\})")
    
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    
    turtle\_obj.begin\_fill()
    for \_ in range(3):
        turtle\_obj.forward(size)
        turtle\_obj.left(120)  \# External angle for triangle
    turtle\_obj.end\_fill()

def draw\_star(turtle\_obj, x, y, size, color):
    """Draw a five{-pointed star"""}
    print(f"Drawing star at (\{x\}, \{y\})")
    
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    
    turtle\_obj.begin\_fill()
    for \_ in range(5):
        turtle\_obj.forward(size)
        turtle\_obj.right(144)  \# 144^ turn for 5{-pointed star}
    turtle\_obj.end\_fill()

def draw\_octagon(turtle\_obj, x, y, size, color):
    """Draw a regular octagon"""
    print(f"Drawing octagon at (\{x\}, \{y\})")
    
    turtle\_obj.penup()
    turtle\_obj.goto(x, y)
    turtle\_obj.pendown()
    turtle\_obj.color(color)
    turtle\_obj.fillcolor(color)
    
    turtle\_obj.begin\_fill()
    for \_ in range(8):
        turtle\_obj.forward(size)
        turtle\_obj.right(45)  \# 360^/8 = 45^ for octagon
    turtle\_obj.end\_fill()

def add\_labels(turtle\_obj):
    """Add labels for each shape"""
    turtle\_obj.color("white")
    
    labels = [
        ({-}250, 30, "Triangle{n}3 sides{n}120^ turns"),
        (0, 30, "Star{n}5 points{n}144^ turns"), 
        (250, 30, "Octagon{n}8 sides{n}45^ turns")
    ]
    
    for x, y, text in labels:
        turtle\_obj.penup()
        turtle\_obj.goto(x, y)
        turtle\_obj.write(text, align="center", font=("Arial", 12, "normal"))

def draw\_advanced\_shapes():
    """Advanced version with animations and multiple variations"""
    screen = turtle.Screen()
    screen.title("Advanced Geometric Shapes")
    screen.bgcolor("navy")
    screen.setup(1000, 700)
    
    artist = turtle.Turtle()
    artist.speed(8)
    artist.pensize(2)
    
    \# Animated triangle variations
    triangle\_sizes = [40, 60, 80]
    triangle\_colors = ["red", "orange", "yellow"]
    
    for i, (size, color) in enumerate(zip(triangle\_sizes, triangle\_colors)):
        x = {-}300 + i * 30
        y = 200 {-} i * 20
        draw\_triangle(artist, x, y, size, color)
    
    \# Animated star variations
    star\_sizes = [30, 50, 70, 90]
    star\_colors = ["pink", "lightblue", "lightgreen", "gold"]
    
    for i, (size, color) in enumerate(zip(star\_sizes, star\_colors)):
        angle = i * 90
        x = 150 + math.cos(math.radians(angle)) * 80
        y = 100 + math.sin(math.radians(angle)) * 80
        
        artist.penup()
        artist.goto(x, y)
        artist.setheading(angle)
        artist.pendown()
        artist.color(color)
        artist.fillcolor(color)
        
        artist.begin\_fill()
        for \_ in range(5):
            artist.forward(size)
            artist.right(144)
        artist.end\_fill()
    
    \# Octagon pattern
    for i in range(3):
        size = 40 + i * 15
        color\_intensity = 0.3 + i * 0.2
        draw\_octagon(artist, {-}100, {-}100 + i * 80, size, 
                    (color\_intensity, 0, color\_intensity))
    
    \# Mathematical information
    artist.penup()
    artist.goto(0, {-}250)
    artist.color("white")
    artist.write("Geometric Shapes {- Mathematical Properties"}, 
                align="center", font=("Arial", 16, "bold"))
    
    artist.goto(0, {-}280)
    artist.write("Triangle: Sum of angles = 180^, Star: 36^ points, Octagon: Sum = 1080^", 
                align="center", font=("Arial", 12, "normal"))
    
    artist.hideturtle()
    screen.exitonclick()

def calculate\_shape\_properties():
    """Calculate and display mathematical properties"""
    shapes\_info = \{
        "Triangle": \{
            "sides": 3,
            "internal\_angle": 180 * (3{-}2) / 3,
            "external\_angle": 360 / 3,
            "sum\_of\_angles": 180 * (3{-}2)
        \,}
        "Star (5{-point)"}: \{
            "points": 5,
            "point\_angle": 36,
            "turn\_angle": 144,
            "total\_rotation": 720
        \,}
        "Octagon": \{
            "sides": 8,
            "internal\_angle": 180 * (8{-}2) / 8,
            "external\_angle": 360 / 8,
            "sum\_of\_angles": 180 * (8{-}2)
        \}
    \}
    
    print("{n}" + "="*50)
    print("GEOMETRIC SHAPES {- MATHEMATICAL PROPERTIES"})
    print("="*50)
    
    for shape, props in shapes\_info.items():
        print(f"{n}\{shape\}:")
        for prop, value in props.items():
            print(f"  \{prop.replace({\_}, { }).title()\}: \{value\}^" if {angle} in prop else f"  \{prop.replace({\_}, { }).title()\}: \{value\}")

\# Run the programs
print("Choose drawing mode:")
print("1. Basic Shapes")
print("2. Advanced Shapes with Variations")

choice = input("Enter choice (1 or 2): ")

if choice == "2":
    draw\_advanced\_shapes()
else:
    draw\_geometric\_shapes()

\# Display mathematical properties
calculate\_shape\_properties()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Angle Calculation}: દરેક shape માટે correct turn angles ની
  calculation જરૂરી
\item
  \textbf{Fill Technique}: begin\_fill() અને end\_fill() વચ્ચે shape
  automatically fill થાય
\item
  \textbf{Mathematical Foundation}: Geometry ના principles આધારે shapes
  construct થાય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Triangle 120, Star 144, Octagon 45''

\end{mnemonicbox}

\end{document}
