\documentclass{article}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}
\usetikzlibrary{shapes.multipart, chains, arrows.meta, positioning, calc, trees}

\title{ડેટા સ્ટ્રક્ચર એન્ડ એપ્લિકેશન (1333203) - સમર 2025 સોલ્યુશન}
\date{May 15, 2025}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{વ્યાખ્યાયિત કરો બિગ- ઓ નોટેશન, બિગ ઓમેગા નોટેશન, બિગ થીટા નોટેશન.}

\begin{solutionbox}
\begin{center}
\captionof{table}{એસિમ્પ્ટોટિક નોટેશન સરખામણી}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{નોટેશન} & \textbf{પ્રતીક} & \textbf{વર્ણન} & \textbf{ઉપયોગ} \\ \hline
બિગ-ઓ & $O(f(n))$ & **ઉપલી હદ** & સૌથી ખરાબ કેસ \\ \hline
બિગ ઓમેગા & $\Omega(f(n))$ & **નીચલી હદ** & સૌથી સારો કેસ \\ \hline
બિગ થીટા & $\Theta(f(n))$ & **ચુસ્ત હદ** & સરેરાશ કેસ \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{બિગ-ઓ નોટેશન}: મહત્તમ સમય/સ્થળ જટિલતા વર્ણવે છે
    \item \textbf{બિગ ઓમેગા}: ન્યૂનતમ સમય/સ્થળ જટિલતા વર્ણવે છે
    \item \textbf{બિગ થીટા}: ચોક્કસ સમય/સ્થળ જટિલતા વર્ણવે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{OWT - O ખરાબ માટે, Omega શ્રેષ્ઠ માટે, Theta ચુસ્ત માટે}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{સેટ વ્યાખ્યાયિત કરો. સેટ પર કરી શકાય તેવા વિવિધ ઓપરેશનો લખો.}

\begin{solutionbox}
\textbf{વ્યાખ્યા}: સેટ એ અનન્ય તત્વોનો સંગ્રહ છે જેમાં કોઈ ડુપ્લિકેટ નથી.

\begin{center}
\captionof{table}{સેટ ઓપરેશનો}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{પ્રતીક} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
**યુનિયન** & $A \cup B$ & બધા તત્વો જોડે છે & $\{1,2\} \cup \{2,3\} = \{1,2,3\}$ \\ \hline
**ઇન્ટરસેક્શન** & $A \cap B$ & સામાન્ય તત્વો & $\{1,2\} \cap \{2,3\} = \{2\}$ \\ \hline
**ડિફરન્સ** & $A - B$ & A માં છે પણ B માં નથી & $\{1,2\} - \{2,3\} = \{1\}$ \\ \hline
**સબસેટ** & $A \subseteq B$ & A ના બધા તત્વો B માં છે & $\{1\} \subseteq \{1,2\} = True$ \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{ઉમેરવું/દાખલ કરવું}: નવું તત્વ ઉમેરવું
    \item \textbf{દૂર કરવું/કાઢવું}: અસ્તિત્વમાં રહેલું તત્વ દૂર કરવું
    \item \textbf{સમાવેશ}: તત્વ અસ્તિત્વમાં છે કે નહીં તપાસવું
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{UIDS - યુનિયન, ઇન્ટરસેક્શન, ડિફરન્સ, સબસેટ}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{ક્રિકેટર માટે Python ક્લાસ લખો...}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
class Cricketer:
    def __init__(self, name="", team="", run=0):
        self.name = name
        self.team = team
        self.run = run
    
    def set_run(self, run):
        self.run = run
    
    def display_run(self):
        print(f"ખેલાડી: {self.name}")
        print(f"ટીમ: {self.team}")
        print(f"રન: {self.run}")

# ઉદાહરણ ઉપયોગ
player = Cricketer("વિરાટ કોહલી", "ભારત", 100)
player.display_run()
\end{lstlisting}

\begin{itemize}
    \item \textbf{કન્સ્ટ્રક્ટર}: નામ, ટીમ અને રન ઇનિશિયલાઇઝ કરે છે
    \item \textbf{set\_run()}: રન વેલ્યુ અપડેટ કરે છે
    \item \textbf{display\_run()}: ખેલાડીની માહિતી બતાવે છે
\end{itemize}

\begin{center}
\begin{tikzpicture}[class/.style={rectangle, draw, minimum width=3cm, align=left, font=\small}]
    \node [class] (cricketer) {
        \textbf{Cricketer} \\
        \rule{3cm}{0.5pt} \\
        +name: string \\
        +team: string \\
        +run: int \\
        \rule{3cm}{0.5pt} \\
        +\_\_init\_\_() \\
        +set\_run() \\
        +display\_run()
    };
\end{tikzpicture}
\captionof{figure}{Cricketer ક્લાસ ડાયાગ્રામ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CSD - કન્સ્ટ્રક્ટર, સેટ, ડિસ્પ્લે}
\end{mnemonicbox}

\questionmarks{1(c) OR}{7}{વિદ્યાર્થીની માહિતી વાંચવા અને પ્રદર્શિત કરવા માટે વિદ્યાર્થી ક્લાસની રચના કરો...}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
class Student:
    def __init__(self):
        self.name = ""
        self.roll_no = ""
        self.marks = 0
        self.__getInfo()  # પ્રાઇવેટ મેથડ કૉલ
    
    def __getInfo__(self):  # પ્રાઇવેટ મેથડ
        self.name = input("નામ દાખલ કરો: ")
        self.roll_no = input("રોલ નંબર દાખલ કરો: ")
        self.marks = int(input("માર્ક્સ દાખલ કરો: "))
    
    def displayInfo(self):
        print(f"નામ: {self.name}")
        print(f"રોલ નંબર: {self.roll_no}")
        print(f"માર્ક્સ: {self.marks}")

# ઉદાહરણ ઉપયોગ
student = Student()
student.displayInfo()
\end{lstlisting}

\begin{itemize}
    \item \textbf{પ્રાઇવેટ મેથડ}: ડબલ અંડરસ્કોર (\_\_getInfo) વાપરે છે
    \item \textbf{કન્સ્ટ્રક્ટર}: આપોઆપ પ્રાઇવેટ મેથડ કૉલ કરે છે
    \item \textbf{પબ્લિક મેથડ}: displayInfo() વિદ્યાર્થીનો ડેટા બતાવે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PCP - પ્રાઇવેટ, કન્સ્ટ્રક્ટર, પબ્લિક}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{સ્ટેક અને ક્યૂ વચ્ચે તફાવત કરો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{સ્ટેક વર્સસ ક્યૂ સરખામણી}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{સ્ટેક} & \textbf{ક્યૂ} \\ \hline
\textbf{ક્રમ} & LIFO (છેલ્લું અંદર, પહેલું બહાર) & FIFO (પહેલું અંદર, પહેલું બહાર) \\ \hline
\textbf{ઓપરેશનો} & Push, Pop & Enqueue, Dequeue \\ \hline
\textbf{એક્સેસ પોઇન્ટ} & એક છેડો (ટોપ) & બે છેડા (ફ્રન્ટ અને રિયર) \\ \hline
\textbf{ઉદાહરણ} & પ્લેટનો સ્ટેક & બેંકની કતાર \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[
    stacknode/.style={rectangle, draw, minimum width=1cm, minimum height=0.5cm},
    queuenode/.style={rectangle, draw, minimum width=0.8cm, minimum height=0.8cm}
]
    % Stack Visualization
    \node (slabel) at (0, 3) {\textbf{Stack (LIFO)}};
    \draw (0,0) -- (0,2) -- (1.5,2) -- (1.5,0) -- cycle;
    \node[stacknode] at (0.75, 0.25) {A};
    \node[stacknode] at (0.75, 0.75) {B};
    \node[stacknode] at (0.75, 1.25) {C};
    \draw[->] (0.75, 2.5) -- node[right] {Push/Pop} (0.75, 2.0);

    % Queue Visualization
    \node (qlabel) at (5, 3) {\textbf{Queue (FIFO)}};
    \node[queuenode] (q1) at (4, 1) {A};
    \node[queuenode] (q2) at (4.8, 1) {B};
    \node[queuenode] (q3) at (5.6, 1) {C};
    \draw (3.6, 1.4) -- (6.0, 1.4);
    \draw (3.6, 0.6) -- (6.0, 0.6);
    \draw[<-] (3.6, 1) -- node[above] {Enqueue} (2.8, 1);
    \draw[->] (6.0, 1) -- node[above] {Dequeue} (6.8, 1);
\end{tikzpicture}
\captionof{figure}{સ્ટેક અને ક્યૂ સ્ટ્રક્ચર}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SLIF QFIF - સ્ટેક LIFO, ક્યૂ FIFO}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{રિકર્સન વ્યાખ્યાયિત કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{વ્યાખ્યા}: ફંક્શન પોતાને જ નાની સમસ્યા સાથે કૉલ કરવું જ્યાં સુધી બેઝ કંડિશન ન મળે.

\begin{lstlisting}[language=Python]
def factorial(n):
    # બેઝ કેસ
    if n <= 1:
        return 1
    # રિકર્સિવ કેસ
    return n * factorial(n-1)

# ઉદાહરણ: factorial(3)
# 3 * factorial(2)
# 3 * 2 * factorial(1)
# 3 * 2 * 1 = 6
\end{lstlisting}

\begin{itemize}
    \item \textbf{બેઝ કેસ}: રોકવાની શરત
    \item \textbf{રિકર્સિવ કેસ}: ફંક્શન પોતાને કૉલ કરે છે
    \item \textbf{સમસ્યા ઘટાડવી}: દરેક કૉલ નાની સમસ્યા હલ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BRP - બેઝ, રિકર્સિવ, પ્રોબ્લેમ-રિડક્શન}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{સ્ટેકના સાઈઝ 5 તરીકે ધ્યાનમાં લો. સ્ટેક પર નીચેની કામગીરી લાગૂ કરો... Push a,b,c pop}

\begin{solutionbox}
\textbf{સ્ટેક ઓપરેશનો ટ્રેસ:}

\begin{center}
\begin{tikzpicture}[
    stackbox/.style={rectangle, draw, minimum width=3cm, minimum height=0.6cm, align=center},
    pointer/.style={->, thick, red}
]
    % Initial
    \node[stackbox] (s0) at (0,0) {[ \_ \_ \_ \_ \_ ]};
    \node[above] at (s0.north) {શરૂઆત (Top=-1)};

    % Push a
    \node[stackbox, right=1cm of s0] (s1) {[ a \_ \_ \_ \_ ]};
    \node[above] at (s1.north) {Push 'a' (Top=0)};

    % Push b
    \node[stackbox, right=1cm of s1] (s2) {[ a b \_ \_ \_ ]};
    \node[above] at (s2.north) {Push 'b' (Top=1)};
    
    % Push c
    \node[stackbox, below=1.5cm of s0] (s3) {[ a b c \_ \_ ]};
    \node[above] at (s3.north) {Push 'c' (Top=2)};
    
    % Pop
    \node[stackbox, right=1cm of s3] (s4) {[ a b \_ \_ \_ ]};
    \node[above] at (s4.north) {Pop (Top=1)};
    \node[right=0.2cm of s4] {કાઢ્યું: c};

    % Arrows
    \draw[->] (s0) -- (s1);
    \draw[->] (s1) -- (s2);
    \draw[->] (s2.east) -- ++(0.5,0) |- (s3.east);
    \draw[->] (s3) -- (s4);

\end{tikzpicture}
\captionof{figure}{સ્ટેક ઓપરેશનો}
\end{center}

\begin{itemize}
    \item \textbf{Push ઓપરેશનો}: ઇન્ડેક્સ 0 થી શરૂ કરીને તત્વો ઉમેરે છે
    \item \textbf{ટોપ પોઇન્ટર}: છેલ્લે દાખલ કરેલા તત્વ તરફ પોઇન્ટ કરે છે
    \item \textbf{Pop ઓપરેશન}: ટોપ તત્વ દૂર કરે છે, ટોપ પોઇન્ટર ઘટાડે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PTD - Push ટોપ ઘટાડવું}
\end{mnemonicbox}

\questionmarks{2(a) OR}{3}{સ્ટેક અને ક્યૂની એપ્લિકેશનોની સૂચિ બનાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{સ્ટેક અને ક્યૂની એપ્લિકેશનો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ડેટા સ્ટ્રક્ચર} & \textbf{એપ્લિકેશનો} \\ \hline
\textbf{સ્ટેક} & ફંક્શન કૉલ્સ, અન્ડુ ઓપરેશનો, એક્સપ્રેશન ઇવેલ્યુએશન, બ્રાઉઝર હિસ્ટરી \\ \hline
\textbf{ક્યૂ} & પ્રોસેસ શેડ્યુલિંગ, પ્રિન્ટર ક્યૂ, BFS ટ્રેવર્સલ, રિક્વેસ્ટ હેન્ડલિંગ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{સ્ટેક FUBE, ક્યૂ SPBH}
\end{mnemonicbox}

\questionmarks{2(b) OR}{4}{સ્ટેકનો ઉપયોગ કરીને નીચેના સમીકરણને પોસ્ટફિક્સ નોટેશનમાં કન્વર્ટ કરો: i) $(a*b)*(c\textasciicircum d(d+e)-f)$ ii) $a-b/(c*d/e)$}

\begin{solutionbox}
\textbf{i) $(a*b)*(c\textasciicircum d(d+e)-f)$}

\textbf{પરિણામ: $ab*cdde+\textasciicircum f-*$}

\textbf{ii) $a-b/(c*d/e)$}

\textbf{પરિણામ: $abcd*e/-$}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PEMDAS પોસ્ટફિક્સ માટે ઉલટું}
\end{mnemonicbox}

\questionmarks{2(c) OR}{7}{લીસ્ટનો ઉપયોગ કરીને ક્યૂને અમલમાં મૂકવા માટે એક પ્રોગ્રામ ડેવલોપ કરો જે નીચેની કામગીરી કરે છે: enqueue, dequeue.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
class Queue:
    def __init__(self):
        self.queue = []
        self.front = 0
        self.rear = -1
    
    def enqueue(self, item):
        self.queue.append(item)
        self.rear += 1
        print(f"એનક્યૂ કર્યું: {item}")
    
    def dequeue(self):
        if self.front <= self.rear:
            item = self.queue[self.front]
            self.front += 1
            print(f"ડીક્યૂ કર્યું: {item}")
            return item
        else:
            print("ક્યૂ ખાલી છે")
            return None
    
    def display(self):
        if self.front <= self.rear:
            print("ક્યૂ:", self.queue[self.front:self.rear+1])
        else:
            print("ક્યૂ ખાલી છે")

# ઉદાહરણ ઉપયોગ
q = Queue()
q.enqueue('A')
q.enqueue('B')
q.dequeue()
q.display()
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[
    cell/.style={rectangle, draw, minimum size=1cm},
    ptr/.style={->, thick, blue}
]
    % Initial
    \foreach \x/\val in {0/A, 1/B, 2/C} {
        \node[cell] at (\x, 0) {\val};
    }
    \node[anchor=south] at (0, 0.6) {Front};
    \draw[ptr] (0, 0.6) -- (0, 0.5);
    \node[anchor=south] at (2, 0.6) {Rear};
    \draw[ptr] (2, 0.6) -- (2, 0.5);
\end{tikzpicture}
\captionof{figure}{ક્યૂ ઇમ્પ્લિમેન્ટેશન}
\end{center}

\begin{itemize}
    \item \textbf{Enqueue}: રિયર પર તત્વ ઉમેરે છે
    \item \textbf{Dequeue}: ફ્રન્ટ પરથી તત્વ દૂર કરે છે
    \item \textbf{FIFO સિદ્ધાંત}: પહેલું અંદર, પહેલું બહાર
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ERF - Enqueue રિયર, ફ્રન્ટ}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{લિંક લિસ્ટના પ્રકારોની સૂચિ બનાવો. દરેક પ્રકારનું ગ્રાફિકલ રજૂઆત આપો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{લિંક લિસ્ટના પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વર્ણન} & \textbf{ડાયાગ્રામ} \\ \hline
**સિંગલી** & એક દિશા પોઇન્ટર & $A \rightarrow B \rightarrow C \rightarrow NULL$ \\ \hline
**ડબલી** & બે દિશા પોઇન્ટરો & $NULL \leftarrow A \rightleftarrows B \rightleftarrows C \rightarrow NULL$ \\ \hline
**સર્ક્યુલર** & છેલ્લું પહેલા તરફ પોઇન્ટ કરે & $A \rightarrow B \rightarrow C \rightarrow A$ \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[list/.style={rectangle, draw, minimum size=6mm}, >=stealth]
    % Singly
    \node (slabel) at (-2,0) {\textbf{સિંગલી}};
    \node[list] (s1) at (0,0) {A};
    \node[list] (s2) at (1.5,0) {B};
    \node (s3) at (3,0) {NULL};
    \draw[->] (s1) -- (s2);
    \draw[->] (s2) -- (s3);

    % Doubly
    \node (dlabel) at (-2,-1.5) {\textbf{ડબલી}};
    \node (dnull1) at (-0.8,-1.5) {NULL};
    \node[list] (d1) at (0.5,-1.5) {A};
    \node[list] (d2) at (2,-1.5) {B};
    \node (dnull2) at (3.3,-1.5) {NULL};
    \draw[<-] (dnull1) -- (d1);
    \draw[transform canvas={yshift=2pt}, ->] (d1) -- (d2);
    \draw[transform canvas={yshift=-2pt}, <-] (d1) -- (d2);
    \draw[->] (d2) -- (dnull2);

    % Circular
    \node (clabel) at (-2,-3) {\textbf{સર્ક્યુલર}};
    \node[list] (c1) at (0,-3) {A};
    \node[list] (c2) at (1.5,-3) {B};
    \node[list] (c3) at (3,-3) {C};
    \draw[->] (c1) -- (c2);
    \draw[->] (c2) -- (c3);
    \draw[->] (c3.south) -- ++(0,-0.5) -| (c1.south);
\end{tikzpicture}
\captionof{figure}{લિંક લિસ્ટ પ્રકારો}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SDC - સિંગલી, ડબલી, સર્ક્યુલર}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{સિંગલી લિંક લિસ્ટમાં આપેલ નોડ શોધવા માટે એક અલ્ગોરિધમ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
def search_node(head, key):
    current = head
    position = 0
    
    while current is not None:
        if current.data == key:
            return position
        current = current.next
        position += 1
    
    return -1  # નહીં મળ્યું
\end{lstlisting}

\begin{itemize}
    \item \textbf{લીનિયર સર્ચ}: હેડ થી ટેઇલ સુધી ટ્રાવર્સ કરો
    \item \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: O(n)
    \item \textbf{રિટર્ન}: મળ્યું તો પોઝિશન, નહીં તો -1
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SCMR - શરૂ, સરખાવો, આગળ વધો, રિટર્ન}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{સિંગલી લિંક લિસ્ટ પર પર નીચેની કામગીરી કરવા માટે પ્રોગ્રામનો અમલ કરો: 1)સિંગલી લિંક લિસ્ટ ની શરૂઆતમાં નોડ દાખલ કરો 2)સિંગલી લિંક લિસ્ટની શરૂઆતથી નોડ કાઢી નાખો}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None
    
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        print(f"શરૂઆતમાં {data} દાખલ કર્યું")
    
    def delete_from_beginning(self):
        if self.head is None:
            print("લિસ્ટ ખાલી છે")
            return None
        
        deleted_data = self.head.data
        self.head = self.head.next
        print(f"શરૂઆતથી {deleted_data} કાઢ્યું")
        return deleted_data
    
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("NULL")
\end{lstlisting}

\begin{itemize}
    \item \textbf{ઇન્સર્ટ}: નોડ બનાવો, હેડ સાથે જોડો, હેડ અપડેટ કરો
    \item \textbf{ડિલીટ}: ડેટા સ્ટોર કરો, હેડને આગળ ખસેડો, ડેટા રિટર્ન કરો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CLU - બનાવો, જોડો, અપડેટ}
\end{mnemonicbox}

\questionmarks{3(a) OR}{3}{સર્ક્યુલર લિંક લિસ્ટ અને સિંગલી લિંક લિસ્ટ વચ્ચે તફાવત કરો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{સર્ક્યુલર વર્સસ સિંગલી લિંક લિસ્ટ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{સિંગલી લિંક લિસ્ટ} & \textbf{સર્ક્યુલર લિંક લિસ્ટ} \\ \hline
**છેલ્લો નોડ પોઇન્ટ કરે છે** & NULL & પહેલા નોડ (હેડ) \\ \hline
**ટ્રાવર્સલ** & લીનિયર (એક દિશા) & સર્ક્યુલર (સતત) \\ \hline
**અંત ડિટેક્શન** & next == NULL & next == head \\ \hline
**મેમરી** & ઓછી (વધારાનું પોઇન્ટર નહીં) & સમાન સ્ટ્રક્ચર \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CNTE - સર્ક્યુલર કોઈ સમાપ્તિ અંત નહીં}
\end{mnemonicbox}

\questionmarks{3(b) OR}{4}{સંક્ષિપ્તમાં લિંક લિસ્ટ સૂચિની ત્રણ એપ્લિકેશનો સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{લિંક લિસ્ટ એપ્લિકેશનો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{વર્ણન} & \textbf{ફાયદો} \\ \hline
**ડાયનામિક મેમરી એલોકેશન** & મેમરી બ્લોક્સ મેનેજ કરે છે & કાર્યક્ષમ મેમરી ઉપયોગ \\ \hline
**સ્ટેક/ક્યૂનું અમલીકરણ** & લિંક સ્ટ્રક્ચર ઉપયોગ કરે છે & ડાયનામિક સાઇઝ \\ \hline
**પોલિનોમિયલ રજૂઆત** & ગુણાંક અને પાવર સ્ટોર કરે છે & સરળ અંકગણિત ઓપરેશનો \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \textbf{મ્યુઝિક પ્લેલિસ્ટ}: ગીતો ડાયનામિક ઉમેરવા/દૂર કરવા
    \item \textbf{બ્રાઉઝર હિસ્ટરી}: પાછળ/આગળ નેવિગેટ કરવા
    \item \textbf{ઇમેજ વ્યૂઅર}: પહેલું/આગલું ઇમેજ નેવિગેશન
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DIP - ડાયનામિક, અમલીકરણ, પોલિનોમિયલ}
\end{mnemonicbox}

\questionmarks{3(c) OR}{7}{સર્ક્યુલર લિંક લિસ્ટ ને બનાવવા અને પ્રદર્શિત કરવા માટે એક પ્રોગ્રામ ડેવલોપ કરો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None
    
    def insert(self, data):
        new_node = Node(data)
        
        if self.head is None:
            self.head = new_node
            new_node.next = self.head
        else:
            current = self.head
            while current.next != self.head:
                current = current.next
            current.next = new_node
            new_node.next = self.head
    
    def display(self):
        if self.head is None:
            print("લિસ્ટ ખાલી છે")
            return
        
        current = self.head
        print("સર્ક્યુલર લિસ્ટ:")
        while True:
            print(current.data, end=" -> ")
            current = current.next
            if current == self.head:
                break
        print(f"{self.head.data} (હેડ પર પાછા)")

# ઉદાહરણ ઉપયોગ
cll = CircularLinkedList()
cll.insert(10)
cll.insert(20)
cll.insert(30)
cll.display()
\end{lstlisting}

\begin{itemize}
    \item \textbf{બનાવટ}: છેલ્લા નોડને હેડ સાથે જોડવું
    \item \textbf{ડિસ્પ્લે}: ફરીથી હેડ પર પહોંચવા સુધી બંધ કરવું
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CLH - બનાવો, જોડો, હેડ}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{સિલેક્શન સૉર્ટ પદ્ધતિનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# ઉદાહરણ ઉપયોગ
data = [64, 34, 25, 12, 22]
sorted_data = selection_sort(data)
print("સૉર્ટેડ એરે:", sorted_data)
\end{lstlisting}

\begin{itemize}
    \item \textbf{મિનિમમ શોધો}: અનસૉર્ટેડ ભાગમાં
    \item \textbf{સ્વેપ}: પ્રથમ અનસૉર્ટેડ એલિમેન્ટ સાથે
    \item \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: $O(n^2)$
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FMS - શોધો, મિનિમમ, સ્વેપ}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{નીચેના ડેટાને ચડતા ક્રમમાં ગોઠવવા માટે ઇન્સર્શન સૉર્ટ લાગૂ કરો. 25 15 35 20 30 5 10}

\begin{solutionbox}
\textbf{ઇન્સર્શન સૉર્ટ સ્ટેપ્સ:}

\begin{center}
\begin{tikzpicture}[
    arrnode/.style={rectangle, draw, minimum size=0.8cm},
    highlight/.style={fill=yellow!30}
]
    % Initial
    \node (l0) at (-3, 0) {શરૂઆત:};
    \foreach \x/\val in {0/25, 1/15, 2/35, 3/20, 4/30, 5/5, 6/10} {
        \node[arrnode] at (\x, 0) {\val};
    }
    
    % Pass 1
    \node (l1) at (-3, -1) {પાસ 1 (15):};
    \foreach \x/\val/\hl in {0/15/highlight, 1/25/white, 2/35/white, 3/20/white, 4/30/white, 5/5/white, 6/10/white} {
        \node[arrnode, \hl] at (\x, -1) {\val};
    }

    % Final
    \node (l6) at (-3, -2.5) {અંતિમ:};
    \foreach \x/\val in {0/5, 1/10, 2/15, 3/20, 4/25, 5/30, 6/35} {
        \node[arrnode, fill=green!20] at (\x, -2.5) {\val};
    }
    
    \node at (2, -1.8) { ... (વચગાળાના સ્ટેપ્સ બાકાત) ... };
\end{tikzpicture}
\captionof{figure}{ઇન્સર્શન સૉર્ટ}
\end{center}

\begin{itemize}
    \item \textbf{પદ્ધતિ}: એલિમેન્ટ લો, સૉર્ટેડ ભાગમાં સ્થાન શોધો
    \item \textbf{સરખામણીઓ}: કુલ 15 સરખામણીઓ
    \item \textbf{શિફ્ટ્સ}: જગ્યા બનાવવા માટે એલિમેન્ટ્સ ખસેડવા
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TFI - લેવું, શોધવું, ઇન્સર્ટ કરવું}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{લીનિયર સર્ચનો ઉપયોગ કરીને લિસ્ટમાંથી ચોક્કસ તત્વ શોધવા માટે પાયથોન પ્રોગ્રામનો અમલ કરો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
def linear_search(arr, target):
    comparisons = 0
    
    for i in range(len(arr)):
        comparisons += 1
        if arr[i] == target:
            print(f"એલિમેન્ટ {target} ઇન્ડેક્સ {i} પર મળ્યું")
            return i
    
    print(f"એલિમેન્ટ {target} નહીં મળ્યું")
    return -1

# ઉદાહરણ ઉપયોગ
data = [10, 25, 30, 15, 20, 30, 35]
target = 30
result = linear_search(data, target)
\end{lstlisting}

\begin{itemize}
    \item \textbf{સિક્વન્શિયલ સર્ચ}: દરેક એલિમેન્ટ એક પછી એક તપાસવું
    \item \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: O(n) સૌથી ખરાબ કેસ
    \item \textbf{બેસ્ટ કેસ}: O(1) જો પ્રથમ પોઝિશન પર મળે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEO - દરેક એક તપાસો}
\end{mnemonicbox}

\questionmarks{4(a) OR}{3}{ઇન્સર્શન સૉર્ટ પદ્ધતિનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr

# ઉદાહરણ ઉપયોગ
data = [12, 11, 13, 5, 6]
sorted_data = insertion_sort(data.copy())
\end{lstlisting}

\begin{itemize}
    \item \textbf{કી એલિમેન્ટ}: વર્તમાન એલિમેન્ટ જે ઇન્સર્ટ કરવાનું છે
    \item \textbf{જમણી બાજુ શિફ્ટ}: મોટા એલિમેન્ટ્સ જમણી બાજુ ખસે છે
    \item \textbf{ઇન્સર્ટ}: યોગ્ય સ્થાને કી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{KSI - કી, શિફ્ટ, ઇન્સર્ટ}
\end{mnemonicbox}

\questionmarks{4(b) OR}{4}{નીચેના ડેટાને ક્વિક સૉર્ટ લાગૂ કરો અને તેમને યોગ્ય રીતે ગોઠવો. 5 6 1 8 2 9 10 15 7 13}

\begin{solutionbox}
\textbf{ક્વિક સૉર્ટ સ્ટેપ્સ:}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2.5cm, 
    level 1/.style={sibling distance=4cm},
    level 2/.style={sibling distance=2cm}]
    \node {Pivot: 5}
        child {node {Left: [1, 2]}
            child {node {Pivot: 1}}
        }
        child {node {Right: [6...13]}
            child {node {Pivot: 6}}
        };
\end{tikzpicture}
\captionof{figure}{ક્વિક સોર્ટ પાર્ટિશન}
\end{center}

\begin{itemize}
    \item \textbf{વિભાજન}: પિવોટ પસંદ કરો, તેની આસપાસ પાર્ટિશન કરો
    \item \textbf{જીતો}: સબએરેને રીકર્સિવલી સૉર્ટ કરો
    \item \textbf{સરેરાશ સમય}: $O(n \log n)$
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DCC - વિભાજન, જીતો, જોડો}
\end{mnemonicbox}

\questionmarks{4(c) OR}{7}{મર્જ સૉર્ટ અલ્ગોરિધમનો અમલ કરો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# ઉદાહરણ ઉપયોગ
data = [38, 27, 43, 3, 9, 82, 10]
sorted_data = merge_sort(data)
\end{lstlisting}

\begin{itemize}
    \item \textbf{વિભાજન}: એરેને અડધામાં વિભાજિત કરો
    \item \textbf{મર્જ}: સૉર્ટેડ સબએરેને જોડો
    \item \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: હંમેશા $O(n \log n)$
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DSM - વિભાજન, સૉર્ટ, મર્જ}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{ટૂંકી નોંધ લખો: એપ્લિકેશન ઓફ ટ્રી.}

\begin{solutionbox}
\begin{center}
\captionof{table}{ટ્રી એપ્લિકેશનો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
**ફાઇલ સિસ્ટમ** & ડિરેક્ટરી સ્ટ્રક્ચર & ફોલ્ડર અને ફાઇલો \\ \hline
**એક્સપ્રેશન પાર્સિંગ** & ગાણિતિક સમીકરણો & $(a+b)*c$ \\ \hline
**ડેટાબેઝ ઇન્ડેક્સિંગ** & ઝડપી ડેટા પુનઃપ્રાપ્તિ & ડેટાબેઝમાં B-ટ્રીઝ \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm]
    \node {Root Folder}
        child {node {Docs}
            child {node {Resume}}
            child {node {Budget}}
        }
        child {node {Photos}
            child {node {Summer}}
        };
\end{tikzpicture}
\captionof{figure}{ફાઇલ સિસ્ટમ ટ્રી સ્ટ્રક્ચર}
\end{center}

\begin{itemize}
    \item \textbf{ડિસિઝન ટ્રીઝ}: AI અને મશીન લર્નિંગ
    \item \textbf{હફમેન કોડિંગ}: ડેટા કોમ્પ્રેશન
    \item \textbf{ગેમ ટ્રીઝ}: ચેસ, ટિક-ટેક-ટો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FED - ફાઇલ, એક્સપ્રેશન, ડેટાબેઝ}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{વિવિધ ટ્રી ટ્રાવર્સલ પદ્ધતિઓ સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{ટ્રી ટ્રાવર્સલ પદ્ધતિઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પદ્ધતિ} & \textbf{ક્રમ} & \textbf{પ્રક્રિયા} \\ \hline
**ઇનઓર્ડર** & ડાબે-રૂટ-જમણે & LNR \\ \hline
**પ્રીઓર્ડર** & રૂટ-ડાબે-જમણે & NLR \\ \hline
**પોસ્ટઓર્ડર** & ડાબે-જમણે-રૂટ & LRN \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm, nodes={circle, draw, minimum size=0.8cm}]
    \node {A}
        child {node {B}
            child {node {D}}
            child {node {E}}
        }
        child {node {C}};
\end{tikzpicture}
\captionof{figure}{ઉદાહરણ ટ્રી}
\end{center}

\begin{itemize}
    \item \textbf{ઇનઓર્ડર}: D B E A C (ડાબે, રૂટ, જમણે)
    \item \textbf{પ્રીઓર્ડર}: A B D E C (રૂટ, ડાબે, જમણે)
    \item \textbf{પોસ્ટઓર્ડર}: D E B C A (ડાબે, જમણે, રૂટ)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LNR PNL LRN ઇન-પ્રી-પોસ્ટ માટે}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{બાઇનરી સર્ચ ટ્રી પર નીચેની કામગીરી કરવા માટે મેન્યૂ સંચાલિત પ્રોગ્રામ લખો: BST ટ્રી બનાવવા માટેનો પ્રોગ્રામ.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        self.root = self._insert_recursive(self.root, data)
    
    def _insert_recursive(self, node, data):
        if node is None:
            return TreeNode(data)
        
        if data < node.data:
            node.left = self._insert_recursive(node.left, data)
        elif data > node.data:
            node.right = self._insert_recursive(node.right, data)
        
        return node
    
    def inorder(self, node):
        if node:
            self.inorder(node.left)
            print(node.data, end=" ")
            self.inorder(node.right)

def main():
    bst = BST()
    while True:
        print("\n1. દાખલ કરો")
        print("2. દર્શાવો (ઇનઓર્ડર)")
        print("3. બહાર નીકળો")
        choice = int(input("પસંદગી દાખલ કરો: "))
        if choice == 1:
            data = int(input("ડેટા દાખલ કરો: "))
            bst.insert(data)
        elif choice == 2:
            print("BST (ઇનઓર્ડર):", end=" ")
            bst.inorder(bst.root)
            print()
        elif choice == 3:
            break

if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{itemize}
    \item \textbf{BST ગુણધર્મ}: ડાબે < રૂટ < જમણે
    \item \textbf{ઇન્સર્શન}: સરખાવો અને ડાબે/જમણે જાઓ
    \item \textbf{મેન્યૂ ડ્રિવન}: વપરાશકર્તા-મૈત્રીપૂર્ણ ઇન્ટરફેસ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CIM - સરખાવો, ઇન્સર્ટ, મેન્યૂ}
\end{mnemonicbox}

\questionmarks{5(a) OR}{3}{વ્યાખ્યાયિત કરો અને ઉદાહરણો આપો: સ્ટ્રિક્ટ બાઇનરી ટ્રી અને કમ્પ્લીટ બાઇનરી ટ્રી.}

\begin{solutionbox}
\begin{center}
\captionof{table}{બાઇનરી ટ્રી પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વ્યાખ્યા} & \textbf{ઉદાહરણ} \\ \hline
\textbf{સ્ટ્રિક્ટ બાઇનરી ટ્રી} & દરેક નોડને 0 અથવા 2 બાળકો છે & દરેક આંતરિક નોડને બરાબર 2 બાળકો \\ \hline
\textbf{કમ્પ્લીટ બાઇનરી ટ્રી} & છેલ્લા સિવાય બધા લેવલ ભરેલા, ડાબેથી જમણે ભરેલા & બીજા છેલ્લા લેવલ સુધી પરફેક્ટ સ્ટ્રક્ચર \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1cm, sibling distance=1.5cm, nodes={circle, draw, minimum size=0.6cm}]
    % Strict
    \node at (-3, 1) [draw=none] {Strict};
    \node at (-3, 0) {A}
        child {node {B}}
        child {node {C}
            child {node {D}}
            child {node {E}}
        };

    % Complete
    \node at (3, 1) [draw=none] {Complete};
    \node at (3, 0) {A}
        child {node {B}
            child {node {D}}
            child {node {E}}
        }
        child {node {C}
            child {node {F}}
            child[missing]
        };
\end{tikzpicture}
\captionof{figure}{બાઇનરી ટ્રી પ્રકારો}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SC - સ્ટ્રિક્ટ કમ્પ્લીટ}
\end{mnemonicbox}

\questionmarks{5(b) OR}{4}{બાઇનરી ટ્રીની મૂળભૂત પરિભાષા સમજાવો: લેવલ નંબર, ડિગ્રી, ઇન-ડિગ્રી, આઉટ-ડિગ્રી, લીફ નોડ.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm, nodes={circle, draw, minimum size=0.8cm}]
    \node (A) {A}
        child {node (B) {B}
            child {node (D) {D}}
            child {node (E) {E}}
        }
        child {node (C) {C}
            child [missing]
            child {node (F) {F}}
        };
    
    \node[right=0.5cm of A] {Level 0, Root};
    \node[right=2.5cm of B] {Level 1};
    \node[right=2.5cm of D] {Level 2, Leaves};
\end{tikzpicture}
\captionof{figure}{બાઇનરી ટ્રી પરિભાષા}
\end{center}

\begin{center}
\captionof{table}{બાઇનરી ટ્રી પરિભાષા}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{શબ્દ} & \textbf{વ્યાખ્યા} & \textbf{ઉદાહરણ} \\ \hline
\textbf{લેવલ નંબર} & રૂટથી અંતર (રૂટ = 0) & A=0, B=1, D=2 \\ \hline
\textbf{ડિગ્રી} & બાળકોની સંખ્યા & A=2, B=2, C=1 \\ \hline
\textbf{ઇન-ડિગ્રી} & આવતા એજની સંખ્યા & બધા નોડ = 1 (સિવાય રૂટ = 0) \\ \hline
\textbf{આઉટ-ડિગ્રી} & જતા એજની સંખ્યા & ડિગ્રી સમાન \\ \hline
\textbf{લીફ નોડ} & બાળકો ન હોય તેવો નોડ & D, E, F \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LDIOL - લેવલ, ડિગ્રી, ઇન-આઉટ, લીફ}
\end{mnemonicbox}

\questionmarks{5(c) OR}{7}{બાઇનરી સર્ચ ટ્રી પર નીચેની કામગીરી કરવા માટે મેન્યૂ સંચાલિત પ્રોગ્રામ લખો: BST માં એક એલિમેન્ટ દાખલ કરો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python]
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
            print(f"રૂટ નોડ {data} બનાવ્યું")
        else:
            self._insert_helper(self.root, data)
    
    def _insert_helper(self, node, data):
        if data < node.data:
            if node.left is None:
                node.left = TreeNode(data)
                print(f"{data} ને {node.data} ની ડાબી બાજુએ દાખલ કર્યું")
            else:
                self._insert_helper(node.left, data)
        elif data > node.data:
            if node.right is None:
                node.right = TreeNode(data)
                print(f"{data} ને {node.data} ની જમણી બાજુએ દાખલ કર્યું")
            else:
                self._insert_helper(node.right, data)
        else:
            print(f"ડેટા {data} પહેલેથી અસ્તિત્વમાં છે")

    def display_inorder(self, node, result):
        if node:
            self.display_inorder(node.left, result)
            result.append(node.data)
            self.display_inorder(node.right, result)

# ... (Main function same as above)
\end{lstlisting}

\begin{itemize}
    \item \textbf{ઇન્સર્ટ લોજિક}: વર્તમાન નોડ સાથે સરખાવો, ડાબે/જમણે જાઓ
    \item \textbf{રિકર્સિવ એપ્રોચ}: સ્વચ્છ અને કાર્યક્ષમ અમલીકરણ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CRL - સરખાવો, રિકર્સિવ, ડાબે/જમણે}
\end{mnemonicbox}

\end{document}
