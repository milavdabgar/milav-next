\documentclass{article}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}
\usetikzlibrary{shapes.multipart, chains, arrows.meta, positioning, calc}

\title{ડેટા સ્ટ્રક્ચર એન્ડ એપ્લિકેશન (1333203) - સમર 2024 સોલ્યુશન}
\date{June 12, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{રેખીય ડેટા સ્ટ્રક્ચર વ્યાખ્યાયિત કરો અને તેના ઉદાહરણો આપો.}

\begin{solutionbox}
રેખીય ડેટા સ્ટ્રક્ચર એ એલિમેન્ટ્સનો એવો સંગ્રહ છે કે જેમાં દરેક એલિમેન્ટની પહેલાં અને પછી એક જ એલિમેન્ટ હોય છે (સિવાય કે પ્રથમ અને છેલ્લા એલિમેન્ટ).

\begin{center}
\captionof{table}{રેખીય ડેટા સ્ટ્રક્ચરના ઉદાહરણો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ડેટા સ્ટ્રક્ચર} & \textbf{વર્ણન} \\ \hline
\textbf{Array} & નિશ્ચિત સાઇઝનો એલિમેન્ટ્સનો સંગ્રહ જે ઇન્ડેક્સ દ્વારા ઍક્સેસ થાય છે \\ \hline
\textbf{Linked List} & નોડ્સની શ્રેણી જેમાં ડેટા અને આગળના નોડનો રેફરન્સ હોય છે \\ \hline
\textbf{Stack} & LIFO (લાસ્ટ ઇન ફર્સ્ટ આઉટ) સ્ટ્રક્ચર \\ \hline
\textbf{Queue} & FIFO (ફર્સ્ટ ઇન ફર્સ્ટ આઉટ) સ્ટ્રક્ચર \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ALSQ are in a Line}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{ટાઇમ અને સ્સ્પેસ કોમ્પ્લેક્ષીટી વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
ટાઇમ અને સ્પેસ કોમ્પ્લેક્સિટી એલ્ગોરિધમની કાર્યક્ષમતાને એક્ઝિક્યુશન ટાઇમ અને મેમરી વપરાશના સંદર્ભમાં માપે છે, જેમ ઇનપુટ સાઇઝ વધે છે.

\begin{center}
\captionof{table}{કોમ્પ્લેક્સિટી કમ્પેરિઝન}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{કોમ્પ્લેક્સિટી પ્રકાર} & \textbf{વ્યાખ્યા} & \textbf{માપન} & \textbf{મહત્વ} \\ \hline
\textbf{ટાઇમ કોમ્પ્લેક્સિટી} & એલ્ગોરિધમના એક્ઝિક્યુશન ટાઇમને ઇનપુટ સાઇઝના ફંક્શન તરીકે માપે છે & બિગ O નોટેશન (O(n), O(1), O(n^2)) & એલ્ગોરિધમ કેટલી ઝડપથી ચાલે છે તે નક્કી કરે છે \\ \hline
\textbf{સ્પેસ કોમ્પ્લેક્સિટી} & એલ્ગોરિધમને જરૂરી મેમરી સ્પેસને ઇનપુટ સાઇઝના ફંક્શન તરીકે માપે છે & બિગ O નોટેશન (O(n), O(1), O(n^2)) & એલ્ગોરિધમને કેટલી મેમરી જોઈએ છે તે નક્કી કરે છે \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TS: Time-Speed and Space-Storage}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{ક્લાસ અને ઓબ્જેક્ટ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
ક્લાસ અને ઓબ્જેક્ટ એ OOP ના મૂળભૂત કોન્સેપ્ટ છે જ્યાં ક્લાસ એ એટ્રિબ્યુટ્સ અને બિહેવિયર્સ ધરાવતા ઓબ્જેક્ટ બનાવવા માટેના બ્લુપ્રિન્ટ છે.

\begin{center}
\begin{tikzpicture}[class/.style={rectangle, draw, minimum width=3cm, align=left, font=\small}]
    \node [class] (student) {
        \textbf{Student} \\
        \rule{3cm}{0.5pt} \\
        +name: string \\
        +rollNo: int \\
        +marks: float \\
        \rule{3cm}{0.5pt} \\
        +displayInfo()
    };
    
    \node [class, rounded corners, right=2cm of student, align=center] (obj) {
        \textbf{StudentObject} \\
        (Instance) \\
        \rule{3cm}{0.5pt} \\
        name="Raj" \\
        rollNo=101
    };
    
    \draw [->, dashed] (obj) -- node[above] {Creates} (student);
\end{tikzpicture}
\captionof{figure}{ક્લાસ અને ઓબ્જેક્ટ રિલેશનશિપ}
\end{center}

\begin{lstlisting}[language=Python, caption={કોડ ઉદાહરણ}]
class Student:
    def __init__(self, name, rollNo, marks):
        self.name = name
        self.rollNo = rollNo
        self.marks = marks
    
    def displayInfo(self):
        print(f"Name: {self.name}, Roll No: {self.rollNo}, Marks: {self.marks}")

# ઓબ્જેક્ટ બનાવવા
student1 = Student("Raj", 101, 85.5)
student1.displayInfo()
\end{lstlisting}

\begin{itemize}
    \item \textbf{ક્લાસ}: એટ્રિબ્યુટ્સ (name, rollNo, marks) અને મેથડ્સ (displayInfo) વ્યાખ્યાયિત કરતા બ્લુપ્રિન્ટ
    \item \textbf{ઓબ્જેક્ટ}: ક્લાસથી બનાવેલ ઇન્સ્ટન્સ (student1) જેમાં ચોક્કસ વેલ્યુઝ હોય છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CAR}
\end{mnemonicbox}

\questionmarks{1(c) OR}{7}{ઇંસ્ટટંસ મેથડ, ક્લાસ મેથડ અને સ્ટેટિક મેથડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
Python ત્રણ પ્રકારની મેથડ્સને સપોર્ટ કરે છે: ઇન્સ્ટન્સ, ક્લાસ અને સ્ટેટિક મેથડ, દરેક અલગ હેતુ માટે વપરાય છે.

\begin{center}
\captionof{table}{મેથડ પ્રકારોની તુલના}
\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\textbf{મેથડ પ્રકાર} & \textbf{ડેકોરેટર} & \textbf{પ્રથમ પેરામીટર} & \textbf{હેતુ} & \textbf{એક્સેસ} \\ \hline
\textbf{ઇન્સ્ટન્સ મેથડ} & કોઈ નહીં & self & ઇન્સ્ટન્સ ડેટા પર કામ કરે & ઇન્સ્ટન્સ સ્ટેટને એક્સેસ/મોડિફાઇ કરી શકે \\ \hline
\textbf{ક્લાસ મેથડ} & @classmethod & cls & ક્લાસ ડેટા પર કામ કરે & ક્લાસ સ્ટેટને એક્સેસ/મોડિફાઇ કરી શકે \\ \hline
\textbf{સ્ટેટિક મેથડ} & @staticmethod & કોઈ નહીં & યુટિલિટી ફંક્શન્સ & ઇન્સ્ટન્સ કે ક્લાસ સ્ટેટને એક્સેસ કરી શકતી નથી \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python, caption={કોડ ઉદાહરણ}]
class Student:
    school = "ABC School"
    def __init__(self, name):
        self.name = name
    def instance_method(self):
        return f"Hi {self.name} from {self.school}"
    @classmethod
    def class_method(cls):
        return f"School is {cls.school}"
    @staticmethod
    def static_method():
        return "This is a utility function"
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ICS}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{રીકર્ઝીવ ફંકશન નો કોંસેપ્ટ સમજાવો.}

\begin{solutionbox}
રિકર્સિવ ફંક્શન એ એવું ફંક્શન છે જે પોતાની એક્ઝિક્યુશન દરમિયાન સમાન સમસ્યાના નાના ઉદાહરણોને હલ કરવા માટે પોતાને જ કૉલ કરે છે.

\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm]
    \node [gtu state] (A) {factorial(3)};
    \node [gtu state, below=of A] (B) {factorial(2)};
    \node [gtu state, below=of B] (C) {factorial(1)};
    \node [below=of C] (D) {Return 1};
    
    \draw [->] (A) -- (B);
    \draw [->] (B) -- (C);
    \draw [->] (C) -- (D);
    \draw [->, bend right=45] (D.east) to node[right] {Return 1} (C.east);
    \draw [->, bend right=45] (C.east) to node[right] {Return 2} (B.east);
    \draw [->, bend right=45] (B.east) to node[right] {Return 6} (A.east);
\end{tikzpicture}
\captionof{figure}{રિકર્સિવ ફંક્શન એક્ઝિક્યુશન}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BASE and RECURSE}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{સ્ટેક અને ક્યુ વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
સ્ટેક અને ક્યુ એ લીનિયર ડેટા સ્ટ્રક્ચર છે જેમાં ડેટા ઇન્સર્શન અને રિમૂવલ માટે અલગ એક્સેસ પેટર્ન છે.

\begin{center}
\captionof{table}{સ્ટેક વિ. ક્યુ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફીચર} & \textbf{સ્ટેક} & \textbf{ક્યુ} \\ \hline
\textbf{એક્સેસ પેટર્ન} & LIFO (લાસ્ટ ઇન ફર્સ્ટ આઉટ) & FIFO (ફર્સ્ટ ઇન ફર્સ્ટ આઉટ) \\ \hline
\textbf{ઓપરેશન્સ} & પુશ (ઇન્સર્ટ), પૉપ (રિમૂવ) & એનક્યુ (ઇન્સર્ટ), ડિક્યુ (રિમૂવ) \\ \hline
\textbf{એક્સેસ પોઇન્ટ્સ} & સિંગલ એન્ડ (ટોપ) & ટુ એન્ડ્સ (ફ્રન્ટ, રિયર) \\ \hline
\textbf{વિઝ્યુઅલાઇઝેશન} & ઊભા થાંભલામાં ગોઠવેલી થાળીઓ જેવું & લાઇનમાં ઊભેલા લોકો જેવું \\ \hline
\textbf{એપ્લિકેશન્સ} & ફંક્શન કૉલ્સ, અનડુ ઓપરેશન્સ & પ્રિન્ટ જોબ્સ, પ્રોસેસ શેડ્યુલિંગ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SLIFF vs QFIFF}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{સ્ટેક ના બેઝિક ઓપરેશન સમજાવો.}

\begin{solutionbox}
સ્ટેક ઓપરેશન્સ LIFO (લાસ્ટ ઇન ફર્સ્ટ આઉટ) સિદ્ધાંતને અનુસરે છે.

\begin{center}
\captionof{table}{સ્ટેક ઓપરેશન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{વર્ણન} & \textbf{ટાઇમ કોમ્પ્લેક્સિટી} \\ \hline
\textbf{પુશ} & ટોપ પર એલિમેન્ટ ઇન્સર્ટ કરવું & O(1) \\ \hline
\textbf{પૉપ} & ટોપથી એલિમેન્ટ રિમૂવ કરવું & O(1) \\ \hline
\textbf{પીક/ટોપ} & રિમૂવ કર્યા વિના ટોપ એલિમેન્ટ જોવું & O(1) \\ \hline
\textbf{isEmpty} & ચેક કરવું કે સ્ટેક ખાલી છે કે નહીં & O(1) \\ \hline
\textbf{isFull} & ચેક કરવું કે સ્ટેક ભરેલો છે કે નહીં & O(1) \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}
    % Stack drawing
    \draw [thick] (0,0) -- (0,3) -- (2,3) -- (2,0) -- cycle;
    \foreach \y/\val in {0.5/1, 1.5/3, 2.5/5}
        \draw (0.2, \y-0.4) rectangle (1.8, \y+0.4) node[midway] {\val};
    \node at (1, -0.5) {Stack};
    \node at (-0.5, 2.5) {Top};
    \draw [->] (-0.2, 2.5) -- (0.2, 2.5);
    \node (push) at (4, 3) {8};
    \draw [->] (push) -- node[above] {Push} (2.2, 3);
    \draw [->] (2.2, 2.5) -- node[above] {Pop} (4, 2);
\end{tikzpicture}
\captionof{figure}{સ્ટેક ઓપરેશન્સ}
\end{center}

\begin{lstlisting}[language=Python, caption={Stack Implementation}]
class Stack:
    def __init__(self):
        self.items = []
    def push(self, item):
        self.items.append(item)
    def pop(self):
        if not self.isEmpty():
            return self.items.pop()
    def isEmpty(self):
        return len(self.items) == 0
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PIPES}
\end{mnemonicbox}

\questionmarks{2(a) OR}{3}{સિંગલી લિંક્ડ લિસ્ટ વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
સિંગલી લિંક્ડ લિસ્ટ એ એક લીનિયર ડેટા સ્ટ્રક્ચર છે જેમાં નોડ્સનો કલેક્શન હોય છે જ્યાં દરેક નોડમાં ડેટા અને આગળના નોડનો રેફરન્સ હોય છે.

\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2, draw, rectangle split horizontal}, >=stealth, start chain]
  \node[list, on chain] (A) {Data:10 \nodepart{second} Next};
  \node[list, on chain] (B) {Data:20 \nodepart{second} Next};
  \node[list, on chain] (C) {Data:30 \nodepart{second} Next};
  \node[on chain, draw, inner sep=6pt] (D) {NULL};
  \draw[*->] let \p1 = (A.two), \p2 = (A.center) in (\x1,\y2) -- (B);
  \draw[*->] let \p1 = (B.two), \p2 = (B.center) in (\x1,\y2) -- (C);
  \draw[*->] let \p1 = (C.two), \p2 = (C.center) in (\x1,\y2) -- (D);
\end{tikzpicture}
\captionof{figure}{સિંગલી લિંક્ડ લિસ્ટ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DNL}
\end{mnemonicbox}

\questionmarks{2(b) OR}{4}{ક્યુ ઉપર એનક્યુ ડીક્યુ ઓપરેશન સમજાવો.}

\begin{solutionbox}
એનક્યુ અને ડિક્યુ ક્યુ ડેટા સ્ટ્રક્ચરમાં એલિમેન્ટ્સ ઉમેરવા અને કાઢવા માટેના મુખ્ય ઓપરેશન્સ છે.

\begin{center}
\captionof{table}{ક્યુ ઓપરેશન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{વર્ણન} & \textbf{ઇમ્પ્લિમેન્ટેશન} & \textbf{ટાઇમ કોમ્પ્લેક્સિટી} \\ \hline
\textbf{એનક્યુ} & રિયર એન્ડ પર એલિમેન્ટ ઉમેરવું & queue.append(element) & O(1) \\ \hline
\textbf{ડિક્યુ} & ફ્રન્ટ એન્ડથી એલિમેન્ટ કાઢવું & element = queue.pop(0) & O(1) linked list, O(n) array \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}
    % Queue
    \foreach \x/\val in {0/30, 1.5/20, 3/10}
        \draw (\x, 0) rectangle (\x+1.5, 1) node[midway] {\val};
    \node at (0, -0.5) {Rear};
    \node at (4.5, -0.5) {Front};
    \draw [<-] (-0.5, 0.5) -- node[above] {Enqueue} (-1.5, 0.5);
    \draw [->] (4.5, 0.5) -- node[above] {Dequeue} (5.5, 0.5);
\end{tikzpicture}
\captionof{figure}{ક્યુ ઓપરેશન્સ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ERfDFr}
\end{mnemonicbox}

\questionmarks{2(c) OR}{7}{A+B/C+D પદ ને પોસ્ટફિક્સ મા ફેરવો અને STACK નો ઉપયોગ કરીને A,B,C અને D ની કોઇ યકમત ધારીને એનુ મુલ્ય શોધો.}

\begin{solutionbox}
"A+B/C+D" એક્સપ્રેશનને પોસ્ટફિક્સમાં કન્વર્ટ કરીને સ્ટેકનો ઉપયોગ કરીને તેનું મૂલ્યાંકન કરવું:

\textbf{સ્ટેપ 1: પોસ્ટફિક્સમાં કન્વર્ટ કરવું}

\begin{center}
\captionof{table}{ઇનફિક્સથી પોસ્ટફિક્સ કન્વર્ઝન}
\begin{tabulary}{\linewidth}{|C|L|L|L|}
\hline
\textbf{સિમ્બોલ} & \textbf{સ્ટેક} & \textbf{આઉટપુટ} & \textbf{એક્શન} \\ \hline
A & & A & આઉટપુટમાં ઉમેરો \\ \hline
+ & + & A & સ્ટેકમાં પુશ કરો \\ \hline
B & + & A B & આઉટપુટમાં ઉમેરો \\ \hline
/ & + / & A B & સ્ટેકમાં પુશ કરો (ઉચ્ચ પ્રિસિડન્સ) \\ \hline
C & + / & A B C & આઉટપુટમાં ઉમેરો \\ \hline
+ & + & A B C / & પૉપ કરો, પુશ કરો \\ \hline
D & + & A B C / + D & આઉટપુટમાં ઉમેરો \\ \hline
End & & A B C / + D + & બાકીના પૉપ કરો \\ \hline
\end{tabulary}
\end{center}
\textbf{ફાઇનલ પોસ્ટફિક્સ:} $A B C / + D +$

\textbf{સ્ટેપ 2: વેલ્યુઝ A=5, B=10, C=2, D=3 સાથે મૂલ્યાંકન કરવું}

\begin{center}
\captionof{table}{પોસ્ટફિક્સ ઇવેલ્યુએશન}
\begin{tabulary}{\linewidth}{|C|L|L|}
\hline
\textbf{સિમ્બોલ} & \textbf{સ્ટેક} & \textbf{કેલ્ક્યુલેશન} \\ \hline
5 (A) & 5 & વેલ્યુ પુશ કરો \\ \hline
10 (B) & 5, 10 & વેલ્યુ પુશ કરો \\ \hline
2 (C) & 5, 10, 2 & વેલ્યુ પુશ કરો \\ \hline
/ & 5, 5 & $10/2 = 5$ \\ \hline
+ & 10 & $5+5 = 10$ \\ \hline
3 (D) & 10, 3 & વેલ્યુ પુશ કરો \\ \hline
+ & 13 & $10+3 = 13$ \\ \hline
\end{tabulary}
\end{center}
\textbf{રિઝલ્ટ:} 13
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PC-SE}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{લિંક્ડ લિસ્ટ ના ઉપયોગો લખો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{લિંક્ડ લિસ્ટના ઉપયોગો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{એપ્લિકેશન} & \textbf{શા માટે લિંક્ડ લિસ્ટ વપરાય છે} \\ \hline
\textbf{ડાયનેમિક મેમરી એલોકેશન} & રિએલોકેશન વિના કાર્યક્ષમ ઇન્સર્શન \\ \hline
\textbf{સ્ટેક અને ક્યુ} & જરૂરિયાત મુજબ વધી અને ઘટી શકે છે \\ \hline
\textbf{અનડુ ફંક્શનાલિટી} & હિસ્ટરી મેનેજમેન્ટ સરળ છે \\ \hline
\textbf{હેશ ટેબલ્સ} & કોલિઝન હેન્ડલિંગ માટે \\ \hline
\textbf{મ્યુઝિક પ્લેલિસ્ટ} & ગીતો વચ્ચે સરળ નેવિગેશન \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DSUHM}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{પાયથનમા સિંગલી લિંક્ડ લિસ્ટ કેવી રીતે બનાવી શકાય એ સમજાવો.}

\begin{solutionbox}
પાયથનમાં સિંગલી લિંક્ડ લિસ્ટ બનાવવા માટે નોડ ક્લાસ ડિફાઇન કરવી અને બેઝિક ઓપરેશન્સ ઇમ્પ્લિમેન્ટ કરવા પડે છે.

\begin{lstlisting}[language=Python, caption={Creating Linked List}]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node
\end{lstlisting}

\begin{center}
\begin{tikzpicture}
    \node [gtu state] (node) {નોડ બનાવો};
    \node [gtu state, right=of node] (head) {હેડ સેટ કરો};
    \node [gtu state, right=of head] (traverse) {ટ્રેવર્સ કરો};
    \node [gtu state, right=of traverse] (attach) {જોડો};
    
    \draw [gtu arrow] (node) -- (head);
    \draw [gtu arrow] (head) -- (traverse);
    \draw [gtu arrow] (traverse) -- (attach);
\end{tikzpicture}
\captionof{figure}{લિસ્ટ બનાવવી}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CHEN}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{સિંગલી લિંક્ડ લિસ્ટ ની શરૂઆતમાં અને અંતમાં નવા નોડ ઉમેરવાનો કોડ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Insertion Code}]
def insert_at_beginning(self, data):
    new_node = Node(data)
    new_node.next = self.head
    self.head = new_node

def insert_at_end(self, data):
    new_node = Node(data)
    if self.head is None:
        self.head = new_node
        return
    current = self.head
    while current.next:
        current = current.next
    current.next = new_node
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=2, draw, rectangle split horizontal}]
    % Insert at Beginning
    \node (new1) [list] {New \nodepart{second} Next};
    \node (head1) [list, right=1cm of new1] {Head \nodepart{second} Next};
    \draw [->] (new1.south) to[out=-45, in=-135] (head1.south);
    \node at (2, -1.5) {Insert at Beginning};

    % Insert at End
    \node (head2) [list, right=4cm of head1] {Head \nodepart{second} Next};
    \node (last) [list, right=1cm of head2] {Last \nodepart{second} Next};
    \node (new2) [list, right=1cm of last] {New \nodepart{second} Next};
    \draw [->] (head2) -- (last);
    \draw [->] (last) -- (new2);
    \node at (10, -1.5) {Insert at End};
\end{tikzpicture}
\captionof{figure}{ઇન્સર્શન ઓપરેશન્સ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BEN}
\end{mnemonicbox}

\questionmarks{3(a) OR}{3}{સિંગલી લિંક્ડ મા રહેલ નોડ ની સંખ્યા ગણવા માટેનો કોડ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Count Nodes}]
def count_nodes(self):
    count = 0
    current = self.head
    while current:
        count += 1
        current = current.next
    return count
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CIT}
\end{mnemonicbox}

\questionmarks{3(b) OR}{4}{કોલમ એ અને કોલમ બી ના યોગ્ય વિકલ્પ જોડો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{મેચ કરો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{કોલમ એ} & \textbf{કોલમ બી} & \textbf{મેચ} \\ \hline
1. સિંગલી લિંક્ડ લિસ્ટ & c. નોડ્સમાં ડેટા અને આગામી નોડનો સંદર્ભ હોય છે & 1-c \\ \hline
2. ડબલી લિંક્ડ લિસ્ટ & d. નોડ્સમાં આગામી અને પાછલા બંને નોડ્સનો ડેટા અને સંદર્ભો હોય છે & 2-d \\ \hline
3. સર્ક્યુલર લિંક્ડ લિસ્ટ & b. નોડ્સ એક લૂપ બનાવે જેમા છેલ્લો નોડ પ્રથમ નોડ તરફ નિર્દેશ કરે & 3-b \\ \hline
4. નોડ & a. મૂળભૂત એકમ કે જેમા ડેટા અને સંદર્ભ હોઇ & 4-a \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node (S) {Singly: $A \rightarrow B \rightarrow NULL$};
    \node [below=0.5cm of S] (D) {Doubly: $A \leftrightarrow B \leftrightarrow NULL$};
    \node [below=0.5cm of D] (C) {Circular: $A \rightarrow B \rightarrow A$};
\end{tikzpicture}
\captionof{figure}{લિંક્ડ લિસ્ટ પ્રકારો}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SDCN}
\end{mnemonicbox}

\questionmarks{3(c) OR}{7}{સિંગલી લિંક્ડ લિસ્ટ મા પ્રથમ અને છેલ્લો નોડ ને કાઢી નાખવાનુ સમજાવો.}

\begin{solutionbox}
સિંગલી લિંક્ડ લિસ્ટમાંથી નોડ કાઢવાની જટિલતા પોઝિશન (પ્રથમ વિ. છેલ્લો) પર આધારિત હોય છે.

\begin{center}
\captionof{table}{ડિલીશન કંપેરિઝન}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પોઝિશન} & \textbf{અભિગમ} & \textbf{કોમ્પ્લેક્સિટી} \\ \hline
પ્રથમ નોડ & હેડ પોઇન્ટર બદલો & O(1) \\ \hline
છેલ્લો નોડ & બીજા છેલ્લા નોડ સુધી ટ્રેવર્સ કરો & O(n) \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python, caption={Deletion Code}]
def delete_first(self):
    if self.head is None: return
    self.head = self.head.next

def delete_last(self):
    if self.head is None: return
    if self.head.next is None:
        self.head = None
        return
    current = self.head
    while current.next.next:
        current = current.next
    current.next = None
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FELO}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{ડબ્લી લિંક્ડ લિસ્ટ નો કોન્સૈપ્ટ સમજાવો.}

\begin{solutionbox}
ડબલી લિંક્ડ લિસ્ટ એ બાયડાયરેક્શનલ લીનિયર ડેટા સ્ટ્રક્ચર છે.

\begin{center}
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=3, draw, rectangle split horizontal}]
    \node[list] (A) {Prev \nodepart{second} 10 \nodepart{third} Next};
    \node[list, right=1cm of A] (B) {Prev \nodepart{second} 20 \nodepart{third} Next};
    \draw[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2) -- (B);
    \draw[*->] let \p1 = (B.one), \p2 = (B.center) in (\x1,\y2) -- (A);
\end{tikzpicture}
\captionof{figure}{ડબલી લિંક્ડ લિસ્ટ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PDN}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{લિનિયર સર્ચ નો કોન્સૈપ્ટ સમજાવો.}

\begin{solutionbox}
લિનિયર સર્ચ એ સરળ સિક્વેન્શિયલ સર્ચ અલ્ગોરિધમ છે.

\begin{center}
\captionof{table}{લિનિયર સર્ચ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કાર્યપ્રણાલી} & શરૂઆતથી અંત સુધી ક્રમશઃ દરેક એલિમેન્ટ ચેક કરો \\ \hline
\textbf{ટાઇમ કોમ્પ્લેક્સિટી} & O(n) - વર્સ્ટ અને એવરેજ કેસ \\ \hline
\textbf{બેસ્ટ કેસ} & O(1) \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[node distance=2cm]
    \node [gtu state] (start) {પ્રારંભ};
    \node [gtu state, right=of start] (check) {એલિમેન્ટ ચેક કરો};
    \node [gtu decision, right=of check] (match) {મેચ?};
    \node [gtu state, below=of match] (found) {મળ્યું};
    \node [gtu state, above=of match] (next) {આગળ};
    
    \draw [gtu arrow] (start) -- (check);
    \draw [gtu arrow] (check) -- (match);
    \draw [gtu arrow] (match) -- node[right] {હા} (found);
    \draw [gtu arrow] (match) -- node[right] {ના} (next);
    \draw [gtu arrow] (next) -| (check);
\end{tikzpicture}
\captionof{figure}{લિનિયર સર્ચ પ્રોસેસ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SCENT}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{બાયનરી સર્ચ અલ્ગોરિધમ ઇમ્પ્લીમેંટ કરવા માટેનો કોડ લખો.}

\begin{solutionbox}
બાયનરી સર્ચ એક કાર્યક્ષમ અલ્ગોરિધમ છે જે સર્ચ ઇન્ટરવલને વારંવાર અડધા ભાગમાં વિભાજિત કરે છે.

\begin{lstlisting}[language=Python, caption={Binary Search}]
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
\end{lstlisting}

\begin{center}
\begin{tikzpicture}
    \draw (0,0) grid (7,1);
    \foreach \x/\v in {0/10, 1/20, 2/30, 3/40, 4/50, 5/60, 6/70} \node at (\x+0.5, 0.5) {\v};
    \node [above] at (0.5, 1) {L};
    \node [above] at (6.5, 1) {R};
    \node [above] at (3.5, 1) {Mid=40};
    \node [below] at (3.5, 0) {Found Target 40};
\end{tikzpicture}
\captionof{figure}{બાયનરી સર્ચ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MCLR}
\end{mnemonicbox}

\questionmarks{4(a) OR}{3}{સિલેક્શન સોર્ટ અલ્ગોરીધમ નો કોન્સૈપ્ટ સમજાવો.}

\begin{solutionbox}
સિલેક્શન સોર્ટ અનસોર્ટેડ ભાગમાંથી મિનિમમ એલિમેન્ટ શોધીને શરૂઆતમાં મૂકે છે.

\begin{itemize}
    \item \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: $O(n^2)$
    \item \textbf{સ્પેસ કોમ્પ્લેક્સિટી}: $O(1)$
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FSMR}
\end{mnemonicbox}

\questionmarks{4(b) OR}{4}{બબલ સોર્ટ મેથડ સમજાવો.}

\begin{solutionbox}
બબલ સોર્ટ આસપાસના એલિમેન્ટ્સની તુલના કરે છે અને જો તેઓ ખોટા ક્રમમાં હોય તો તેમને સ્વેપ કરે છે.

\begin{center}
\captionof{table}{બબલ સોર્ટ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પાસ} & $n-1$ પાસ \\ \hline
\textbf{કોમ્પ્લેક્સિટી} & $O(n^2)$ \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}
    \node at (0,2) {[5, 3, 8, 4, 2]};
    \node at (0,1.5) {$\downarrow$};
    \node at (0,1) {[3, 5, 4, 2, 8] (પાસ 1)};
    \node at (0,0.5) {$\downarrow$};
    \node at (0,0) {[3, 4, 2, 5, 8] (પાસ 2)};
\end{tikzpicture}
\captionof{figure}{બબલ સોર્ટ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CABS}
\end{mnemonicbox}

\questionmarks{4(c) OR}{7}{ઉદાહરણ સાથે ક્વીક સોર્ટ મેથડનુ વર્કિંગ સમજાવો.}

\begin{solutionbox}
ક્વિક સોર્ટ એ ડિવાઇડ-એન્ડ-કોન્કર અલ્ગોરિધમ છે.

\begin{center}
\captionof{table}{ક્વિક સોર્ટ સ્ટેપ્સ}
\begin{tabulary}{\linewidth}{|C|L|}
\hline
1 & પિવોટ એલિમેન્ટ પસંદ કરો \\ \hline
2 & પાર્ટિશન: નાના ડાબી બાજુ, મોટા જમણી બાજુ \\ \hline
3 & રિકર્સિવલી સોર્ટ કરો \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2.5cm]
    \node {Pivot: 4}
    child {node {Left: [2, 1, 3]}}
    child {node {Right: [7, 6, 8, 5]}};
\end{tikzpicture}
\captionof{figure}{ક્વિક સોર્ટ પાર્ટિશન}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PPR}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{બાયનરી ટ્રી સમજાવો.}

\begin{solutionbox}
બાયનરી ટ્રી એ એક હાયરાર્કિકલ ડેટા સ્ટ્રક્ચર છે જેમાં દરેક નોડને વધુમાં વધુ બે ચિલ્ડ્રન હોય છે.

\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm]
    \node [circle, draw] {A}
    child {node [circle, draw] {B}}
    child {node [circle, draw] {C}};
\end{tikzpicture}
\captionof{figure}{બાયનરી ટ્રી}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RLTM}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{ટ્રી ના સંદભભ મા રૂટ, પાથ, પેરંટ અને ચિલ્ડ્રન પદો વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{ટ્રી શબ્દાવલી}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પદ} & \textbf{વ્યાખ્યા} \\ \hline
\textbf{રૂટ} & સૌથી ઉપરનો નોડ જેને કોઈ પેરેન્ટ નથી \\ \hline
\textbf{પાથ} & નોડ્સનો સિક્વન્સ \\ \hline
\textbf{પેરેન્ટ} & નોડ જે ચાઇલ્ડ ધરાવે છે \\ \hline
\textbf{ચિલ્ડ્રન} & પેરેન્ટ નોડથી સીધા જોડાયેલા નોડ્સ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RPPC}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{નીચે આપેલા ટ્રી માટે પ્રીઓર્ડર અને પોસ્ટઓર્ડર ટ્રાવર્સલ લાગુ કરો.}

\begin{solutionbox}
આપેલ ટ્રી: 40(Root), Left:30, Right:50...

\begin{center}
\captionof{table}{ટ્રાવર્સલ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ટ્રાવર્સલ} & \textbf{ઓર્ડર} & \textbf{રિઝલ્ટ} \\ \hline
\textbf{પ્રીઓર્ડર} & રૂટ, લેફ્ટ, રાઇટ & 40, 30, 25, 15, 28, 35, 50, 45, 60, 55, 70 \\ \hline
\textbf{પોસ્ટઓર્ડર} & લેફ્ટ, રાઇટ, રૂટ & 15, 28, 25, 35, 30, 45, 55, 70, 60, 50, 40 \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PRE-NLR, POST-LRN}
\end{mnemonicbox}

\questionmarks{5(a) OR}{3}{બાયનરી ટ્રી ની એપ્લિકેશન્સ લખો.}

\begin{solutionbox}
\begin{itemize}
    \item બાયનરી સર્ચ ટ્રી (સર્ચિંગ)
    \item એક્સપ્રેશન ટ્રી (મેથેમેટિકલ)
    \item હફમેન કોડિંગ (કમ્પ્રેશન)
    \item પ્રાયોરિટી ક્યુ (હીપ)
    \item ડિસિઝન ટ્રી (મશીન લર્નિંગ)
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BEHPD}
\end{mnemonicbox}

\questionmarks{5(b) OR}{4}{બાયનરી સર્ચ ટ્રી મા નોડ કેવી રીતે ઉમેરી શકાય તે સમજાવો.}

\begin{solutionbox}
BST પ્રોપર્ટી: લેફ્ટ $<$ નોડ $<$ રાઇટ.

\begin{enumerate}
    \item રૂટથી શરૂ કરો.
    \item જો નવી $<$ કરંટ, લેફ્ટ જાઓ.
    \item જો નવી $>$ કરંટ, રાઇટ જાઓ.
    \item ખાલી પોઝિશન પર ઇન્સર્ટ કરો.
\end{enumerate}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node [gtu state] (start) {શરૂ કરો};
    \node [gtu decision, below=of start] (check) {કમ્પેર};
    \node [gtu state, left=of check] (left) {લેફ્ટ જાઓ};
    \node [gtu state, right=of check] (right) {રાઇટ જાઓ};
    \node [gtu state, below=of check] (insert) {ઇન્સર્ટ};
    
    \draw [gtu arrow] (start) -- (check);
    \draw [gtu arrow] (check) -- node[above] {નાનું} (left);
    \draw [gtu arrow] (check) -- node[above] {મોટું} (right);
    \draw [gtu arrow] (left) |- (insert);
    \draw [gtu arrow] (right) |- (insert);
\end{tikzpicture}
\captionof{figure}{BST ઇન્સર્શન}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LSRG}
\end{mnemonicbox}

\questionmarks{5(c) OR}{7}{8, 4, 12, 2, 6, 10, 14, 1, 3, 5 નમ્બર માટે બાયનરી સર્ચ ટ્રી દોરો અને ટ્રી માટે ઇન ઓર્ડર ટ્રાવર્સલ લખો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[level distance=1.5cm, sibling distance=2cm]
    \node [circle, draw] {8}
    child {node [circle, draw] {4}
        child {node [circle, draw] {2}
            child {node [circle, draw] {1}}
            child {node [circle, draw] {3}}
        }
        child {node [circle, draw] {6}
            child {node [circle, draw] {5}}
            child[missing]
        }
    }
    child {node [circle, draw] {12}
        child {node [circle, draw] {10}}
        child {node [circle, draw] {14}}
    };
\end{tikzpicture}
\captionof{figure}{બનાવેલ BST}
\end{center}

\textbf{ઇન-ઓર્ડર ટ્રાવર્સલ (લેફ્ટ, રૂટ, રાઇટ):} \\
1, 2, 3, 4, 5, 6, 8, 10, 12, 14
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LNR}
\end{mnemonicbox}

\end{document}
