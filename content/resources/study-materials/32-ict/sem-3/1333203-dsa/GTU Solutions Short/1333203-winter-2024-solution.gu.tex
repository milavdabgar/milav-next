\documentclass{article}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{C:/Users/milav/OneDrive/Git/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{ડેટા સ્ટ્રક્ચર અને એપ્લિકેશન (1333203) - વિન્ટર 2024 સોલ્યુશન}
\date{December 07, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{રેખીય ડેટા સ્ટ્રક્ચર્સના નામ લખો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{રેખીય ડેટા સ્ટ્રક્ચર્સ}
\begin{tabulary}{\linewidth}{|L|}
\hline
\textbf{રેખીય ડેટા સ્ટ્રક્ચર્સ} \\ \hline
1. એરે (Array) \\ \hline
2. સ્ટેક (Stack) \\ \hline
3. ક્યુ (Queue) \\ \hline
4. લિંક્ડ લિસ્ટ (Linked List) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{બધા વિદ્યાર્થીઓ લાઈનમાં ઊભા રહે છે}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{ટાઇમ અને સ્પેસ કોમ્પલેક્ષીટી વ્યાખ્યાયીત કરો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{વ્યાખ્યાઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{કોમ્પ્લેક્સિટી પ્રકાર} & \textbf{વ્યાખ્યા} & \textbf{નોટેશન} \\ \hline
ટાઇમ કોમ્પ્લેક્સિટી & માપે છે કે ઇનપુટ સાઇઝ વધતાં એક્ઝિક્યુશન ટાઇમ કેવી રીતે વધે છે & O(n), O(1), O(log n) \\ \hline
સ્પેસ કોમ્પ્લેક્સિટી & માપે છે કે ઇનપુટ સાઇઝ વધતાં મેમરી વપરાશ કેવી રીતે વધે છે & O(n), O(1), O(log n) \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[
    node distance=1.5cm,
    block/.style={rectangle, draw, minimum height=1cm, align=center},
    arrow/.style={-latex}
]
    \node[block] (input) {ઇનપુટ સાઈઝ\\(n)};
    \node[block, right=2cm of input] (algo) {અલગોરિધમ};
    
    \node[block, below left=1.5cm and -1cm of algo] (time) {ટાઇમ\\O(n)};
    \node[block, below right=1.5cm and -1cm of algo] (space) {સ્પેસ\\O(n)};
    
    \draw[arrow] (input) -- (algo);
    \draw[arrow] (algo) -- (time);
    \draw[arrow] (algo) -- (space);
\end{tikzpicture}
\captionof{figure}{કોમ્પ્લેક્ષીટી વિશ્લેષણ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ટાઇમ સ્ટેપ્સ, સ્પેસ સ્ટોર્સ}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{ઉદાહરણ સાથે ક્લાસ અને ઓબ્જેક્ટનો કોન્સેપ્ટ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    class/.style={rectangle, draw, fill=yellow!10, text width=4cm, align=left, font=\ttfamily},
    header/.style={fill=blue!20, align=center, font=\bfseries\sffamily}
]
    \node[class] (student) {
        \textbf{Student} \\ \hrule
        - int rollNo \\
        - string name \\ \hrule
        + setData() \\
        + displayData()
    };
    \node[above=0.1cm of student] {\textbf{Class Diagram}};
\end{tikzpicture}
\captionof{figure}{Student ક્લાસ સ્ટ્રક્ચર}
\end{center}

\begin{center}
\captionof{table}{ક્લાસ vs ઓબ્જેક્ટ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{કોન્સેપ્ટ} & \textbf{વ્યાખ્યા} & \textbf{ઉદાહરણ} \\ \hline
ક્લાસ & ઓબ્જેક્ટ બનાવવા માટેનો બ્લૂપ્રિન્ટ અથવા ટેમ્પલેટ & Student ક્લાસ જેમાં properties (rollNo, name) અને methods (setData, displayData) છે \\ \hline
ઓબ્જેક્ટ & ક્લાસનું ચોક્કસ ડેટા ધરાવતું ઇન્સ્ટન્સ & student1 (rollNo=101, name="રાજ") \\ \hline
\end{tabulary}
\end{center}

\textbf{કોડ ઉદાહરણ:}
\begin{lstlisting}[language=Python]
class Student:
    def __init__(self):
        self.rollNo = 0
        self.name = ""
        
    def setData(self, r, n):
        self.rollNo = r
        self.name = n
        
    def displayData(self):
        print(self.rollNo, self.name)

# ઓબ્જેક્ટ બનાવવા
student1 = Student()
student1.setData(101, "રાજ")
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ક્લાસ બનાવે, ઓબ્જેક્ટ વાપરે}
\end{mnemonicbox}

\questionmarks{1(c) OR}{7}{વિદ્યાર્થીઓના રેકોર્ડ્સ ને સંચાલિત કરવા માટેનો એક ક્લાસ બનાવો જેમા વિદ્યાર્થીને ઉમેરવા તેમજ બાદ કરવા માટેની મેથડ હોય.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    class/.style={rectangle, draw, fill=green!10, text width=5cm, align=left},
    header/.style={fill=green!30, align=center, font=\bfseries}
]
    \node[class] (manager) {
        \textbf{StudentManager} \\ \hrule
        - Student[] students \\
        - int count \\ \hrule
        + addStudent() \\
        + removeStudent() \\
        + displayAll()
    };
\end{tikzpicture}
\captionof{figure}{StudentManager ક્લાસ}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
class StudentManager:
    def __init__(self):
        self.students = []
        
    def addStudent(self, roll, name):
        student = Student()
        student.setData(roll, name)
        self.students.append(student)
        
    def removeStudent(self, roll):
        for i in range(len(self.students)):
            if self.students[i].rollNo == roll:
                self.students.pop(i)
                break
    
    def displayAll(self):
        for student in self.students:
            student.displayData()
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ઉમેરો વધારે, કાઢો ઘટાડે}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{ક્લાસમાં કન્સ્ટ્રક્ટરનું મહત્વ સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{કન્સ્ટ્રક્ટરનું મહત્વ}
\begin{tabulary}{\linewidth}{|L|}
\hline
\textbf{કન્સ્ટ્રક્ટરનું મહત્વ} \\ \hline
1. ઓબ્જેક્ટના ડેટા મેમ્બર્સને પ્રારંભિક મૂલ્ય આપે છે \\ \hline
2. ઓબ્જેક્ટ બનતી વખતે આપોઆપ કોલ થાય છે \\ \hline
3. અલગ અલગ પ્રકારના હોઈ શકે (ડિફોલ્ટ, પેરામીટરાઈઝ્ડ, કોપી) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{શરૂઆત હંમેશા સારી}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{સ્ટેક પર વિવિધ ઓપરેશન સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{સ્ટેક ઓપરેશન}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
પુશ (Push) & ટોપ પર એલિમેન્ટ ઉમેરે છે & push(5) \\ \hline
પોપ (Pop) & ટોપ પરથી એલિમેન્ટ દૂર કરે છે & x = pop() \\ \hline
પીક/ટોપ (Peek/Top) & ટોપ એલિમેન્ટને દૂર કર્યા વગર જુએ છે & x = peek() \\ \hline
isEmpty & ચકાસે છે કે સ્ટેક ખાલી છે કે નહીં & if(isEmpty()) \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[
    stack/.style={rectangle, draw, minimum width=1.5cm, minimum height=0.6cm, fill=white},
    arrow/.style={-latex, thick}
]
    % Push State
    \node[anchor=south] at (0, 3) {PUSH 5};
    \draw[thick] (-0.75, 0) -- (-0.75, 2) (0.75, 0) -- (0.75, 2) (-0.75, 0) -- (0.75, 0);
    \node[stack] at (0, 0.3) {8};
    \node[stack] at (0, 0.9) {7};
    \node[stack, dashed] (new) at (0, 2.5) {5};
    \draw[arrow] (new) -- (0, 1.5);

    % Pop State
    \begin{scope}[xshift=4cm]
    \node[anchor=south] at (0, 3) {POP};
    \draw[thick] (-0.75, 0) -- (-0.75, 2) (0.75, 0) -- (0.75, 2) (-0.75, 0) -- (0.75, 0);
    \node[stack] at (0, 0.3) {2};
    \node[stack] at (0, 0.9) {7};
    \node[stack] (top) at (0, 1.5) {8};
    \draw[arrow] (top) -- (1.5, 2);
    \end{scope}

    % Peek State
    \begin{scope}[xshift=8cm]
    \node[anchor=south] at (0, 3) {PEEK};
    \draw[thick] (-0.75, 0) -- (-0.75, 2) (0.75, 0) -- (0.75, 2) (-0.75, 0) -- (0.75, 0);
    \node[stack] at (0, 0.3) {2};
    \node[stack] (peek) at (0, 0.9) {7};
    \draw[arrow, dashed] (peek) -- (1.5, 0.9) node[right] {Read};
    \end{scope}
\end{tikzpicture}
\captionof{figure}{સ્ટેક ઓપરેશન્સ}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{નાખો કાઢો જુઓ}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{પોસ્ટફિક્સ એક્સપ્રેશન ABC+*D/ નું મૂલ્યાંકન અલગોરિધમનું વર્ણન કરો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    cell/.style={rectangle, draw, minimum size=0.6cm},
    arrow/.style={-latex}
]
    \node[anchor=west] at (-1, 1) {Input:};
    \foreach \x/\val in {0/A, 1/B, 2/C, 3/+, 4/*, 5/D, 6//} {
        \node[cell] at (\x*0.6, 0) {\val};
    }
    \draw[arrow] (0, -0.5) -- (3.6, -0.5) node[midway, below] {ડાબેથી જમણે વાંચો};
\end{tikzpicture}
\captionof{figure}{પોસ્ટફિક્સ મૂલ્યાંકન પ્રક્રિયા}
\end{center}

\begin{center}
\captionof{table}{સ્ટેપ-બાય-સ્ટેપ ટ્રેસ}
\begin{tabulary}{\linewidth}{|C|C|L|L|}
\hline
\textbf{સ્ટેપ} & \textbf{સિમ્બોલ} & \textbf{એક્શન} & \textbf{સ્ટેક} \\ \hline
1 & A & સ્ટેક પર પુશ કરો & A \\ \hline
2 & B & સ્ટેક પર પુશ કરો & A, B \\ \hline
3 & C & સ્ટેક પર પુશ કરો & A, B, C \\ \hline
4 & + & B, C પોપ કરો; B+C પુશ કરો & A, (B+C) \\ \hline
5 & * & A, (B+C) પોપ કરો; A*(B+C) પુશ કરો & A*(B+C) \\ \hline
6 & D & સ્ટેક પર પુશ કરો & A*(B+C), D \\ \hline
7 & / & A*(B+C),D પોપ કરો; રીઝલ્ટ પુશ કરો & (A*(B+C))/D \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{વાંચો, પુશ કરો, પોપ કરો, ગણતરી કરો}
\end{mnemonicbox}

\questionmarks{2(a) OR}{3}{સ્ટેક અને ક્યુ વચ્ચેનો તફાવત લખો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{સ્ટેક vs ક્યુ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફીચર} & \textbf{સ્ટેક} & \textbf{ક્યુ} \\ \hline
સિદ્ધાંત & LIFO (છેલ્લું આવે પહેલું જાય) & FIFO (પહેલું આવે પહેલું જાય) \\ \hline
ઓપરેશન & પુશ/પોપ & એનક્યુ/ડિક્યુ \\ \hline
એક્સેસ પોઈન્ટ્સ & એક છેડો (ટોપ) & બે છેડા (ફ્રન્ટ, રીઅર) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{સ્ટેક છેલ્લું પહેલું, ક્યુ પહેલું પહેલું}
\end{mnemonicbox}

\questionmarks{2(b) OR}{4}{સર્ક્યુલર ક્યુ નો કોન્સેપ્ટ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    segment/.style={circle, draw, minimum size=0.8cm},
    arrow/.style={-latex}
]
    \node[segment] (n1) at (90:1.5) {1};
    \node[segment] (n2) at (30:1.5) {2};
    \node[segment] (n3) at (330:1.5) {3};
    \node[segment] (n4) at (270:1.5) {4};
    \node[segment] (n5) at (210:1.5) {5};
    \node[segment] (n6) at (150:1.5) {};

    \draw[arrow] (n1) to[bend left] (n2);
    \draw[arrow] (n2) to[bend left] (n3);
    \draw[arrow] (n3) to[bend left] (n4);
    \draw[arrow] (n4) to[bend left] (n5);
    \draw[arrow] (n5) to[bend left] (n6);
    \draw[arrow] (n6) to[bend left] (n1);

    \node[above=0.2cm of n1] {Front};
    \node[below=0.2cm of n5] {Rear};
\end{tikzpicture}
\captionof{figure}{સર્ક્યુલર ક્યુ કોન્સેપ્ટ}
\end{center}

\begin{center}
\captionof{table}{સર્ક્યુલર ક્યુ ફીચર્સ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ફીચર} & \textbf{વર્ણન} \\ \hline
સ્ટ્રક્ચર & છેડાઓ જોડાયેલ હોય તેવો લીનિયર ડેટા સ્ટ્રક્ચર \\ \hline
ફાયદો & ખાલી જગ્યાનો ફરીથી ઉપયોગ કરીને મેમરી કાર્યક્ષમ રીતે વાપરે છે \\ \hline
ઓપરેશન & એનક્યુ, ડિક્યુ (મોડ્યુલો ગણતરી સાથે) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{સર્ક્યુલર ફ્રન્ટને રીઅર સાથે જોડે}
\end{mnemonicbox}

\questionmarks{2(c) OR}{7}{સિંગલી લિંક્ડ લિસ્ટમાં આપેલ નોડ પછી અને પહેલાં નવા નોડ દાખલ કરવાની પ્રક્રિયાનું વર્ણન કરો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    listnode/.style={rectangle, draw, minimum size=0.6cm},
    arrow/.style={-latex}
]
    % Insert After
    \node[anchor=west] at (0, 3) {\textbf{નોડ X પછી ઇન્સર્ટ:}};
    \node[listnode] (a) at (0, 2) {A};
    \node[listnode] (x) at (2, 2) {X};
    \node[listnode, dashed, fill=green!10] (n) at (4, 2) {N};
    \node[listnode] (b) at (6, 2) {B};
    
    \draw[arrow] (a) -- (x);
    \draw[arrow] (x) -- (n);
    \draw[arrow] (n) -- (b);

    % Insert Before
    \node[anchor=west] at (0, 1) {\textbf{નોડ X પહેલા ઇન્સર્ટ:}};
    \node[listnode] (a2) at (0, 0) {A};
    \node[listnode, dashed, fill=green!10] (n2) at (2, 0) {N};
    \node[listnode] (x2) at (4, 0) {X};
    \node[listnode] (b2) at (6, 0) {B};

    \draw[arrow] (a2) -- (n2);
    \draw[arrow] (n2) -- (x2);
    \draw[arrow] (x2) -- (b2);
\end{tikzpicture}
\captionof{figure}{સિંગલી લિંક્ડ લિસ્ટમાં ઇન્સર્શન}
\end{center}

\begin{center}
\captionof{table}{ઇન્સર્શન પ્રક્રિયા}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઇન્સર્શન} & \textbf{સ્ટેપ્સ} \\ \hline
નોડ X પછી & 1. નવો નોડ N બનાવો \newline 2. N નો next X ના next પર સેટ કરો \newline 3. X નો next N પર સેટ કરો \\ \hline
નોડ X પહેલા & 1. નવો નોડ N બનાવો \newline 2. X પર પોઇન્ટ કરતો નોડ A શોધો \newline 3. N નો next X પર સેટ કરો \newline 4. A નો next N પર સેટ કરો \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\questionmarks{3(a)}{3}{લિંક્ડ લિસ્ટ મા એક છેડાથી બીજા છેડા સુધી પસાર થવાની પ્રક્રિયા સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    listnode/.style={rectangle, draw, minimum size=0.6cm},
    arrow/.style={-latex}
]
    \node[anchor=east] (start) at (0, 0) {Start};
    \node[listnode] (n1) at (1.5, 0) {10};
    \node[listnode] (n2) at (3.5, 0) {20};
    \node[listnode] (n3) at (5.5, 0) {30};
    \node (null) at (7, 0) {NULL};

    \draw[arrow] (start) -- (n1);
    \draw[arrow] (n1) -- (n2);
    \draw[arrow] (n2) -- (n3);
    \draw[arrow] (n3) -- (null);

    \node[below=0.3cm of n1, align=center] {Visit\\$\uparrow$};
    \node[below=0.3cm of n2, align=center] {Visit\\$\uparrow$};
    \node[below=0.3cm of n3, align=center] {Visit\\$\uparrow$};
\end{tikzpicture}
\captionof{figure}{લિંક્ડ લિસ્ટ ટ્રાવર્સલ}
\end{center}

\begin{center}
\captionof{table}{ટ્રાવર્સલ સ્ટેપ્સ}
\begin{tabulary}{\linewidth}{|C|L|}
\hline
\textbf{સ્ટેપ} & \textbf{એક્શન} \\ \hline
1 & હેડ નોડથી શરૂ કરો \\ \hline
2 & વર્તમાન નોડનો ડેટા એક્સેસ કરો \\ \hline
3 & પોઈન્ટરને આગળના નોડ પર ખસેડો \\ \hline
4 & NULL મળે ત્યાં સુધી દોહરાવો \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{શરૂ કરો, જુઓ, આગળ વધો, દોહરાવો}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{ઇનફિક્સથી પોસ્ટફિક્સમાં એક્સપ્રેસનનું રૂપાંતર સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tcolorbox}[colback=blue!5, colframe=blue!40, title=ઉદાહરણ રૂપાંતર]
\textbf{Infix:} $A + B * C$ \\
\textbf{Postfix:} $A \ B \ C \ * \ +$
\end{tcolorbox}
\end{center}

\begin{center}
\captionof{table}{રૂપાંતર અલગોરિધમ ટ્રેસ}
\begin{tabulary}{\linewidth}{|C|L|C|L|}
\hline
\textbf{સ્ટેપ} & \textbf{એક્શન} & \textbf{સ્ટેક} & \textbf{આઉટપુટ} \\ \hline
1 & ડાબેથી જમણે સ્કેન કરો & & \\ \hline
2 & જો ઓપરેન્ડ હોય, તો આઉટપુટમાં ઉમેરો & & A \\ \hline
3 & જો ઓપરેટર હોય, તો ઉચ્ચ પ્રાધાન્યતા હોય તો પુશ કરો & + & A \\ \hline
4 & ઓછી પ્રાધાન્યતાવાળા ઓપરેટર પોપ કરો & + & A B \\ \hline
5 & વર્તમાન ઓપરેટર પુશ કરો & * & A B \\ \hline
6 & એક્સપ્રેશન પૂરું થાય ત્યાં સુધી ચાલુ રાખો & * & A B C \\ \hline
7 & બાકીના ઓપરેટર પોપ કરો & & A B C * + \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ઓપરેટર પુશ-પોપ, ઓપરેન્ડ સીધા આઉટપુટમાં}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{સિંગલી લિંક્ડ લિસ્ટની શરૂઆતનો અને અંતનો નોડ ડીલીટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    listnode/.style={rectangle, draw, minimum size=0.6cm},
    arrow/.style={-latex},
    scale=0.8, transform shape
]
    \node[anchor=west] at (-2, 1) {\textbf{Before:}};
    \node (head) at (0, 1) {Head};
    \node[listnode] (n1) at (1.5, 1) {10};
    \node[listnode] (n2) at (3, 1) {20};
    \node[listnode] (n3) at (4.5, 1) {30};
    \node (null) at (6, 1) {NULL};
    \draw[arrow] (head) -- (n1); \draw[arrow] (n1) -- (n2); \draw[arrow] (n2) -- (n3); \draw[arrow] (n3) -- (null);

    \node[anchor=west] at (-2, 0) {\textbf{After (Delete First):}};
    \node (head2) at (0, 0) {Head};
    \node[listnode] (n22) at (3, 0) {20};
    \node (null2) at (6, 0) {NULL};
    \draw[arrow] (head2) -- (n22); \draw[arrow] (n22) -- (null2);
\end{tikzpicture}
\captionof{figure}{ડીલીશન વિઝ્યુઅલાઈઝેશન}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def deleteFirst(self):
        if self.head is None:
            return
        self.head = self.head.next
    
    def deleteLast(self):
        if self.head is None:
            return
        
        # જો માત્ર એક જ નોડ હોય
        if self.head.next is None:
            self.head = None
            return
            
        temp = self.head
        while temp.next.next:
            temp = temp.next
        
        temp.next = None
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{પહેલો: હેડ શિફ્ટ કરો, છેલ્લો: પાછલો શોધો}
\end{mnemonicbox}

\questionmarks{3(a) OR}{3}{લિંક્ડ લિસ્ટમાં કોઇ એલિમેન્ટ શોધવાની પ્રક્રિયા સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    listnode/.style={rectangle, draw, minimum size=0.6cm},
    arrow/.style={-latex}
]
    \node (head) at (0, 0) {Head};
    \node[listnode] (n1) at (1.5, 0) {10};
    \node[listnode] (n2) at (3, 0) {20};
    \node[listnode] (n3) at (4.5, 0) {30};
    \node (null) at (6, 0) {NULL};

    \draw[arrow] (head) -- (n1); \draw[arrow] (n1) -- (n2); \draw[arrow] (n2) -- (n3); \draw[arrow] (n3) -- (null);
    
    \node[below=0.3cm of n1] {Check?};
    \node[below=0.3cm of n2] {Check?};
    \node[below=0.3cm of n3] {Check?};
\end{tikzpicture}
\captionof{figure}{લિંક્ડ લિસ્ટમાં લિનિયર સર્ચ}
\end{center}

\begin{center}
\captionof{table}{સર્ચ સ્ટેપ્સ}
\begin{tabulary}{\linewidth}{|C|L|}
\hline
\textbf{સ્ટેપ} & \textbf{વર્ણન} \\ \hline
1 & હેડ નોડથી શરૂ કરો \\ \hline
2 & વર્તમાન નોડના ડેટાને કી સાથે સરખાવો \\ \hline
3 & જો મેચ મળે, તો true રીટર્ન કરો \\ \hline
4 & નહીંતર, આગળના નોડ પર જાઓ અને રિપીટ કરો \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{શરૂ કરો, ચેક કરો, આગળ વધો, દોહરાવો}
\end{mnemonicbox}

\questionmarks{3(b) OR}{4}{સર્ક્યુલર લિંક્ડ લિસ્ટ નો કોન્સેપ્ટ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    listnode/.style={rectangle, draw, minimum size=0.6cm},
    arrow/.style={-latex}
]
    \node[listnode] (n1) at (0, 0) {10};
    \node[listnode] (n2) at (2, 0) {20};
    \node[listnode] (n3) at (4, 0) {30};

    \draw[arrow] (n1) -- (n2);
    \draw[arrow] (n2) -- (n3);
    \draw[arrow] (n3) -- (4, -1) -- (0, -1) -- (n1);
\end{tikzpicture}
\captionof{figure}{સર્ક્યુલર લિંક્ડ લિસ્ટ}
\end{center}

\begin{center}
\captionof{table}{સર્ક્યુલર LL ફીચર્સ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ફીચર} & \textbf{વર્ણન} \\ \hline
સ્ટ્રક્ચર & છેલ્લો નોડ પહેલા નોડને પોઇન્ટ કરે છે \\ \hline
ફાયદો & NULL પોઈન્ટર્સ નથી, સર્ક્યુલર ઓપરેશન માટે કાર્યક્ષમ \\ \hline
ટ્રાવર્સલ & અનંત લૂપ ટાળવા માટે વધારાની શરત જરૂરી \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{છેલ્લો પહેલાને જોડે}
\end{mnemonicbox}

\questionmarks{3(c) OR}{7}{લિસ્ટમાંથી બાઇનરી સર્ચનો ઉપયોગ કરીને કોઇ એક એલિમેન્ટ શોધવાનું અલગોરીધમ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node[gtu block] (start) {Start};
    \node[gtu block, right=of start] (init) {Low=0, High=n-1};
    \node[gtu decision, right=of init] (check) {Low $\le$ High?};
    \node[gtu block, below=of check] (mid) {Mid = (L+H)/2};
    \node[gtu decision, below=of mid] (compare) {A[Mid] == Key?};
    \node[gtu state, right=of compare] (found) {Return Mid};
    
    \node[gtu decision, left=of compare] (smaller) {A[Mid] < Key?};
    \node[gtu block, above=of smaller] (right) {Low = Mid+1};
    \node[gtu block, left=of smaller] (left) {High = Mid-1};
    \node[gtu state, right=of check] (notfound) {Return -1};

    \path[gtu arrow] (start) -- (init);
    \path[gtu arrow] (init) -- (check);
    \path[gtu arrow] (check) -- node[right] {Yes} (mid);
    \path[gtu arrow] (check) -- node[above] {No} (notfound);
    \path[gtu arrow] (mid) -- (compare);
    \path[gtu arrow] (compare) -- node[above] {Yes} (found);
    \path[gtu arrow] (compare) -- node[above] {No} (smaller);
    \path[gtu arrow] (smaller) -- node[left] {Yes} (right);
    \path[gtu arrow] (smaller) -- node[above] {No} (left);
    \path[gtu arrow] (right) |- (check);
    \path[gtu arrow] (left) |- (check);

\end{tikzpicture}
\captionof{figure}{બાઇનરી સર્ચ ફ્લોચાર્ટ}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
def binarySearch(arr, key):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        
        if arr[mid] == key:
            return mid
        elif arr[mid] < key:
            low = mid + 1
        else:
            high = mid - 1
            
    return -1
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{મધ્ય, તુલના, અડધું કાઢો}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{લિંક્ડ લિસ્ટના ઉપયોગ લખો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{લિંક્ડ લિસ્ટના ઉપયોગ}
\begin{tabulary}{\linewidth}{|L|}
\hline
\textbf{ઉપયોગ} \\ \hline
1. સ્ટેક અને ક્યુનો અમલીકરણ \\ \hline
2. ડાયનેમિક મેમરી એલોકેશન \\ \hline
3. ઇમેજ વ્યૂઅર (આગલી/પાછલી ઇમેજ) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ડેટા ડાયનેમિક સ્ટોર કરો}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{સિંગલી અને ડબલી લિંક્ડ લિસ્ટ વચ્ચેનો તફાવત લખો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{સિંગલી vs ડબલી લિંક્ડ લિસ્ટ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફીચર} & \textbf{સિંગલી લિંક્ડ લિસ્ટ} & \textbf{ડબલી લિંક્ડ લિસ્ટ} \\ \hline
નોડ સ્ટ્રક્ચર & એક પોઈન્ટર (next) & બે પોઈન્ટર (next, prev) \\ \hline
ટ્રાવર્સલ & માત્ર ફોરવર્ડ & બંને દિશામાં \\ \hline
મેમરી & ઓછી મેમરી & વધુ મેમરી \\ \hline
ઓપરેશન & સરળ, ઓછો કોડ & જટિલ, વધુ ફ્લેક્સિબલ \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[
    listnode/.style={rectangle, draw, minimum size=0.6cm},
    dnode/.style={rectangle, draw, minimum width=1.8cm, minimum height=0.6cm},
    arrow/.style={-latex}
]
    \node[anchor=west] at (0, 2) {\textbf{Singly:}};
    \node[listnode] (s1) at (2, 2) {Data}; \node[listnode] (s2) at (4, 2) {Data};
    \draw[arrow] (s1) -- (s2);

    \node[anchor=west] at (0, 0) {\textbf{Doubly:}};
    \node[dnode] (d1) at (2, 0) {Prev|Data|Next};
    \node[dnode] (d2) at (5, 0) {Prev|Data|Next};
    
    \draw[arrow] (d1.east) -- ([yshift=0.1cm]d2.west);
    \draw[arrow] (d2.west) -- ([yshift=-0.1cm]d1.east);
\end{tikzpicture}
\captionof{figure}{નોડ સ્ટ્રક્ચર}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{એક દિશા, બે દિશા}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{સિલેક્શન સોર્ટ અલગોરીધમનો ઉપયોગ કરીને આંકડાઓને ચઢતા ક્રમમાં ગોઠવવાનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    cell/.style={rectangle, draw, minimum size=0.5cm},
    scale=0.9, transform shape
]
    \foreach \x/\val in {0/5, 1/3, 2/8, 3/1, 4/2} \node[cell] at (\x*0.5, 0) {\val};
    \node[anchor=east] at (-0.5, 0) {Initial:};

    \foreach \x/\val in {0/1, 1/3, 2/8, 3/5, 4/2} \node[cell] at (\x*0.5, -0.7) {\val};
    \node[anchor=east] at (-0.5, -0.7) {Pass 1 (Swap 5,1):};

    \foreach \x/\val in {0/1, 1/2, 2/8, 3/5, 4/3} \node[cell] at (\x*0.5, -1.4) {\val};
    \node[anchor=east] at (-0.5, -1.4) {Pass 2 (Swap 3,2):};

    \foreach \x/\val in {0/1, 1/2, 2/3, 3/5, 4/8} \node[cell] at (\x*0.5, -2.1) {\val};
    \node[anchor=east] at (-0.5, -2.1) {Pass 3 (Swap 8,3):};
\end{tikzpicture}
\captionof{figure}{સિલેક્શન સોર્ટ ગણતરી}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
def selectionSort(arr):
    n = len(arr)
    
    for i in range(n):
        min_idx = i
        
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # મિનિમમ એલિમેન્ટને પહેલા એલિમેન્ટ સાથે સ્વેપ કરો
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# ઉદાહરણ
arr = [5, 3, 8, 1, 2]
sorted_arr = selectionSort(arr)
print(sorted_arr)  # આઉટપુટ: [1, 2, 3, 5, 8]
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{મિનિમમ શોધો, પોઝિશન બદલો}
\end{mnemonicbox}

\questionmarks{4(a) OR}{3}{બબલ સોર્ટ અલગોરીધમ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[node distance=1.2cm]
    \node[gtu block] (p1) {Pass 1};
    \node[gtu block, right=of p1] (p2) {Pass 2};
    \node[gtu block, right=of p2] (p3) {Pass 3};
    \node[gtu state, right=of p3] (sorted) {Sorted};

    \draw[gtu arrow] (p1) -- (p2);
    \draw[gtu arrow] (p2) -- (p3);
    \draw[gtu arrow] (p3) -- (sorted);
\end{tikzpicture}
\captionof{figure}{બબલ સોર્ટ ફ્લો}
\end{center}

\begin{center}
\captionof{table}{મુખ્ય પોઈન્ટ્સ}
\begin{tabulary}{\linewidth}{|L|}
\hline
\textbf{મુખ્ય પોઈન્ટ્સ} \\ \hline
આસપાસના એલિમેન્ટની તુલના કરો \\ \hline
જો ખોટા ક્રમમાં હોય તો સ્વેપ કરો \\ \hline
દરેક પાસમાં મોટા એલિમેન્ટ છેવટે પહોંચે \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{મોટા બબલ ઉપર જાય}
\end{mnemonicbox}

\questionmarks{4(b) OR}{4}{લિનિયર અને બાઇનરી સર્ચ વચ્ચેનો તફાવત લખો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{લિનિયર vs બાઇનરી સર્ચ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફીચર} & \textbf{લિનિયર સર્ચ} & \textbf{બાઇનરી સર્ચ} \\ \hline
કાર્ય સિદ્ધાંત & ક્રમિક ચકાસણી & વિભાજન અને જીત \\ \hline
ટાઇમ કોમ્પ્લેક્સિટી & O(n) & O(log n) \\ \hline
ડેટા અરેન્જમેન્ટ & અનસોર્ટેડ અથવા સોર્ટેડ & સોર્ટેડ હોવું જરૂરી \\ \hline
શેના માટે સારું & નાના ડેટાસેટ & મોટા ડેટાસેટ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{લિનિયર બધાને જુએ, બાઇનરી અડધું કાપે}
\end{mnemonicbox}

\questionmarks{4(c) OR}{7}{ક્વીક સોર્ટ અને મર્જ સોર્ટ સમજાવો.}

\begin{solutionbox}
\textbf{ક્વીક સોર્ટ:}
\begin{center}
\begin{tikzpicture}[node distance=1.2cm]
    \node[gtu block] (start) {Quick Sort};
    \node[gtu block, right=of start] (pivot) {Select Pivot};
    \node[gtu block, right=of pivot] (part) {Partition};
    \node[gtu block, above right=of part] (left) {Sort Left};
    \node[gtu block, below right=of part] (right) {Sort Right};

    \draw[gtu arrow] (start) -- (pivot);
    \draw[gtu arrow] (pivot) -- (part);
    \draw[gtu arrow] (part) -- (left);
    \draw[gtu arrow] (part) -- (right);
\end{tikzpicture}
\end{center}

\textbf{મર્જ સોર્ટ:}
\begin{center}
\begin{tikzpicture}[node distance=1.2cm]
    \node[gtu block] (start) {Merge Sort};
    \node[gtu block, right=of start] (divide) {Divide Half};
    \node[gtu block, above right=of divide] (left) {Sort Left};
    \node[gtu block, below right=of divide] (right) {Sort Right};
    \node[gtu state, right=of divide, xshift=2cm] (merge) {Merge};

    \draw[gtu arrow] (start) -- (divide);
    \draw[gtu arrow] (divide) -- (left);
    \draw[gtu arrow] (divide) -- (right);
    \draw[gtu arrow] (left) -- (merge);
    \draw[gtu arrow] (right) -- (merge);
\end{tikzpicture}
\end{center}

\begin{center}
\captionof{table}{કોમ્પ્લેક્ષીટી તુલના}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{અલગોરિધમ} & \textbf{સિદ્ધાંત} & \textbf{સરેરાશ ટાઇમ} & \textbf{સ્પેસ} \\ \hline
ક્વીક સોર્ટ & પીવોટની આસપાસ પાર્ટિશનિંગ & O(n log n) & O(log n) \\ \hline
મર્જ સોર્ટ & વિભાજન, જીત, જોડાણ & O(n log n) & O(n) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ક્વીક વિભાજે, મર્જ જોડે}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{પૂર્ણ બાઇનરી ટ્રી ની વ્યાખ્યા આપો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    treenode/.style={circle, draw, minimum size=0.6cm},
    level distance=0.8cm,
    sibling distance=1cm
]
    \node[treenode] {1}
        child {node[treenode] {2}
            child {node[treenode] {4}}
            child {node[treenode] {5}}
        }
        child {node[treenode] {3}
            child {node[treenode] {6}}
        };
\end{tikzpicture}
\captionof{figure}{પૂર્ણ બાઇનરી ટ્રી (Complete Binary Tree)}
\end{center}

\begin{center}
\captionof{table}{પ્રોપર્ટી}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પ્રોપર્ટી} & \textbf{વર્ણન} \\ \hline
બધા લેવલ ભરેલા & છેલ્લા લેવલ સિવાય \\ \hline
છેલ્લુ લેવલ ડાબેથી ભરેલું & નોડ ડાબેથી જમણે એડ થાય \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ડાબેથી જમણે, લેવલ દર લેવલ ભરો}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{બાઇનરી ટ્રી મા ઇનઓર્ડર ટ્રાવર્સલ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    treenode/.style={circle, draw, minimum size=0.6cm},
    level distance=1cm,
    sibling distance=1.5cm
]
    \node[treenode] {A}
        child {node[treenode] {B}
            child {node[treenode] {D}}
            child {node[treenode] {E}}
        }
        child {node[treenode] {C}};
    
    \node[below=2.5cm] {\textbf{Inorder:} $D \rightarrow B \rightarrow E \rightarrow A \rightarrow C$};
\end{tikzpicture}
\captionof{figure}{ઇનઓર્ડર ટ્રાવર્સલ}
\end{center}

\begin{center}
\captionof{table}{અલગોરિધમ સ્ટેપ્સ}
\begin{tabulary}{\linewidth}{|C|L|}
\hline
\textbf{સ્ટેપ} & \textbf{એક્શન} \\ \hline
1 & ડાબા સબટ્રી પર ટ્રાવર્સ કરો \\ \hline
2 & રૂટ નોડની મુલાકાત લો \\ \hline
3 & જમણા સબટ્રી પર ટ્રાવર્સ કરો \\ \hline
\end{tabulary}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
def inorderTraversal(root):
    if root:
        inorderTraversal(root.left)
        print(root.data, end=" -> ")
        inorderTraversal(root.right)
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ડાબું, રૂટ, જમણું}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{બાઇનરી સર્ચ ટ્રી મા નોડ દાખલ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    treenode/.style={circle, draw, minimum size=0.6cm},
    level distance=1cm,
    sibling distance=1.5cm,
    arrow/.style={-latex, dashed, blue}
]
    \node[treenode] (50) {50}
        child {node[treenode] (30) {30}
            child {node[treenode] (20) {20}}
            child {node[treenode] (40) {40}
                child[missing] {}
                child {node[treenode, fill=green!20] (35) {35}}
            }
        }
        child {node[treenode] (70) {70}};
        
    \draw[arrow] (50) to[bend left] (30);
    \draw[arrow] (30) to[bend left] (40);
    \draw[arrow] (40) to[bend left] (35);
    
    \node[right=2cm of 50, align=left] {Insert 35:\\1. 35 < 50 (Left)\\2. 35 > 30 (Right)\\3. 35 < 40 (Left)};
\end{tikzpicture}
\captionof{figure}{ઇન્સર્શન પ્રક્રિયા}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert(root, key):
    if root is None:
        return Node(key)
    
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
        
    return root
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{તુલના કરો, મૂવ કરો, દાખલ કરો}
\end{mnemonicbox}

\questionmarks{5(a) OR}{3}{બાઇનરી સર્ચ ટ્રીની મૂળભૂત ખાસિયતો જણાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{BST ખાસિયતો}
\begin{tabulary}{\linewidth}{|L|}
\hline
\textbf{ખાસિયતો} \\ \hline
1. ડાબા ચાઈલ્ડ નોડ < પેરેન્ટ નોડ \\ \hline
2. જમણા ચાઈલ્ડ નોડ > પેરેન્ટ નોડ \\ \hline
3. ડુપ્લિકેટ વેલ્યુ માન્ય નથી \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ડાબે ઓછું, જમણે વધુ}
\end{mnemonicbox}

\questionmarks{5(b) OR}{4}{બાઇનરી ટ્રી મા પોસ્ટ ઓર્ડર ટ્રાવર્સલ સમજાવો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[
    treenode/.style={circle, draw, minimum size=0.6cm},
    level distance=1cm,
    sibling distance=1.5cm
]
    \node[treenode] {A}
        child {node[treenode] {B}
            child {node[treenode] {D}}
            child {node[treenode] {E}}
        }
        child {node[treenode] {C}};
    
    \node[below=2.5cm] {\textbf{Postorder:} $D \rightarrow E \rightarrow B \rightarrow C \rightarrow A$};
\end{tikzpicture}
\captionof{figure}{પોસ્ટ ઓર્ડર ટ્રાવર્સલ}
\end{center}

\begin{center}
\captionof{table}{સ્ટેપ-બાય-સ્ટેપ}
\begin{tabulary}{\linewidth}{|C|L|}
\hline
\textbf{સ્ટેપ} & \textbf{એક્શન} \\ \hline
1 & ડાબા સબટ્રી પર ટ્રાવર્સ કરો \\ \hline
2 & જમણા સબટ્રી પર ટ્રાવર્સ કરો \\ \hline
3 & રૂટ નોડની મુલાકાત લો \\ \hline
\end{tabulary}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
def postorderTraversal(root):
    if root:
        postorderTraversal(root.left)
        postorderTraversal(root.right)
        print(root.data, end=" -> ")
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ડાબું, જમણું, રૂટ}
\end{mnemonicbox}

\questionmarks{5(c) OR}{7}{બાઇનરી સર્ચ ટ્રી માંથી નોડ ડીલીટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node[gtu block] (start) {Find Node};
    \node[gtu decision, below=of start] (zero) {0 Children?};
    \node[gtu state, right=of zero] (rem) {Remove};
    \node[gtu decision, below=of zero] (one) {1 Child?};
    \node[gtu state, right=of one] (repl) {Replace w/ Child};
    \node[gtu state, below=of one] (succ) {Replace w/ Successor};

    \draw[gtu arrow] (start) -- (zero);
    \draw[gtu arrow] (zero) -- node[above] {Yes} (rem);
    \draw[gtu arrow] (zero) -- node[right] {No} (one);
    \draw[gtu arrow] (one) -- node[above] {Yes} (repl);
    \draw[gtu arrow] (one) -- node[right] {No} (succ);
\end{tikzpicture}
\captionof{figure}{ડીલીશન લોજિક}
\end{center}

\textbf{કોડ:}
\begin{lstlisting}[language=Python]
def minValueNode(node):
    current = node
    while current.left is not None:
        current = current.left
    return current

def deleteNode(root, key):
    if root is None: return root

    if key < root.key:
        root.left = deleteNode(root.left, key)
    elif key > root.key:
        root.right = deleteNode(root.right, key)
    else:
        # Node with only one child or no child
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left

        # Node with two children
        temp = minValueNode(root.right)
        root.key = temp.key
        root.right = deleteNode(root.right, temp.key)

    return root
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ઝીરો: કાઢો, એક: બદલો, બે: સક્સેસર}
\end{mnemonicbox}

\end{document}

