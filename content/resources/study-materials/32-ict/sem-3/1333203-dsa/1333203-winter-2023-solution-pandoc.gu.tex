\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 1333203 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{લીન્કડ લીસ્ટની વ્યાખ્યા આપો. વિવિધ પ્રકારના લિન્ક્ડ લીસ્ટ ની યાદી આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6364}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
લિન્ક્ડ લિસ્ટના પ્રકાર
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લિન્ક્ડ લિસ્ટ એ લીનિયર ડેટા સ્ટ્રક્ચર છે જેમાં એલિમેન્ટ્સ નોડ્સમાં સ્ટોર થાય છે, અને દરેક
નોડ ક્રમમાં આગળના નોડને પોઇન્ટ કરે છે & 1. સિંગલી લિન્ક્ડ લિસ્ટ 2. ડબલી લિન્ક્ડ લિસ્ટ
3. સર્ક્યુલર લિન્ક્ડ લિસ્ટ 4. સર્ક્યુલર ડબલી લિન્ક્ડ લિસ્ટ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Singly:     [Data|Next]  [Data|Next]  [Data|Next]  NULL
Doubly:     [Prev|Data|Next] ⟷ [Prev|Data|Next] ⟷ [Prev|Data|Next]  NULL
Circular:   [Data|Next]  [Data|Next]  [Data|Next] ↩
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``એક, બે, ગોળ, બે-ગોળ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{પાયથનમાં લીનીયર અને નોન-લીનીયર ડેટા સ્ટર્ચર ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3556}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3556}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ડેટા સ્ટ્રક્ચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પાયથન ઉદાહરણો
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લીનીયર & એલિમેન્ટ્સ ક્રમિક રીતે ગોઠવાયેલા હોય છે જેમાં દરેક એલિમેન્ટને એકદમ એક અગાઉનું
અને એક પછીનું એલિમેન્ટ હોય છે (પ્રથમ અને છેલ્લા સિવાય) & Lists:
\texttt{[1,\ 2,\ 3]} Tuples: \texttt{(1,\ 2,\ 3)} Strings:
\texttt{"abc"} Queue: \texttt{queue.Queue()} \\
નોન-લીનીયર & એલિમેન્ટ્સ ક્રમિક રીતે ગોઠવાયેલા નથી; એક એલિમેન્ટ અનેક એલિમેન્ટ્સ સાથે
જોડાઈ શકે છે & Dictionary: \texttt{\{"a":\ 1,\ "b":\ 2\}} Set:
\texttt{\{1,\ 2,\ 3\}} Tree: કસ્ટમ ઇમ્પ્લીમેન્ટેશન Graph: કસ્ટમ ઇમ્પ્લીમેન્ટેશન \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[ડેટા સ્ટ્રક્ચર્સ]
    A {-{-}{} B[લીનીયર]}
    A {-{-}{} C[નોન{-}લીનીયર]}
    B {-{-}{} D[એરે]}
    B {-{-}{} E[લિન્ક્ડ લિસ્ટ]}
    B {-{-}{} F[સ્ટેક]}
    B {-{-}{} G[ક્યુ]}
    C {-{-}{} H[ટ્રી]}
    C {-{-}{} I[ગ્રાફ]}
    C {-{-}{} J[હેશ ટેબલ]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}
``લીનીયર લાઈનમાં, નોન-લીનીયર ચારે બાજુ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{પાયથનમાં ક્લાસ, એટ્રીબ્યુટ, ઓબ્જેક્ટ અને ક્લાસ મેથડ યોગ્ય ઉદાહરણ સાથે
સમજાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
classDiagram
    class Student \{
        {-roll\_no}
        {-name}
        +\_\_init\_\_()
        +display()
    \}
\end{verbatim}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3158}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6842}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શબ્દ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ક્લાસ & ઓબ્જેક્ટ્સ બનાવવા માટેનો બ્લૂપ્રિન્ટ, જેમાં શેર્ડ એટ્રિબ્યુટ્સ અને મેથડ્સ હોય છે \\
એટ્રિબ્યુટ્સ & ક્લાસની અંદર ડેટા સ્ટોર કરતા વેરિએબલ્સ \\
ઓબ્જેક્ટ & ક્લાસનું ઇન્સ્ટન્સ, જેમાં ચોક્કસ એટ્રિબ્યુટ વેલ્યુ હોય છે \\
ક્લાસ મેથડ & ક્લાસની અંદર ડિફાઇન થયેલા ફંક્શન્સ જે ક્લાસની સ્થિતિને એક્સેસ અને મોડિફાય
કરી શકે છે \\
\end{longtable}
}

\textbf{કોડ:}

\begin{verbatim}
class Student:
    \# ક્લાસ એટ્રિબ્યુટ
    school = "GTU"
    
    \# કન્સ્ટ્રક્ટર
    def \_\_init\_\_(self, roll\_no, name):
        \# ઇન્સ્ટન્સ એટ્રિબ્યુટ્સ
        self.roll\_no = roll\_no
        self.name = name
    
    \# ઇન્સ્ટન્સ મેથડ
    def display(self):
        print(f"Roll No: \{self.roll\_no\}, Name: \{self.name\}")
    
    \# ક્લાસ મેથડ
    @classmethod
    def change\_school(cls, new\_school):
        cls.school = new\_school

\# ઓબ્જેક્ટ બનાવવું
student1 = Student(101, "રાજ")
student1.display()  \# આઉટપુટ: Roll No: 101, Name: રાજ
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ક્લાસ બનાવે, એટ્રિબ્યુટ સંગ્રહે, ઓબ્જેક્ટ વાપરે, મેથડ ક્રિયા
કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{ડેટા એન્કેપ્સુલેસન અને પોલી મોર્ફીસમની વ્યાખ્યા આપો. પોલી મોર્ફીસમ સમજાવવા
માટેનો પાયથન કોડ વિકસાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4286}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5714}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કોન્સેપ્ટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેટા એન્કેપ્સુલેસન & ડેટા અને મેથડ્સને એક એકમ (ક્લાસ)માં બંધ કરવા અને કેટલાક કોમ્પોનન્ટ્સને
સીધી એક્સેસથી પ્રતિબંધિત કરવા \\
પોલીમોર્ફિઝમ & વિવિધ ક્લાસને એક જ નામના મેથડનો પોતાનો અમલ પૂરો પાડવાની
ક્ષમતા \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[પોલીમોર્ફિઝમ]
    A {-{-}{} B[મેથડ ઓવરરાઇડિંગ]}
    A {-{-}{} C[મેથડ ઓવરલોડિંગ]}
    A {-{-}{} D[ડક ટાઇપિંગ]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ:}

\begin{verbatim}
\# પોલીમોર્ફિઝમ ઉદાહરણ
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "ભૌં ભૌં!"

class Cat(Animal):
    def speak(self):
        return "મ્યાઉં!"

class Duck(Animal):
    def speak(self):
        return "ક્વેક!"

\# પોલીમોર્ફિઝમ દર્શાવતું ફંક્શન
def animal\_sound(animal):
    return animal.speak()

\# ઓબ્જેક્ટ્સ બનાવવા
dog = Dog()
cat = Cat()
duck = Duck()

\# એક જ ફંક્શન વિવિધ પ્રાણી ઓબ્જેક્ટ્સ માટે કામ કરે છે
print(animal\_sound(dog))   \# આઉટપુટ: ભૌં ભૌં!
print(animal\_sound(cat))   \# આઉટપુટ: મ્યાઉં!
print(animal\_sound(duck))  \# આઉટપુટ: ક્વેક!
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``એન્કેપ્સુલેશન છુપાવે છે, પોલીમોર્ફિઝમ બદલાય છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{સ્ટેક અને ક્યુ નો તફાવત આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3913}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્ટેક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ક્યુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સિદ્ધાંત & LIFO (છેલ્લું આવે પહેલું જાય) & FIFO (પહેલું આવે પહેલું જાય) \\
ઓપરેશન & પુશ, પોપ & એનક્યુ, ડિક્યુ \\
એક્સેસ & એલિમેન્ટ્સ ફક્ત એક છેડેથી ઉમેરાય/દૂર થાય છે (ટોપ) & એલિમેન્ટ્સ છેલ્લે ઉમેરાય છે અને
આગળથી દૂર થાય છે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Stack:       [3]      Queue:  [1]  [2]  [3]
             [2]              Front      Rear
             [1]      
             {-{-}{-}}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``સ્ટેક ઉપરનું પહેલા, ક્યુ આગળનું પહેલા''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{પુશ અને પોપ ઓપરેશન માટેનો અલ્ગોરીધમ લખો.}

\begin{solutionbox}

\textbf{PUSH અલ્ગોરિધમ:}

\begin{verbatim}
શરુઆત
  1. ચેક કરો કે સ્ટેક ભરેલો છે કે નહીં
  2. જો ભરેલો ન હોય, તો top ને 1 વધારો
  3. {top પોઝિશન પર એલિમેન્ટ ઉમેરો}
સમાપ્ત
\end{verbatim}

\textbf{POP અલ્ગોરિધમ:}

\begin{verbatim}
શરુઆત
  1. ચેક કરો કે સ્ટેક ખાલી છે કે નહીં
  2. જો ખાલી ન હોય, તો {top પરના એલિમેન્ટને લો}
  3. top ને 1 ઘટાડો
  4. મેળવેલ એલિમેન્ટ પાછો આપો
સમાપ્ત
\end{verbatim}

\textbf{કોડ:}

\begin{verbatim}
class Stack:
    def \_\_init\_\_(self, size):
        self.stack = []
        self.size = size
        self.top = {-}1
    
    def push(self, element):
        if self.top {=} self.size {-} 1:
            return "Stack Overflow"
        else:
            self.top += 1
            self.stack.append(element)
            return "Pushed " + str(element)
    
    def pop(self):
        if self.top {} 0:
            return "Stack Underflow"
        else:
            element = self.stack.pop()
            self.top {-=} 1
            return element
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ટોપ પર પુશ, ટોપથી પોપ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{નીચે. આપેલ સમીકરણ ને ઇન્ફીક્સ માંથી પોસ્ટફિક્ષ માં બદલો.} \textbf{A * (B
+ C) - D / (E + F)}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Infix:   A * (B + C) {- D / (E + F)}
Postfix: A B C + * D E F + / {-}
\end{verbatim}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
સ્ટેપ & સિમ્બોલ & સ્ટેક & આઉટપુટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & A & & A \\
2 & * & * & A \\
3 & ( & * ( & A \\
4 & B & * ( & A B \\
5 & + & * ( + & A B \\
6 & C & * ( + & A B C \\
7 & ) & * & A B C + \\
8 & - & - & A B C + * \\
9 & D & - & A B C + * D \\
10 & / & - / & A B C + * D \\
11 & ( & - / ( & A B C + * D \\
12 & E & - / ( & A B C + * D E \\
13 & + & - / ( + & A B C + * D E \\
14 & F & - / ( + & A B C + * D E F \\
15 & ) & - / & A B C + * D E F + \\
16 & end & & A B C + * D E F + / - \\
\end{longtable}
}

\end{solutionbox}
\begin{solutionbox}
\texttt{A\ B\ C\ +\ *\ D\ E\ F\ +\ /\ -}

\end{solutionbox}
\begin{mnemonicbox}
``ઓપરેટર સ્ટેક પર, ઓપરન્ડ સીધા પ્રિન્ટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{સિમ્પલ ક્યુ અને સર્ક્યુલર ક્યુ નો તફાવત આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3590}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4103}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિમ્પલ ક્યુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સર્ક્યુલર ક્યુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સ્ટ્રક્ચર & લીનિયર ડેટા સ્ટ્રક્ચર & જોડાયેલા છેડાવાળો લીનિયર ડેટા સ્ટ્રક્ચર \\
મેમરી & ડિક્યુ પછી ખાલી જગ્યાઓને કારણે અકાર્યક્ષમ મેમરી વપરાશ & ખાલી જગ્યાઓનો
ફરીથી ઉપયોગ કરીને કાર્યક્ષમ મેમરી વપરાશ \\
ઇમ્પ્લિમેન્ટેશન & ફ્રન્ટ હંમેશા ઇન્ડેક્સ 0 પર, રીયર વધે & ફ્રન્ટ અને રીયર મોડ્યુલો ઓપરેશન
સાથે સર્ક્યુલર રીતે ફરે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[સિમ્પલ ક્યુ] {-{-}{} B[ફ્રન્ટ]}
    B {-{-}{} C[...]}
    C {-{-}{} D[રીયર]}

    E[સર્ક્યુલર ક્યુ] {-{-}{} F[ફ્રન્ટ]}
    F {-{-}{} G[...]}
    G {-{-}{} H[રીયર]}
    H {-{-}{} F}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}
``સાદી વેડફે, ગોળ ફરીથી વાપરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{રીકસીવ ફંક્શનનો કોન્સેપ્ટ યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મુખ્ય પાસાઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
વ્યાખ્યા & એવું ફંક્શન જે એક જ સમસ્યાના નાના ભાગને હલ કરવા માટે પોતાને જ કોલ કરે
છે \\
બેઝ કેસ & એવી સ્થિતિ જ્યાં ફંક્શન પોતાને કોલ કરવાનું બંધ કરે છે \\
રિકર્સિવ કેસ & એવી સ્થિતિ જ્યાં ફંક્શન સમસ્યાના સરળ સ્વરૂપ સાથે પોતાને કોલ કરે છે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A["factorial(3)"] {-{-}{} B["3 * factorial(2)"]}
    B {-{-}{} C["3 * 2 * factorial(1)"]}
    C {-{-}{} D["3 * 2 * 1 * factorial(0)"]}
    D {-{-}{} E[3 * 2 * 1 * 1]}
    E {-{-}{} F[3 * 2 * 1]}
    F {-{-}{} G[3 * 2]}
    G {-{-}{} H[6]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ:}

\begin{verbatim}
def factorial(n):
    \# બેઝ કેસ
if

n == 0:

        return 1
    \# રિકર્સિવ કેસ
    else:
        return n * factorial(n{-}1)

\# ઉદાહરણ
result = factorial(5)  \# 5! = 120
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``બેઝ તોડે, રિકર્શન પાછું આપે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{Enqueue અને Dequeue ઓપરેશન માટેનો પાયથન કોડ વિકસાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Enqueue:
  [1][2][3]  [1][2][3][4]
  
Dequeue:
  [1][2][3][4]  [2][3][4]
\end{verbatim}

\textbf{કોડ:}

\begin{verbatim}
class Queue:
    def \_\_init\_\_(self, size):
        self.queue = []
        self.size = size
        self.front = 0
        self.rear = {-}1
        self.count = 0
    
    def enqueue(self, item):
        if self.count {=} self.size:
            return "ક્યુ ભરેલી છે"
        else:
            self.rear += 1
            self.queue.append(item)
            self.count += 1
            return "Enqueued " + str(item)
    
    def dequeue(self):
        if self.count {=} 0:
            return "ક્યુ ખાલી છે"
        else:
            item = self.queue.pop(0)
            self.count {-=} 1
            return item
    
    def display(self):
        return self.queue

\# ટેસ્ટ
q = Queue(5)
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)
print(q.display())  \# [10, 20, 30]
print(q.dequeue())  \# 10
print(q.display())  \# [20, 30]
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``છેડે ઉમેરો, શરૂઆતથી કાઢો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{સીન્ગલી લિન્ક્ડ લીસ્ટ અને સર્ક્યુલર લિન્ક્ડ લીસ્ટ નો તફાવત આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફીચર & સિંગલી લિન્ક્ડ લિસ્ટ & સર્ક્યુલર લિન્ક્ડ લિસ્ટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
છેલ્લો નોડ & NULL તરફ પોઇન્ટ કરે છે & પહેલા નોડ તરફ પાછો પોઇન્ટ કરે છે \\
ટ્રાવર્સલ & ચોક્કસ અંત ધરાવે છે & સતત ટ્રાવર્સ કરી શકાય છે \\
મેમરી & દરેક નોડને એક પોઇન્ટર જોઈએ & દરેક નોડને એક પોઇન્ટર જોઈએ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Singly:   [1]  [2]  [3]  NULL
Circular: [1]  [2]  [3]  ↩
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``સિંગલી અટકે, સર્ક્યુલર ફરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{ડબલી લિન્ક્ડ લીસ્ટ નો કોન્સેપ્ટ સમજાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
NULL  [Prev|1|Next] ⟷ [Prev|2|Next] ⟷ [Prev|3|Next]  NULL
\end{verbatim}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફીચર & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
નોડ સ્ટ્રક્ચર & દરેક નોડમાં ડેટા અને બે પોઇન્ટર્સ (previous અને next) હોય છે \\
નેવિગેશન & આગળ અને પાછળ એમ બંને દિશામાં ટ્રાવર્સ કરી શકાય છે \\
ઓપરેશન્સ & બંને છેડેથી ઇન્સર્શન અને ડિલીશન કરી શકાય છે \\
મેમરી વપરાશ & વધારાના પોઇન્ટરને કારણે સિંગલી લિન્ક્ડ લિસ્ટ કરતા વધુ મેમરી જોઈએ \\
\end{longtable}
}

\textbf{કોડ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.prev = None
        self.next = None
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``બે પોઇન્ટર, બે દિશા''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{નીચે આપેલ ઓપરેશન માટે અલગોરિધમ લખો:} \textbf{૧. લીસ્ટ ની શરૂઆતમાં નોડ
દાખલ કરવા} \textbf{૨. લીસ્ટ ના અંતમાં નોડ દાખલ કરવા}

\begin{solutionbox}

\textbf{શરૂઆતમાં ઇન્સર્ટ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[શરૂ] {-{-}{} B[નવો નોડ બનાવો]}
    B {-{-}{} C[નવા નોડનો ડેટા સેટ કરો]}
    C {-{-}{} D[નવા નોડનો next હેડ પર સેટ કરો]}
    D {-{-}{} E[હેડને નવા નોડ પર સેટ કરો]}
    E {-{-}{} F[અંત]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{અંતે ઇન્સર્ટ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[શરૂ] {-{-}{} B[નવો નોડ બનાવો]}
    B {-{-}{} C[નવા નોડનો ડેટા સેટ કરો]}
    C {-{-}{} D[નવા નોડનો next NULL પર સેટ કરો]}
    D {-{-}{} E\{શું head NULL છે?\}}
    E {-{-}{}|હા| F[head ને નવા નોડ પર સેટ કરો]}
    E {-{-}{}|ના| G[છેલ્લા નોડ સુધી ટ્રાવર્સ કરો]}
    G {-{-}{} H[છેલ્લા નોડનો next નવા નોડ પર સેટ કરો]}
    F {-{-}{} I[અંત]}
    H {-{-}{} I}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ:}

\begin{verbatim}
def insert\_at\_beginning(head, data):
    new\_node = Node(data)
    new\_node.next = head
    return new\_node  \# નવો head

def insert\_at\_end(head, data):
    new\_node = Node(data)
    new\_node.next = None
    
    \# જો લિન્ક્ડ લિસ્ટ ખાલી હોય
    if head is None:
        return new\_node
    
    \# છેલ્લા નોડ સુધી ટ્રાવર્સ કરો
    temp = head
    while temp.next:
        temp = temp.next
    
    \# છેલ્લા નોડને નવા નોડ સાથે જોડો
    temp.next = new\_node
    return head
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``શરૂઆત: નવો જૂનાને આગળ કરે, અંત: જૂનો નવાને આગળ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{સીન્ગલી લિન્ક્ડ લીસ્ટ પરના વિવિધ ઓપરેશન ની યાદી આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
સિંગલી લિન્ક્ડ લિસ્ટ પરના ઓપરેશન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. ઇન્સર્શન (શરૂઆતમાં, મધ્યમાં, અંતે) \\
2. ડિલીશન (શરૂઆતથી, મધ્યમાંથી, અંતથી) \\
3. ટ્રાવર્સલ (દરેક નોડની મુલાકાત) \\
4. શોધ (ચોક્કસ નોડ શોધવો) \\
5. અપડેટિંગ (નોડ ડેટા બદલવો) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[લિન્ક્ડ લિસ્ટ ઓપરેશન]
    A {-{-}{} B[ઇન્સર્શન]}
    A {-{-}{} C[ડિલિશન]}
    A {-{-}{} D[ટ્રાવર્સલ]}
    A {-{-}{} E[શોધ]}
    A {-{-}{} F[અપડેટિંગ]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}
``ઉમેરો કાઢો ફરો શોધો બદલો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{સર્ક્યુલર લિન્ક્ડ લીસ્ટ નો કોન્સેપ્ટ સમજાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
    ↗{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}↘}
   /             {}
  ↓               ↓
[1]  [2]  [3]  [4]
\end{verbatim}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4091}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5909}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સ્ટ્રક્ચર & છેલ્લો નોડ NULL ને બદલે પહેલા નોડને પોઇન્ટ કરે છે \\
ફાયદો & બધા નોડમાં સતત ટ્રાવર્સલની અનુમતિ આપે છે \\
એપ્લિકેશન & રાઉન્ડ રોબિન શેડ્યુલિંગ, સર્ક્યુલર બફર ઇમ્પ્લિમેન્ટેશન \\
ઓપરેશન & છેલ્લા નોડ માટે ખાસ હેન્ડલિંગ સાથે સિંગલી લિન્ક્ડ લિસ્ટ જેવા ઇન્સર્શન અને
ડિલીશન \\
\end{longtable}
}

\textbf{કોડ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

\# 3 નોડવાળી સર્ક્યુલર લિન્ક્ડ લિસ્ટ બનાવવી
head = Node(1)
node2 = Node(2)
node3 = Node(3)

head.next = node2
node2.next = node3
node3.next = head  \# તેને સર્ક્યુલર બનાવે છે
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``છેલ્લો પહેલાને જોડે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{લિન્ક્ડ લીસ્ટની એપ્લીકેશનોની યાદી આપો. સીન્ગલી લિન્ક્ડ લીસ્ટમાં કુલ નોડ
ગણવા માટેનો અલગોરિધમ લખો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
લિન્ક્ડ લિસ્ટની એપ્લિકેશન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. સ્ટેક અને ક્યુનો અમલીકરણ \\
2. ડાયનેમિક મેમરી એલોકેશન \\
3. એપ્લિકેશનમાં અન્ડુ ફંક્શનાલિટી \\
4. હેશ ટેબલ્સ (ચેઇનિંગ) \\
5. ગ્રાફ્સ માટે એડજસન્સી લિસ્ટ \\
\end{longtable}
}

\textbf{નોડ ગણવા માટેનો અલ્ગોરિધમ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[શરૂ] {-{-}{} B[count = 0 થી શરૂ કરો]}
    B {-{-}{} C[temp = head સેટ કરો]}
    C {-{-}{} D\{temp != NULL?\}}
    D {-{-}{}|હા| E[count વધારો]}
    D {-{-}{}|ના| F[count પાછું આપો]}
    E {-{-}{} G[temp = temp.next]}
    G {-{-}{} D}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ:}

\begin{verbatim}
def count\_nodes(head):
    count = 0
    temp = head
    
    while temp:
        count += 1
        temp = temp.next
    
    return count

\# ઉદાહરણ
\# ધારી લો કે head લિન્ક્ડ લિસ્ટના પ્રથમ નોડને પોઇન્ટ કરે છે
total\_nodes = count\_nodes(head)
print(f"કુલ નોડ: \{total\_nodes\}")
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ગણો ત્યારે ખસો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{લીનીયર સર્ચ અને બાયનરી સર્ચની સરખામણી કરો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3684}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3947}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
લીનીયર સર્ચ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
બાયનરી સર્ચ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેટા ગોઠવણ & સોર્ટેડ અને અનસોર્ટેડ બંને ડેટા પર કામ કરે છે & ફક્ત સોર્ટેડ ડેટા પર કામ
કરે છે \\
ટાઇમ કોમ્પ્લેક્સિટી & O(n) & O(log n) \\
ઇમ્પ્લિમેન્ટેશન & સરળ & વધુ જટિલ \\
શેના માટે શ્રેષ્ઠ & નાના ડેટાસેટ અથવા અનસોર્ટેડ ડેટા & મોટા સોર્ટેડ ડેટાસેટ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Linear: [1] [2] [3] [4] [5] [6] [7] [8]
        ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
        ક્રમવાર ચેક કરવું

Binary: [1] [2] [3] [4] [5] [6] [7] [8]
                    ↓
                 મધ્ય ચેક
                /     {}
               /       {}
         નીચો ભાગ    ઉપરનો ભાગ
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``લીનીયર બધું જુએ, બાઈનરી આધું કાપે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{સિલેકશન સોર્ટ માટેનો અલગોરિધમ લખો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Initial: [5, 3, 8, 1, 2]
Pass 1:  [1, 3, 8, 5, 2]  (min = 1 શોધો, 5 સાથે સ્વેપ)
Pass 2:  [1, 2, 8, 5, 3]  (min = 2 શોધો, 3 સાથે સ્વેપ)
Pass 3:  [1, 2, 3, 5, 8]  (min = 3 શોધો, 8 સાથે સ્વેપ)
Pass 4:  [1, 2, 3, 5, 8]  (min = 5 શોધો, જગ્યા પર છે જ)
\end{verbatim}

\textbf{અલ્ગોરિધમ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[શરૂ] {-{-}{} B[i = 0 થી n{-}1 સુધી]}
    B {-{-}{} C[અનસોર્ટેડ ભાગમાં લઘુતમ એલિમેન્ટ શોધો]}
    C {-{-}{} D[લઘુતમને અનસોર્ટેડ ભાગના પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરો]}
    D {-{-}{} E[અંત]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડનો ઢાંચો:}

\begin{verbatim}
def selection\_sort(arr):
    n = len(arr)
    
    for i in range(n):
        min\_idx = i
        
        \# અનસોર્ટેડ એરેમાં લઘુતમ એલિમેન્ટ શોધો
        for j in range(i+1, n):
            if arr[j] {} arr[min\_idx]:
                min\_idx = j
        
        \# શોધેલા લઘુતમ એલિમેન્ટને પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરો
        arr[i], arr[min\_idx] = arr[min\_idx], arr[i]
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``લઘુતમ શોધો, પોઝિશન બદલો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{નીચે આપેલા લીસ્ટ ને બબલ સોર્ટ મેથડ વડે ચઢતા ક્રમમાં ગોઠવવા માટેનો પાયથન
કોડ વિકસાવો.} \textbf{list1=[5,4,3,2,1,0]}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Initial: [5, 4, 3, 2, 1, 0]
Pass 1:  [4, 3, 2, 1, 0, 5]
Pass 2:  [3, 2, 1, 0, 4, 5]
Pass 3:  [2, 1, 0, 3, 4, 5]
Pass 4:  [1, 0, 2, 3, 4, 5]
Pass 5:  [0, 1, 2, 3, 4, 5]
\end{verbatim}

\textbf{કોડ:}

\begin{verbatim}
def bubble\_sort(arr):
    n = len(arr)
    
    \# બધા એરે એલિમેન્ટ્સ પર ટ્રાવર્સ કરો
    for i in range(n):
        \# છેલ્લા i એલિમેન્ટ્સ પહેલેથી જ યોગ્ય જગ્યા પર છે
        for j in range(0, n{-}i{-}1):
            \# જો વર્તમાન એલિમેન્ટ આગળના એલિમેન્ટ કરતાં મોટો હોય, તો સ્વેપ કરો
            if arr[j] {} arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

\# ઇનપુટ લિસ્ટ
list1 = [5, 4, 3, 2, 1, 0]

\# લિસ્ટ સોર્ટ કરવી
sorted\_list = bubble\_sort(list1)

\# રિઝલ્ટ ડિસ્પ્લે કરવું
print("સોર્ટેડ લિસ્ટ:", sorted\_list)
\# આઉટપુટ: સોર્ટેડ લિસ્ટ: [0, 1, 2, 3, 4, 5]
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``મોટા બબલ ઉપર જાય''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{સોર્ટિંગ ની વ્યાખ્યા આપો. વિવિધ પ્રકારના સોર્ટિંગ ની યાદી આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4138}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5862}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સોર્ટિંગ મેથડ્સ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સોર્ટિંગ એટલે ડેટાને ચોક્કસ ક્રમમાં (ચઢતા અથવા ઉતરતા) ગોઠવવાની પ્રક્રિયા & 1. બબલ
સોર્ટ 2. સિલેક્શન સોર્ટ 3. ઇન્સર્શન સોર્ટ 4. મર્જ સોર્ટ 5. ક્વિક સોર્ટ 6. હીપ સોર્ટ
7. રેડિક્સ સોર્ટ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[સોર્ટિંગ અલ્ગોરિધમ]
    A {-{-}{} B[કમ્પેરિઝન{-}બેઝ્ડ]}
    A {-{-}{} C[નોન{-}કમ્પેરિઝન]}
    B {-{-}{} D[બબલ સોર્ટ]}
    B {-{-}{} E[સિલેક્શન સોર્ટ]}
    B {-{-}{} F[ઇન્સર્શન સોર્ટ]}
    B {-{-}{} G[મર્જ સોર્ટ]}
    B {-{-}{} H[ક્વિક સોર્ટ]}
    C {-{-}{} I[કાઉન્ટિંગ સોર્ટ]}
    C {-{-}{} J[રેડિક્સ સોર્ટ]}
    C {-{-}{} K[બકેટ સોર્ટ]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}
``સારા સોર્ટથી શોધવાનું સરળ બને''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{Insertion sort method નો અલગોરિધમ લખો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Initial: [5, 2, 4, 6, 1, 3]
Pass 1:  [2, 5, 4, 6, 1, 3]  (2 ને 5 પહેલા મૂકો)
Pass 2:  [2, 4, 5, 6, 1, 3]  (4 ને 5 પહેલા મૂકો)
Pass 3:  [2, 4, 5, 6, 1, 3]  (6 પહેલેથી જગ્યા પર છે)
Pass 4:  [1, 2, 4, 5, 6, 3]  (1 ને શરૂઆતમાં મૂકો)
Pass 5:  [1, 2, 3, 4, 5, 6]  (3 ને 2 પછી મૂકો)
\end{verbatim}

\textbf{અલ્ગોરિધમ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[શરૂ] {-{-}{} B[i = 1 થી n{-}1 સુધી]}
    B {-{-}{} C["key = arr[i] સેટ કરો"]}
    C {-{-}{} D[j = i{-}1 સેટ કરો]}
    D {-{-}{} E\{"j {}= 0 અને arr[j] {} key?"\}}
    E {-{-}{}|હા| F[એલિમેન્ટ જમણી તરફ ખસેડો]}
    F {-{-}{} G[j ઘટાડો]}
    G {-{-}{} E}
    E {-{-}{}|ના| H[key ને યોગ્ય પોઝિશન પર મૂકો]}
    H {-{-}{} I[અંત]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડનો ઢાંચો:}

\begin{verbatim}
def insertion\_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i {-} 1
        
        \# key કરતાં મોટા એલિમેન્ટ્સને એક પોઝિશન આગળ ખસેડો
        while j {=} 0 and arr[j] {} key:
            arr[j + 1] = arr[j]
            j {-=} 1
        
        arr[j + 1] = key
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``કાર્ડ લો, યોગ્ય ક્રમમાં મૂકો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{નીચે આપેલા લીસ્ટ ને સિલેકશન સોર્ટ મેથડ વડે ચઢતા ક્રમમાં ગોઠવવા માટેનો પાયથન
કોડ વિકસાવો.} \textbf{list1=[6,3,25,8,-1,55,0]}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Initial: [6, 3, 25, 8, {-1, 55, 0]}
Pass 1:  [{-1, 3, 25, 8, 6, 55, 0]  (min = {-}1 શોધો, 6 સાથે સ્વેપ)}
Pass 2:  [{-1, 0, 25, 8, 6, 55, 3]  (min = 0 શોધો, 3 સાથે સ્વેપ)}
Pass 3:  [{-1, 0, 3, 8, 6, 55, 25]  (min = 3 શોધો, 25 સાથે સ્વેપ)}
Pass 4:  [{-1, 0, 3, 6, 8, 55, 25]  (min = 6 શોધો, 8 સાથે સ્વેપ)}
Pass 5:  [{-1, 0, 3, 6, 8, 55, 25]  (min = 8 શોધો, પહેલેથી જગ્યા પર છે)}
Pass 6:  [{-1, 0, 3, 6, 8, 25, 55]  (min = 25 શોધો, 55 સાથે સ્વેપ)}
\end{verbatim}

\textbf{કોડ:}

\begin{verbatim}
def selection\_sort(arr):
    n = len(arr)
    
    for i in range(n):
        \# બાકીના અનસોર્ટેડ એરેમાં લઘુતમ એલિમેન્ટ શોધો
        min\_idx = i
        for j in range(i+1, n):
            if arr[j] {} arr[min\_idx]:
                min\_idx = j
                
        \# શોધેલા લઘુતમ એલિમેન્ટને પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરો
        arr[i], arr[min\_idx] = arr[min\_idx], arr[i]
    
    return arr

\# ઇનપુટ લિસ્ટ
list1 = [6, 3, 25, 8, {-}1, 55, 0]

\# લિસ્ટ સોર્ટ કરવી
sorted\_list = selection\_sort(list1)

\# રિઝલ્ટ ડિસ્પ્લે કરવું
print("સોર્ટેડ લિસ્ટ:", sorted\_list)
\# આઉટપુટ: સોર્ટેડ લિસ્ટ: [{-1, 0, 3, 6, 8, 25, 55]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``નાનામાં નાનું શોધો, આગળ મૂકો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{Tree data structure ને લગતા નીચે આપેલ પદોની વ્યાખ્યા આપો.} \textbf{1.
Forest} \textbf{2. Root node} \textbf{3. Leaf node}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Forest & અલગ-અલગ ટ્રીઓનો સમૂહ (ટ્રીઓ વચ્ચે કોઈ જોડાણ નથી) \\
Root Node & ટ્રીનો સૌથી ઉપરનો નોડ જેનો કોઈ પેરેન્ટ નથી, જેનાથી બધા બીજા નોડ્સ
ઉતરે છે \\
Leaf Node & એવો નોડ જેને કોઈ ચિલ્ડ્રન નથી (ટ્રીના તળિયે આવેલો ટર્મિનલ નોડ) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
Forest:    Tree1    Tree2    Tree3
           /  {      /       |}
          /    {    /        |}
         
Root:     [R]
         /   {}
        /     {}
        
Leaf:  [A]  [B]  [L]  [L]
                    કોઈ ચિલ્ડ્રન નથી
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ફોરેસ્ટમાં ઘણા રૂટ, રૂટથી બધું શરૂ, લીફ્સ બધું પૂરું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{78,58,82,15,66,80,99 માટે Binary search tree દોરો અને તે tree માટેનું
In-order traversal લખો.}

\begin{solutionbox}

\textbf{બાઈનરી સર્ચ ટ્રી:}

\begin{verbatim}
          78
         /  {}
        /    {}
      58      82
     /  {    /  }
   15   66  80   99
\end{verbatim}

\textbf{ઇન-ઓર્ડર ટ્રાવર્સલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
સ્ટેપ & વિઝિટ ક્રમ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 78 ના ડાબા સબટ્રી પર જાઓ \\
2 & 58 ના ડાબા સબટ્રી પર જાઓ \\
3 & 15 ને વિઝિટ કરો \\
4 & 58 ને વિઝિટ કરો \\
5 & 66 ને વિઝિટ કરો \\
6 & 78 ને વિઝિટ કરો \\
7 & 82 ના ડાબા સબટ્રી પર જાઓ \\
8 & 80 ને વિઝિટ કરો \\
9 & 82 ને વિઝિટ કરો \\
10 & 99 ને વિઝિટ કરો \\
\end{longtable}
}

\textbf{ઇન-ઓર્ડર ટ્રાવર્સલ રિઝલ્ટ: 15, 58, 66, 78, 80, 82, 99}

\end{solutionbox}
\begin{mnemonicbox}
``ડાબું, રૂટ, જમણું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{નીચે આપેલ ઓપરેશન માટે અલગોરિધમ લખો:} \textbf{૧. Binary Tree માં નોડ
દાખલ કરવા} \textbf{૨. Binary Tree માંથી નોડ કાઢવા માટે}

\begin{solutionbox}

\textbf{ઇન્સર્શન અલ્ગોરિધમ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[શરૂ] {-{-}{} B[આપેલ ડેટા સાથે નવો નોડ બનાવો]}
    B {-{-}{} C\{શું root NULL છે?\}}
    C {-{-}{}|હા| D[root ને નવા નોડ પર સેટ કરો]}
    C {-{-}{}|ના| E[લેવલ ઓર્ડર ટ્રાવર્સલનો ઉપયોગ કરી પોઝિશન શોધો]}
    E {-{-}{} F[પ્રથમ ખાલી પોઝિશન પર નોડ ઉમેરો]}
    D {-{-}{} G[અંત]}
    F {-{-}{} G}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{ડિલીશન અલ્ગોરિધમ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[શરૂ] {-{-}{} B\{શું ટ્રી ખાલી છે?\}}
    B {-{-}{}|હા| C[રિટર્ન]}
    B {-{-}{}|ના| D[ડિલીટ કરવાના નોડને શોધો]}
    D {-{-}{} E[સૌથી ઊંડા જમણા નોડને શોધો]}
    E {-{-}{} F[ડિલીટ કરવાના નોડની જગ્યાએ ઊંડા જમણા નોડને મૂકો]}
    F {-{-}{} G[ઊંડા જમણા નોડને ડિલીટ કરો]}
    C {-{-}{} H[અંત]}
    G {-{-}{} H}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.left = None
        self.right = None

\# Binary Tree માં ઇન્સર્શન
def insert(root, data):
    if root is None:
        return Node(data)
    
    \# લેવલ ઓર્ડર ટ્રાવર્સલથી ખાલી પોઝિશન શોધવી
    queue = []
    queue.append(root)
    
    while queue:
        temp = queue.pop(0)
        
        if temp.left is None:
            temp.left = Node(data)
            break
        else:
            queue.append(temp.left)
            
        if temp.right is None:
            temp.right = Node(data)
            break
        else:
            queue.append(temp.right)
    
    return root

\# Binary Tree માંથી ડિલીશન
def delete\_node(root, key):
    if root is None:
        return None
    
    if root.left is None and root.right is None:
        if root.data == key:
            return None
        else:
            return root
    
    \# ડિલીટ કરવાના નોડને શોધો
    key\_node = None
    \# છેવટના નોડને શોધો
    last = None
    parent = None
    
    \# લેવલ ઓર્ડર ટ્રાવર્સલ
    queue = []
    queue.append(root)
    
    while queue:
        temp = queue.pop(0)
        
        if temp.data == key:
            key\_node = temp
            
        if temp.left:
            parent = temp
            queue.append(temp.left)
            last = temp.left
            
        if temp.right:
            parent = temp
            queue.append(temp.right)
            last = temp.right
    
    if key\_node:
        \# છેવટના નોડના ડેટા સાથે બદલો
        key\_node.data = last.data
        
        \# છેવટના નોડને ડિલીટ કરો
        if parent.right == last:
            parent.right = None
        else:
            parent.left = None
    
    return root
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ખાલી જગ્યાએ ઉમેરો, બદલીને કાઢો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{Tree data structure ને લગતા નીચે આપેલ પદોની વ્યાખ્યા આપો.} \textbf{1.
In-degree} \textbf{2. Out-degree} \textbf{3. Depth}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
In-degree & નોડમાં આવતી એજ્જીસની સંખ્યા (ટ્રીમાં પ્રત્યેક નોડ માટે (રૂટ સિવાય) હંમેશા
1 હોય છે) \\
Out-degree & નોડમાંથી બહાર જતી એજ્જીસની સંખ્યા (નોડના ચિલ્ડ્રનની સંખ્યા) \\
Depth & રૂટથી નોડ સુધીના પાથની લંબાઈ (પાથમાં એજ્જીસની સંખ્યા) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
        A (રૂટ, ડેપ્થ 0)
       / {}
      /   {}
     B     C (ડેપ્થ 1)
    / {     }
   D   E     F (ડેપ્થ 2)
\end{verbatim}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
નોડ & In-degree & Out-degree \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & 0 & 2 \\
B & 1 & 2 \\
C & 1 & 1 \\
D & 1 & 0 \\
E & 1 & 0 \\
F & 1 & 0 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ઈન કાઉન્ટ્સ પેરેન્ટ્સ, આઉટ કાઉન્ટ્સ ચિલ્ડ્રન, ડેપ્થ કાઉન્ટ્સ
એજ્જીસ ફ્રોમ રૂટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{નીચે દર્શાવેલા Binary tree માટે Preorder and postorder traversal
લખો.}

\textbf{બાઈનરી ટ્રી:}

\begin{verbatim}
        100
       /   {}
      /     {}
    20      200
   /  {     /  }
  10   30  150  300
\end{verbatim}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ટ્રાવર્સલ & ક્રમ & રિઝલ્ટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Preorder & રૂટ, ડાબું, જમણું & 100, 20, 10, 30, 200, 150, 300 \\
Postorder & ડાબું, જમણું, રૂટ & 10, 30, 20, 150, 300, 200, 100 \\
\end{longtable}
}

\textbf{પ્રીઓર્ડર વિઝ્યુઅલાઈઝેશન:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[100] {-{-}{} B[100 વિઝિટ કરો]}
    B {-{-}{} C[ડાબા સબટ્રી પર જાઓ]}
    C {-{-}{} D[20 વિઝિટ કરો]}
    D {-{-}{} E[10 વિઝિટ કરો]}
    E {-{-}{} F[30 વિઝિટ કરો]}
    F {-{-}{} G[જમણા સબટ્રી પર જાઓ]}
    G {-{-}{} H[200 વિઝિટ કરો]}
    H {-{-}{} I[150 વિઝિટ કરો]}
    I {-{-}{} J[300 વિઝિટ કરો]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{પોસ્ટઓર્ડર વિઝ્યુઅલાઈઝેશન:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[100] {-{-}{} B[ડાબા સબટ્રી પર જાઓ]}
    B {-{-}{} C[10 વિઝિટ કરો]}
    C {-{-}{} D[30 વિઝિટ કરો]}
    D {-{-}{} E[20 વિઝિટ કરો]}
    E {-{-}{} F[જમણા સબટ્રી પર જાઓ]}
    F {-{-}{} G[150 વિઝિટ કરો]}
    G {-{-}{} H[300 વિઝિટ કરો]}
    H {-{-}{} I[200 વિઝિટ કરો]}
    I {-{-}{} J[100 વિઝિટ કરો]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}

\begin{itemize}
\tightlist
\item
  પ્રીઓર્ડર: ``રૂટ પહેલા, પછી બાળકો''
\item
  પોસ્ટઓર્ડર: ``બાળકો પહેલા, પછી રૂટ''
\end{itemize}

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{Binary Search Tree રચવા માટેનો પાયથન કોડ વિકસાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[રૂટ] {-{-}{}|50 ઉમેરો| B[50]}
    B {-{-}{}|30 ઉમેરો| C[50]}
    C {-.{-}{} D[30]}
    C {-{-}{}|70 ઉમેરો| E[50]}
    E {-.{-}{} F[30]}
    E {-{-}{} G[70]}
    G {-{-}{}|20 ઉમેરો| H[50]}
    H {-.{-}{} I[30]}
    I {-.{-}{} J[20]}
    H {-{-}{} K[70]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{કોડ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert(root, key):
    \# જો ટ્રી ખાલી હોય, તો નવો નોડ પાછો આપો
    if root is None:
        return Node(key)
    
    \# અન્યથા, ટ્રીમાં નીચે જાઓ
    if key {} root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    
    \# અબદાયેલ નોડ પોઈન્ટર પાછો આપો
    return root

def inorder(root):
    if root:
        inorder(root.left)
        print(root.key, end=" ")
        inorder(root.right)

def preorder(root):
    if root:
        print(root.key, end=" ")
        preorder(root.left)
        preorder(root.right)

def postorder(root):
    if root:
        postorder(root.left)
        postorder(root.right)
        print(root.key, end=" ")

\# ટેસ્ટ માટેનો પ્રોગ્રામ
def main():
    \# આ એલિમેન્ટ્સ સાથે BST બનાવો: 50, 30, 20, 40, 70, 60, 80
    root = None
    elements = [50, 30, 20, 40, 70, 60, 80]
    
    for element in elements:
        root = insert(root, element)
    
    \# ટ્રાવર્સલ્સ પ્રિન્ટ કરો
    print("ઇનઓર્ડર ટ્રાવર્સલ: ", end="")
    inorder(root)
    print("{n}પ્રીઓર્ડર ટ્રાવર્સલ: ", end="")
    preorder(root)
    print("{n}પોસ્ટઓર્ડર ટ્રાવર્સલ: ", end="")
    postorder(root)

\# પ્રોગ્રામ ચલાવો
main()
\end{verbatim}

\textbf{ઉદાહરણ આઉટપુટ:}

\begin{verbatim}
ઇનઓર્ડર ટ્રાવર્સલ: 20 30 40 50 60 70 80
પ્રીઓર્ડર ટ્રાવર્સલ: 50 30 20 40 70 60 80
પોસ્ટઓર્ડર ટ્રાવર્સલ: 20 40 30 60 80 70 50
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``નાના ડાબે, મોટા જમણે''

\end{mnemonicbox}

\end{document}
