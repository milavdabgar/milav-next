\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 1333203 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{લીન્કડ લીસ્ટની વ્યાખ્યા આપો. વિવિધ પ્રકારના લિન્ક્ડ લીસ્ટ ની યાદી આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3636}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6364}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
લિન્ક્ડ લિસ્ટના પ્રકાર
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લિન્ક્ડ લિસ્ટ એ લીનિયર ડેટા સ્ટ્રક્ચર છે જેમાં એલિમેન્ટ્સ નોડ્સમાં સ્ટોર થાય છે, અને દરેક
નોડ ક્રમમાં આગળના નોડને પોઇન્ટ કરે છે & 1. સિંગલી લિન્ક્ડ લિસ્ટ 2. ડબલી લિન્ક્ડ લિસ્ટ
3. સર્ક્યુલર લિન્ક્ડ લિસ્ટ 4. સર્ક્યુલર ડબલી લિન્ક્ડ લિસ્ટ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Singly:     [Data|Next] \rightarrow [Data|Next] \rightarrow [Data|Next] \rightarrow NULL
Doubly:     [Prev|Data|Next] ⟷ [Prev|Data|Next] ⟷ [Prev|Data|Next] \rightarrow NULL
Circular:   [Data|Next] \rightarrow [Data|Next] \rightarrow [Data|Next] ↩
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``એક, બે, ગોળ, બે-ગોળ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{પાયથનમાં લીનીયર અને નોન-લીનીયર ડેટા સ્ટર્ચર ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3556}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3556}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ડેટા સ્ટ્રક્ચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પાયથન ઉદાહરણો
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લીનીયર & એલિમેન્ટ્સ ક્રમિક રીતે ગોઠવાયેલા હોય છે જેમાં દરેક એલિમેન્ટને એકદમ એક અગાઉનું
અને એક પછીનું એલિમેન્ટ હોય છે (પ્રથમ અને છેલ્લા સિવાય) & Lists:
\passthrough{\lstinline![1, 2, 3]!} Tuples:
\passthrough{\lstinline!(1, 2, 3)!} Strings:
\passthrough{\lstinline!"abc"!} Queue:
\passthrough{\lstinline!queue.Queue()!} \\
નોન-લીનીયર & એલિમેન્ટ્સ ક્રમિક રીતે ગોઠવાયેલા નથી; એક એલિમેન્ટ અનેક એલિમેન્ટ્સ સાથે
જોડાઈ શકે છે & Dictionary: \passthrough{\lstinline!\{"a": 1, "b": 2\}!}
Set: \passthrough{\lstinline!\{1, 2, 3\}!} Tree: કસ્ટમ ઇમ્પ્લીમેન્ટેશન Graph:
કસ્ટમ ઇમ્પ્લીમેન્ટેશન \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-247e0712.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``લીનીયર લાઈનમાં, નોન-લીનીયર ચારે બાજુ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{પાયથનમાં ક્લાસ, એટ્રીબ્યુટ, ઓબ્જેક્ટ અને ક્લાસ મેથડ યોગ્ય ઉદાહરણ સાથે
સમજાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-4513c07f.pdf}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3158}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6842}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
શબ્દ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ક્લાસ & ઓબ્જેક્ટ્સ બનાવવા માટેનો બ્લૂપ્રિન્ટ, જેમાં શેર્ડ એટ્રિબ્યુટ્સ અને મેથડ્સ હોય છે \\
એટ્રિબ્યુટ્સ & ક્લાસની અંદર ડેટા સ્ટોર કરતા વેરિએબલ્સ \\
ઓબ્જેક્ટ & ક્લાસનું ઇન્સ્ટન્સ, જેમાં ચોક્કસ એટ્રિબ્યુટ વેલ્યુ હોય છે \\
ક્લાસ મેથડ & ક્લાસની અંદર ડિફાઇન થયેલા ફંક્શન્સ જે ક્લાસની સ્થિતિને એક્સેસ અને મોડિફાય
કરી શકે છે \\
\end{longtable}
}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
class Student:
    # ક્લાસ એટ્રિબ્યુટ
    school = "GTU"
    
    # કન્સ્ટ્રક્ટર
    def __init__(self, roll_no, name):
        # ઇન્સ્ટન્સ એટ્રિબ્યુટ્સ
        self.roll_no = roll_no
        self.name = name
    
    # ઇન્સ્ટન્સ મેથડ
    def display(self):
        print(f"Roll No: {self.roll_no}, Name: {self.name}")
    
    # ક્લાસ મેથડ
    @classmethod
    def change_school(cls, new_school):
        cls.school = new_school

# ઓબ્જેક્ટ બનાવવું
student1 = Student(101, "રાજ")
student1.display()  # આઉટપુટ: Roll No: 101, Name: રાજ
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``ક્લાસ બનાવે, એટ્રિબ્યુટ સંગ્રહે, ઓબ્જેક્ટ વાપરે, મેથડ ક્રિયા
કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{ડેટા એન્કેપ્સુલેસન અને પોલી મોર્ફીસમની વ્યાખ્યા આપો. પોલી મોર્ફીસમ સમજાવવા
માટેનો પાયથન કોડ વિકસાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4286}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5714}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કોન્સેપ્ટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેટા એન્કેપ્સુલેસન & ડેટા અને મેથડ્સને એક એકમ (ક્લાસ)માં બંધ કરવા અને કેટલાક કોમ્પોનન્ટ્સને
સીધી એક્સેસથી પ્રતિબંધિત કરવા \\
પોલીમોર્ફિઝમ & વિવિધ ક્લાસને એક જ નામના મેથડનો પોતાનો અમલ પૂરો પાડવાની
ક્ષમતા \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-19b2dc02.pdf}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
# પોલીમોર્ફિઝમ ઉદાહરણ
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "ભૌં ભૌં!"

class Cat(Animal):
    def speak(self):
        return "મ્યાઉં!"

class Duck(Animal):
    def speak(self):
        return "ક્વેક!"

# પોલીમોર્ફિઝમ દર્શાવતું ફંક્શન
def animal_sound(animal):
    return animal.speak()

# ઓબ્જેક્ટ્સ બનાવવા
dog = Dog()
cat = Cat()
duck = Duck()

# એક જ ફંક્શન વિવિધ પ્રાણી ઓબ્જેક્ટ્સ માટે કામ કરે છે
print(animal_sound(dog))   # આઉટપુટ: ભૌં ભૌં!
print(animal_sound(cat))   # આઉટપુટ: મ્યાઉં!
print(animal_sound(duck))  # આઉટપુટ: ક્વેક!
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``એન્કેપ્સુલેશન છુપાવે છે, પોલીમોર્ફિઝમ બદલાય છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{સ્ટેક અને ક્યુ નો તફાવત આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3913}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્ટેક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ક્યુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સિદ્ધાંત & LIFO (છેલ્લું આવે પહેલું જાય) & FIFO (પહેલું આવે પહેલું જાય) \\
ઓપરેશન & પુશ, પોપ & એનક્યુ, ડિક્યુ \\
એક્સેસ & એલિમેન્ટ્સ ફક્ત એક છેડેથી ઉમેરાય/દૂર થાય છે (ટોપ) & એલિમેન્ટ્સ છેલ્લે ઉમેરાય છે અને
આગળથી દૂર થાય છે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Stack:       [3]      Queue:  [1] \rightarrow [2] \rightarrow [3]
             [2]              Front      Rear
             [1]      
             ---
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``સ્ટેક ઉપરનું પહેલા, ક્યુ આગળનું પહેલા''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{પુશ અને પોપ ઓપરેશન માટેનો અલ્ગોરીધમ લખો.}

\begin{solutionbox}

\textbf{PUSH અલ્ગોરિધમ:}

\begin{lstlisting}
શરુઆત
  1. ચેક કરો કે સ્ટેક ભરેલો છે કે નહીં
  2. જો ભરેલો ન હોય, તો top ને 1 વધારો
  3. 'top' પોઝિશન પર એલિમેન્ટ ઉમેરો
સમાપ્ત
\end{lstlisting}

\textbf{POP અલ્ગોરિધમ:}

\begin{lstlisting}
શરુઆત
  1. ચેક કરો કે સ્ટેક ખાલી છે કે નહીં
  2. જો ખાલી ન હોય, તો 'top' પરના એલિમેન્ટને લો
  3. top ને 1 ઘટાડો
  4. મેળવેલ એલિમેન્ટ પાછો આપો
સમાપ્ત
\end{lstlisting}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
class Stack:
    def __init__(self, size):
        self.stack = []
        self.size = size
        self.top = -1
    
    def push(self, element):
        if self.top >= self.size - 1:
            return "Stack Overflow"
        else:
            self.top += 1
            self.stack.append(element)
            return "Pushed " + str(element)
    
    def pop(self):
        if self.top < 0:
            return "Stack Underflow"
        else:
            element = self.stack.pop()
            self.top -= 1
            return element
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``ટોપ પર પુશ, ટોપથી પોપ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{નીચે. આપેલ સમીકરણ ને ઇન્ફીક્સ માંથી પોસ્ટફિક્ષ માં બદલો.} \textbf{A * (B
+ C) - D / (E + F)}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Infix:   A * (B + C) - D / (E + F)
Postfix: A B C + * D E F + / -
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
સ્ટેપ & સિમ્બોલ & સ્ટેક & આઉટપુટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & A & & A \\
2 & * & * & A \\
3 & ( & * ( & A \\
4 & B & * ( & A B \\
5 & + & * ( + & A B \\
6 & C & * ( + & A B C \\
7 & ) & * & A B C + \\
8 & - & - & A B C + * \\
9 & D & - & A B C + * D \\
10 & / & - / & A B C + * D \\
11 & ( & - / ( & A B C + * D \\
12 & E & - / ( & A B C + * D E \\
13 & + & - / ( + & A B C + * D E \\
14 & F & - / ( + & A B C + * D E F \\
15 & ) & - / & A B C + * D E F + \\
16 & end & & A B C + * D E F + / - \\
\end{longtable}
}

\end{solutionbox}
\begin{solutionbox}
\passthrough{\lstinline!A B C + * D E F + / -!}

\end{solutionbox}
\begin{mnemonicbox}
``ઓપરેટર સ્ટેક પર, ઓપરન્ડ સીધા પ્રિન્ટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{સિમ્પલ ક્યુ અને સર્ક્યુલર ક્યુ નો તફાવત આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3590}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4103}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિમ્પલ ક્યુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સર્ક્યુલર ક્યુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સ્ટ્રક્ચર & લીનિયર ડેટા સ્ટ્રક્ચર & જોડાયેલા છેડાવાળો લીનિયર ડેટા સ્ટ્રક્ચર \\
મેમરી & ડિક્યુ પછી ખાલી જગ્યાઓને કારણે અકાર્યક્ષમ મેમરી વપરાશ & ખાલી જગ્યાઓનો
ફરીથી ઉપયોગ કરીને કાર્યક્ષમ મેમરી વપરાશ \\
ઇમ્પ્લિમેન્ટેશન & ફ્રન્ટ હંમેશા ઇન્ડેક્સ 0 પર, રીયર વધે & ફ્રન્ટ અને રીયર મોડ્યુલો ઓપરેશન
સાથે સર્ક્યુલર રીતે ફરે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-65454a3c.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``સાદી વેડફે, ગોળ ફરીથી વાપરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{રીકસીવ ફંક્શનનો કોન્સેપ્ટ યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મુખ્ય પાસાઓ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
વ્યાખ્યા & એવું ફંક્શન જે એક જ સમસ્યાના નાના ભાગને હલ કરવા માટે પોતાને જ કોલ કરે
છે \\
બેઝ કેસ & એવી સ્થિતિ જ્યાં ફંક્શન પોતાને કોલ કરવાનું બંધ કરે છે \\
રિકર્સિવ કેસ & એવી સ્થિતિ જ્યાં ફંક્શન સમસ્યાના સરળ સ્વરૂપ સાથે પોતાને કોલ કરે છે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-51d9ec5e.pdf}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
def factorial(n):
    # બેઝ કેસ
if

n == 0:

        return 1
    # રિકર્સિવ કેસ
    else:
        return n * factorial(n-1)

# ઉદાહરણ
result = factorial(5)  # 5! = 120
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``બેઝ તોડે, રિકર્શન પાછું આપે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{Enqueue અને Dequeue ઓપરેશન માટેનો પાયથન કોડ વિકસાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Enqueue:
  [1][2][3] \rightarrow [1][2][3][4]
  
Dequeue:
  [1][2][3][4] \rightarrow [2][3][4]
\end{lstlisting}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
class Queue:
    def __init__(self, size):
        self.queue = []
        self.size = size
        self.front = 0
        self.rear = -1
        self.count = 0
    
    def enqueue(self, item):
        if self.count >= self.size:
            return "ક્યુ ભરેલી છે"
        else:
            self.rear += 1
            self.queue.append(item)
            self.count += 1
            return "Enqueued " + str(item)
    
    def dequeue(self):
        if self.count <= 0:
            return "ક્યુ ખાલી છે"
        else:
            item = self.queue.pop(0)
            self.count -= 1
            return item
    
    def display(self):
        return self.queue

# ટેસ્ટ
q = Queue(5)
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)
print(q.display())  # [10, 20, 30]
print(q.dequeue())  # 10
print(q.display())  # [20, 30]
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``છેડે ઉમેરો, શરૂઆતથી કાઢો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{સીન્ગલી લિન્ક્ડ લીસ્ટ અને સર્ક્યુલર લિન્ક્ડ લીસ્ટ નો તફાવત આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફીચર & સિંગલી લિન્ક્ડ લિસ્ટ & સર્ક્યુલર લિન્ક્ડ લિસ્ટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
છેલ્લો નોડ & NULL તરફ પોઇન્ટ કરે છે & પહેલા નોડ તરફ પાછો પોઇન્ટ કરે છે \\
ટ્રાવર્સલ & ચોક્કસ અંત ધરાવે છે & સતત ટ્રાવર્સ કરી શકાય છે \\
મેમરી & દરેક નોડને એક પોઇન્ટર જોઈએ & દરેક નોડને એક પોઇન્ટર જોઈએ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Singly:   [1] \rightarrow [2] \rightarrow [3] \rightarrow NULL
Circular: [1] \rightarrow [2] \rightarrow [3] \rightarrow ↩
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``સિંગલી અટકે, સર્ક્યુલર ફરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{ડબલી લિન્ક્ડ લીસ્ટ નો કોન્સેપ્ટ સમજાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
NULL \leftarrow [Prev|1|Next] ⟷ [Prev|2|Next] ⟷ [Prev|3|Next] \rightarrow NULL
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફીચર & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
નોડ સ્ટ્રક્ચર & દરેક નોડમાં ડેટા અને બે પોઇન્ટર્સ (previous અને next) હોય છે \\
નેવિગેશન & આગળ અને પાછળ એમ બંને દિશામાં ટ્રાવર્સ કરી શકાય છે \\
ઓપરેશન્સ & બંને છેડેથી ઇન્સર્શન અને ડિલીશન કરી શકાય છે \\
મેમરી વપરાશ & વધારાના પોઇન્ટરને કારણે સિંગલી લિન્ક્ડ લિસ્ટ કરતા વધુ મેમરી જોઈએ \\
\end{longtable}
}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``બે પોઇન્ટર, બે દિશા''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{નીચે આપેલ ઓપરેશન માટે અલગોરિધમ લખો:} \textbf{૧. લીસ્ટ ની શરૂઆતમાં નોડ
દાખલ કરવા} \textbf{૨. લીસ્ટ ના અંતમાં નોડ દાખલ કરવા}

\begin{solutionbox}

\textbf{શરૂઆતમાં ઇન્સર્ટ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-4c8d7995.pdf}

\textbf{અંતે ઇન્સર્ટ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-3fdce3b1.pdf}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
def insert_at_beginning(head, data):
    new_node = Node(data)
    new_node.next = head
    return new_node  # નવો head

def insert_at_end(head, data):
    new_node = Node(data)
    new_node.next = None
    
    # જો લિન્ક્ડ લિસ્ટ ખાલી હોય
    if head is None:
        return new_node
    
    # છેલ્લા નોડ સુધી ટ્રાવર્સ કરો
    temp = head
    while temp.next:
        temp = temp.next
    
    # છેલ્લા નોડને નવા નોડ સાથે જોડો
    temp.next = new_node
    return head
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``શરૂઆત: નવો જૂનાને આગળ કરે, અંત: જૂનો નવાને આગળ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{સીન્ગલી લિન્ક્ડ લીસ્ટ પરના વિવિધ ઓપરેશન ની યાદી આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
સિંગલી લિન્ક્ડ લિસ્ટ પરના ઓપરેશન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. ઇન્સર્શન (શરૂઆતમાં, મધ્યમાં, અંતે) \\
2. ડિલીશન (શરૂઆતથી, મધ્યમાંથી, અંતથી) \\
3. ટ્રાવર્સલ (દરેક નોડની મુલાકાત) \\
4. શોધ (ચોક્કસ નોડ શોધવો) \\
5. અપડેટિંગ (નોડ ડેટા બદલવો) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-ced00faa.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``ઉમેરો કાઢો ફરો શોધો બદલો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{સર્ક્યુલર લિન્ક્ડ લીસ્ટ નો કોન્સેપ્ટ સમજાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
    ↗-----------↘
   /             \
  ↓               ↓
[1] \rightarrow [2] \rightarrow [3] \rightarrow [4]
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4091}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5909}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સ્ટ્રક્ચર & છેલ્લો નોડ NULL ને બદલે પહેલા નોડને પોઇન્ટ કરે છે \\
ફાયદો & બધા નોડમાં સતત ટ્રાવર્સલની અનુમતિ આપે છે \\
એપ્લિકેશન & રાઉન્ડ રોબિન શેડ્યુલિંગ, સર્ક્યુલર બફર ઇમ્પ્લિમેન્ટેશન \\
ઓપરેશન & છેલ્લા નોડ માટે ખાસ હેન્ડલિંગ સાથે સિંગલી લિન્ક્ડ લિસ્ટ જેવા ઇન્સર્શન અને
ડિલીશન \\
\end{longtable}
}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# 3 નોડવાળી સર્ક્યુલર લિન્ક્ડ લિસ્ટ બનાવવી
head = Node(1)
node2 = Node(2)
node3 = Node(3)

head.next = node2
node2.next = node3
node3.next = head  # તેને સર્ક્યુલર બનાવે છે
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``છેલ્લો પહેલાને જોડે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{લિન્ક્ડ લીસ્ટની એપ્લીકેશનોની યાદી આપો. સીન્ગલી લિન્ક્ડ લીસ્ટમાં કુલ નોડ
ગણવા માટેનો અલગોરિધમ લખો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
લિન્ક્ડ લિસ્ટની એપ્લિકેશન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. સ્ટેક અને ક્યુનો અમલીકરણ \\
2. ડાયનેમિક મેમરી એલોકેશન \\
3. એપ્લિકેશનમાં અન્ડુ ફંક્શનાલિટી \\
4. હેશ ટેબલ્સ (ચેઇનિંગ) \\
5. ગ્રાફ્સ માટે એડજસન્સી લિસ્ટ \\
\end{longtable}
}

\textbf{નોડ ગણવા માટેનો અલ્ગોરિધમ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-5716880e.pdf}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
def count_nodes(head):
    count = 0
    temp = head
    
    while temp:
        count += 1
        temp = temp.next
    
    return count

# ઉદાહરણ
# ધારી લો કે head લિન્ક્ડ લિસ્ટના પ્રથમ નોડને પોઇન્ટ કરે છે
total_nodes = count_nodes(head)
print(f"કુલ નોડ: {total_nodes}")
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``ગણો ત્યારે ખસો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{લીનીયર સર્ચ અને બાયનરી સર્ચની સરખામણી કરો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3684}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3947}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
લીનીયર સર્ચ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
બાયનરી સર્ચ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેટા ગોઠવણ & સોર્ટેડ અને અનસોર્ટેડ બંને ડેટા પર કામ કરે છે & ફક્ત સોર્ટેડ ડેટા પર કામ
કરે છે \\
ટાઇમ કોમ્પ્લેક્સિટી & O(n) & O(log n) \\
ઇમ્પ્લિમેન્ટેશન & સરળ & વધુ જટિલ \\
શેના માટે શ્રેષ્ઠ & નાના ડેટાસેટ અથવા અનસોર્ટેડ ડેટા & મોટા સોર્ટેડ ડેટાસેટ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Linear: [1] [2] [3] [4] [5] [6] [7] [8]
        ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
        ક્રમવાર ચેક કરવું

Binary: [1] [2] [3] [4] [5] [6] [7] [8]
                    ↓
                 મધ્ય ચેક
                /     \
               /       \
         નીચો ભાગ    ઉપરનો ભાગ
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``લીનીયર બધું જુએ, બાઈનરી આધું કાપે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{સિલેકશન સોર્ટ માટેનો અલગોરિધમ લખો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Initial: [5, 3, 8, 1, 2]
Pass 1:  [1, 3, 8, 5, 2]  (min = 1 શોધો, 5 સાથે સ્વેપ)
Pass 2:  [1, 2, 8, 5, 3]  (min = 2 શોધો, 3 સાથે સ્વેપ)
Pass 3:  [1, 2, 3, 5, 8]  (min = 3 શોધો, 8 સાથે સ્વેપ)
Pass 4:  [1, 2, 3, 5, 8]  (min = 5 શોધો, જગ્યા પર છે જ)
\end{lstlisting}

\textbf{અલ્ગોરિધમ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-73bd1be1.pdf}

\textbf{કોડનો ઢાંચો:}

\begin{lstlisting}[language=Python]
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        min_idx = i
        
        # અનસોર્ટેડ એરેમાં લઘુતમ એલિમેન્ટ શોધો
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # શોધેલા લઘુતમ એલિમેન્ટને પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરો
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``લઘુતમ શોધો, પોઝિશન બદલો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{નીચે આપેલા લીસ્ટ ને બબલ સોર્ટ મેથડ વડે ચઢતા ક્રમમાં ગોઠવવા માટેનો પાયથન
કોડ વિકસાવો.} \textbf{list1=[5,4,3,2,1,0]}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Initial: [5, 4, 3, 2, 1, 0]
Pass 1:  [4, 3, 2, 1, 0, 5]
Pass 2:  [3, 2, 1, 0, 4, 5]
Pass 3:  [2, 1, 0, 3, 4, 5]
Pass 4:  [1, 0, 2, 3, 4, 5]
Pass 5:  [0, 1, 2, 3, 4, 5]
\end{lstlisting}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
def bubble_sort(arr):
    n = len(arr)
    
    # બધા એરે એલિમેન્ટ્સ પર ટ્રાવર્સ કરો
    for i in range(n):
        # છેલ્લા i એલિમેન્ટ્સ પહેલેથી જ યોગ્ય જગ્યા પર છે
        for j in range(0, n-i-1):
            # જો વર્તમાન એલિમેન્ટ આગળના એલિમેન્ટ કરતાં મોટો હોય, તો સ્વેપ કરો
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# ઇનપુટ લિસ્ટ
list1 = [5, 4, 3, 2, 1, 0]

# લિસ્ટ સોર્ટ કરવી
sorted_list = bubble_sort(list1)

# રિઝલ્ટ ડિસ્પ્લે કરવું
print("સોર્ટેડ લિસ્ટ:", sorted_list)
# આઉટપુટ: સોર્ટેડ લિસ્ટ: [0, 1, 2, 3, 4, 5]
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``મોટા બબલ ઉપર જાય''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{સોર્ટિંગ ની વ્યાખ્યા આપો. વિવિધ પ્રકારના સોર્ટિંગ ની યાદી આપો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4138}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5862}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સોર્ટિંગ મેથડ્સ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સોર્ટિંગ એટલે ડેટાને ચોક્કસ ક્રમમાં (ચઢતા અથવા ઉતરતા) ગોઠવવાની પ્રક્રિયા & 1. બબલ
સોર્ટ 2. સિલેક્શન સોર્ટ 3. ઇન્સર્શન સોર્ટ 4. મર્જ સોર્ટ 5. ક્વિક સોર્ટ 6. હીપ સોર્ટ
7. રેડિક્સ સોર્ટ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-0a43491c.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``સારા સોર્ટથી શોધવાનું સરળ બને''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{Insertion sort method નો અલગોરિધમ લખો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Initial: [5, 2, 4, 6, 1, 3]
Pass 1:  [2, 5, 4, 6, 1, 3]  (2 ને 5 પહેલા મૂકો)
Pass 2:  [2, 4, 5, 6, 1, 3]  (4 ને 5 પહેલા મૂકો)
Pass 3:  [2, 4, 5, 6, 1, 3]  (6 પહેલેથી જગ્યા પર છે)
Pass 4:  [1, 2, 4, 5, 6, 3]  (1 ને શરૂઆતમાં મૂકો)
Pass 5:  [1, 2, 3, 4, 5, 6]  (3 ને 2 પછી મૂકો)
\end{lstlisting}

\textbf{અલ્ગોરિધમ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-b7c94569.pdf}

\textbf{કોડનો ઢાંચો:}

\begin{lstlisting}[language=Python]
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        # key કરતાં મોટા એલિમેન્ટ્સને એક પોઝિશન આગળ ખસેડો
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``કાર્ડ લો, યોગ્ય ક્રમમાં મૂકો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{નીચે આપેલા લીસ્ટ ને સિલેકશન સોર્ટ મેથડ વડે ચઢતા ક્રમમાં ગોઠવવા માટેનો પાયથન
કોડ વિકસાવો.} \textbf{list1=[6,3,25,8,-1,55,0]}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Initial: [6, 3, 25, 8, -1, 55, 0]
Pass 1:  [-1, 3, 25, 8, 6, 55, 0]  (min = -1 શોધો, 6 સાથે સ્વેપ)
Pass 2:  [-1, 0, 25, 8, 6, 55, 3]  (min = 0 શોધો, 3 સાથે સ્વેપ)
Pass 3:  [-1, 0, 3, 8, 6, 55, 25]  (min = 3 શોધો, 25 સાથે સ્વેપ)
Pass 4:  [-1, 0, 3, 6, 8, 55, 25]  (min = 6 શોધો, 8 સાથે સ્વેપ)
Pass 5:  [-1, 0, 3, 6, 8, 55, 25]  (min = 8 શોધો, પહેલેથી જગ્યા પર છે)
Pass 6:  [-1, 0, 3, 6, 8, 25, 55]  (min = 25 શોધો, 55 સાથે સ્વેપ)
\end{lstlisting}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # બાકીના અનસોર્ટેડ એરેમાં લઘુતમ એલિમેન્ટ શોધો
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
                
        # શોધેલા લઘુતમ એલિમેન્ટને પ્રથમ એલિમેન્ટ સાથે સ્વેપ કરો
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# ઇનપુટ લિસ્ટ
list1 = [6, 3, 25, 8, -1, 55, 0]

# લિસ્ટ સોર્ટ કરવી
sorted_list = selection_sort(list1)

# રિઝલ્ટ ડિસ્પ્લે કરવું
print("સોર્ટેડ લિસ્ટ:", sorted_list)
# આઉટપુટ: સોર્ટેડ લિસ્ટ: [-1, 0, 3, 6, 8, 25, 55]
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``નાનામાં નાનું શોધો, આગળ મૂકો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{Tree data structure ને લગતા નીચે આપેલ પદોની વ્યાખ્યા આપો.} \textbf{1.
Forest} \textbf{2. Root node} \textbf{3. Leaf node}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Forest & અલગ-અલગ ટ્રીઓનો સમૂહ (ટ્રીઓ વચ્ચે કોઈ જોડાણ નથી) \\
Root Node & ટ્રીનો સૌથી ઉપરનો નોડ જેનો કોઈ પેરેન્ટ નથી, જેનાથી બધા બીજા નોડ્સ
ઉતરે છે \\
Leaf Node & એવો નોડ જેને કોઈ ચિલ્ડ્રન નથી (ટ્રીના તળિયે આવેલો ટર્મિનલ નોડ) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
Forest:    Tree1    Tree2    Tree3
           /  \      / \      |
          /    \    /   \     |
         
Root:     [R]
         /   \
        /     \
        
Leaf:  [A] \rightarrow [B] \rightarrow [L] \rightarrow [L]
                    કોઈ ચિલ્ડ્રન નથી
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``ફોરેસ્ટમાં ઘણા રૂટ, રૂટથી બધું શરૂ, લીફ્સ બધું પૂરું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{78,58,82,15,66,80,99 માટે Binary search tree દોરો અને તે tree માટેનું
In-order traversal લખો.}

\begin{solutionbox}

\textbf{બાઈનરી સર્ચ ટ્રી:}

\begin{lstlisting}
          78
         /  \
        /    \
      58      82
     /  \    /  \
   15   66  80   99
\end{lstlisting}

\textbf{ઇન-ઓર્ડર ટ્રાવર્સલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
સ્ટેપ & વિઝિટ ક્રમ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 78 ના ડાબા સબટ્રી પર જાઓ \\
2 & 58 ના ડાબા સબટ્રી પર જાઓ \\
3 & 15 ને વિઝિટ કરો \\
4 & 58 ને વિઝિટ કરો \\
5 & 66 ને વિઝિટ કરો \\
6 & 78 ને વિઝિટ કરો \\
7 & 82 ના ડાબા સબટ્રી પર જાઓ \\
8 & 80 ને વિઝિટ કરો \\
9 & 82 ને વિઝિટ કરો \\
10 & 99 ને વિઝિટ કરો \\
\end{longtable}
}

\textbf{ઇન-ઓર્ડર ટ્રાવર્સલ રિઝલ્ટ: 15, 58, 66, 78, 80, 82, 99}

\end{solutionbox}
\begin{mnemonicbox}
``ડાબું, રૂટ, જમણું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{નીચે આપેલ ઓપરેશન માટે અલગોરિધમ લખો:} \textbf{૧. Binary Tree માં નોડ
દાખલ કરવા} \textbf{૨. Binary Tree માંથી નોડ કાઢવા માટે}

\begin{solutionbox}

\textbf{ઇન્સર્શન અલ્ગોરિધમ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-ae37894a.pdf}

\textbf{ડિલીશન અલ્ગોરિધમ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-f6988c7b.pdf}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# Binary Tree માં ઇન્સર્શન
def insert(root, data):
    if root is None:
        return Node(data)
    
    # લેવલ ઓર્ડર ટ્રાવર્સલથી ખાલી પોઝિશન શોધવી
    queue = []
    queue.append(root)
    
    while queue:
        temp = queue.pop(0)
        
        if temp.left is None:
            temp.left = Node(data)
            break
        else:
            queue.append(temp.left)
            
        if temp.right is None:
            temp.right = Node(data)
            break
        else:
            queue.append(temp.right)
    
    return root

# Binary Tree માંથી ડિલીશન
def delete_node(root, key):
    if root is None:
        return None
    
    if root.left is None and root.right is None:
        if root.data == key:
            return None
        else:
            return root
    
    # ડિલીટ કરવાના નોડને શોધો
    key_node = None
    # છેવટના નોડને શોધો
    last = None
    parent = None
    
    # લેવલ ઓર્ડર ટ્રાવર્સલ
    queue = []
    queue.append(root)
    
    while queue:
        temp = queue.pop(0)
        
        if temp.data == key:
            key_node = temp
            
        if temp.left:
            parent = temp
            queue.append(temp.left)
            last = temp.left
            
        if temp.right:
            parent = temp
            queue.append(temp.right)
            last = temp.right
    
    if key_node:
        # છેવટના નોડના ડેટા સાથે બદલો
        key_node.data = last.data
        
        # છેવટના નોડને ડિલીટ કરો
        if parent.right == last:
            parent.right = None
        else:
            parent.left = None
    
    return root
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``ખાલી જગ્યાએ ઉમેરો, બદલીને કાઢો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{Tree data structure ને લગતા નીચે આપેલ પદોની વ્યાખ્યા આપો.} \textbf{1.
In-degree} \textbf{2. Out-degree} \textbf{3. Depth}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
In-degree & નોડમાં આવતી એજ્જીસની સંખ્યા (ટ્રીમાં પ્રત્યેક નોડ માટે (રૂટ સિવાય) હંમેશા
1 હોય છે) \\
Out-degree & નોડમાંથી બહાર જતી એજ્જીસની સંખ્યા (નોડના ચિલ્ડ્રનની સંખ્યા) \\
Depth & રૂટથી નોડ સુધીના પાથની લંબાઈ (પાથમાં એજ્જીસની સંખ્યા) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ:}

\begin{lstlisting}
        A (રૂટ, ડેપ્થ 0)
       / \
      /   \
     B     C (ડેપ્થ 1)
    / \     \
   D   E     F (ડેપ્થ 2)
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
નોડ & In-degree & Out-degree \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & 0 & 2 \\
B & 1 & 2 \\
C & 1 & 1 \\
D & 1 & 0 \\
E & 1 & 0 \\
F & 1 & 0 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ઈન કાઉન્ટ્સ પેરેન્ટ્સ, આઉટ કાઉન્ટ્સ ચિલ્ડ્રન, ડેપ્થ કાઉન્ટ્સ
એજ્જીસ ફ્રોમ રૂટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{નીચે દર્શાવેલા Binary tree માટે Preorder and postorder traversal
લખો.}

\textbf{બાઈનરી ટ્રી:}

\begin{lstlisting}
        100
       /   \
      /     \
    20      200
   /  \     /  \
  10   30  150  300
\end{lstlisting}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ટ્રાવર્સલ & ક્રમ & રિઝલ્ટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Preorder & રૂટ, ડાબું, જમણું & 100, 20, 10, 30, 200, 150, 300 \\
Postorder & ડાબું, જમણું, રૂટ & 10, 30, 20, 150, 300, 200, 100 \\
\end{longtable}
}

\textbf{પ્રીઓર્ડર વિઝ્યુઅલાઈઝેશન:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-9d7c8163.pdf}

\textbf{પોસ્ટઓર્ડર વિઝ્યુઅલાઈઝેશન:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-c40f7e2c.pdf}

\end{solutionbox}
\begin{mnemonicbox}

\begin{itemize}
\tightlist
\item
  પ્રીઓર્ડર: ``રૂટ પહેલા, પછી બાળકો''
\item
  પોસ્ટઓર્ડર: ``બાળકો પહેલા, પછી રૂટ''
\end{itemize}

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{Binary Search Tree રચવા માટેનો પાયથન કોડ વિકસાવો.}

\begin{solutionbox}

\textbf{ડાયાગ્રામ:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-312f67f2.pdf}

\textbf{કોડ:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert(root, key):
    # જો ટ્રી ખાલી હોય, તો નવો નોડ પાછો આપો
    if root is None:
        return Node(key)
    
    # અન્યથા, ટ્રીમાં નીચે જાઓ
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    
    # અબદાયેલ નોડ પોઈન્ટર પાછો આપો
    return root

def inorder(root):
    if root:
        inorder(root.left)
        print(root.key, end=" ")
        inorder(root.right)

def preorder(root):
    if root:
        print(root.key, end=" ")
        preorder(root.left)
        preorder(root.right)

def postorder(root):
    if root:
        postorder(root.left)
        postorder(root.right)
        print(root.key, end=" ")

# ટેસ્ટ માટેનો પ્રોગ્રામ
def main():
    # આ એલિમેન્ટ્સ સાથે BST બનાવો: 50, 30, 20, 40, 70, 60, 80
    root = None
    elements = [50, 30, 20, 40, 70, 60, 80]
    
    for element in elements:
        root = insert(root, element)
    
    # ટ્રાવર્સલ્સ પ્રિન્ટ કરો
    print("ઇનઓર્ડર ટ્રાવર્સલ: ", end="")
    inorder(root)
    print("\nપ્રીઓર્ડર ટ્રાવર્સલ: ", end="")
    preorder(root)
    print("\nપોસ્ટઓર્ડર ટ્રાવર્સલ: ", end="")
    postorder(root)

# પ્રોગ્રામ ચલાવો
main()
\end{lstlisting}

\textbf{ઉદાહરણ આઉટપુટ:}

\begin{lstlisting}
ઇનઓર્ડર ટ્રાવર્સલ: 20 30 40 50 60 70 80
પ્રીઓર્ડર ટ્રાવર્સલ: 50 30 20 40 70 60 80
પોસ્ટઓર્ડર ટ્રાવર્સલ: 20 40 30 60 80 70 50
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``નાના ડાબે, મોટા જમણે''

\end{mnemonicbox}

\end{document}
