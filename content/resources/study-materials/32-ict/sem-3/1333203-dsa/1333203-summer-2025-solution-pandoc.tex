\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 1333203 -- Summer 2025}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Define Big - O Notation, Big Omega Notation, Big Theta
Notation.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Asymptotic Notations Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Notation & Symbol & Description & Usage \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Big-O & O(f(n)) & Upper bound & Worst case \\
Big Omega & Ω(f(n)) & Lower bound & Best case \\
Big Theta & Θ(f(n)) & Tight bound & Average case \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Big-O Notation}: Describes maximum time/space complexity
\item
  \textbf{Big Omega}: Describes minimum time/space complexity\\
\item
  \textbf{Big Theta}: Describes exact time/space complexity
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``OWT - O for wOrst, Omega for Best, Theta for
Tight''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Define Set. Write various operations that can be performed on
Set.}

\begin{solutionbox}

\textbf{Definition}: Set is a collection of unique elements with no
duplicates.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Set Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operation & Symbol & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Union & A \cup B & Combines all elements & \{1,2\} \cup \{2,3\} = \{1,2,3\} \\
Intersection & A \cap B & Common elements & \{1,2\} \cap \{2,3\} = \{2\} \\
Difference & A - B & Elements in A not in B & \{1,2\} - \{2,3\} =
\{1\} \\
Subset & A ⊆ B & All A elements in B & \{1\} ⊆ \{1,2\} = True \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Add/Insert}: Adding new element
\item
  \textbf{Remove/Delete}: Removing existing element
\item
  \textbf{Contains}: Check if element exists
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``UIDS - Union, Intersection, Difference, Subset''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Write a Python class to represent a Cricketer. The class
contains the name of the cricketer, team name and run as the data
members. The member functions are as follows: to initialize the data
members, to set run and display run.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
class Cricketer:
    def __init__(self, name="", team="", run=0):
        self.name = name
        self.team = team
        self.run = run
    
    def set_run(self, run):
        self.run = run
    
    def display_run(self):
        print(f"Player: {self.name}")
        print(f"Team: {self.team}")
        print(f"Runs: {self.run}")

# Example usage
player = Cricketer("Virat Kohli", "India", 100)
player.display_run()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Constructor}: Initializes name, team, and run
\item
  \textbf{set\_run()}: Updates run value
\item
  \textbf{display\_run()}: Shows player information
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CSD - Constructor, Set, Display''

\end{mnemonicbox}
\subsection*{Question 1(c OR) [7
marks]}\label{question-1c-or-7-marks}

\textbf{Design a student class for reading and displaying the student
information, the getInfo() and displayInfo() methods will be used
respectively. Where getInfo() will be a private method.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
class Student:
    def __init__(self):
        self.name = ""
        self.roll_no = ""
        self.marks = 0
        self.__getInfo()  # Private method call
    
    def __getInfo__(self):  # Private method
        self.name = input("Enter name: ")
        self.roll_no = input("Enter roll number: ")
        self.marks = int(input("Enter marks: "))
    
    def displayInfo(self):
        print(f"Name: {self.name}")
        print(f"Roll No: {self.roll_no}")
        print(f"Marks: {self.marks}")

# Example usage
student = Student()
student.displayInfo()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Private method}: Uses double underscore (\_\_getInfo)
\item
  \textbf{Constructor}: Automatically calls private method
\item
  \textbf{Public method}: displayInfo() shows student data
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PCP - Private, Constructor, Public''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Differentiate between Stack and Queue.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Stack vs Queue Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Stack & Queue \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Order & LIFO (Last In First Out) & FIFO (First In First Out) \\
Operations & Push, Pop & Enqueue, Dequeue \\
Access Point & One end (top) & Two ends (front \& rear) \\
Example & Plates stack & Bank queue \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Stack}: Like book pile - last added, first removed
\item
  \textbf{Queue}: Like waiting line - first come, first served
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SLIF QFIF - Stack LIFO, Queue FIFO''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Define recursion. Explain with example.}

\begin{solutionbox}

\textbf{Definition}: Function calling itself with smaller problem until
base condition.

\begin{lstlisting}[language=Python]
def factorial(n):
    # Base case
    if n <= 1:
        return 1
    # Recursive case
    return n * factorial(n-1)

# Example: factorial(3)
# 3 * factorial(2)
# 3 * 2 * factorial(1)
# 3 * 2 * 1 = 6
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Base case}: Stopping condition
\item
  \textbf{Recursive case}: Function calls itself
\item
  \textbf{Problem reduction}: Each call handles smaller problem
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BRP - Base, Recursive, Problem-reduction''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Consider the size of the stack as 5. Apply the following
operation on stack and show status and top pointer after each operation.
Push a,b,c pop}

\begin{solutionbox}

\textbf{Stack Operations Trace:}

\begin{lstlisting}
Initial State:
Stack: [ _ _ _ _ _ ]  Top: -1
       0 1 2 3 4

After Push 'a':
Stack: [ a _ _ _ _ ]  Top: 0
       0 1 2 3 4

After Push 'b':
Stack: [ a b _ _ _ ]  Top: 1
       0 1 2 3 4

After Push 'c':
Stack: [ a b c _ _ ]  Top: 2
       0 1 2 3 4

After Pop:
Stack: [ a b _ _ _ ]  Top: 1
       0 1 2 3 4
Popped element: c
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Push operations}: Add elements from index 0 onwards
\item
  \textbf{Top pointer}: Points to last inserted element
\item
  \textbf{Pop operation}: Removes top element, decrements top pointer
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PTD - Push Top Decrement''

\end{mnemonicbox}
\subsection*{Question 2(a OR) [3
marks]}\label{question-2a-or-3-marks}

\textbf{List applications of Stack and Queue.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Applications of Stack and Queue}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4667}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Data Structure
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Applications
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Stack} & Function calls, Undo operations, Expression evaluation,
Browser history \\
\textbf{Queue} & Process scheduling, Printer queue, BFS traversal,
Handling requests \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Stack applications}: Undo-redo, recursion, parsing
\item
  \textbf{Queue applications}: Task scheduling, buffering, breadth-first
  search
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Stack FUBE, Queue SPBH''

\end{mnemonicbox}
\subsection*{Question 2(b OR) [4
marks]}\label{question-2b-or-4-marks}

**Convert following algebraic expression into postfix notation using
Stack: i) (a\emph{b)}(c\^{}d(d+e)-f) ii) a-b/(c*d/e)**

\begin{solutionbox}

\textbf{i) (a\emph{b)}(c\^{}d(d+e)-f)}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Symbol & Stack & Output \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
( & ( & \\
a & ( & a \\
* & (* & a \\
b & (* & ab \\
) & & ab* \\
* & * & ab* \\
( & *( & ab* \\
c & *( & ab*c \\
\^{} & *(\^{} & ab*c \\
d & *(\^{} & ab*cd \\
( & *(\^{}( & ab*cd \\
d & *(\^{}( & ab*cdd \\
+ & *(\^{}(+ & ab*cdd \\
e & *(\^{}(+ & ab*cdde \\
) & *(\^{} & ab*cdde+ \\
) & * & ab*cdde+\^{} \\
- & *- & ab*cdde+\^{} \\
f & *- & ab*cdde+\^{}f \\
& & ab\emph{cdde+\^{}f-} \\
\end{longtable}
}

\textbf{Result: ab\emph{cdde+\^{}f-}}

**ii) a-b/(c*d/e)**

**Result: abcd*e/-**

\end{solutionbox}
\begin{mnemonicbox}
``PEMDAS reversed for postfix''

\end{mnemonicbox}
\subsection*{Question 2(c OR) [7
marks]}\label{question-2c-or-7-marks}

\textbf{Develop a program to implement a queue using a list that
performs following operations: enqueue, dequeue.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
class Queue:
    def __init__(self):
        self.queue = []
        self.front = 0
        self.rear = -1
    
    def enqueue(self, item):
        self.queue.append(item)
        self.rear += 1
        print(f"Enqueued: {item}")
    
    def dequeue(self):
        if self.front <= self.rear:
            item = self.queue[self.front]
            self.front += 1
            print(f"Dequeued: {item}")
            return item
        else:
            print("Queue is empty")
            return None
    
    def display(self):
        if self.front <= self.rear:
            print("Queue:", self.queue[self.front:self.rear+1])
        else:
            print("Queue is empty")

# Example usage
q = Queue()
q.enqueue('A')
q.enqueue('B')
q.dequeue()
q.display()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Enqueue}: Add element at rear
\item
  \textbf{Dequeue}: Remove element from front
\item
  \textbf{FIFO principle}: First In, First Out
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ERF - Enqueue Rear, Front''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{List types of linked lists. Give graphical representation of
each type.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Types of Linked Lists}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Description & Diagram \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Singly & One direction pointer & A\rightarrowB\rightarrowC\rightarrowNULL \\
Doubly & Two direction pointers & NULL\leftarrowA⇄B⇄C\rightarrowNULL \\
Circular & Last points to first & A\rightarrowB\rightarrowC\rightarrowA \\
\end{longtable}
}

\begin{lstlisting}
Singly Linked List:
[Data|Next] -> [Data|Next] -> [Data|NULL]

Doubly Linked List:
[Prev|Data|Next] <-> [Prev|Data|Next] <-> [Prev|Data|Next]

Circular Linked List:
[Data|Next] -> [Data|Next] -> [Data|Next]
    ^                              |
    |______________________________|
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``SDC - Singly, Doubly, Circular''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Write an algorithm to search a given node in a singly link
list.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
def search_node(head, key):
    current = head
    position = 0
    
    while current is not None:
        if current.data == key:
            return position
        current = current.next
        position += 1
    
    return -1  # Not found

# Algorithm steps:
# 1. Start from head
# 2. Compare current data with key
# 3. If found, return position
# 4. Move to next node
# 5. Repeat until end
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Linear search}: Traverse from head to tail
\item
  \textbf{Time complexity}: O(n)
\item
  \textbf{Return}: Position if found, -1 if not found
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SCMR - Start, Compare, Move, Return''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Implement program to perform following operation on singly
linked list: 1)Insert a node at the beginning of a singly linked list.
2)Delete a node from the beginning of a singly linked list.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None
    
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        print(f"Inserted {data} at beginning")
    
    def delete_from_beginning(self):
        if self.head is None:
            print("List is empty")
            return None
        
        deleted_data = self.head.data
        self.head = self.head.next
        print(f"Deleted {deleted_data} from beginning")
        return deleted_data
    
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("NULL")

# Example usage
ll = SinglyLinkedList()
ll.insert_at_beginning(10)
ll.insert_at_beginning(20)
ll.delete_from_beginning()
ll.display()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Insert}: Create node, link to head, update head
\item
  \textbf{Delete}: Store data, move head to next, return data
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CLU - Create, Link, Update''

\end{mnemonicbox}
\subsection*{Question 3(a OR) [3
marks]}\label{question-3a-or-3-marks}

\textbf{Differentiate between circular linked list and singly linked
list.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Circular vs Singly Linked List}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Singly Linked List & Circular Linked List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Last node points to & NULL & First node (head) \\
Traversal & Linear (one direction) & Circular (continuous) \\
End detection & next == NULL & next == head \\
Memory & Less (no extra pointer) & Same structure \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Circular advantage}: No NULL pointers, continuous traversal
\item
  \textbf{Singly advantage}: Simple implementation, clear end point
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CNTE - Circular No Termination End''

\end{mnemonicbox}
\subsection*{Question 3(b OR) [4
marks]}\label{question-3b-or-4-marks}

\textbf{Explain three applications of linked list in brief.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Linked List Applications}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3514}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3514}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2973}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Advantage
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Dynamic memory allocation} & Manage memory blocks & Efficient
memory usage \\
\textbf{Implementation of stacks/queues} & Using linked structure &
Dynamic size \\
\textbf{Polynomial representation} & Store coefficients and powers &
Easy arithmetic operations \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Music playlist}: Add/remove songs dynamically
\item
  \textbf{Browser history}: Navigate back/forward
\item
  \textbf{Image viewer}: Previous/next image navigation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DIP - Dynamic, Implementation, Polynomial''

\end{mnemonicbox}
\subsection*{Question 3(c OR) [7
marks]}\label{question-3c-or-7-marks}

\textbf{Implement a program to create and display circular linked
lists.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class CircularLinkedList:
    def __init__(self):
        self.head = None
    
    def insert(self, data):
        new_node = Node(data)
        
        if self.head is None:
            self.head = new_node
            new_node.next = self.head
        else:
            current = self.head
            while current.next != self.head:
                current = current.next
            current.next = new_node
            new_node.next = self.head
    
    def display(self):
        if self.head is None:
            print("List is empty")
            return
        
        current = self.head
        print("Circular List:")
        while True:
            print(current.data, end=" -> ")
            current = current.next
            if current == self.head:
                break
        print(f"{self.head.data} (back to head)")

# Example usage
cll = CircularLinkedList()
cll.insert(10)
cll.insert(20)
cll.insert(30)
cll.display()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Creation}: Link last node to head
\item
  \textbf{Display}: Stop when reaching head again
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CLH - Create, Link, Head''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Write a program for Selection Sort Method.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Example usage
data = [64, 34, 25, 12, 22]
sorted_data = selection_sort(data)
print("Sorted array:", sorted_data)
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Find minimum}: In unsorted portion
\item
  \textbf{Swap}: With first unsorted element
\item
  \textbf{Time complexity}: O(n^{2})
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FMS - Find, Minimum, Swap''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Apply Insertion sort to following data to arrange them in
ascending order. 25 15 35 20 30 5 10}

\begin{solutionbox}

\textbf{Insertion Sort Steps:}

\begin{lstlisting}
Initial: [25, 15, 35, 20, 30, 5, 10]

Pass 1: [15, 25, 35, 20, 30, 5, 10]  (Insert 15)
Pass 2: [15, 25, 35, 20, 30, 5, 10]  (35 in place)
Pass 3: [15, 20, 25, 35, 30, 5, 10]  (Insert 20)
Pass 4: [15, 20, 25, 30, 35, 5, 10]  (Insert 30)
Pass 5: [5, 15, 20, 25, 30, 35, 10]  (Insert 5)
Pass 6: [5, 10, 15, 20, 25, 30, 35]  (Insert 10)

Final: [5, 10, 15, 20, 25, 30, 35]
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Method}: Take element, find position in sorted part
\item
  \textbf{Comparisons}: 15 total comparisons
\item
  \textbf{Shifts}: Elements moved to make space
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TFI - Take, Find, Insert''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Implement a python program to search a particular element from a
list using Linear Search.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
def linear_search(arr, target):
    comparisons = 0
    
    for i in range(len(arr)):
        comparisons += 1
        if arr[i] == target:
            print(f"Element {target} found at index {i}")
            print(f"Number of comparisons: {comparisons}")
            return i
    
    print(f"Element {target} not found")
    print(f"Number of comparisons: {comparisons}")
    return -1

def linear_search_all_positions(arr, target):
    positions = []
    for i in range(len(arr)):
        if arr[i] == target:
            positions.append(i)
    return positions

# Example usage
data = [10, 25, 30, 15, 20, 30, 35]
target = 30

result = linear_search(data, target)
all_positions = linear_search_all_positions(data, target)
print(f"All positions of {target}: {all_positions}")
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Sequential search}: Check each element one by one
\item
  \textbf{Time complexity}: O(n) worst case
\item
  \textbf{Best case}: O(1) if found at first position
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CEO - Check Each One''

\end{mnemonicbox}
\subsection*{Question 4(a OR) [3
marks]}\label{question-4a-or-3-marks}

\textbf{Write a program of Insertion Sort Method.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr

# Example usage
data = [12, 11, 13, 5, 6]
print("Original:", data)
sorted_data = insertion_sort(data.copy())
print("Sorted:", sorted_data)
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Key element}: Current element to be inserted
\item
  \textbf{Shift right}: Larger elements move right
\item
  \textbf{Insert}: Key at correct position
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``KSI - Key, Shift, Insert''

\end{mnemonicbox}
\subsection*{Question 4(b OR) [4
marks]}\label{question-4b-or-4-marks}

\textbf{Apply Quick Sort to the following data and arrange them in the
proper manner. 5 6 1 8 2 9 10 15 7 13}

\begin{solutionbox}

\textbf{Quick Sort Steps:}

\begin{lstlisting}
Initial: [5, 6, 1, 8, 2, 9, 10, 15, 7, 13]
Pivot: 5 (first element)

Partition 1: [1, 2] 5 [6, 8, 9, 10, 15, 7, 13]

Left subarray [1, 2]:
Pivot: 1 \rightarrow [] 1 [2]
Result: [1, 2]

Right subarray [6, 8, 9, 10, 15, 7, 13]:
Pivot: 6 \rightarrow [] 6 [8, 9, 10, 15, 7, 13]

Continue partitioning...

Final: [1, 2, 5, 6, 7, 8, 9, 10, 13, 15]
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Divide}: Choose pivot, partition around it
\item
  \textbf{Conquer}: Recursively sort subarrays
\item
  \textbf{Average time}: O(n log n)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DCC - Divide, Conquer, Combine''

\end{mnemonicbox}
\subsection*{Question 4(c OR) [7
marks]}\label{question-4c-or-7-marks}

\textbf{Implement Merge sort algorithm.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# Example usage
data = [38, 27, 43, 3, 9, 82, 10]
sorted_data = merge_sort(data)
print("Sorted array:", sorted_data)
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Divide}: Split array into halves
\item
  \textbf{Merge}: Combine sorted subarrays
\item
  \textbf{Time complexity}: O(n log n) always
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DSM - Divide, Sort, Merge''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Write Short note on: Applications of Tree.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Tree Applications}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Application & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{File systems} & Directory structure & Folders and files \\
\textbf{Expression parsing} & Mathematical expressions & (a+b)*c \\
\textbf{Database indexing} & Fast data retrieval & B-trees in
databases \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Decision trees}: AI and machine learning
\item
  \textbf{Huffman coding}: Data compression
\item
  \textbf{Game trees}: Chess, tic-tac-toe
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FED - File, Expression, Database''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Explain different Tree Traversal Methods.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Tree Traversal Methods}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & Order & Process \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Inorder} & Left-Root-Right & LNR \\
\textbf{Preorder} & Root-Left-Right & NLR \\
\textbf{Postorder} & Left-Right-Root & LRN \\
\end{longtable}
}

\begin{lstlisting}
Example Tree:
        A
       / \
      B   C
     / \
    D   E

Inorder: D B E A C
Preorder: A B D E C  
Postorder: D E B C A
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Inorder}: Gives sorted sequence for BST
\item
  \textbf{Preorder}: Used for copying tree
\item
  \textbf{Postorder}: Used for deleting tree
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``LNR PNL LRN for In-Pre-Post''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Write a menu driven program to perform the following operation
on Binary Search Tree: Create a BST.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        self.root = self._insert_recursive(self.root, data)
    
    def _insert_recursive(self, node, data):
        if node is None:
            return TreeNode(data)
        
        if data < node.data:
            node.left = self._insert_recursive(node.left, data)
        elif data > node.data:
            node.right = self._insert_recursive(node.right, data)
        
        return node
    
    def inorder(self, node):
        if node:
            self.inorder(node.left)
            print(node.data, end=" ")
            self.inorder(node.right)

def main():
    bst = BST()
    
    while True:
        print("\n1. Insert")
        print("2. Display (Inorder)")
        print("3. Exit")
        
        choice = int(input("Enter choice: "))
        
        if choice == 1:
            data = int(input("Enter data: "))
            bst.insert(data)
        elif choice == 2:
            print("BST (Inorder):", end=" ")
            bst.inorder(bst.root)
            print()
        elif choice == 3:
            break

if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{BST property}: Left \textless{} Root \textless{} Right
\item
  \textbf{Insertion}: Compare and go left/right
\item
  \textbf{Menu driven}: User-friendly interface
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CIM - Compare, Insert, Menu''

\end{mnemonicbox}
\subsection*{Question 5(a OR) [3
marks]}\label{question-5a-or-3-marks}

\textbf{Define and give examples : Strict Binary Tree and Complete
Binary Tree.}

\begin{solutionbox}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Binary Tree Types}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Strict Binary Tree} & Every node has 0 or 2 children & Each
internal node has exactly 2 children \\
\textbf{Complete Binary Tree} & All levels filled except possibly last,
filled left to right & Perfect structure till second last level \\
\end{longtable}
}

\begin{lstlisting}
Strict Binary Tree:
        A
       / \
      B   C
         / \
        D   E

Complete Binary Tree:
        A
       / \
      B   C
     / \ /
    D  E F
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Strict}: No node with single child
\item
  \textbf{Complete}: Optimal space utilization
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SC - Strict Complete''

\end{mnemonicbox}
\subsection*{Question 5(b OR) [4
marks]}\label{question-5b-or-4-marks}

\textbf{Explain basic terminology of Binary Tree : Level number, Degree,
Indegree , Out-degree , Leaf Node.}

\begin{solutionbox}

\begin{lstlisting}
Binary Tree Example:
    Level 0:     A        (Root)
                / \
   Level 1:    B   C
              / \   \
   Level 2:  D   E   F   (Leaves: D, E, F)
\end{lstlisting}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Binary Tree Terminology}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Term
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Level number} & Distance from root (root = 0) & A=0, B=1, D=2 \\
\textbf{Degree} & Number of children & A=2, B=2, C=1 \\
\textbf{Indegree} & Number of incoming edges & All nodes = 1 (except
root = 0) \\
\textbf{Out-degree} & Number of outgoing edges & Same as degree \\
\textbf{Leaf Node} & Node with no children & D, E, F \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``LDIOL - Level, Degree, In-Out, Leaf''

\end{mnemonicbox}
\subsection*{Question 5(c OR) [7
marks]}\label{question-5c-or-7-marks}

\textbf{Write a menu driven program to perform the following operation
on Binary Search Tree: Insert an element in BST.}

\begin{solutionbox}

\begin{lstlisting}[language=Python]
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
            print(f"Root node {data} created")
        else:
            self._insert_helper(self.root, data)
    
    def _insert_helper(self, node, data):
        if data < node.data:
            if node.left is None:
                node.left = TreeNode(data)
                print(f"Inserted {data} to left of {node.data}")
            else:
                self._insert_helper(node.left, data)
        elif data > node.data:
            if node.right is None:
                node.right = TreeNode(data)
                print(f"Inserted {data} to right of {node.data}")
            else:
                self._insert_helper(node.right, data)
        else:
            print(f"Data {data} already exists")
    
    def display_inorder(self, node, result):
        if node:
            self.display_inorder(node.left, result)
            result.append(node.data)
            self.display_inorder(node.right, result)

def main():
    bst = BST()
    
    while True:
        print("\n--- BST Operations ---")
        print("1. Insert Element")
        print("2. Display BST (Inorder)")
        print("3. Exit")
        
        choice = int(input("Enter your choice: "))
        
        if choice == 1:
            data = int(input("Enter element to insert: "))
            bst.insert(data)
        elif choice == 2:
            result = []
            bst.display_inorder(bst.root, result)
            print("BST Elements (sorted):", result)
        elif choice == 3:
            print("Exiting...")
            break
        else:
            print("
            print("Invalid choice!")

if __name__ == "__main__":
    main()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Insert logic}: Compare with current node, go left/right
\item
  \textbf{Recursive approach}: Clean and efficient implementation
\item
  \textbf{Menu system}: Interactive user interface
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CRL - Compare, Recursive, Left/right''

\end{mnemonicbox}

\end{document}
