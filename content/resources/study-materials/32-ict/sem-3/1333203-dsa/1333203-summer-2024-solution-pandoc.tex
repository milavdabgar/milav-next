\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 1333203 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Define linear data structure and give its examples.}

\begin{solutionbox}
A linear data structure is a collection of elements
arranged in sequential order where each element has exactly one
predecessor and one successor (except first and last elements).


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Linear Data Structures Examples}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Data Structure & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Array & Fixed-size collection of elements accessed by index \\
Linked List & Chain of nodes with data and reference to next node \\
Stack & LIFO (Last In First Out) structure \\
Queue & FIFO (First In First Out) structure \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ALSQ are in a Line''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Define time and space complexity.}

\begin{solutionbox}
Time and space complexity measure algorithm efficiency
in terms of execution time and memory usage as input size grows.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Complexity Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3019}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2264}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2453}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2264}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Complexity Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Measurement
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Importance
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Time Complexity & Measures execution time required by an algorithm as a
function of input size & Big O notation (O(n), O(1), O(n^{2})) & Determines
how fast an algorithm runs \\
Space Complexity & Measures memory space required by an algorithm as a
function of input size & Big O notation (O(n), O(1), O(n^{2})) & Determines
how much memory an algorithm needs \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``TS: Time-Speed and Space-Storage''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Explain the concept of class and object with example.}

\begin{solutionbox}
Classes and objects are fundamental OOP concepts where
classes are blueprints for creating objects with attributes and
behaviors.

\textbf{Diagram: Class and Object Relationship}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-1fe0b29e.pdf}

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
class Student:
    def __init__(self, name, rollNo, marks):
        self.name = name
        self.rollNo = rollNo
        self.marks = marks
    
    def displayInfo(self):
        print(f"Name: {self.name}, Roll No: {self.rollNo}, Marks: {self.marks}")

# Creating object
student1 = Student("Raj", 101, 85.5)
student1.displayInfo()
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Class}: Blueprint defining attributes (name, rollNo, marks)
  and methods (displayInfo)
\item
  \textbf{Object}: Instance (student1) created from the class with
  specific values
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CAR - Class defines Attributes and Routines''

\end{mnemonicbox}
\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Explain instance method, class method and static method with
example.}

\begin{solutionbox}
Python supports three method types: instance, class,
and static methods, each serving different purposes.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Comparison of Method Types}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2241}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1897}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2931}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1552}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1379}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Decorator
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
First Parameter
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Access
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Instance Method & None & self & Operate on instance data & Can
access/modify instance state \\
Class Method & @classmethod & cls & Operate on class data & Can
access/modify class state \\
Static Method & @staticmethod & None & Utility functions & Cannot access
instance or class state \\
\end{longtable}
}

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
class Student:
    school = "ABC School"  # class variable
    
    def __init__(self, name):
        self.name = name  # instance variable
    
    def instance_method(self):  # instance method
        return f"Hi {self.name} from {self.school}"
    
    @classmethod
    def class_method(cls):  # class method
        return f"School is {cls.school}"
    
    @staticmethod
    def static_method():  # static method
        return "This is a utility function"
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``ICS: Instance-Self, Class-Cls, Static-Solo''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Explain concept of recursive function.}

\begin{solutionbox}
A recursive function is a function that calls itself
during its execution to solve smaller instances of the same problem.

\textbf{Diagram: Recursive Function Execution}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-14e877fb.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``BASE and RECURSE - Base case stops, Recursion
repeats''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Define stack and queue.}

\begin{solutionbox}
Stack and queue are linear data structures with
different access patterns for data insertion and removal.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Stack vs Queue}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3913}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3043}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Stack
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Queue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Access Pattern & LIFO (Last In First Out) & FIFO (First In First Out) \\
Operations & Push (insert), Pop (remove) & Enqueue (insert), Dequeue
(remove) \\
Access Points & Single end (top) & Two ends (front, rear) \\
Visualization & Like plates stacked vertically & Like people in a
line \\
Applications & Function calls, undo operations & Print jobs, process
scheduling \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``SLIFF vs QFIFF - Stack-LIFO vs Queue-FIFO''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Explain basic operations on stack.}

\begin{solutionbox}
Stack operations follow LIFO (Last In First Out)
principle with the following basic operations:


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Stack Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Description & Time Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Push & Insert element at the top & O(1) \\
Pop & Remove element from the top & O(1) \\
Peek/Top & View top element without removing & O(1) \\
isEmpty & Check if stack is empty & O(1) \\
isFull & Check if stack is full (for array implementation) & O(1) \\
\end{longtable}
}

\textbf{Diagram: Stack Operations}

\begin{lstlisting}
       +---+    Push
       | 8 | <-------
Top -> +---+
       | 5 |    Pop
       +---+ -------->
       | 3 |
       +---+
       | 1 |
       +---+
\end{lstlisting}

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.isEmpty():
            return self.items.pop()
    
    def peek(self):
        if not self.isEmpty():
            return self.items[-1]
    
    def isEmpty(self):
        return len(self.items) == 0
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``PIPES - Push In, Pop Exit, See top''

\end{mnemonicbox}
\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{Define singly linked list.}

\begin{solutionbox}
A singly linked list is a linear data structure with a
collection of nodes where each node contains data and a reference to the
next node.

\textbf{Diagram: Singly Linked List}

\begin{lstlisting}
    +---------+    +---------+    +---------+    +---------+
    | Data:10 |    | Data:20 |    | Data:30 |    | Data:40 |
    |  Next:--|--->|  Next:--|--->|  Next:--|--->|  Next:/0|
    +---------+    +---------+    +---------+    +---------+
     Head Node                                    Tail Node
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``DNL - Data and Next Link''

\end{mnemonicbox}
\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{Explain Enqueue and Dequeue operations on Queue.}

\begin{solutionbox}
Enqueue and Dequeue are the primary operations for
adding and removing elements in a queue data structure.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Queue Operations}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1930}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2281}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2807}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2982}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Operation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Implementation
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Time Complexity
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Enqueue & Add element at the rear end & queue.append(element) & O(1) \\
Dequeue & Remove element from the front end & element = queue.pop(0) &
O(1) with linked list, O(n) with array \\
\end{longtable}
}

\textbf{Diagram: Queue Operations}

\begin{lstlisting}
      Enqueue                         Dequeue
     -------->                       --------->
     +-----+    +-----+    +-----+    +-----+
Rear |  30 |    |  20 |    |  10 |   Front
     +-----+    +-----+    +-----+
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``ERfDFr - Enqueue at Rear, Dequeue from Front''

\end{mnemonicbox}
\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Convert expression A+B/C+D to postfix and evaluate postfix
expression using stack assuming some values for A, B, C and D.}

\begin{solutionbox}
Converting and evaluating the expression ``A+B/C+D''
using stack:

\textbf{Step 1: Convert to Postfix}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Infix to Postfix Conversion}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Symbol & Stack & Output & Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & & A & Add to output \\
+ & + & A & Push to stack \\
B & + & A B & Add to output \\
/ & + / & A B & Push to stack (higher precedence) \\
C & + / & A B C & Add to output \\
+ & + & A B C / & Pop all higher/equal precedence, push + \\
D & + & A B C / + D & Add to output \\
End & & A B C / + D + & Pop remaining operators \\
\end{longtable}
}

\textbf{Final Postfix:} A B C / + D +

\textbf{Step 2: Evaluate with values A=5, B=10, C=2, D=3}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Postfix Evaluation}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Symbol & Stack & Calculation \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
5 (A) & 5 & Push value \\
10 (B) & 5, 10 & Push value \\
2 (C) & 5, 10, 2 & Push value \\
/ & 5, 5 & 10/2 = 5 \\
+ & 10 & 5+5 = 10 \\
3 (D) & 10, 3 & Push value \\
+ & 13 & 10+3 = 13 \\
\end{longtable}
}

\textbf{Result:} 13

\end{solutionbox}
\begin{mnemonicbox}
``PC-SE - Push operands, Calculate when operators,
Stack holds Everything''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Enlist applications of Linked List.}

\begin{solutionbox}
Linked lists are versatile data structures with many
practical applications.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Applications of Linked List}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3421}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6579}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Why Linked List is Used
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Dynamic Memory Allocation & Efficient insertion/deletion without
reallocation \\
Implementing Stacks \& Queues & Can grow and shrink as needed \\
Undo Functionality & Easy to add/remove operations from history \\
Hash Tables & For handling collisions via chaining \\
Music Playlists & Easy navigation between songs (next/previous) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``DSUHM - Dynamic allocation, Stacks \& queues, Undo,
Hash tables, Music players''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Explain creation of singly linked list in python.}

\begin{solutionbox}
Creating a singly linked list in Python involves
defining a Node class and implementing basic operations.

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def append(self, data):
        new_node = Node(data)
        # If empty list, set new node as head
        if self.head is None:
            self.head = new_node
            return
        # Traverse to the end and add node
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node
\end{lstlisting}

\textbf{Diagram: Creating a Linked List}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-21d3ded3.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``CHEN - Create nodes, Head first, End attachment,
Next pointers''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Write a code to insert a new node at the beginning and end of
singly linked list.}

\begin{solutionbox}
Adding nodes at the beginning and end of a singly
linked list requires different approaches.

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    # Insert at beginning (prepend)
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    
    # Insert at end (append)
    def insert_at_end(self, data):
        new_node = Node(data)
        # If empty list
        if self.head is None:
            self.head = new_node
            return
        
        # Traverse to last node
        current = self.head
        while current.next:
            current = current.next
        
        # Attach new node
        current.next = new_node
\end{lstlisting}

\textbf{Diagram: Insertion Operations}

\begin{lstlisting}
  Insert at Beginning:          Insert at End:
  +---------+       +-----+     +-----+     +-----+     +---------+
  | New Node|------>| Head|     | Head|---->| ... |---->| New Node|
  +---------+       +-----+     +-----+     +-----+     +---------+
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``BEN - Beginning is Easy and Next-based, End Needs
traversal''

\end{mnemonicbox}
\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

\textbf{Write a code to count the number of nodes in singly linked
list.}

\begin{solutionbox}
Counting nodes requires traversing the entire linked
list from head to tail.

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
def count_nodes(self):
    count = 0
    current = self.head
    
    # Traverse the list and count nodes
    while current:
        count += 1
        current = current.next
    
    return count
\end{lstlisting}

\textbf{Diagram: Counting Nodes}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-273888bc.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``CIT - Count Incrementally while Traversing''

\end{mnemonicbox}
\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Match appropriate options from column A and B}

\begin{solutionbox}
The matching between different linked list types and
their characteristics:


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Matching Linked List Types with Characteristics}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3704}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3704}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2593}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Column A
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Column B
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Match
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Singly Linked List & c.~Nodes contain data and a reference to the
next node & 1-c \\
2. Doubly Linked List & d.~Nodes contain data and references to both the
next and previous nodes & 2-d \\
3. Circular Linked List & b. Nodes form a loop where the last node
points to the first node & 3-b \\
4. Node in a Linked List & a. Basic unit containing data and references
& 4-a \\
\end{longtable}
}

\textbf{Diagram: Different Linked List Types}

\begin{lstlisting}
Singly Linked:    A->B->C->D->null
Doubly Linked:    A<->B<->C<->D<->null
Circular Linked:  A->B->C->D-+
                  ^          |
                  +----------+
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``SDCN - Single-Direction, Double-Direction,
Circular-Connection, Node-Component''

\end{mnemonicbox}
\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{Explain deletion of first and last node in singly linked list.}

\begin{solutionbox}
Deleting nodes from a singly linked list varies in
complexity based on the position (first vs.~last).


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Deletion Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3400}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Position
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Approach
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Time Complexity
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Special Case
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
First Node & Change head pointer & O(1) & Check if list is empty \\
Last Node & Traverse to second-last node & O(n) & Handle single node
list \\
\end{longtable}
}

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
def delete_first(self):
    # Check if list is empty
    if self.head is None:
        return
    
    # Update head to second node
    self.head = self.head.next

def delete_last(self):
    # Check if list is empty
    if self.head is None:
        return
    
    # If only one node
    if self.head.next is None:
        self.head = None
        return
    
    # Traverse to second last node
    current = self.head
    while current.next.next:
        current = current.next
    
    # Remove last node
    current.next = None
\end{lstlisting}

\textbf{Diagram: Deletion Operations}

\begin{lstlisting}
Delete First:               Delete Last:
+-----+     +-----+         +-----+     +-----+     +-----+
| Head|---->| Next|   =>    | Head|---->| Next|---->| Last|   =>
+-----+     +-----+         +-----+     +-----+     +-----+
                            +-----+     +-----+
                            | Head|---->| Next|--X
                            +-----+     +-----+
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``FELO - First is Easy, Last needs One-before-last''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Explain concept of doubly linked list.}

\begin{solutionbox}
A doubly linked list is a bidirectional linear data
structure with nodes containing data, previous, and next references.

\textbf{Diagram: Doubly Linked List}

\begin{lstlisting}
    +-------------------+     +-------------------+     +-------------------+
    | prev | data | next|     | prev | data | next|     | prev | data | next|
NULL<------|  10  |---->|<----|  20  |---->|<-----|  30 |----->NULL         |
    +-------------------+     +-------------------+     +-------------------+
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``PDN - Previous, Data, Next''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Explain concept of linear search.}

\begin{solutionbox}
Linear search is a simple sequential search algorithm
that checks each element one by one until finding the target.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Linear Search Characteristics}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Aspect & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Working & Sequentially check each element from start to end \\
Time Complexity & O(n) - worst and average case \\
Best Case & O(1) - element found at first position \\
Suitability & Small lists or unsorted data \\
Advantage & Simple implementation, works on any collection \\
\end{longtable}
}

\textbf{Diagram: Linear Search Process}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-bc36c6c9.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``SCENT - Search Consecutively Each element until
Target''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Write a code to implement binary search algorithm.}

\begin{solutionbox}
Binary search is an efficient algorithm for finding
elements in a sorted array by repeatedly dividing the search interval in
half.

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Check if target is present at mid
        if arr[mid] == target:
            return mid
        
        # If target is greater, ignore left half
        elif arr[mid] < target:
            left = mid + 1
        
        # If target is smaller, ignore right half
        else:
            right = mid - 1
    
    # Target not found
    return -1
\end{lstlisting}

\textbf{Diagram: Binary Search Process}

\begin{lstlisting}
 Array: [10, 20, 30, 40, 50, 60, 70]
 Search: 40

 Step 1: mid = 3, arr[mid] = 40 (Found!)
  left                 right
   |                     |
  [10, 20, 30, 40, 50, 60, 70]
               ^
              mid
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``MCLR - Middle Compare, Left or Right adjust''

\end{mnemonicbox}
\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{Explain concept of selection sort algorithm.}

\begin{solutionbox}
Selection sort is a simple comparison-based sorting
algorithm that divides the array into sorted and unsorted regions.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Selection Sort Characteristics}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3810}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6190}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Approach & Find minimum element from unsorted part and place at
beginning \\
Time Complexity & O(n^{2}) - worst, average, and best cases \\
Space Complexity & O(1) - in-place sorting \\
Stability & Not stable (equal elements may change relative order) \\
Advantage & Simple implementation with minimal memory usage \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``FSMR - Find Smallest, Move to Right position,
Repeat''

\end{mnemonicbox}
\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Explain bubble sort method.}

\begin{solutionbox}
Bubble sort is a simple sorting algorithm that
repeatedly steps through the list, compares adjacent elements, and swaps
them if they're in the wrong order.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Bubble Sort Characteristics}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Aspect & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Approach & Repeatedly compare adjacent elements and swap if needed \\
Passes & (n-1) passes for n elements \\
Time Complexity & O(n^{2}) - worst and average case, O(n) - best case \\
Space Complexity & O(1) - in-place sorting \\
Optimization & Early termination if no swaps occur in a pass \\
\end{longtable}
}

\textbf{Diagram: Bubble Sort Process}

\begin{lstlisting}
Array: [5, 3, 8, 4, 2]

Pass 1: [3, 5, 4, 2, 8]
        ^-^ ^-^ ^-^
         
Pass 2: [3, 4, 2, 5, 8]
         ^-^ ^-^

Pass 3: [3, 2, 4, 5, 8]
         ^-^

Pass 4: [2, 3, 4, 5, 8] (Sorted)
         ^-^
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``CABS - Compare Adjacent, Bubble-up Swapping''

\end{mnemonicbox}
\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Explain the working of quick sort method with example.}

\begin{solutionbox}
Quick sort is an efficient divide-and-conquer sorting
algorithm that works by selecting a pivot element and partitioning the
array.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Quick Sort Steps}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3158}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6842}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Step
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Choose a pivot element from the array \\
2 & Partition: Rearrange elements (smaller than pivot to left, larger to
right) \\
3 & Recursively apply quick sort to subarrays on left and right of
pivot \\
\end{longtable}
}

\textbf{Example with Array [7, 2, 1, 6, 8, 5, 3, 4]}:

\begin{lstlisting}
Pivot: 4
After partition: [2, 1, 3] 4 [7, 6, 8, 5]
                 Left      P  Right

Recursively sort left: [1] 2 [3] \rightarrow [1, 2, 3]
Recursively sort right: [5] 7 [6, 8] \rightarrow [5, 6, 7, 8]

Final sorted array: [1, 2, 3, 4, 5, 6, 7, 8]
\end{lstlisting}

\textbf{Diagram: Quick Sort Partitioning}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-f805bcc6.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``PPR - Pivot, Partition, Recursive divide''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Explain binary tree.}

\begin{solutionbox}
A binary tree is a hierarchical data structure where
each node has at most two children referred to as left and right child.

\textbf{Diagram: Binary Tree}

\begin{lstlisting}
        A
       / \
      B   C
     / \   \
    D   E   F
\end{lstlisting}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Binary Tree Properties}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Property & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Node & Contains data and references to left and right children \\
Depth & Length of path from root to the node \\
Height & Length of the longest path from node to a leaf \\
Binary Tree & Each node has at most 2 children \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``RLTM - Root, Left, Two, Maximum''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Define the terms root, path, parent and children with reference
to tree.}

\begin{solutionbox}
Trees have specific terminology to describe
relationships between nodes in the hierarchy.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Tree Terminology}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Term & Definition \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Root & Topmost node of the tree with no parent \\
Path & Sequence of nodes connected by edges from one node to another \\
Parent & Node that has one or more child nodes \\
Children & Nodes directly connected to a parent node \\
\end{longtable}
}

\textbf{Diagram: Tree Terminology}

\begin{lstlisting}
        A  <-- Root
       / \
      B   C  <-- Children of A, A is Parent
     / \   \   
    D   E   F  <-- Path from A to F: A->C->F
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``RPPC - Root at Top, Path connects, Parent above,
Children below''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Apply preorder and postorder traversal for given below tree.}

\begin{solutionbox}
Preorder and postorder are depth-first tree traversal
methods with different node visiting sequences.

\textbf{Given Tree:}

\begin{lstlisting}
        40
       /  \
     30    50
    / \    / \
   25 35  45  60
  / \        / \
 15  28     55  70
\end{lstlisting}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Tree Traversal Comparison}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2619}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5714}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Traversal
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Order
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Result for Given Tree
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Preorder & Root, Left, Right & 40, 30, 25, 15, 28, 35, 50, 45, 60, 55,
70 \\
Postorder & Left, Right, Root & 15, 28, 25, 35, 30, 45, 55, 70, 60, 50,
40 \\
\end{longtable}
}

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
def preorder(root):
    if root:
        print(root.data, end=", ")  # Visit root
        preorder(root.left)         # Visit left subtree
        preorder(root.right)        # Visit right subtree

def postorder(root):
    if root:
        postorder(root.left)        # Visit left subtree
        postorder(root.right)       # Visit right subtree
        print(root.data, end=", ")  # Visit root
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``PRE-NLR, POST-LRN - Preorder (Node-Left-Right),
Postorder (Left-Right-Node)''

\end{mnemonicbox}
\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{Enlist applications of binary tree.}

\begin{solutionbox}
Binary trees have numerous practical applications in
various fields of computer science.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Binary Tree Applications}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Application
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Binary Search Trees & Efficient searching, insertion, and deletion
operations \\
Expression Trees & Representing mathematical expressions for
evaluation \\
Huffman Coding & Data compression algorithms \\
Priority Queues & Implementation of heap data structure \\
Decision Trees & Classification algorithms in machine learning \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``BEHPD - BST, Expression, Huffman, Priority queue,
Decision tree''

\end{mnemonicbox}
\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Explain insertion of a node in binary search tree.}

\begin{solutionbox}
Insertion in a Binary Search Tree (BST) follows the BST
property: left child \textless{} parent \textless{} right child.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Insertion Steps in BST}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Step & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Start at the root node \\
2 & If new value \textless{} current node value, go to left subtree \\
3 & If new value \textgreater{} current node value, go to right
subtree \\
4 & Repeat until finding an empty position (null pointer) \\
5 & Insert the new node at the empty position found \\
\end{longtable}
}

\textbf{Diagram: BST Insertion}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-b3585fa5.pdf}

\end{solutionbox}
\begin{mnemonicbox}
``LSRG - Less-go-left, Same-or-greater-go-right''

\end{mnemonicbox}
\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{Draw Binary search tree for 8, 4, 12, 2, 6, 10, 14, 1, 3, 5 and
write In-order traversal for the tree.}

\begin{solutionbox}
Binary Search Tree (BST) is constructed by inserting
nodes while maintaining the BST property.

\textbf{Binary Search Tree for the given elements:}

\begin{lstlisting}
        8
       / \
      4   12
     / \  / \
    2   6 10 14
   / \  /
  1   3 5
\end{lstlisting}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{BST Construction Process}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Step & Insert & Tree Structure \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 8 & Root = 8 \\
2 & 4 & Left of 8 \\
3 & 12 & Right of 8 \\
4 & 2 & Left of 4 \\
5 & 6 & Right of 4 \\
6 & 10 & Left of 12 \\
7 & 14 & Right of 12 \\
8 & 1 & Left of 2 \\
9 & 3 & Right of 2 \\
10 & 5 & Left of 6 \\
\end{longtable}
}

\textbf{In-order Traversal:}

An in-order traversal visits nodes in the order: left subtree, current
node, right subtree.

For the given BST, the in-order traversal is: 1, 2, 3, 4, 5, 6, 8, 10,
12, 14

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)    # Visit left subtree
        print(root.data, end=", ")      # Visit current node
        inorder_traversal(root.right)   # Visit right subtree
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``LNR - Left, Node, Right makes sorted order in BST''

\end{mnemonicbox}

\end{document}
