\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 1333203 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{રેખીય ડેટા સ્ટ્રક્ચર વ્યાખ્યાયિત કરો અને તેના ઉદાહરણો આપો.}

\begin{solutionbox}
રેખીય ડેટા સ્ટ્રક્ચર એ એલિમેન્ટ્સનો એવો સંગ્રહ છે કે જેમાં દરેક એલિમેન્ટની
પહેલાં અને પછી એક જ એલિમેન્ટ હોય છે (સિવાય કે પ્રથમ અને છેલ્લા એલિમેન્ટ).


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{રેખીય ડેટા સ્ટ્રક્ચરના ઉદાહરણો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ડેટા સ્ટ્રક્ચર & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Array & નિશ્ચિત સાઇઝનો એલિમેન્ટ્સનો સંગ્રહ જે ઇન્ડેક્સ દ્વારા ઍક્સેસ થાય છે \\
Linked List & નોડ્સની શ્રેણી જેમાં ડેટા અને આગળના નોડનો રેફરન્સ હોય છે \\
Stack & LIFO (લાસ્ટ ઇન ફર્સ્ટ આઉટ) સ્ટ્રક્ચર \\
Queue & FIFO (ફર્સ્ટ ઇન ફર્સ્ટ આઉટ) સ્ટ્રક્ચર \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ALSQ એ લાઇનમાં છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{ટાઇમ અને સ્સ્પેસ કોમ્પ્લેક્ષીટી વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
ટાઇમ અને સ્પેસ કોમ્પ્લેક્સિટી એલ્ગોરિધમની કાર્યક્ષમતાને એક્ઝિક્યુશન
ટાઇમ અને મેમરી વપરાશના સંદર્ભમાં માપે છે, જેમ ઇનપુટ સાઇઝ વધે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{કોમ્પ્લેક્સિટી કમ્પેરિઝન}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3019}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2264}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2453}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2264}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કોમ્પ્લેક્સિટી પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
માપન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
મહત્વ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ટાઇમ કોમ્પ્લેક્સિટી & એલ્ગોરિધમના એક્ઝિક્યુશન ટાઇમને ઇનપુટ સાઇઝના ફંક્શન તરીકે માપે છે
& બિગ O નોટેશન (O(n), O(1), O(n^{2})) & એલ્ગોરિધમ કેટલી ઝડપથી ચાલે છે તે નક્કી કરે
છે \\
સ્પેસ કોમ્પ્લેક્સિટી & એલ્ગોરિધમને જરૂરી મેમરી સ્પેસને ઇનપુટ સાઇઝના ફંક્શન તરીકે માપે છે &
બિગ O નોટેશન (O(n), O(1), O(n^{2})) & એલ્ગોરિધમને કેટલી મેમરી જોઈએ છે તે નક્કી કરે
છે \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``TS: ટાઇમ-સ્પીડ અને સ્પેસ-સ્ટોરેજ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{ક્લાસ અને ઓબ્જેક્ટ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
ક્લાસ અને ઓબ્જેક્ટ એ OOP ના મૂળભૂત કોન્સેપ્ટ છે જ્યાં ક્લાસ એ એટ્રિબ્યુટ્સ
અને બિહેવિયર્સ ધરાવતા ઓબ્જેક્ટ બનાવવા માટેના બ્લુપ્રિન્ટ છે.

\textbf{ડાયાગ્રામ: ક્લાસ અને ઓબ્જેક્ટ રિલેશનશિપ}

\begin{verbatim}
classDiagram
    class Student \{
        +name: string
        +rollNo: int
        +marks: float
        +displayInfo()
    \}
    Student {|{-}{-} StudentObject: Creates}
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Student:
    def \_\_init\_\_(self, name, rollNo, marks):
        self.name = name
        self.rollNo = rollNo
        self.marks = marks
    
    def displayInfo(self):
        print(f"Name: \{self.name\}, Roll No: \{self.rollNo\}, Marks: \{self.marks\}")

\# ઓબ્જેક્ટ બનાવવા
student1 = Student("રાજ", 101, 85.5)
student1.displayInfo()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ક્લાસ}: એટ્રિબ્યુટ્સ (name, rollNo, marks) અને મેથડ્સ (displayInfo)
  વ્યાખ્યાયિત કરતા બ્લુપ્રિન્ટ
\item
  \textbf{ઓબ્જેક્ટ}: ક્લાસથી બનાવેલ ઇન્સ્ટન્સ (student1) જેમાં ચોક્કસ વેલ્યુઝ હોય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CAR - ક્લાસ એટ્રિબ્યુટ્સ અને રુટિન્સ વ્યાખ્યાયિત કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{ઇંસ્ટટંસ મેથડ, ક્લાસ મેથડ અને સ્ટેટિક મેથડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
Python ત્રણ પ્રકારની મેથડ્સને સપોર્ટ કરે છે: ઇન્સ્ટન્સ, ક્લાસ અને
સ્ટેટિક મેથડ, દરેક અલગ હેતુ માટે વપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{મેથડ પ્રકારોની તુલના}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2241}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1897}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2931}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1552}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1379}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મેથડ પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ડેકોરેટર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પ્રથમ પેરામીટર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
એક્સેસ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ઇન્સ્ટન્સ મેથડ & કોઈ નહીં & self & ઇન્સ્ટન્સ ડેટા પર કામ કરે & ઇન્સ્ટન્સ સ્ટેટને
એક્સેસ/મોડિફાઇ કરી શકે \\
ક્લાસ મેથડ & @classmethod & cls & ક્લાસ ડેટા પર કામ કરે & ક્લાસ સ્ટેટને
એક્સેસ/મોડિફાઇ કરી શકે \\
સ્ટેટિક મેથડ & @staticmethod & કોઈ નહીં & યુટિલિટી ફંક્શન્સ & ઇન્સ્ટન્સ કે ક્લાસ સ્ટેટને
એક્સેસ કરી શકતી નથી \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Student:
    school = "ABC School"  \# ક્લાસ વેરિએબલ
    
    def \_\_init\_\_(self, name):
        self.name = name  \# ઇન્સ્ટન્સ વેરિએબલ
    
    def instance\_method(self):  \# ઇન્સ્ટન્સ મેથડ
        return f"Hi \{self.name\} from \{self.school\}"
    
    @classmethod
    def class\_method(cls):  \# ક્લાસ મેથડ
        return f"School is \{cls.school\}"
    
    @staticmethod
    def static\_method():  \# સ્ટેટિક મેથડ
        return "This is a utility function"
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ICS: ઇન્સ્ટન્સ-Self, ક્લાસ-Cls, સ્ટેટિક-Solo''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{રીકર્ઝીવ ફંકશન નો કોંસેપ્ટ સમજાવો.}

\begin{solutionbox}
રિકર્સિવ ફંક્શન એ એવું ફંક્શન છે જે પોતાની એક્ઝિક્યુશન દરમિયાન સમાન
સમસ્યાના નાના ઉદાહરણોને હલ કરવા માટે પોતાને જ કૉલ કરે છે.

\textbf{ડાયાગ્રામ: રિકર્સિવ ફંક્શન એક્ઝિક્યુશન}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A["factorial(3)"] {-{-}{} B["factorial(2)"]}
    B {-{-}{} C["factorial(1)"]}
    C {-{-}{} D[Return 1]}
    D {-{-}{} E[Return 1*2=2]}
    E {-{-}{} F[Return 2*3=6]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\end{solutionbox}
\begin{mnemonicbox}
``BASE અને RECURSE - બેઝ કેસ સ્ટોપ્સ, રિકર્ઝન રિપીટ્સ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{સ્ટેક અને ક્યુ વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
સ્ટેક અને ક્યુ એ લીનિયર ડેટા સ્ટ્રક્ચર છે જેમાં ડેટા ઇન્સર્શન અને રિમૂવલ
માટે અલગ એક્સેસ પેટર્ન છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{સ્ટેક વિ. ક્યુ}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફીચર & સ્ટેક & ક્યુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
એક્સેસ પેટર્ન & LIFO (લાસ્ટ ઇન ફર્સ્ટ આઉટ) & FIFO (ફર્સ્ટ ઇન ફર્સ્ટ આઉટ) \\
ઓપરેશન્સ & પુશ (ઇન્સર્ટ), પૉપ (રિમૂવ) & એનક્યુ (ઇન્સર્ટ), ડિક્યુ (રિમૂવ) \\
એક્સેસ પોઇન્ટ્સ & સિંગલ એન્ડ (ટોપ) & ટુ એન્ડ્સ (ફ્રન્ટ, રિયર) \\
વિઝ્યુઅલાઇઝેશન & ઊભા થાંભલામાં ગોઠવેલી થાળીઓ જેવું & લાઇનમાં ઊભેલા લોકો જેવું \\
એપ્લિકેશન્સ & ફંક્શન કૉલ્સ, અનડુ ઓપરેશન્સ & પ્રિન્ટ જોબ્સ, પ્રોસેસ શેડ્યુલિંગ \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``SLIFF vs QFIFF - સ્ટેક-LIFO vs ક્યુ-FIFO''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{સ્ટેક ના બેઝિક ઓપરેશન સમજાવો.}

\begin{solutionbox}
સ્ટેક ઓપરેશન્સ LIFO (લાસ્ટ ઇન ફર્સ્ટ આઉટ) સિદ્ધાંતને અનુસરે છે અને
નીચેના મૂળભૂત ઓપરેશન્સ ધરાવે છે:


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{સ્ટેક ઓપરેશન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઓપરેશન & વર્ણન & ટાઇમ કોમ્પ્લેક્સિટી \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
પુશ & ટોપ પર એલિમેન્ટ ઇન્સર્ટ કરવું & O(1) \\
પૉપ & ટોપથી એલિમેન્ટ રિમૂવ કરવું & O(1) \\
પીક/ટોપ & રિમૂવ કર્યા વિના ટોપ એલિમેન્ટ જોવું & O(1) \\
isEmpty & ચેક કરવું કે સ્ટેક ખાલી છે કે નહીં & O(1) \\
isFull & ચેક કરવું કે સ્ટેક ભરેલો છે કે નહીં (એરે ઇમ્પ્લિમેન્ટેશન માટે) & O(1) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: સ્ટેક ઓપરેશન્સ}

\begin{verbatim}
       +{-{-}{-}+    Push}
       | 8 | {{-}{-}{-}{-}{-}{-}{-}}
Top {- +{-}{-}{-}+}
       | 5 |    Pop
       +{-{-}{-}+ {-}{-}{-}{-}{-}{-}{-}{-}}
       | 3 |
       +{-{-}{-}+}
       | 1 |
       +{-{-}{-}+}
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Stack:
    def \_\_init\_\_(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.isEmpty():
            return self.items.pop()
    
    def peek(self):
        if not self.isEmpty():
            return self.items[{-}1]
    
    def isEmpty(self):
        return len(self.items) == 0
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``PIPES - Push In, Pop Exit, See top''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{સિંગલી લિંક્ડ લિસ્ટ વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
સિંગલી લિંક્ડ લિસ્ટ એ એક લીનિયર ડેટા સ્ટ્રક્ચર છે જેમાં નોડ્સનો કલેક્શન
હોય છે જ્યાં દરેક નોડમાં ડેટા અને આગળના નોડનો રેફરન્સ હોય છે.

\textbf{ડાયાગ્રામ: સિંગલી લિંક્ડ લિસ્ટ}

\begin{verbatim}
    +{-{-}{-}{-}{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
    | Data:10 |    | Data:20 |    | Data:30 |    | Data:40 |
    |  Next:{-{-}|{-}{-}{-}|  Next:{-}{-}|{-}{-}{-}|  Next:{-}{-}|{-}{-}{-}|  Next:/0|}
    +{-{-}{-}{-}{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
     Head Node                                    Tail Node
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``DNL - ડેટા અને નેક્સ્ટ લિંક''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{ક્યુ ઉપર એનક્યુ ડીક્યુ ઓપરેશન સમજાવો.}

\begin{solutionbox}
એનક્યુ અને ડિક્યુ ક્યુ ડેટા સ્ટ્રક્ચરમાં એલિમેન્ટ્સ ઉમેરવા અને કાઢવા માટેના
મુખ્ય ઓપરેશન્સ છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ક્યુ ઓપરેશન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1930}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2281}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2807}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2982}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઇમ્પ્લિમેન્ટેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ટાઇમ કોમ્પ્લેક્સિટી
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
એનક્યુ & રિયર એન્ડ પર એલિમેન્ટ ઉમેરવું & queue.append(element) & O(1) \\
ડિક્યુ & ફ્રન્ટ એન્ડથી એલિમેન્ટ કાઢવું & element = queue.pop(0) & લિંક્ડ લિસ્ટ સાથે
O(1), એરે સાથે O(n) \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: ક્યુ ઓપરેશન્સ}

\begin{verbatim}
      Enqueue                         Dequeue
     {-{-}{-}{-}{-}{-}{-}{-}                       {-}{-}{-}{-}{-}{-}{-}{-}{-}}
     +{-{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}+}
Rear |  30 |    |  20 |    |  10 | Front
     +{-{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}+    +{-}{-}{-}{-}{-}+}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ERfDFr - Enqueue at Rear, Dequeue from Front''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{A+B/C+D પદ ને પોસ્ટફિક્સ મા ફેરવો અને STACK નો ઉપયોગ કરીને A,B,C અને D
ની કોઇ યકમત ધારીને એનુ મુલ્ય શોધો.}

\begin{solutionbox}
``A+B/C+D'' એક્સપ્રેશનને પોસ્ટફિક્સમાં કન્વર્ટ કરીને સ્ટેકનો ઉપયોગ
કરીને તેનું મૂલ્યાંકન કરવું:

\textbf{સ્ટેપ 1: પોસ્ટફિક્સમાં કન્વર્ટ કરવું}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ઇનફિક્સથી પોસ્ટફિક્સ કન્વર્ઝન}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
સિમ્બોલ & સ્ટેક & આઉટપુટ & એક્શન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
A & & A & આઉટપુટમાં ઉમેરો \\
+ & + & A & સ્ટેકમાં પુશ કરો \\
B & + & A B & આઉટપુટમાં ઉમેરો \\
/ & + / & A B & સ્ટેકમાં પુશ કરો (ઉચ્ચ પ્રિસિડન્સ) \\
C & + / & A B C & આઉટપુટમાં ઉમેરો \\
+ & + & A B C / & ઉચ્ચ/સમાન પ્રિસિડન્સના બધા ઓપરેટર્સ પૉપ કરો, + પુશ કરો \\
D & + & A B C / + D & આઉટપુટમાં ઉમેરો \\
End & & A B C / + D + & બાકીના ઓપરેટર્સ પૉપ કરો \\
\end{longtable}
}

\textbf{ફાઇનલ પોસ્ટફિક્સ:} A B C / + D +

\textbf{સ્ટેપ 2: વેલ્યુઝ A=5, B=10, C=2, D=3 સાથે મૂલ્યાંકન કરવું}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{પોસ્ટફિક્સ ઇવેલ્યુએશન}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
સિમ્બોલ & સ્ટેક & કેલ્ક્યુલેશન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
5 (A) & 5 & વેલ્યુ પુશ કરો \\
10 (B) & 5, 10 & વેલ્યુ પુશ કરો \\
2 (C) & 5, 10, 2 & વેલ્યુ પુશ કરો \\
/ & 5, 5 & 10/2 = 5 \\
+ & 10 & 5+5 = 10 \\
3 (D) & 10, 3 & વેલ્યુ પુશ કરો \\
+ & 13 & 10+3 = 13 \\
\end{longtable}
}

\textbf{રિઝલ્ટ:} 13

\end{solutionbox}
\begin{mnemonicbox}
``PC-SE - પુશ ઓપરેન્ડ્સ, કેલ્ક્યુલેટ ઓપરેટર્સ પર, સ્ટેક બધું સ્ટોર
કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{લિંક્ડ લિસ્ટ ના ઉપયોગો લખો.}

\begin{solutionbox}
લિંક્ડ લિસ્ટ એ વર્સેટાઇલ ડેટા સ્ટ્રક્ચર છે જેના ઘણા વ્યવહારિક ઉપયોગો
છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{લિંક્ડ લિસ્ટના ઉપયોગો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
એપ્લિકેશન & શા માટે લિંક્ડ લિસ્ટ વપરાય છે \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડાયનેમિક મેમરી એલોકેશન & રિએલોકેશન વિના કાર્યક્ષમ ઇન્સર્શન/ડિલીશન \\
સ્ટેક અને ક્યુ ઇમ્પ્લિમેન્ટેશન & જરૂરિયાત મુજબ વધી અને ઘટી શકે છે \\
અનડુ ફંક્શનાલિટી & હિસ્ટરીમાંથી ઓપરેશન્સ સરળતાથી ઉમેરી/કાઢી શકાય છે \\
હેશ ટેબલ્સ & ચેઇનિંગ દ્વારા કોલિઝન હેન્ડલિંગ માટે \\
મ્યુઝિક પ્લેલિસ્ટ & ગીતો વચ્ચે સરળ નેવિગેશન (આગળ/પાછળ) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``DSUHM - ડાયનેમિક એલોકેશન, સ્ટેક \& ક્યુ, અનડુ, હેશ ટેબલ્સ,
મ્યુઝિક પ્લેયર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{પાયથનમા સિંગલી લિંક્ડ લિસ્ટ કેવી રીતે બનાવી શકાય એ સમજાવો.}

\begin{solutionbox}
પાયથનમાં સિંગલી લિંક્ડ લિસ્ટ બનાવવા માટે નોડ ક્લાસ ડિફાઇન કરવી
અને બેઝિક ઓપરેશન્સ ઇમ્પ્લિમેન્ટ કરવા પડે છે.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def append(self, data):
        new\_node = Node(data)
        \# જો લિસ્ટ ખાલી હોય, તો નવા નોડને હેડ તરીકે સેટ કરો
        if self.head is None:
            self.head = new\_node
            return
        \# છેલ્લે સુધી ટ્રેવર્સ કરીને નોડ ઉમેરો
        last = self.head
        while last.next:
            last = last.next
        last.next = new\_node
\end{verbatim}

\textbf{ડાયાગ્રામ: લિંક્ડ લિસ્ટ બનાવવી}

\begin{verbatim}
flowchart LR
    A["નોડ બનાવો"] {-{-} B["ખાલી હોય તો હેડ સેટ કરો"]}
    A {-{-} C["નહીંતર છેડા સુધી જાઓ"]}
    C {-{-} D["છેડે નવો નોડ જોડો"]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CHEN - Create nodes, Head first, End attachment,
Next pointers''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{સિંગલી લિંક્ડ લિસ્ટ ની શરૂઆતમાં અને અંતમાં નવા નોડ ઉમેરવાનો કોડ લખો.}

\begin{solutionbox}
સિંગલી લિંક્ડ લિસ્ટની શરૂઆત અને અંતમાં નોડ ઉમેરવા માટે અલગ અલગ
અભિગમની જરૂર પડે છે.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    \# શરૂઆતમાં ઉમેરવું (prepend)
    def insert\_at\_beginning(self, data):
        new\_node = Node(data)
        new\_node.next = self.head
        self.head = new\_node
    
    \# અંતમાં ઉમેરવું (append)
    def insert\_at\_end(self, data):
        new\_node = Node(data)
        \# જો ખાલી લિસ્ટ હોય
        if self.head is None:
            self.head = new\_node
            return
        
        \# છેલ્લા નોડ સુધી ટ્રેવર્સ કરો
        current = self.head
        while current.next:
            current = current.next
        
        \# નવો નોડ જોડો
        current.next = new\_node
\end{verbatim}

\textbf{ડાયાગ્રામ: ઇન્સર્શન ઓપરેશન્સ}

\begin{verbatim}
  Insert at Beginning:          Insert at End:
  +{-{-}{-}{-}{-}{-}{-}{-}{-}+       +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
  | New Node|{-{-}{-}{-}{-}{-}| Head|     | Head|{-}{-}{-}{-}| ... |{-}{-}{-}{-}| New Node|}
  +{-{-}{-}{-}{-}{-}{-}{-}{-}+       +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``BEN - Beginning is Easy and Next-based, End Needs
traversal''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{સિંગલી લિંક્ડ મા રહેલ નોડ ની સંખ્યા ગણવા માટેનો કોડ લખો.}

\begin{solutionbox}
નોડની સંખ્યા ગણવા માટે હેડથી ટેઇલ સુધી આખી લિંક્ડ લિસ્ટ ટ્રેવર્સ કરવી
પડે છે.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
def count\_nodes(self):
    count = 0
    current = self.head
    
    \# લિસ્ટને ટ્રેવર્સ કરો અને નોડ્સ ગણો
    while current:
        count += 1
        current = current.next
    
    return count
\end{verbatim}

\textbf{ડાયાગ્રામ: નોડ્સ ગણવા}

\begin{verbatim}
flowchart LR
    A[count=0 ઇનિશિયલાઇઝ કરો] {-{-} B[હેડથી શરૂ કરો]}
    B {-{-} C[દરેક નોડ ટ્રેવર્સ કરો]}
    C {-{-} D[count વધારો]}
    D {-{-} E[આગળના નોડ પર જાઓ]}
    E {-{-} C}
    C {-{-} બધા નોડ્સ ટ્રેવર્સ થયા {-}{-} F[count રિટર્ન કરો]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CIT - Count Incrementally while Traversing''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{કોલમ એ અને કોલમ બી ના યોગ્ય વિકલ્પ જોડો.}

\begin{solutionbox}
વિવિધ લિંક્ડ લિસ્ટ પ્રકારો અને તેમના લક્ષણો વચ્ચેનું મેચિંગ:


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{લિંક્ડ લિસ્ટ પ્રકારો અને લક્ષણોનું મેચિંગ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3704}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3704}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2593}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કોલમ એ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
કોલમ બી
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
મેચ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. સિંગલી લિંક્ડ લિસ્ટ & c.~નોડ્સમાં ડેટા અને આગામી નોડનો સંદર્ભ હોય છે & 1-c \\
2. ડબલી લિંક્ડ લિસ્ટ & d.~નોડ્સમાં આગામી અને પાછલા બંને નોડ્સનો ડેટા અને સંદર્ભો હોય
છે & 2-d \\
3. સર્ક્યુલર લિંક્ડ લિસ્ટ & b. નોડ્સ એક લૂપ બનાવે જેમા છેલ્લો નોડ પ્રથમ નોડ તરફ નિર્દેશ
કરે & 3-b \\
4. લિંક્ડ લિસ્ટ નો એક નોડ & a. મૂળભૂત એકમ કે જેમા ડેટા અને સંદર્ભ હોઇ & 4-a \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: વિવિધ લિંક્ડ લિસ્ટ પ્રકારો}

\begin{verbatim}
સિંગલી લિંક્ડ:    A{-B{-}C{-}D{-}null}
ડબલી લિંક્ડ:    A{{-}B{-}C{-}D{-}null}
સર્ક્યુલર લિંક્ડ:  A{-B{-}C{-}D{-}+}
                  \^{          |}
                  +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SDCN - Single-Direction, Double-Direction,
Circular-Connection, Node-Component''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{સિંગલી લિંક્ડ લિસ્ટ મા પ્રથમ અને છેલ્લો નોડ ને કાઢી નાખવાનુ સમજાવો.}

\begin{solutionbox}
સિંગલી લિંક્ડ લિસ્ટમાંથી નોડ કાઢવાની જટિલતા પોઝિશન (પ્રથમ વિ.
છેલ્લો) પર આધારિત હોય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ડિલીશન કંપેરિઝન}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3400}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પોઝિશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
અભિગમ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ટાઇમ કોમ્પ્લેક્સિટી
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્પેશિયલ કેસ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
પ્રથમ નોડ & હેડ પોઇન્ટર બદલો & O(1) & ચેક કરો કે લિસ્ટ ખાલી છે કે નહીં \\
છેલ્લો નોડ & બીજા છેલ્લા નોડ સુધી ટ્રેવર્સ કરો & O(n) & સિંગલ નોડ લિસ્ટ હેન્ડલ
કરો \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
def delete\_first(self):
    \# ચેક કરો કે લિસ્ટ ખાલી છે કે નહીં
    if self.head is None:
        return
    
    \# હેડને બીજા નોડ પર અપડેટ કરો
    self.head = self.head.next

def delete\_last(self):
    \# ચેક કરો કે લિસ્ટ ખાલી છે કે નહીં
    if self.head is None:
        return
    
    \# જો માત્ર એક જ નોડ હોય
    if self.head.next is None:
        self.head = None
        return
    
    \# બીજા છેલ્લા નોડ સુધી ટ્રેવર્સ કરો
    current = self.head
    while current.next.next:
        current = current.next
    
    \# છેલ્લો નોડ દૂર કરો
    current.next = None
\end{verbatim}

\textbf{ડાયાગ્રામ: ડિલીશન ઓપરેશન્સ}

\begin{verbatim}
Delete First:               Delete Last:
+{-{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+         +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+}
| Head|{-{-}{-}{-}| Next|   =    | Head|{-}{-}{-}{-}| Next|{-}{-}{-}{-}| Last|   =}
+{-{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+         +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+}
                            +{-{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+}
                            | Head|{-{-}{-}{-}| Next|{-}{-}X}
                            +{-{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}+}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``FELO - First is Easy, Last needs One-before-last''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{ડબ્લી લિંક્ડ લિસ્ટ નો કોન્સૈપ્ટ સમજાવો.}

\begin{solutionbox}
ડબલી લિંક્ડ લિસ્ટ એ બાયડાયરેક્શનલ લીનિયર ડેટા સ્ટ્રક્ચર છે જેમાં
નોડ્સમાં ડેટા, અગાઉના, અને આગળના રેફરન્સ હોય છે.

\textbf{ડાયાગ્રામ: ડબલી લિંક્ડ લિસ્ટ}

\begin{verbatim}
    +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
    | prev | data | next|     | prev | data | next|     | prev | data | next|
NULL{{-}{-}{-}{-}{-}{-}|  10  |{-}{-}{-}{-}|{-}{-}{-}{-}|  20  |{-}{-}{-}{-}|{-}{-}{-}{-}{-}|  30 |{-}{-}{-}{-}{-}NULL         |}
    +{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``PDN - Previous, Data, Next''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{લિનિયર સર્ચ નો કોન્સૈપ્ટ સમજાવો.}

\begin{solutionbox}
લિનિયર સર્ચ એ સરળ સિક્વેન્શિયલ સર્ચ અલ્ગોરિધમ છે જે ટાર્ગેટ શોધવા
માટે એક પછી એક દરેક એલિમેન્ટ ચેક કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{લિનિયર સર્ચ લક્ષણો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પાસું & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
કાર્યપ્રણાલી & શરૂઆતથી અંત સુધી ક્રમશઃ દરેક એલિમેન્ટ ચેક કરો \\
ટાઇમ કોમ્પ્લેક્સિટી & O(n) - વર્સ્ટ અને એવરેજ કેસ \\
બેસ્ટ કેસ & O(1) - પ્રથમ પોઝિશન પર એલિમેન્ટ મળે \\
અનુકૂળતા & નાના લિસ્ટ અથવા અનસોર્ટેડ ડેટા માટે \\
ફાયદો & સરળ ઇમ્પ્લિમેન્ટેશન, કોઈપણ કલેક્શન પર કામ કરે છે \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: લિનિયર સર્ચ પ્રોસેસ}

\begin{verbatim}
flowchart LR
    A[પ્રારંભ] {-{-} B[પ્રથમ એલિમેન્ટ ચેક કરો]}
    B {-{-} મેચ થયું {-}{-} C[પોઝિશન રિટર્ન કરો]}
    B {-{-} મેચ નથી થયું {-}{-} D[આગળના એલિમેન્ટ પર જાઓ]}
    D {-{-} E\{અંત સુધી પહોંચ્યા?\}}
    E {-{-} ના {-}{-} B}
    E {-{-} હા {-}{-} F[નથી મળ્યું]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SCENT - Search Consecutively Each element until
Target''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{બાયનરી સર્ચ અલ્ગોરિધમ ઇમ્પ્લીમેંટ કરવા માટેનો કોડ લખો.}

\begin{solutionbox}
બાયનરી સર્ચ એક કાર્યક્ષમ અલ્ગોરિધમ છે જે સર્ચ ઇન્ટરવલને વારંવાર
અડધા ભાગમાં વિભાજિત કરીને સોર્ટેડ એરેમાં એલિમેન્ટ્સ શોધે છે.

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
def binary\_search(arr, target):
    left = 0
    right = len(arr) {-} 1
    
    while left {=} right:
        mid = (left + right) // 2
        
        \# ચેક કરો કે ટાર્ગેટ મિડ પર છે કે નહીં
        if arr[mid] == target:
            return mid
        
        \# જો ટાર્ગેટ મોટો હોય, તો ડાબા ભાગને અવગણો
        elif arr[mid] {} target:
            left = mid + 1
        
        \# જો ટાર્ગેટ નાનો હોય, તો જમણા ભાગને અવગણો
        else:
            right = mid {-} 1
    
    \# ટાર્ગેટ નથી મળ્યો
    return {-}1
\end{verbatim}

\textbf{ડાયાગ્રામ: બાયનરી સર્ચ પ્રોસેસ}

\begin{verbatim}
 Array: [10, 20, 30, 40, 50, 60, 70]
 Search: 40

 Step 1: mid = 3, arr[mid] = 40 (મળી ગયું!)
  left                 right
   |                     |
  [10, 20, 30, 40, 50, 60, 70]
               \^{}
              mid
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``MCLR - Middle Compare, Left or Right adjust''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{સિલેક્શન સોર્ટ અલ્ગોરીધમ નો કોન્સૈપ્ટ સમજાવો.}

\begin{solutionbox}
સિલેક્શન સોર્ટ એ સરળ કમ્પેરિઝન-બેઝ્ડ સોર્ટિંગ અલ્ગોરિધમ છે જે એરેને
સોર્ટેડ અને અનસોર્ટેડ રીજનમાં વિભાજિત કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{સિલેક્શન સોર્ટ લક્ષણો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પાસું & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
અભિગમ & અનસોર્ટેડ ભાગમાંથી મિનિમમ એલિમેન્ટ શોધો અને શરૂઆતમાં મૂકો \\
ટાઇમ કોમ્પ્લેક્સિટી & O(n^{2}) - વર્સ્ટ, એવરેજ, અને બેસ્ટ કેસ \\
સ્પેસ કોમ્પ્લેક્સિટી & O(1) - ઇન-પ્લેસ સોર્ટિંગ \\
સ્ટેબિલિટી & સ્ટેબલ નથી (સમાન એલિમેન્ટ્સનો રિલેટિવ ઓર્ડર બદલાઈ શકે) \\
ફાયદો & સરળ ઇમ્પ્લિમેન્ટેશન સાથે મિનિમલ મેમરી વપરાશ \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``FSMR - Find Smallest, Move to Right position,
Repeat''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{બબલ સોર્ટ મેથડ સમજાવો.}

\begin{solutionbox}
બબલ સોર્ટ એ સરળ સોર્ટિંગ અલ્ગોરિધમ છે જે વારંવાર લિસ્ટમાં આગળ વધે
છે, આસપાસના એલિમેન્ટ્સની તુલના કરે છે, અને જો તેઓ ખોટા ક્રમમાં હોય તો તેમને સ્વેપ કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{બબલ સોર્ટ લક્ષણો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પાસું & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
અભિગમ & આસપાસના એલિમેન્ટ્સની વારંવાર તુલના કરો અને જરૂર પડે તો સ્વેપ કરો \\
પાસ & n એલિમેન્ટ્સ માટે (n-1) પાસ \\
ટાઇમ કોમ્પ્લેક્સિટી & O(n^{2}) - વર્સ્ટ અને એવરેજ કેસ, O(n) - બેસ્ટ કેસ \\
સ્પેસ કોમ્પ્લેક્સિટી & O(1) - ઇન-પ્લેસ સોર્ટિંગ \\
ઓપ્ટિમાઇઝેશન & જો કોઈ પાસમાં સ્વેપ ન થાય તો અર્લી ટર્મિનેશન \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: બબલ સોર્ટ પ્રોસેસ}

\begin{verbatim}
Array: [5, 3, 8, 4, 2]

Pass 1: [3, 5, 4, 2, 8]
        \^{{-}\^{} \^{}{-}\^{} \^{}{-}\^{}}
         
Pass 2: [3, 4, 2, 5, 8]
         \^{{-}\^{} \^{}{-}\^{}}

Pass 3: [3, 2, 4, 5, 8]
         \^{{-}\^{}}

Pass 4: [2, 3, 4, 5, 8] (સોર્ટેડ)
         \^{{-}\^{}}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CABS - Compare Adjacent, Bubble-up Swapping''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{ઉદાહરણ સાથે ક્વીક સોર્ટ મેથડનુ વર્કિંગ સમજાવો.}

\begin{solutionbox}
ક્વિક સોર્ટ એ કાર્યક્ષમ ડિવાઇડ-એન્ડ-કોન્કર સોર્ટિંગ અલ્ગોરિધમ છે જે
પિવોટ એલિમેન્ટ પસંદ કરીને અને એરેને પાર્ટિશન કરીને કામ કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ક્વિક સોર્ટ સ્ટેપ્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3158}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6842}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
સ્ટેપ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & એરેમાંથી પિવોટ એલિમેન્ટ પસંદ કરો \\
2 & પાર્ટિશન: એલિમેન્ટ્સને ફરીથી ગોઠવો (પિવોટથી નાના ડાબી બાજુ, મોટા જમણી
બાજુ) \\
3 & પિવોટની ડાબી અને જમણી બાજુના સબએરે પર રિકર્સિવલી ક્વિક સોર્ટ લાગુ કરો \\
\end{longtable}
}

\textbf{એરે [7, 2, 1, 6, 8, 5, 3, 4] સાથે ઉદાહરણ}:

\begin{verbatim}
Pivot: 4
After partition: [2, 1, 3] 4 [7, 6, 8, 5]
                 Left      P  Right

Recursively sort left: [1] 2 [3] \rightarrow [1, 2, 3]
Recursively sort right: [5] 7 [6, 8] \rightarrow [5, 6, 7, 8]

Final sorted array: [1, 2, 3, 4, 5, 6, 7, 8]
\end{verbatim}

\textbf{ડાયાગ્રામ: ક્વિક સોર્ટ પાર્ટિશનિંગ}

\begin{verbatim}
flowchart LR
    A[એરે: 7,2,1,6,8,5,3,4] {-{-} B[પિવોટ પસંદ કરો: 4]}
    B {-{-} C[પાર્ટિશન]}
    C {-{-} D[ડાબી: 2,1,3]}
    C {-{-} E[પિવોટ: 4]}
    C {-{-} F[જમણી: 7,6,8,5]}
    D {-{-} G[ડાબા ભાગને રિકર્સિવલી સોર્ટ કરો]}
    F {-{-} H[જમણા ભાગને રિકર્સિવલી સોર્ટ કરો]}
    G {-{-} I[સોર્ટેડ ડાબો: 1,2,3]}
    H {-{-} J[સોર્ટેડ જમણો: 5,6,7,8]}
    I {-{-} K[ફાઇનલ: 1,2,3,4,5,6,7,8]}
    E {-{-} K}
    J {-{-} K}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``PPR - Pivot, Partition, Recursive divide''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{બાયનરી ટ્રી સમજાવો.}

\begin{solutionbox}
બાયનરી ટ્રી એ એક હાયરાર્કિકલ ડેટા સ્ટ્રક્ચર છે જેમાં દરેક નોડને વધુમાં
વધુ બે ચિલ્ડ્રન હોય છે જેને લેફ્ટ અને રાઇટ ચાઇલ્ડ તરીકે ઓળખવામાં આવે છે.

\textbf{ડાયાગ્રામ: બાયનરી ટ્રી}

\begin{verbatim}
        A
       / {}
      B   C
     / {   }
    D   E   F
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{બાયનરી ટ્રી પ્રોપર્ટીઝ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પ્રોપર્ટી & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
નોડ & ડેટા અને લેફ્ટ અને રાઇટ ચિલ્ડ્રનના રેફરન્સ ધરાવે છે \\
ડેપ્થ & રૂટથી નોડ સુધીના પાથની લંબાઈ \\
હાઇટ & નોડથી લીફ સુધીના સૌથી લાંબા પાથની લંબાઈ \\
બાયનરી ટ્રી & દરેક નોડને વધુમાં વધુ 2 ચિલ્ડ્રન હોય છે \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``RLTM - Root, Left, Two, Maximum''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{ટ્રી ના સંદભભ મા રૂટ, પાથ, પેરંટ અને ચિલ્ડ્રન પદો વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
ટ્રીમાં હાયરાર્કીમાં નોડ્સ વચ્ચેના સંબંધોને વર્ણવવા માટે ચોક્કસ
શબ્દાવલી છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ટ્રી શબ્દાવલી}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પદ & વ્યાખ્યા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
રૂટ & ટ્રીનો સૌથી ઉપરનો નોડ જેને કોઈ પેરેન્ટ નથી હોતા \\
પાથ & એક નોડથી બીજા નોડ સુધી એજ દ્વારા જોડાયેલા નોડ્સનો સિક્વન્સ \\
પેરેન્ટ & એક અથવા વધુ ચાઇલ્ડ નોડ્સ ધરાવતો નોડ \\
ચિલ્ડ્રન & પેરેન્ટ નોડથી સીધા જોડાયેલા નોડ્સ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: ટ્રી શબ્દાવલી}

\begin{verbatim}
        A  {{-}{-} Root}
       / {}
      B   C  {{-}{-} Children of A, A is Parent}
     / {      }
    D   E   F  {{-}{-} Path from A to F: A{-}C{-}F}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``RPPC - Root at Top, Path connects, Parent above,
Children below''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{નીચે આપેલા ટ્રી માટે પ્રીઓર્ડર અને પોસ્ટઓર્ડર ટ્રાવર્સલ લાગુ કરો.}

\begin{solutionbox}
પ્રીઓર્ડર અને પોસ્ટઓર્ડર એ ડેપ્થ-ફર્સ્ટ ટ્રી ટ્રાવર્સલ મેથડ્સ છે જેમાં અલગ
અલગ નોડ વિઝિટિંગ સિક્વન્સ હોય છે.

\textbf{આપેલ ટ્રી:}

\begin{verbatim}
        40
       /  {}
     30    50
    / {    / }
   25 35  45  60
  / {        / }
 15  28     55  70
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ટ્રી ટ્રાવર્સલ કંપેરિઝન}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2619}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5714}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ટ્રાવર્સલ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઓર્ડર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આપેલ ટ્રી માટે રિઝલ્ટ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
પ્રીઓર્ડર & રૂટ, લેફ્ટ, રાઇટ & 40, 30, 25, 15, 28, 35, 50, 45, 60, 55, 70 \\
પોસ્ટઓર્ડર & લેફ્ટ, રાઇટ, રૂટ & 15, 28, 25, 35, 30, 45, 55, 70, 60, 50, 40 \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
def preorder(root):
    if root:
        print(root.data, end=", ")  \# રૂટ વિઝિટ
        preorder(root.left)         \# લેફ્ટ સબટ્રી વિઝિટ
        preorder(root.right)        \# રાઇટ સબટ્રી વિઝિટ

def postorder(root):
    if root:
        postorder(root.left)        \# લેફ્ટ સબટ્રી વિઝિટ
        postorder(root.right)       \# રાઇટ સબટ્રી વિઝિટ
        print(root.data, end=", ")  \# રૂટ વિઝિટ
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``PRE-NLR, POST-LRN - પ્રીઓર્ડર (Node-Left-Right),
પોસ્ટઓર્ડર (Left-Right-Node)''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) OR [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{બાયનરી ટ્રી ની એપ્લિકેશન્સ લખો.}

\begin{solutionbox}
બાયનરી ટ્રીના કમ્પ્યુટર સાયન્સના વિવિધ ક્ષેત્રોમાં અનેક વ્યવહારિક
ઉપયોગો છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{બાયનરી ટ્રી એપ્લિકેશન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
એપ્લિકેશન & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
બાયનરી સર્ચ ટ્રી & કાર્યક્ષમ સર્ચિંગ, ઇન્સર્શન, અને ડિલીશન ઓપરેશન્સ \\
એક્સપ્રેશન ટ્રી & ઇવેલ્યુએશન માટે મેથેમેટિકલ એક્સપ્રેશન્સ રજૂ કરવા \\
હફમેન કોડિંગ & ડેટા કમ્પ્રેશન અલ્ગોરિધમ્સ \\
પ્રાયોરિટી ક્યુ & હીપ ડેટા સ્ટ્રક્ચરનું ઇમ્પ્લિમેન્ટેશન \\
ડિસિઝન ટ્રી & મશીન લર્નિંગમાં ક્લાસિફિકેશન અલ્ગોરિધમ્સ \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``BEHPD - BST, Expression, Huffman, Priority queue,
Decision tree''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) OR [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{બાયનરી સર્ચ ટ્રી મા નોડ કેવી રીતે ઉમેરી શકાય તે સમજાવો.}

\begin{solutionbox}
બાયનરી સર્ચ ટ્રી (BST)માં ઇન્સર્શન BST પ્રોપર્ટી અનુસરે છે: લેફ્ટ
ચાઇલ્ડ \textless{} પેરેન્ટ \textless{} રાઇટ ચાઇલ્ડ.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{BST માં ઇન્સર્શન સ્ટેપ્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
સ્ટેપ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & રૂટ નોડથી શરૂ કરો \\
2 & જો નવી વેલ્યુ \textless{} કરંટ નોડ વેલ્યુ, તો લેફ્ટ સબટ્રીમાં જાઓ \\
3 & જો નવી વેલ્યુ \textgreater{} કરંટ નોડ વેલ્યુ, તો રાઇટ સબટ્રીમાં જાઓ \\
4 & ખાલી પોઝિશન (નલ પોઇન્ટર) મળે ત્યાં સુધી રિપીટ કરો \\
5 & મળેલી ખાલી પોઝિશન પર નવો નોડ ઇન્સર્ટ કરો \\
\end{longtable}
}

\textbf{ડાયાગ્રામ: BST ઇન્સર્શન}

\begin{verbatim}
flowchart LR
    A[રૂટથી શરૂ કરો] {-{-} B\{નવી વેલ્યુ  કરંટ?\}}
    B {-{-} હા {-}{-} C[લેફ્ટ ચાઇલ્ડ પર જાઓ]}
    B {-{-} ના {-}{-} D[રાઇટ ચાઇલ્ડ પર જાઓ]}
    C {-{-} E\{લેફ્ટ ચાઇલ્ડ છે?\}}
    D {-{-} F\{રાઇટ ચાઇલ્ડ છે?\}}
    E {-{-} હા {-}{-} B}
    E {-{-} ના {-}{-} G[લેફ્ટ ચાઇલ્ડ તરીકે ઇન્સર્ટ કરો]}
    F {-{-} હા {-}{-} B}
    F {-{-} ના {-}{-} H[રાઇટ ચાઇલ્ડ તરીકે ઇન્સર્ટ કરો]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LSRG - Less-go-left, Same-or-greater-go-right''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) OR [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{8, 4, 12, 2, 6, 10, 14, 1, 3, 5 નમ્બર માટે બાયનરી સર્ચ ટ્રી દોરો અને
ટ્રી માટે ઇન ઓર્ડર ટ્રાવર્સલ લખો.}

\begin{solutionbox}
બાયનરી સર્ચ ટ્રી (BST) BST પ્રોપર્ટી જાળવીને નોડ્સ ઇન્સર્ટ કરીને
બનાવવામાં આવે છે.

\textbf{આપેલ એલિમેન્ટ્સ માટે બાયનરી સર્ચ ટ્રી:}

\begin{verbatim}
        8
       / {}
      4   12
     / {  / }
    2   6 10 14
   / {  /}
  1   3 5
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{BST કન્સ્ટ્રક્શન પ્રોસેસ}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
સ્ટેપ & ઇન્સર્ટ & ટ્રી સ્ટ્રક્ચર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 8 & રૂટ = 8 \\
2 & 4 & 8 ની ડાબી બાજુ \\
3 & 12 & 8 ની જમણી બાજુ \\
4 & 2 & 4 ની ડાબી બાજુ \\
5 & 6 & 4 ની જમણી બાજુ \\
6 & 10 & 12 ની ડાબી બાજુ \\
7 & 14 & 12 ની જમણી બાજુ \\
8 & 1 & 2 ની ડાબી બાજુ \\
9 & 3 & 2 ની જમણી બાજુ \\
10 & 5 & 6 ની ડાબી બાજુ \\
\end{longtable}
}

\textbf{ઇન-ઓર્ડર ટ્રાવર્સલ:}

ઇન-ઓર્ડર ટ્રાવર્સલ નોડ્સને આ ક્રમમાં વિઝિટ કરે છે: લેફ્ટ સબટ્રી, કરંટ નોડ, રાઇટ
સબટ્રી.

આપેલ BST માટે, ઇન-ઓર્ડર ટ્રાવર્સલ આ છે: 1, 2, 3, 4, 5, 6, 8, 10, 12, 14

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
def inorder\_traversal(root):
    if root:
        inorder\_traversal(root.left)    \# લેફ્ટ સબટ્રી વિઝિટ
        print(root.data, end=", ")      \# કરંટ નોડ વિઝિટ
        inorder\_traversal(root.right)   \# રાઇટ સબટ્રી વિઝિટ
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LNR - Left, Node, Right makes sorted order in
BST''

\end{mnemonicbox}

\end{document}
