\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 1333203 -- Summer 2025}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{વ્યાખ્યાયિત કરો બિગ- ઓ નોટેશન, બિગ ઓમેગા નોટેશન, બિગ થીટા નોટેશન.}

\begin{solutionbox}

\textbf{સારણી: એસિમ્પ્ટોટિક નોટેશન સરખામણી}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
નોટેશન & પ્રતીક & વર્ણન & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
બિગ-ઓ & O(f(n)) & \textbf{ઉપલી હદ} & સૌથી ખરાબ કેસ \\
બિગ ઓમેગા & Ω(f(n)) & \textbf{નીચલી હદ} & સૌથી સારો કેસ \\
બિગ થીટા & Θ(f(n)) & \textbf{ચુસ્ત હદ} & સરેરાશ કેસ \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{બિગ-ઓ નોટેશન}: મહત્તમ સમય/સ્થળ જટિલતા વર્ણવે છે
\item
  \textbf{બિગ ઓમેગા}: ન્યૂનતમ સમય/સ્થળ જટિલતા વર્ણવે છે\\
\item
  \textbf{બિગ થીટા}: ચોક્કસ સમય/સ્થળ જટિલતા વર્ણવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``OWT - O ખરાબ માટે, Omega શ્રેષ્ઠ માટે, Theta ચુસ્ત માટે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{સેટ વ્યાખ્યાયિત કરો. સેટ પર કરી શકાય તેવા વિવિધ ઓપરેશનો લખો.}

\begin{solutionbox}

\textbf{વ્યાખ્યા}: સેટ એ અનન્ય તત્વોનો સંગ્રહ છે જેમાં કોઈ ડુપ્લિકેટ નથી.

\textbf{સારણી: સેટ ઓપરેશનો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેશન & પ્રતીક & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{યુનિયન} & A \cup B & બધા તત્વો જોડે છે & \{1,2\} \cup \{2,3\} =
\{1,2,3\} \\
\textbf{ઇન્ટરસેક્શન} & A \cap B & સામાન્ય તત્વો & \{1,2\} \cap \{2,3\} = \{2\} \\
\textbf{ડિફરન્સ} & A - B & A માં છે પણ B માં નથી & \{1,2\} - \{2,3\} =
\{1\} \\
\textbf{સબસેટ} & A ⊆ B & A ના બધા તત્વો B માં છે & \{1\} ⊆ \{1,2\} = સાચું \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{ઉમેરવું/દાખલ કરવું}: નવું તત્વ ઉમેરવું
\item
  \textbf{દૂર કરવું/કાઢવું}: અસ્તિત્વમાં રહેલું તત્વ દૂર કરવું
\item
  \textbf{સમાવેશ}: તત્વ અસ્તિત્વમાં છે કે નહીં તપાસવું
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``UIDS - યુનિયન, ઇન્ટરસેક્શન, ડિફરન્સ, સબસેટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{ક્રિકેટર માટે Python ક્લાસ લખો. ક્લાસ માં ક્રિકેટરનું નામ, ટીમનું નામ અને ડેટા
સભ્યો તરીકે રનનો સમાવેશ થાય છે. ક્લાસ કાર્યો નીચે મુજબ છે: ડેટા સભ્યોને ઇનિશિયલાઇઝ
કરવા, રન સેટ કરવા અને રન ડિસ્પ્લે કરવા.}

\begin{solutionbox}

\begin{verbatim}
class Cricketer:
    def \_\_init\_\_(self, name="", team="", run=0):
        self.name = name
        self.team = team
        self.run = run
    
    def set\_run(self, run):
        self.run = run
    
    def display\_run(self):
        print(f"ખેલાડી: \{self.name\}")
        print(f"ટીમ: \{self.team\}")
        print(f"રન: \{self.run\}")

\# ઉદાહરણ ઉપયોગ
player = Cricketer("વિરાટ કોહલી", "ભારત", 100)
player.display\_run()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કન્સ્ટ્રક્ટર}: નામ, ટીમ અને રન ઇનિશિયલાઇઝ કરે છે
\item
  \textbf{set\_run()}: રન વેલ્યુ અપડેટ કરે છે
\item
  \textbf{display\_run()}: ખેલાડીની માહિતી બતાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CSD - કન્સ્ટ્રક્ટર, સેટ, ડિસ્પ્લે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક અથવા) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-uxa85uxaa5uxab5-7-uxa97uxaa3}

\textbf{વિદ્યાર્થીની માહિતી વાંચવા અને પ્રદર્શિત કરવા માટે વિદ્યાર્થી ક્લાસની રચના
કરો, અને તેમાં getInfo() અને displayInfo() પદ્ધતિઓનો ઉપયોગ કરવામાં આવશે. જ્યાં
getInfo() પ્રાઇવેટ પદ્ધતિ હશે.}

\begin{solutionbox}

\begin{verbatim}
class Student:
    def \_\_init\_\_(self):
        self.name = ""
        self.roll\_no = ""
        self.marks = 0
        self.\_\_getInfo()  \# પ્રાઇવેટ મેથડ કૉલ
    
    def \_\_getInfo\_\_(self):  \# પ્રાઇવેટ મેથડ
        self.name = input("નામ દાખલ કરો: ")
        self.roll\_no = input("રોલ નંબર દાખલ કરો: ")
        self.marks = int(input("માર્ક્સ દાખલ કરો: "))
    
    def displayInfo(self):
        print(f"નામ: \{self.name\}")
        print(f"રોલ નંબર: \{self.roll\_no\}")
        print(f"માર્ક્સ: \{self.marks\}")

\# ઉદાહરણ ઉપયોગ
student = Student()
student.displayInfo()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રાઇવેટ મેથડ}: ડબલ અંડરસ્કોર (\_\_getInfo) વાપરે છે
\item
  \textbf{કન્સ્ટ્રક્ટર}: આપોઆપ પ્રાઇવેટ મેથડ કૉલ કરે છે
\item
  \textbf{પબ્લિક મેથડ}: displayInfo() વિદ્યાર્થીનો ડેટા બતાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PCP - પ્રાઇવેટ, કન્સ્ટ્રક્ટર, પબ્લિક''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{સ્ટેક અને ક્યૂ વચ્ચે તફાવત કરો.}

\begin{solutionbox}

\textbf{સારણી: સ્ટેક વર્સસ ક્યૂ સરખામણી}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & સ્ટેક & ક્યૂ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ક્રમ} & LIFO (છેલ્લું અંદર, પહેલું બહાર) & FIFO (પહેલું અંદર, પહેલું બહાર) \\
\textbf{ઓપરેશનો} & Push, Pop & Enqueue, Dequeue \\
\textbf{એક્સેસ પોઇન્ટ} & એક છેડો (ટોપ) & બે છેડા (ફ્રન્ટ અને રિયર) \\
\textbf{ઉદાહરણ} & પ્લેટનો સ્ટેક & બેંકની કતાર \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{સ્ટેક}: પુસ્તકોના ઢગલા જેવું - છેલ્લું ઉમેર્યું, પહેલું કાઢ્યું
\item
  \textbf{ક્યૂ}: રાહ જોવાની લાઇન જેવું - પહેલું આવ્યું, પહેલું સેવા મળી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SLIF QFIF - સ્ટેક LIFO, ક્યૂ FIFO''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{રિકર્સન વ્યાખ્યાયિત કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{વ્યાખ્યા}: ફંક્શન પોતાને જ નાની સમસ્યા સાથે કૉલ કરવું જ્યાં સુધી બેઝ કંડિશન ન
મળે.

\begin{verbatim}
def factorial(n):
    \# બેઝ કેસ
    if n {=} 1:
        return 1
    \# રિકર્સિવ કેસ
    return n * factorial(n{-}1)

\# ઉદાહરણ: factorial(3)
\# 3 * factorial(2)
\# 3 * 2 * factorial(1)
\# 3 * 2 * 1 = 6
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{બેઝ કેસ}: રોકવાની શરત
\item
  \textbf{રિકર્સિવ કેસ}: ફંક્શન પોતાને કૉલ કરે છે
\item
  \textbf{સમસ્યા ઘટાડવી}: દરેક કૉલ નાની સમસ્યા હલ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BRP - બેઝ, રિકર્સિવ, પ્રોબ્લેમ-રિડક્શન''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{સ્ટેકના સાઈઝ 5 તરીકે ધ્યાનમાં લો. સ્ટેક પર નીચેની કામગીરી લાગૂ કરો અને દરેક
ઑપરેશન પછી સ્ટેટસ અને ટોપ પોઇન્ટર બતાવો. Push a,b,c pop}

\begin{solutionbox}

\textbf{સ્ટેક ઓપરેશનો ટ્રેસ:}

\begin{verbatim}
શરૂઆતની સ્થિતિ:
સ્ટેક: [ \_ \_ \_ \_ \_ ]  ટોપ: {-1}
       0 1 2 3 4

Push {a પછી:}
સ્ટેક: [ a \_ \_ \_ \_ ]  ટોપ: 0
       0 1 2 3 4

Push {b પછી:}
સ્ટેક: [ a b \_ \_ \_ ]  ટોપ: 1
       0 1 2 3 4

Push {c પછી:}
સ્ટેક: [ a b c \_ \_ ]  ટોપ: 2
       0 1 2 3 4

Pop પછી:
સ્ટેક: [ a b \_ \_ \_ ]  ટોપ: 1
       0 1 2 3 4
કાઢેલું તત્વ: c
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Push ઓપરેશનો}: ઇન્ડેક્સ 0 થી શરૂ કરીને તત્વો ઉમેરે છે
\item
  \textbf{ટોપ પોઇન્ટર}: છેલ્લે દાખલ કરેલા તત્વ તરફ પોઇન્ટ કરે છે
\item
  \textbf{Pop ઓપરેશન}: ટોપ તત્વ દૂર કરે છે, ટોપ પોઇન્ટર ઘટાડે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PTD - Push ટોપ ઘટાડવું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ અથવા) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-uxa85uxaa5uxab5-3-uxa97uxaa3}

\textbf{સ્ટેક અને ક્યૂની એપ્લિકેશનોની સૂચિ બનાવો.}

\begin{solutionbox}

\textbf{સારણી: સ્ટેક અને ક્યૂની એપ્લિકેશનો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ડેટા સ્ટ્રક્ચર & એપ્લિકેશનો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સ્ટેક} & ફંક્શન કૉલ્સ, અન્ડુ ઓપરેશનો, એક્સપ્રેશન ઇવેલ્યુએશન, બ્રાઉઝર હિસ્ટરી \\
\textbf{ક્યૂ} & પ્રોસેસ શેડ્યુલિંગ, પ્રિન્ટર ક્યૂ, BFS ટ્રેવર્સલ, રિક્વેસ્ટ હેન્ડલિંગ \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{સ્ટેક એપ્લિકેશનો}: અન્ડુ-રિડુ, રિકર્સન, પાર્સિંગ
\item
  \textbf{ક્યૂ એપ્લિકેશનો}: ટાસ્ક શેડ્યુલિંગ, બફરિંગ, બ્રેડથ-ફર્સ્ટ સર્ચ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``સ્ટેક FUBE, ક્યૂ SPBH''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ અથવા) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-uxa85uxaa5uxab5-4-uxa97uxaa3}

**સ્ટેકનો ઉપયોગ કરીને નીચેના સમીકરણને પોસ્ટફિક્સ નોટેશનમાં કન્વર્ટ કરો: i)
(a\emph{b)}(c\^{}d(d+e)-f) ii) a-b/(c*d/e)**

\begin{solutionbox}

\textbf{i) (a\emph{b)}(c\^{}d(d+e)-f)}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રતીક & સ્ટેક & આઉટપુટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
( & ( & \\
a & ( & a \\
* & (* & a \\
b & (* & ab \\
) & & ab* \\
* & * & ab* \\
( & *( & ab* \\
c & *( & ab*c \\
\^{} & *(\^{} & ab*c \\
d & *(\^{} & ab*cd \\
( & *(\^{}( & ab*cd \\
d & *(\^{}( & ab*cdd \\
+ & *(\^{}(+ & ab*cdd \\
e & *(\^{}(+ & ab*cdde \\
) & *(\^{} & ab*cdde+ \\
) & * & ab*cdde+\^{} \\
- & *- & ab*cdde+\^{} \\
f & *- & ab*cdde+\^{}f \\
& & ab\emph{cdde+\^{}f-} \\
\end{longtable}
}

\textbf{પરિણામ: ab\emph{cdde+\^{}f-}}

**ii) a-b/(c*d/e)**

**પરિણામ: abcd*e/-**

\end{solutionbox}
\begin{mnemonicbox}
``PEMDAS પોસ્ટફિક્સ માટે ઉલટું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક અથવા) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-uxa85uxaa5uxab5-7-uxa97uxaa3}

\textbf{લીસ્ટનો ઉપયોગ કરીને ક્યૂને અમલમાં મૂકવા માટે એક પ્રોગ્રામ ડેવલોપ કરો જે
નીચેની કામગીરી કરે છે: enqueue, dequeue.}

\begin{solutionbox}

\begin{verbatim}
class Queue:
    def \_\_init\_\_(self):
        self.queue = []
        self.front = 0
        self.rear = {-}1
    
    def enqueue(self, item):
        self.queue.append(item)
        self.rear += 1
        print(f"એનક્યૂ કર્યું: \{item\}")
    
    def dequeue(self):
        if self.front {=} self.rear:
            item = self.queue[self.front]
            self.front += 1
            print(f"ડીક્યૂ કર્યું: \{item\}")
            return item
        else:
            print("ક્યૂ ખાલી છે")
            return None
    
    def display(self):
        if self.front {=} self.rear:
            print("ક્યૂ:", self.queue[self.front:self.rear+1])
        else:
            print("ક્યૂ ખાલી છે")

\# ઉદાહરણ ઉપયોગ
q = Queue()
q.enqueue({A})
q.enqueue({B})
q.dequeue()
q.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{Enqueue}: રિયર પર તત્વ ઉમેરે છે
\item
  \textbf{Dequeue}: ફ્રન્ટ પરથી તત્વ દૂર કરે છે
\item
  \textbf{FIFO સિદ્ધાંત}: પહેલું અંદર, પહેલું બહાર
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ERF - Enqueue રિયર, ફ્રન્ટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{લિંક લિસ્ટના પ્રકારોની સૂચિ બનાવો. દરેક પ્રકારનું ગ્રાફિકલ રજૂઆત આપો.}

\begin{solutionbox}

\textbf{સારણી: લિંક લિસ્ટના પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & ડાયાગ્રામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સિંગલી} & એક દિશા પોઇન્ટર & A\rightarrowB\rightarrowC\rightarrowNULL \\
\textbf{ડબલી} & બે દિશા પોઇન્ટરો & NULL\leftarrowA⇄B⇄C\rightarrowNULL \\
\textbf{સર્ક્યુલર} & છેલ્લું પહેલા તરફ પોઇન્ટ કરે & A\rightarrowB\rightarrowC\rightarrowA \\
\end{longtable}
}

\begin{verbatim}
સિંગલી લિંક લિસ્ટ:
[ડેટા|નેક્સ્ટ] {- [ડેટા|નેક્સ્ટ] {-} [ડેટા|NULL]}

ડબલી લિંક લિસ્ટ:
[પ્રિવ|ડેટા|નેક્સ્ટ] {{-} [પ્રિવ|ડેટા|નેક્સ્ટ] {-} [પ્રિવ|ડેટા|નેક્સ્ટ]}

સર્ક્યુલર લિંક લિસ્ટ:
[ડેટા|નેક્સ્ટ] {- [ડેટા|નેક્સ્ટ] {-} [ડેટા|નેક્સ્ટ]}
    \^{                              |}
    |\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_|
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SDC - સિંગલી, ડબલી, સર્ક્યુલર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{સિંગલી લિંક લિસ્ટમાં આપેલ નોડ શોધવા માટે એક અલ્ગોરિધમ લખો.}

\begin{solutionbox}

\begin{verbatim}
def search\_node(head, key):
    current = head
    position = 0
    
    while current is not None:
        if current.data == key:
            return position
        current = current.next
        position += 1
    
    return {-}1  \# નહીં મળ્યું

\# અલ્ગોરિધમ સ્ટેપ્સ:
\# 1. હેડ થી શરૂ કરો
\# 2. વર્તમાન ડેટાને કી સાથે સરખાવો
\# 3. જો મળ્યું તો પોઝિશન રિટર્ન કરો
\# 4. આગલા નોડ પર જાઓ
\# 5. અંત સુધી પુનરાવર્તન કરો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{લીનિયર સર્ચ}: હેડ થી ટેઇલ સુધી ટ્રાવર્સ કરો
\item
  \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: O(n)
\item
  \textbf{રિટર્ન}: મળ્યું તો પોઝિશન, નહીં તો -1
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SCMR - શરૂ, સરખાવો, આગળ વધો, રિટર્ન''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{સિંગલી લિંક લિસ્ટ પર પર નીચેની કામગીરી કરવા માટે પ્રોગ્રામનો અમલ કરો:
1)સિંગલી લિંક લિસ્ટ ની શરૂઆતમાં નોડ દાખલ કરો 2)સિંગલી લિંક લિસ્ટની શરૂઆતથી નોડ
કાઢી નાખો}

\begin{solutionbox}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def insert\_at\_beginning(self, data):
        new\_node = Node(data)
        new\_node.next = self.head
        self.head = new\_node
        print(f"શરૂઆતમાં \{data\} દાખલ કર્યું")
    
    def delete\_from\_beginning(self):
        if self.head is None:
            print("લિસ્ટ ખાલી છે")
            return None
        
        deleted\_data = self.head.data
        self.head = self.head.next
        print(f"શરૂઆતથી \{deleted\_data\} કાઢ્યું")
        return deleted\_data
    
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" {- "})
            current = current.next
        print("NULL")

\# ઉદાહરણ ઉપયોગ
ll = SinglyLinkedList()
ll.insert\_at\_beginning(10)
ll.insert\_at\_beginning(20)
ll.delete\_from\_beginning()
ll.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઇન્સર્ટ}: નોડ બનાવો, હેડ સાથે જોડો, હેડ અપડેટ કરો
\item
  \textbf{ડિલીટ}: ડેટા સ્ટોર કરો, હેડને આગળ ખસેડો, ડેટા રિટર્ન કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CLU - બનાવો, જોડો, અપડેટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ અથવા) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-uxa85uxaa5uxab5-3-uxa97uxaa3}

\textbf{સર્ક્યુલર લિંક લિસ્ટ અને સિંગલી લિંક લિસ્ટ વચ્ચે તફાવત કરો.}

\begin{solutionbox}

\textbf{સારણી: સર્ક્યુલર વર્સસ સિંગલી લિંક લિસ્ટ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & સિંગલી લિંક લિસ્ટ & સર્ક્યુલર લિંક લિસ્ટ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{છેલ્લો નોડ પોઇન્ટ કરે છે} & NULL & પહેલા નોડ (હેડ) \\
\textbf{ટ્રાવર્સલ} & લીનિયર (એક દિશા) & સર્ક્યુલર (સતત) \\
\textbf{અંત ડિટેક્શન} & next == NULL & next == head \\
\textbf{મેમરી} & ઓછી (વધારાનું પોઇન્ટર નહીં) & સમાન સ્ટ્રક્ચર \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{સર્ક્યુલર ફાયદો}: NULL પોઇન્ટરો નહીં, સતત ટ્રાવર્સલ
\item
  \textbf{સિંગલી ફાયદો}: સાદું અમલીકરણ, સ્પષ્ટ અંત
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CNTE - સર્ક્યુલર કોઈ સમાપ્તિ અંત નહીં''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ અથવા) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-uxa85uxaa5uxab5-4-uxa97uxaa3}

\textbf{સંક્ષિપ્તમાં લિંક લિસ્ટ સૂચિની ત્રણ એપ્લિકેશનો સમજાવો.}

\begin{solutionbox}

\textbf{સારણી: લિંક લિસ્ટ એપ્લિકેશનો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
એપ્લિકેશન & વર્ણન & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ડાયનામિક મેમરી એલોકેશન} & મેમરી બ્લોક્સ મેનેજ કરે છે & કાર્યક્ષમ મેમરી
ઉપયોગ \\
\textbf{સ્ટેક/ક્યૂનું અમલીકરણ} & લિંક સ્ટ્રક્ચર ઉપયોગ કરે છે & ડાયનામિક સાઇઝ \\
\textbf{પોલિનોમિયલ રજૂઆત} & ગુણાંક અને પાવર સ્ટોર કરે છે & સરળ અંકગણિત ઓપરેશનો \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{મ્યુઝિક પ્લેલિસ્ટ}: ગીતો ડાયનામિક ઉમેરવા/દૂર કરવા
\item
  \textbf{બ્રાઉઝર હિસ્ટરી}: પાછળ/આગળ નેવિગેટ કરવા
\item
  \textbf{ઇમેજ વ્યૂઅર}: પહેલું/આગલું ઇમેજ નેવિગેશન
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DIP - ડાયનામિક, અમલીકરણ, પોલિનોમિયલ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક અથવા) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-uxa85uxaa5uxab5-7-uxa97uxaa3}

\textbf{સર્ક્યુલર લિંક લિસ્ટ ને બનાવવા અને પ્રદર્શિત કરવા માટે એક પ્રોગ્રામ ડેવલોપ
કરો.}

\begin{solutionbox}

\begin{verbatim}
class Node:
    def \_\_init\_\_(self, data):
        self.data = data
        self.next = None

class CircularLinkedList:
    def \_\_init\_\_(self):
        self.head = None
    
    def insert(self, data):
        new\_node = Node(data)
        
        if self.head is None:
            self.head = new\_node
            new\_node.next = self.head
        else:
            current = self.head
            while current.next != self.head:
                current = current.next
            current.next = new\_node
            new\_node.next = self.head
    
    def display(self):
        if self.head is None:
            print("લિસ્ટ ખાલી છે")
            return
        
        current = self.head
        print("સર્ક્યુલર લિસ્ટ:")
        while True:
            print(current.data, end=" {- "})
            current = current.next
            if current == self.head:
                break
        print(f"\{self.head.data\} (હેડ પર પાછા)")

\# ઉદાહરણ ઉપયોગ
cll = CircularLinkedList()
cll.insert(10)
cll.insert(20)
cll.insert(30)
cll.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{બનાવટ}: છેલ્લા નોડને હેડ સાથે જોડવું
\item
  \textbf{ડિસ્પ્લે}: ફરીથી હેડ પર પહોંચવા સુધી બંધ કરવું
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CLH - બનાવો, જોડો, હેડ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{સિલેક્શન સૉર્ટ પદ્ધતિનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
def selection\_sort(arr):
    n = len(arr)
    
    for i in range(n):
        min\_idx = i
        for j in range(i+1, n):
            if arr[j] {} arr[min\_idx]:
                min\_idx = j
        
        arr[i], arr[min\_idx] = arr[min\_idx], arr[i]
    
    return arr

\# ઉદાહરણ ઉપયોગ
data = [64, 34, 25, 12, 22]
sorted\_data = selection\_sort(data)
print("સૉર્ટેડ એરે:", sorted\_data)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મિનિમમ શોધો}: અનસૉર્ટેડ ભાગમાં
\item
  \textbf{સ્વેપ}: પ્રથમ અનસૉર્ટેડ એલિમેન્ટ સાથે
\item
  \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: O(n^{2})
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FMS - શોધો, મિનિમમ, સ્વેપ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{નીચેના ડેટાને ચડતા ક્રમમાં ગોઠવવા માટે ઇન્સર્શન સૉર્ટ લાગૂ કરો. 25 15 35
20 30 5 10}

\begin{solutionbox}

\textbf{ઇન્સર્શન સૉર્ટ સ્ટેપ્સ:}

\begin{verbatim}
શરૂઆત: [25, 15, 35, 20, 30, 5, 10]

પાસ 1: [15, 25, 35, 20, 30, 5, 10]  (15 ઇન્સર્ટ કર્યું)
પાસ 2: [15, 25, 35, 20, 30, 5, 10]  (35 જગ્યાએ)
પાસ 3: [15, 20, 25, 35, 30, 5, 10]  (20 ઇન્સર્ટ કર્યું)
પાસ 4: [15, 20, 25, 30, 35, 5, 10]  (30 ઇન્સર્ટ કર્યું)
પાસ 5: [5, 15, 20, 25, 30, 35, 10]  (5 ઇન્સર્ટ કર્યું)
પાસ 6: [5, 10, 15, 20, 25, 30, 35]  (10 ઇન્સર્ટ કર્યું)

અંતિમ: [5, 10, 15, 20, 25, 30, 35]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{પદ્ધતિ}: એલિમેન્ટ લો, સૉર્ટેડ ભાગમાં સ્થાન શોધો
\item
  \textbf{સરખામણીઓ}: કુલ 15 સરખામણીઓ
\item
  \textbf{શિફ્ટ્સ}: જગ્યા બનાવવા માટે એલિમેન્ટ્સ ખસેડવા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TFI - લેવું, શોધવું, ઇન્સર્ટ કરવું''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{લીનિયર સર્ચનો ઉપયોગ કરીને લિસ્ટમાંથી ચોક્કસ તત્વ શોધવા માટે પાયથોન
પ્રોગ્રામનો અમલ કરો.}

\begin{solutionbox}

\begin{verbatim}
def linear\_search(arr, target):
    comparisons = 0
    
    for i in range(len(arr)):
        comparisons += 1
        if arr[i] == target:
            print(f"એલિમેન્ટ \{target\} ઇન્ડેક્સ \{i\} પર મળ્યું")
            print(f"સરખામણીઓની સંખ્યા: \{comparisons\}")
            return i
    
    print(f"એલિમેન્ટ \{target\} નહીં મળ્યું")
    print(f"સરખામણીઓની સંખ્યા: \{comparisons\}")
    return {-}1

def linear\_search\_all\_positions(arr, target):
    positions = []
    for i in range(len(arr)):
        if arr[i] == target:
            positions.append(i)
    return positions

\# ઉદાહરણ ઉપયોગ
data = [10, 25, 30, 15, 20, 30, 35]
target = 30

result = linear\_search(data, target)
all\_positions = linear\_search\_all\_positions(data, target)
print(f"\{target\} ની બધી પોઝિશન: \{all\_positions\}")
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{સિક્વન્શિયલ સર્ચ}: દરેક એલિમેન્ટ એક પછી એક તપાસવું
\item
  \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: O(n) સૌથી ખરાબ કેસ
\item
  \textbf{બેસ્ટ કેસ}: O(1) જો પ્રથમ પોઝિશન પર મળે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CEO - દરેક એક તપાસો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ અથવા) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-uxa85uxaa5uxab5-3-uxa97uxaa3}

\textbf{ઇન્સર્શન સૉર્ટ પદ્ધતિનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
def insertion\_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i {-} 1
        
        while j {=} 0 and arr[j] {} key:
            arr[j + 1] = arr[j]
            j {-=} 1
        
        arr[j + 1] = key
    
    return arr

\# ઉદાહરણ ઉપયોગ
data = [12, 11, 13, 5, 6]
print("મૂળ:", data)
sorted\_data = insertion\_sort(data.copy())
print("સૉર્ટેડ:", sorted\_data)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કી એલિમેન્ટ}: વર્તમાન એલિમેન્ટ જે ઇન્સર્ટ કરવાનું છે
\item
  \textbf{જમણી બાજુ શિફ્ટ}: મોટા એલિમેન્ટ્સ જમણી બાજુ ખસે છે
\item
  \textbf{ઇન્સર્ટ}: યોગ્ય સ્થાને કી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``KSI - કી, શિફ્ટ, ઇન્સર્ટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ અથવા) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-uxa85uxaa5uxab5-4-uxa97uxaa3}

\textbf{નીચેના ડેટાને ક્વિક સૉર્ટ લાગૂ કરો અને તેમને યોગ્ય રીતે ગોઠવો. 5 6 1 8 2 9
10 15 7 13}

\begin{solutionbox}

\textbf{ક્વિક સૉર્ટ સ્ટેપ્સ:}

\begin{verbatim}
શરૂઆત: [5, 6, 1, 8, 2, 9, 10, 15, 7, 13]
પિવોટ: 5 (પ્રથમ એલિમેન્ટ)

પાર્ટિશન 1: [1, 2] 5 [6, 8, 9, 10, 15, 7, 13]

ડાબો સબએરે [1, 2]:
પિવોટ: 1 \rightarrow [] 1 [2]
પરિણામ: [1, 2]

જમણો સબએરે [6, 8, 9, 10, 15, 7, 13]:
પિવોટ: 6 \rightarrow [] 6 [8, 9, 10, 15, 7, 13]

પાર્ટિશનિંગ ચાલુ...

અંતિમ: [1, 2, 5, 6, 7, 8, 9, 10, 13, 15]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{વિભાજન}: પિવોટ પસંદ કરો, તેની આસપાસ પાર્ટિશન કરો
\item
  \textbf{જીતો}: સબએરેને રીકર્સિવલી સૉર્ટ કરો
\item
  \textbf{સરેરાશ સમય}: O(n log n)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DCC - વિભાજન, જીતો, જોડો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક અથવા) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-uxa85uxaa5uxab5-7-uxa97uxaa3}

\textbf{મર્જ સૉર્ટ અલ્ગોરિધમનો અમલ કરો.}

\begin{solutionbox}

\begin{verbatim}
def merge\_sort(arr):
    if len(arr) {=} 1:
        return arr
    
    mid = len(arr) // 2
    left = merge\_sort(arr[:mid])
    right = merge\_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i {} len(left) and j {} len(right):
        if left[i] {=} right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

\# ઉદાહરણ ઉપયોગ
data = [38, 27, 43, 3, 9, 82, 10]
sorted\_data = merge\_sort(data)
print("સૉર્ટેડ એરે:", sorted\_data)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{વિભાજન}: એરેને અડધામાં વિભાજિત કરો
\item
  \textbf{મર્જ}: સૉર્ટેડ સબએરેને જોડો
\item
  \textbf{ટાઇમ કોમ્પ્લેક્સિટી}: હંમેશા O(n log n)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DSM - વિભાજન, સૉર્ટ, મર્જ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{ટૂંકી નોંધ લખો: એપ્લિકેશન ઓફ ટ્રી.}

\begin{solutionbox}

\textbf{સારણી: ટ્રી એપ્લિકેશનો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
એપ્લિકેશન & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ફાઇલ સિસ્ટમ} & ડિરેક્ટરી સ્ટ્રક્ચર & ફોલ્ડર અને ફાઇલો \\
\textbf{એક્સપ્રેશન પાર્સિંગ} & ગાણિતિક સમીકરણો & (a+b)*c \\
\textbf{ડેટાબેઝ ઇન્ડેક્સિંગ} & ઝડપી ડેટા પુનઃપ્રાપ્તિ & ડેટાબેઝમાં B-ટ્રીઝ \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{ડિસિઝન ટ્રીઝ}: AI અને મશીન લર્નિંગ
\item
  \textbf{હફમેન કોડિંગ}: ડેટા કોમ્પ્રેશન
\item
  \textbf{ગેમ ટ્રીઝ}: ચેસ, ટિક-ટેક-ટો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FED - ફાઇલ, એક્સપ્રેશન, ડેટાબેઝ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{વિવિધ ટ્રી ટ્રાવર્સલ પદ્ધતિઓ સમજાવો.}

\begin{solutionbox}

\textbf{સારણી: ટ્રી ટ્રાવર્સલ પદ્ધતિઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પદ્ધતિ & ક્રમ & પ્રક્રિયા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઇનઓર્ડર} & ડાબે-રૂટ-જમણે & LNR \\
\textbf{પ્રીઓર્ડર} & રૂટ-ડાબે-જમણે & NLR \\
\textbf{પોસ્ટઓર્ડર} & ડાબે-જમણે-રૂટ & LRN \\
\end{longtable}
}

\begin{verbatim}
ઉદાહરણ ટ્રી:
        A
       / {}
      B   C
     / {}
    D   E

ઇનઓર્ડર: D B E A C
પ્રીઓર્ડર: A B D E C  
પોસ્ટઓર્ડર: D E B C A
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનઓર્ડર}: BST માટે સૉર્ટેડ સિક્વન્સ આપે છે
\item
  \textbf{પ્રીઓર્ડર}: ટ્રી કોપી કરવા માટે વપરાય છે
\item
  \textbf{પોસ્ટઓર્ડર}: ટ્રી ડિલીટ કરવા માટે વપરાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``LNR PNL LRN ઇન-પ્રી-પોસ્ટ માટે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{બાઇનરી સર્ચ ટ્રી પર નીચેની કામગીરી કરવા માટે મેન્યૂ સંચાલિત પ્રોગ્રામ લખો:
BST ટ્રી બનાવવા માટેનો પ્રોગ્રામ.}

\begin{solutionbox}

\begin{verbatim}
class TreeNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:
    def \_\_init\_\_(self):
        self.root = None
    
    def insert(self, data):
        self.root = self.\_insert\_recursive(self.root, data)
    
    def \_insert\_recursive(self, node, data):
        if node is None:
            return TreeNode(data)
        
        if data {} node.data:
            node.left = self.\_insert\_recursive(node.left, data)
        elif data {} node.data:
            node.right = self.\_insert\_recursive(node.right, data)
        
        return node
    
    def inorder(self, node):
        if node:
            self.inorder(node.left)
            print(node.data, end=" ")
            self.inorder(node.right)

def main():
    bst = BST()
    
    while True:
        print("{n}1. દાખલ કરો")
        print("2. દર્શાવો (ઇનઓર્ડર)")
        print("3. બહાર નીકળો")
        
        choice = int(input("પસંદગી દાખલ કરો: "))
        
        if choice == 1:
            data = int(input("ડેટા દાખલ કરો: "))
            bst.insert(data)
        elif choice == 2:
            print("BST (ઇનઓર્ડર):", end=" ")
            bst.inorder(bst.root)
            print()
        elif choice == 3:
            break

if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{BST ગુણધર્મ}: ડાબે \textless{} રૂટ \textless{} જમણે
\item
  \textbf{ઇન્સર્શન}: સરખાવો અને ડાબે/જમણે જાઓ
\item
  \textbf{મેન્યૂ ડ્રિવન}: વપરાશકર્તા-મૈત્રીપૂર્ણ ઇન્ટરફેસ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CIM - સરખાવો, ઇન્સર્ટ, મેન્યૂ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ અથવા) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-uxa85uxaa5uxab5-3-uxa97uxaa3}

\textbf{વ્યાખ્યાયિત કરો અને ઉદાહરણો આપો: સ્ટ્રિક્ટ બાઇનરી ટ્રી અને કમ્પ્લીટ બાઇનરી
ટ્રી.}

\begin{solutionbox}

\textbf{સારણી: બાઇનરી ટ્રી પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સ્ટ્રિક્ટ બાઇનરી ટ્રી} & દરેક નોડને 0 અથવા 2 બાળકો છે & દરેક આંતરિક નોડને
બરાબર 2 બાળકો \\
\textbf{કમ્પ્લીટ બાઇનરી ટ્રી} & છેલ્લા સિવાય બધા લેવલ ભરેલા, ડાબેથી જમણે ભરેલા &
બીજા છેલ્લા લેવલ સુધી પરફેક્ટ સ્ટ્રક્ચર \\
\end{longtable}
}

\begin{verbatim}
સ્ટ્રિક્ટ બાઇનરી ટ્રી:
        A
       / {}
      B   C
         / {}
        D   E

કમ્પ્લીટ બાઇનરી ટ્રી:
        A
       / {}
      B   C
     / { /}
    D  E F
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{સ્ટ્રિક્ટ}: એક બાળક વાળો કોઈ નોડ નહીં
\item
  \textbf{કમ્પ્લીટ}: શ્રેષ્ઠ સ્પેસ ઉપયોગ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SC - સ્ટ્રિક્ટ કમ્પ્લીટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ અથવા) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-uxa85uxaa5uxab5-4-uxa97uxaa3}

\textbf{બાઇનરી ટ્રીની મૂળભૂત પરિભાષા સમજાવો: લેવલ નંબર, ડિગ્રી, ઇન-ડિગ્રી,
આઉટ-ડિગ્રી, લીફ નોડ.}

\begin{solutionbox}

\begin{verbatim}
બાઇનરી ટ્રી ઉદાહરણ:
    લેવલ 0:     A        (રૂટ)
                / {}
   લેવલ 1:    B   C
              / {   }
   લેવલ 2:  D   E   F   (લીવ્સ: D, E, F)
\end{verbatim}

\textbf{સારણી: બાઇનરી ટ્રી પરિભાષા}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
શબ્દ & વ્યાખ્યા & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{લેવલ નંબર} & રૂટથી અંતર (રૂટ = 0) & A=0, B=1, D=2 \\
\textbf{ડિગ્રી} & બાળકોની સંખ્યા & A=2, B=2, C=1 \\
\textbf{ઇન-ડિગ્રી} & આવતા એજની સંખ્યા & બધા નોડ = 1 (સિવાય રૂટ = 0) \\
\textbf{આઉટ-ડિગ્રી} & જતા એજની સંખ્યા & ડિગ્રી સમાન \\
\textbf{લીફ નોડ} & બાળકો ન હોય તેવો નોડ & D, E, F \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``LDIOL - લેવલ, ડિગ્રી, ઇન-આઉટ, લીફ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક અથવા) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-uxa85uxaa5uxab5-7-uxa97uxaa3}

\textbf{બાઇનરી સર્ચ ટ્રી પર નીચેની કામગીરી કરવા માટે મેન્યૂ સંચાલિત પ્રોગ્રામ લખો:
BST માં એક એલિમેન્ટ દાખલ કરો.}

\begin{solutionbox}

\begin{verbatim}
class TreeNode:
    def \_\_init\_\_(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:
    def \_\_init\_\_(self):
        self.root = None
    
    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
            print(f"રૂટ નોડ \{data\} બનાવ્યું")
        else:
            self.\_insert\_helper(self.root, data)
    
    def \_insert\_helper(self, node, data):
        if data {} node.data:
            if node.left is None:
                node.left = TreeNode(data)
                print(f"\{data\} ને \{node.data\} ની ડાબી બાજુએ દાખલ કર્યું")
            else:
                self.\_insert\_helper(node.left, data)
        elif data {} node.data:
            if node.right is None:
                node.right = TreeNode(data)
                print(f"\{data\} ને \{node.data\} ની જમણી બાજુએ દાખલ કર્યું")
            else:
                self.\_insert\_helper(node.right, data)
        else:
            print(f"ડેટા \{data\} પહેલેથી અસ્તિત્વમાં છે")
    
    def display\_inorder(self, node, result):
        if node:
            self.display\_inorder(node.left, result)
            result.append(node.data)
            self.display\_inorder(node.right, result)

def main():
    bst = BST()
    
    while True:
        print("{n}{-{-}{-} BST ઓપરેશનો {-}{-}{-}"})
        print("1. એલિમેન્ટ દાખલ કરો")
        print("2. BST દર્શાવો (ઇનઓર્ડર)")
        print("3. બહાર નીકળો")
        
        choice = int(input("તમારી પસંદગી દાખલ કરો: "))
        
        if choice == 1:
            data = int(input("દાખલ કરવાનું એલિમેન્ટ દાખલ કરો: "))
            bst.insert(data)
        elif choice == 2:
            result = []
            bst.display\_inorder(bst.root, result)
            print("BST એલિમેન્ટ્સ (સૉર્ટેડ):", result)
        elif choice == 3:
            print("બહાર નીકળી રહ્યા છીએ...")
            break
        else:
            print("અયોગ્ય પસંદગી!")

if \_\_name\_\_ == "\_\_main\_\_":
    main()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઇન્સર્ટ લોજિક}: વર્તમાન નોડ સાથે સરખાવો, ડાબે/જમણે જાઓ
\item
  \textbf{રિકર્સિવ એપ્રોચ}: સ્વચ્છ અને કાર્યક્ષમ અમલીકરણ
\item
  \textbf{મેન્યૂ સિસ્ટમ}: ઇન્ટરેક્ટિવ વપરાશકર્તા ઇન્ટરફેસ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CRL - સરખાવો, રિકર્સિવ, ડાબે/જમણે''

\end{mnemonicbox}

\end{document}
