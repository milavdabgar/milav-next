\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 1333203 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{Write names of linear data structures.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
Linear Data Structures \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Array \\
2. Stack \\
3. Queue \\
4. Linked List \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``All Students Queue Lazily''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Define Time and space complexity.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4211}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3158}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2632}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Complexity Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notation
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Time Complexity & Measures how execution time increases as input size
grows & O(n), O(1), O(log n) \\
Space Complexity & Measures how memory usage increases as input size
grows & O(n), O(1), O(log n) \\
\end{longtable}
}

\textbf{Diagram:}

\begin{lstlisting}
+---------------+         +----------------+
| INPUT SIZE    |-------->| ALGORITHM      |
| (n)           |         |                |
+---------------+         +----------------+
                              |       |
                              v       v
                   +---------+       +----------+
                   | TIME    |       | SPACE    |
                   | O(n)    |       | O(n)     |
                   +---------+       +----------+
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Time Steps, Space Stores''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Explain concept of class \& object with example.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-447442f9.pdf}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Concept
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Definition
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Class & Blueprint or template for creating objects & Student class with
properties (rollNo, name) and methods (setData, displayData) \\
Object & Instance of a class with specific values & student1
(rollNo=101, name=``Raj'') \\
\end{longtable}
}

\textbf{Code Example:}

\begin{lstlisting}[language=Python]
class Student:
    def __init__(self):
        self.rollNo = 0
        self.name = ""
        
    def setData(self, r, n):
        self.rollNo = r
        self.name = n
        
    def displayData(self):
        print(self.rollNo, self.name)

# Creating objects
student1 = Student()
student1.setData(101, "Raj")
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Class Creates, Objects Operate''

\end{mnemonicbox}
\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Develop a class for managing student records with instance
methods for adding and removing students from a class.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-7911879e.pdf}

\textbf{Code:}

\begin{lstlisting}[language=Python]
class StudentManager:
    def __init__(self):
        self.students = []
        
    def addStudent(self, roll, name):
        student = Student()
        student.setData(roll, name)
        self.students.append(student)
        
    def removeStudent(self, roll):
        for i in range(len(self.students)):
            if self.students[i].rollNo == roll:
                self.students.pop(i)
                break
    
    def displayAll(self):
        for student in self.students:
            student.displayData()
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Add Accumulates, Remove Reduces''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Explain the importance of constructor in class.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
Constructor Importance \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Initializes object's data members \\
2. Automatically called when object is created \\
3. Can have different versions (default, parameterized, copy) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Initialization Always Creates''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Explain different operations on stack.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Push & Adds element to top & push(5) \\
Pop & Removes element from top & x = pop() \\
Peek/Top & Views top element without removing & x = peek() \\
isEmpty & Checks if stack is empty & if(isEmpty()) \\
\end{longtable}
}

\textbf{Diagram:}

\begin{lstlisting}
     PUSH                     POP
      |                        ^
      v                        |
    +---+                    +---+
    | 5 |                    | 8 |
    +---+                    +---+
    | 7 |  PEEK/TOP ------>  | 7 |
    +---+                    +---+
    | 8 |                    | 2 |
    +---+                    +---+
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Push Pop Peek Properly''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Describe evaluation algorithm of postfix expression A B C + * D
/}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
Input: A B C + * D /

+---+---+---+---+---+---+---+---+
| A | B | C | + | * | D | / |   |
+---+---+---+---+---+---+---+---+
      Read left to right
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Step & Symbol & Action & Stack \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & A & Push onto stack & A \\
2 & B & Push onto stack & A,B \\
3 & C & Push onto stack & A,B,C \\
4 & + & Pop B,C; Push B+C & A,B+C \\
5 & * & Pop A,B+C; Push A*(B+C) & A*(B+C) \\
6 & D & Push onto stack & A*(B+C),D \\
7 & / & Pop A\emph{(B+C),D; Push A}(B+C)/D & A*(B+C)/D \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Read, Push, Pop, Calculate''

\end{mnemonicbox}
\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{Write difference between stack and queue.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Stack & Queue \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Principle & LIFO (Last In First Out) & FIFO (First In First Out) \\
Operations & Push/Pop & Enqueue/Dequeue \\
Access Points & Single end (top) & Two ends (front, rear) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Stack LIFO, Queue FIFO''

\end{mnemonicbox}
\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{Explain concept of circular queue.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-7e2eef04.pdf}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Structure & Linear data structure with connected ends \\
Advantage & Efficiently uses memory by reusing empty spaces \\
Operations & Enqueue, Dequeue with modulo arithmetic \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Circular Connects Front to Rear''

\end{mnemonicbox}
\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Describe the procedure for inserting a new node after and before
a given node in a singly linked list.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
Insert After Node X:
Before: A \rightarrow X \rightarrow B
After:  A \rightarrow X \rightarrow N \rightarrow B

Insert Before Node X:
Before: A \rightarrow X \rightarrow B
After:  A \rightarrow N \rightarrow X \rightarrow B
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.6111}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.3889}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Insertion
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Steps
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
After Node X & 1. Create new node N2. Set N's next to X's next3. Set X's
next to N \\
Before Node X & 1. Create new node N2. Find node A pointing to X3. Set
N's next to X4. Set A's next to N \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``After: Set Next Links, Before: Find Previous
First''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Explain traversing a linked list.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
start \rightarrow [10] \rightarrow [20] \rightarrow [30] \rightarrow NULL
         ^      ^      ^
         |      |      |
       Visit  Visit  Visit
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Step & Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Initialize pointer to head \\
2 & Access data at current node \\
3 & Move pointer to next node \\
4 & Repeat until NULL \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Start, Access, Move, Repeat''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Explain expression conversion from infix to postfix.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
Infix:    A + B * C
Postfix:  A B C * +
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Step & Action & Stack & Output \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Scan from left to right & & \\
2 & If operand, add to output & & A \\
3 & If operator, push if higher precedence & + & A \\
4 & Pop lower precedence operators & + & A B \\
5 & Push current operator & * & A B \\
6 & Continue until expression ends & * & A B C \\
7 & Pop remaining operators & & A B C * + \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Operators Push Pop, Operands Output Directly''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Write a program to delete a node at the beginning and end of
singly linked list.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
Before:  Head \rightarrow [10] \rightarrow [20] \rightarrow [30] \rightarrow NULL
After:   Head \rightarrow [20] \rightarrow NULL
\end{lstlisting}

\textbf{Code:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def deleteFirst(self):
        if self.head is None:
            return
        self.head = self.head.next
    
    def deleteLast(self):
        if self.head is None:
            return
        
        # If only one node
        if self.head.next is None:
            self.head = None
            return
            
        temp = self.head
        while temp.next.next:
            temp = temp.next
        
        temp.next = None
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Delete First: Shift Head, Delete Last: Find
Second-Last''

\end{mnemonicbox}
\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

\textbf{Explain searching an element in linked list.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
Head \rightarrow [10] \rightarrow [20] \rightarrow [30] \rightarrow NULL
         ^      ^      ^
       Check  Check  Check
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Step & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Start from head node \\
2 & Compare current node's data with key \\
3 & If match found, return true \\
4 & Else, move to next node and repeat \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Start, Compare, Move, Repeat''

\end{mnemonicbox}
\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Explain concepts of circular linked lists.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-8d2e3c9e.pdf}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Structure & Last node points to first node \\
Advantage & No NULL pointers, efficient for circular operations \\
Traversal & Need extra condition to prevent infinite loop \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Last Links to First''

\end{mnemonicbox}
\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{Explain algorithm to search a particular element from list using
Binary Search.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-2e9dfa01.pdf}

\textbf{Code:}

\begin{lstlisting}[language=Python]
def binarySearch(arr, key):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        
        if arr[mid] == key:
            return mid
        elif arr[mid] < key:
            low = mid + 1
        else:
            high = mid - 1
            
    return -1
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Middle, Compare, Eliminate Half''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Write applications of linked list.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
Applications of Linked List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Implementation of stacks and queues \\
2. Dynamic memory allocation \\
3. Image viewer (next/previous images) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Store Data Dynamically''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Differentiate between singly linked list and doubly linked
list.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Singly Linked List & Doubly Linked List \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Node Structure & One pointer (next) & Two pointers (next, prev) \\
Traversal & Forward only & Both directions \\
Memory & Less memory & More memory \\
Operations & Simple, less code & Complex, more flexible \\
\end{longtable}
}

\textbf{Diagram:}

\begin{lstlisting}
Singly: [Data|Next] \rightarrow [Data|Next] \rightarrow [Data|Next]

Doubly: [Prev|Data|Next] ⟷ [Prev|Data|Next] ⟷ [Prev|Data|Next]
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Single Direction, Double Direction''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Write a program to sort numbers in ascending order using
selection sort algorithm.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
Initial: [5, 3, 8, 1, 2]
Pass 1:  [1, 3, 8, 5, 2]  (Swap 5,1)
Pass 2:  [1, 2, 8, 5, 3]  (Swap 3,2)
Pass 3:  [1, 2, 3, 5, 8]  (Swap 8,3)
Pass 4:  [1, 2, 3, 5, 8]  (No swap)
\end{lstlisting}

\textbf{Code:}

\begin{lstlisting}[language=Python]
def selectionSort(arr):
    n = len(arr)
    
    for i in range(n):
        min_idx = i
        
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum element with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Example usage
arr = [5, 3, 8, 1, 2]
sorted_arr = selectionSort(arr)
print(sorted_arr)  # Output: [1, 2, 3, 5, 8]
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Find Minimum, Swap Position''

\end{mnemonicbox}
\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{Explain bubble sort algorithm.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-e9d1cb7b.pdf}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
Key Points \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Compare adjacent elements \\
Swap if they are in wrong order \\
Largest element bubbles to end in each pass \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Bubble Bigger Elements Upward''

\end{mnemonicbox}
\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Differentiate Linear \& Binary search.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & Linear Search & Binary Search \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Working Principle & Sequential checking & Divide and conquer \\
Time Complexity & O(n) & O(log n) \\
Data Arrangement & Unsorted or sorted & Must be sorted \\
Best For & Small datasets & Large datasets \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Linear Looks at All, Binary Breaks in Half''

\end{mnemonicbox}
\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Explain Quick sort \& Merge sort algorithm.}

\begin{solutionbox}

\textbf{Quick Sort:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-fbc19991.pdf}

\textbf{Merge Sort:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-16c29927.pdf}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Algorithm & Principle & Average Time & Space Complexity \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Quick Sort & Partitioning around pivot & O(n log n) & O(log n) \\
Merge Sort & Divide, conquer, combine & O(n log n) & O(n) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Quick Partitions, Merge Divides''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Define a complete binary tree.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
    1
   / \
  2   3
 / \  /
4  5 6
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Property & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
All levels filled & Except possibly the last level \\
Last level filled from left & Nodes added from left to right \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Fill Left to Right, Level by Level''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Explain inorder traversal of a binary tree.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
      A
     / \
    B   C
   / \
  D   E

Inorder: D \rightarrow B \rightarrow E \rightarrow A \rightarrow C
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Step & Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Traverse left subtree \\
2 & Visit root node \\
3 & Traverse right subtree \\
\end{longtable}
}

\textbf{Code:}

\begin{lstlisting}[language=Python]
def inorderTraversal(root):
    if root:
        inorderTraversal(root.left)
        print(root.data, end=" \rightarrow ")
        inorderTraversal(root.right)
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Left, Root, Right''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Write a program to inserting a node into a binary search tree.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-db1025eb.pdf}

\textbf{Code:}

\begin{lstlisting}[language=Python]
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert(root, key):
    if root is None:
        return Node(key)
    
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
        
    return root
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Compare, Move, Insert''

\end{mnemonicbox}
\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{State the fundamental characteristic of a binary search tree.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}l@{}}
\toprule\noalign{}
Characteristics of Binary Search Tree \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1. Left child nodes \textless{} Parent node \\
2. Right child nodes \textgreater{} Parent node \\
3. No duplicate values allowed \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``Left Less, Right More''

\end{mnemonicbox}
\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Explain postorder traversal of a binary tree.}

\begin{solutionbox}

\textbf{Diagram:}

\begin{lstlisting}
      A
     / \
    B   C
   / \
  D   E

Postorder: D \rightarrow E \rightarrow B \rightarrow C \rightarrow A
\end{lstlisting}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Step & Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Traverse left subtree \\
2 & Traverse right subtree \\
3 & Visit root node \\
\end{longtable}
}

\textbf{Code:}

\begin{lstlisting}[language=Python]
def postorderTraversal(root):
    if root:
        postorderTraversal(root.left)
        postorderTraversal(root.right)
        print(root.data, end=" \rightarrow ")
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Left, Right, Root''

\end{mnemonicbox}
\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{Write a program to delete a node from a binary search tree.}

\begin{solutionbox}

\textbf{Diagram:}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-9b3d628a.pdf}

\textbf{Code:}

\begin{lstlisting}[language=Python]
def minValueNode(node):
    current = node
    while current.left is not None:
        current = current.left
    return current

def deleteNode(root, key):
    if root is None:
        return root
        
    if key < root.key:
        root.left = deleteNode(root.left, key)
    elif key > root.key:
        root.right = deleteNode(root.right, key)
    else:
        # Node with one or no child
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
            
        # Node with two children
        successor = minValueNode(root.right)
        root.key = successor.key
        root.right = deleteNode(root.right, successor.key)
        
    return root
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``Find, Replace, Reconnect''

\end{mnemonicbox}

\end{document}
