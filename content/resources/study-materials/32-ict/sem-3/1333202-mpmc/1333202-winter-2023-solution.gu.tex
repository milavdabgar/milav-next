\documentclass{article}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Microprocessor \& Microcontroller Systems (1333202) - Winter 2023 Solution}
\date{January 16, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{માઇક્રોપ્રોસેસર ની વ્યાખ્યા આપો.}

\begin{solutionbox}
માઇક્રોપ્રોસેસર એ એક સિંગલ ચિપ CPU છે જેમાં digital computer ના central processing unit ના કાર્યો કરવા માટે જરૂરી બધા arithmetic, logic અને control circuits હોય છે.

\begin{answertable}{માઇક્રોપ્રોસેસર ની મુખ્ય વિશેષતાઓ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{વિશેષતા} & \textbf{વર્ણન} \\ \hline
\textbf{Single Chip} & એક integrated circuit પર સંપૂર્ણ CPU \\ \hline
\textbf{Processing Unit} & instructions execute કરે છે અને calculations કરે છે \\ \hline
\textbf{Control Logic} & system operations અને data flow ને manage કરે છે \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Central Processing Unit}: મુખ્ય component જે instructions execute કરે છે
    \item \textbf{Integrated Circuit}: બધા functions એક જ silicon chip પર combined
    \item \textbf{Programmable Device}: stored instructions આધારે વિવિધ programs execute કરી શકે છે
\end{itemize}

\begin{mnemonicbox}
Single Chip CPU = Smart Computer Processor Unit
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(b)}{4}{માઇક્રોપ્રોસેસર ના ફ્લેગ રેજિસ્ટર ને સમજાવો.}

\begin{solutionbox}
Flag register માં ALU દ્વારા કરવામાં આવેલા arithmetic અને logical operations ના result વિશે status information store થાય છે.

\begin{answertable}{8085 Flag Register Bits}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Flag} & \textbf{Position} & \textbf{હેતુ} \\ \hline
\textbf{S (Sign)} & Bit 7 & Result નું sign દશાર્વે છે (1=negative, 0=positive) \\ \hline
\textbf{Z (Zero)} & Bit 6 & Result zero હોય ત્યારે set થાય છે \\ \hline
\textbf{AC (Auxiliary Carry)} & Bit 4 & Bit 3 થી bit 4 માં carry \\ \hline
\textbf{P (Parity)} & Bit 2 & Even parity flag \\ \hline
\textbf{CY (Carry)} & Bit 0 & MSB માંથી carry \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Status Indicator}: છેલ્લા operation result ની condition બતાવે છે
    \item \textbf{Conditional Instructions}: Branching અને decision making માટે ઉપયોગ થાય છે
    \item \textbf{5 Active Flags}: Sign, Zero, Auxiliary Carry, Parity અને Carry flags
\end{itemize}

\begin{mnemonicbox}
Flags Show Zero, Sign, Parity, Auxiliary, Carry
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1(c)}{7}{માઇક્રોપ્રોસેસર નું instruction format ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
Microprocessor instructions માં opcode અને operand fields હોય છે જે operation અને data locations specify કરે છે.

\begin{answertable}{8085 Instruction Format Types}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Format} & \textbf{Size} & \textbf{Structure} & \textbf{Example} \\ \hline
\textbf{1-Byte} & 8 bits & Opcode only & MOV A,B \\ \hline
\textbf{2-Byte} & 16 bits & Opcode + 8-bit data & MVI A,05H \\ \hline
\textbf{3-Byte} & 24 bits & Opcode + 16-bit address & LDA 2000H \\ \hline
\end{tabulary}
\end{answertable}

\begin{center}
\begin{tikzpicture}[node distance=2cm]
    \node [gtu block, minimum width=2.5cm] (opcode) {Opcode Field};
    \node [gtu block, minimum width=2.5cm, right=1cm of opcode] (operand) {Operand Field};

    \node [below=0.5cm of opcode, align=center, font=\footnotesize] {Operation Code\\Operation Specify કરે છે};
    \node [below=0.5cm of operand, align=center, font=\footnotesize] {Data/Address\\Source/Destination Specify કરે છે};

    \path [gtu arrow, ->] (opcode.south) -- +(0,-0.4);
    \path [gtu arrow, ->] (operand.south) -- +(0,-0.4);
    
    \node [above=0.2cm of opcode] {Instruction Format};
    \draw [dashed] ($(opcode.north west)+(-0.2,0.5)$) rectangle ($(operand.south east)+(0.2,-1.5)$);
\end{tikzpicture}
\captionof{figure}{Instruction Format}
\end{center}

\begin{itemize}
    \item \textbf{Opcode Field}: કયું operation કરવું છે તે define કરે છે (ADD, MOV, JMP)
    \item \textbf{Operand Field}: Data, register અથવા memory address information હોય છે
    \item \textbf{Variable Length}: Instructions 1, 2 અથવા 3 bytes ની હોઈ શકે છે
    \item \textbf{Addressing Modes}: Operand location specify કરવાની વિવિધ રીતો
\end{itemize}

\begin{mnemonicbox}
Opcode Operations + Operand Objects = Complete Commands
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{1(c)}{7}{માઇક્રોપ્રોસેસરમાં ALU, Control Unit અને CPU સમજાવો.}

\begin{solutionbox}
CPU માં ત્રણ મુખ્ય functional units છે જે instructions execute કરવા માટે સાથે મળીને કામ કરે છે.

\begin{answertable}{CPU Components અને Functions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Component} & \textbf{Primary Function} & \textbf{Key Operations} \\ \hline
\textbf{ALU} & Arithmetic \& Logic Operations & ADD, SUB, AND, OR, XOR \\ \hline
\textbf{Control Unit} & Instruction Control & Fetch, Decode, Execute \\ \hline
\textbf{CPU} & Overall Processing & બધા operations coordinate કરે છે \\ \hline
\end{tabulary}
\end{answertable}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node [gtu block] (cpu) {CPU};
    \node [gtu block, below left=1.5cm and 0.5cm of cpu] (alu) {ALU};
    \node [gtu block, below right=1.5cm and 0.5cm of cpu] (cu) {Control Unit};
    \node [gtu block, below=1.5cm of cpu] (regs) {Register Array};

    \draw [gtu arrow, ->] (cpu) -- (alu);
    \draw [gtu arrow, ->] (cpu) -- (cu);
    \draw [gtu arrow, ->] (cpu) -- (regs);
    
    \node [below=0.2cm of alu, align=center, font=\scriptsize] {Math \& Logic};
    \node [below=0.2cm of cu, align=center, font=\scriptsize] {Control \& Timing};
\end{tikzpicture}
\captionof{figure}{CPU Components}
\end{center}

\begin{itemize}
    \item \textbf{ALU Functions}: બધા arithmetic calculations અને logical operations કરે છે
    \item \textbf{Control Unit Tasks}: Instruction execution cycle manage કરે છે અને control signals generate કરે છે
    \item \textbf{CPU Coordination}: Complete processing માટે ALU અને Control Unit ને integrate કરે છે
\end{itemize}

\begin{mnemonicbox}
ALU Adds, Control Commands, CPU Coordinates
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(a)}{3}{ALE signal નું કાર્ય સમજાવો.}

\begin{solutionbox}
ALE (Address Latch Enable) signal નો ઉપયોગ lower-order address અને data lines ને demultiplex કરવા માટે થાય છે.

\begin{answertable}{ALE Signal Functions}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Function} & \textbf{વર્ણન} \\ \hline
\textbf{Address Latching} & Lower 8-bit address capture કરે છે \\ \hline
\textbf{Demultiplexing} & Address ને data થી separate કરે છે \\ \hline
\textbf{Timing Control} & Timing reference પ્રદાન કરે છે \\ \hline
\end{tabulary}
\end{answertable}

\begin{center}
\begin{tikzpicture}[node distance=2.5cm]
    \node [gtu block, minimum height=3cm] (cpu) {8085\\CPU};
    \node [gtu block, right=3cm of cpu] (latch) {74373\\Latch};
    
    \draw [->, thick] ($(cpu.east)+(0,0.5)$) -- node[above] {AD0-AD7} ($(latch.west)+(0,0.5)$);
    \draw [->, thick] ($(cpu.east)+(0,-0.5)$) -- node[below] {ALE} ($(latch.west)+(0,-0.5)$);
    
    \draw [->, thick] (latch.south) -- ++(0,-1) node[below] {A0-A7 (Address)};
\end{tikzpicture}
\captionof{figure}{ALE Signal Usage}
\end{center}

\begin{itemize}
    \item \textbf{Active High Signal}: T1 state દરમિયાન ALE high જાય છે
    \item \textbf{External Latching}: Address hold કરવા માટે 74373 latch સાથે ઉપયોગ થાય છે
    \item \textbf{System Timing}: External devices માટે reference પ્રદાન કરે છે
\end{itemize}

\begin{mnemonicbox}
ALE Always Latches External Addresses
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(b)}{4}{માઇક્રોપ્રોસેસર અને માઇક્રોકંટ્રોલર ની સરખામણી કરો}

\begin{solutionbox}
\begin{answertable}{Microprocessor vs Microcontroller Comparison}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Parameter} & \textbf{Microprocessor} & \textbf{Microcontroller} \\ \hline
\textbf{Design} & General purpose & Application specific \\ \hline
\textbf{Memory} & External RAM/ROM & Internal RAM/ROM \\ \hline
\textbf{I/O Ports} & External interface & Built-in I/O ports \\ \hline
\textbf{Timers} & External & Built-in timers \\ \hline
\textbf{Cost} & વધુ system cost & ઓછો system cost \\ \hline
\textbf{Power} & વધુ consumption & ઓછો consumption \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Integration Level}: Microcontroller માં વધુ integrated components હોય છે
    \item \textbf{Application Focus}: Microprocessor computing માટે, microcontroller control માટે
    \item \textbf{System Complexity}: Microprocessor ને વધુ external components જોઈએ છે
    \item \textbf{Design Flexibility}: Microprocessor વધુ expandability આપે છે
\end{itemize}

\begin{mnemonicbox}
Microprocessor = More Power, Microcontroller = More Control
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2(c)}{7}{માઇક્રોપ્રોસેસરનો બ્લોક ડાયાગ્રામ દોરો અને સમજાવો.}

\begin{solutionbox}
8085 microprocessor માં કેટલાક functional blocks છે જે સાથે મળીને કામ કરે છે.

\begin{center}
\begin{tikzpicture}[scale=0.8, transform shape]
    % Main Blocks
    \node [gtu block] (alu) {ALU};
    \node [gtu block, below=1cm of alu] (acc) {Accumulator};
    \node [gtu block, right=1cm of acc] (flags) {Flags};
    \node [gtu block, left=1cm of acc] (temp) {Temp Reg};
    
    \node [gtu block, right=3cm of alu, minimum width=3cm] (regs) {Register Array\\B, C, D, E, H, L\\SP, PC};
    
    \node [gtu block, below=2cm of temp] (id) {Instruction\\Decoder};
    \node [gtu block, below=1cm of id] (timing) {Timing \&\\Control};
    
    % Connections
    \draw [gtu arrow, <->] (alu) -- (acc);
    \draw [gtu arrow] (alu) -- (flags);
    \draw [gtu arrow] (id) -- (timing);
    \draw [gtu arrow, <->] (alu) -- (regs);
    
    % Address/Data Buffers
    \node [gtu block, below=1cm of regs] (abuf) {Address Buffer};
    \node [gtu block, below=1cm of abuf] (adbuf) {Addr/Data Buffer};
    
    \draw [gtu arrow, ->] (regs) -- (abuf);
    \draw [gtu arrow, ->] (regs) -- (adbuf);
    
    \draw [->, thick] (abuf.east) -- ++(1,0) node[right] {A8-A15};
    \draw [->, thick] (adbuf.east) -- ++(1,0) node[right] {AD0-AD7};

\end{tikzpicture}
\captionof{figure}{8085 Block Diagram}
\end{center}

\begin{answertable}{Block Functions}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Block} & \textbf{Function} \\ \hline
\textbf{ALU} & Arithmetic અને logical operations \\ \hline
\textbf{Register Array} & Temporary data storage (B,C,D,E,H,L) \\ \hline
\textbf{Control Unit} & Instruction execution control \\ \hline
\textbf{Address Buffer} & Address bus lines drive કરે છે \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Data Path}: Internal bus દ્વારા registers વચ્ચે information flow થાય છે
    \item \textbf{Control Signals}: Timing અને control unit દ્વારા generate થાય છે
    \item \textbf{Bus Interface}: External memory અને I/O devices સાથે connect કરે છે
    \item \textbf{Register Operations}: Operands અને results માટે temporary storage
\end{itemize}

\begin{mnemonicbox}
Blocks Build Better Processing Systems
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2(a)}{3}{માઇક્રોપ્રોસેસરના 16 bits registers સમજાવો.}

\begin{solutionbox}
8085 માં 8-bit register pairs ને combine કરીને બનેલા ત્રણ 16-bit registers છે.

\begin{answertable}{16-bit Registers}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Register} & \textbf{Formation} & \textbf{Purpose} \\ \hline
\textbf{PC} & Single 16-bit & Program Counter - next instruction address \\ \hline
\textbf{SP} & Single 16-bit & Stack Pointer - stack ના top નું address \\ \hline
\textbf{HL} & H + L registers & Memory pointer - data address \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Program Counter}: આપમેળે next instruction પર increment થાય છે
    \item \textbf{Stack Pointer}: Stack પર last pushed data તરફ point કરે છે
    \item \textbf{HL Pair}: Memory addressing માટે સૌથી વધુ વપરાતું
\end{itemize}

\begin{mnemonicbox}
PC Points Program, SP Stacks Properly, HL Holds Location
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2(b)}{4}{માઇક્રોપ્રોસેસર માં lower order address અને data lines ને de-multiplexing કરવાનું સમજાવો.}

\begin{solutionbox}
8085 pin count ઘટાડવા માટે lower 8-bit address ને data lines સાથે multiplex કરે છે.

\begin{answertable}{Multiplexed Lines}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Lines} & \textbf{T1 State} & \textbf{T2-T4 States} \\ \hline
\textbf{AD0-AD7} & Lower Address A0-A7 & Data D0-D7 \\ \hline
\textbf{ALE Signal} & High & Low \\ \hline
\end{tabulary}
\end{answertable}

\begin{center}
\begin{tikzpicture}[node distance=2.5cm]
    \node [gtu block, minimum height=3cm] (cpu) {8085};
    \node [gtu block, right=3cm of cpu] (latch) {74373\\Latch};
    
    % Lines
    \draw [->, thick] ($(cpu.east)+(0,0.5)$) -- node[above] {AD0-AD7} ($(latch.west)+(0,0.5)$);
    \draw [->, thick] ($(cpu.east)+(0,-0.5)$) -- node[below] {ALE} ($(latch.west)+(0,-0.5)$);
    
    % Outputs
    \draw [->, thick] (latch.east) -- ++(1,0) node[right] {A0-A7 (Address)};
    \draw [->, thick] ($(latch.west)+(0.5,0.5)$) -- ++(0,-1.5) -- ++(2.5,0) node[right] {D0-D7 (Data)};
    
\end{tikzpicture}
\captionof{figure}{Demultiplexing Circuit}
\end{center}

\begin{itemize}
    \item \textbf{Time Division}: સમાન lines પહેલા address પછી data carry કરે છે
    \item \textbf{External Latch}: ALE high હોય ત્યારે 74373 address capture કરે છે
    \item \textbf{Signal Separation}: અલગ address અને data buses બનાવે છે
\end{itemize}

\begin{mnemonicbox}
ALE Always Latches External Address Elegantly
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2(c)}{7}{8085 નો pin diagram દોરો અને સમજાવો.}

\begin{solutionbox}
8085 એ multiplexed address/data bus વાળું 40-pin microprocessor છે.

\begin{center}
\begin{tikzpicture}[scale=0.7, transform shape]
    \draw [thick] (0,0) rectangle (6,10);
    \node at (3,5) {\textbf{8085}};
    \node at (3,9.5) {\textbf{Pin Diagram}};
    
    % Left Pins (Sample)
    \draw (0, 9) -- (-0.5, 9) node[left] {X1};
    \draw (0, 8.5) -- (-0.5, 8.5) node[left] {X2};
    \draw (0, 8) -- (-0.5, 8) node[left] {RESET OUT};
    \draw (0, 6.5) -- (-0.5, 6.5) node[left] {TRAP};
    
    % Right Pins (Sample)
    \draw (6, 9) -- (6.5, 9) node[right] {Vcc};
    \draw (6, 8.5) -- (6.5, 8.5) node[right] {HOLD};
    \draw (6, 7.5) -- (6.5, 7.5) node[right] {CLK OUT};
    \draw (6, 0.5) -- (6.5, 0.5) node[right] {AD0};
    
    \node at (3,2) {.... (Total 40 Pins) ....};
\end{tikzpicture}
\captionof{figure}{8085 Pin Diagram}
\end{center}

\begin{answertable}{Pin Groups}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Group} & \textbf{Pins} & \textbf{Function} \\ \hline
\textbf{Address/Data} & AD0-AD7, A8-A15 & Memory addressing અને data transfer \\ \hline
\textbf{Control} & ALE, RD*, WR*, IO/M* & Bus control signals \\ \hline
\textbf{Interrupts} & INTR, RST7-RST5, TRAP & Interrupt handling \\ \hline
\textbf{Power} & Vcc, Vss & Power supply connections \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Multiplexed Bus}: AD0-AD7 address અને data બંને carry કરે છે
    \item \textbf{Active Low Signals}: * વાળા signals active low છે
    \item \textbf{Crystal Connections}: Clock generation માટે X1, X2
\end{itemize}

\questionmarks{3(a)}{3}{માઇક્રોકંટ્રોલરનો clock અને reset circuit દોરો.}

\begin{solutionbox}
8051 microcontroller ને operate કરવા માટે external oscillator અને reliable reset circuit ની જરૂર પડે છે.

\begin{center}
\begin{tikzpicture}[scale=0.9, transform shape]
    \node [gtu block, minimum height=3cm] (mcu) {8051};
    
    % Clock Circuit
    \coordinate (x1) at ($(mcu.west)+(0,0.5)$);
    \coordinate (x2) at ($(mcu.west)+(0,-0.5)$);
    \node [left] at (x1) {XTAL1};
    \node [left] at (x2) {XTAL2};
    
    \node [draw, generic, minimum size=0.8cm, left=1.5cm of mcu] (xtal) {Crystal};
    \draw (x1) -- ++(-1.5,0) -- (xtal.north);
    \draw (x2) -- ++(-1.5,0) -- (xtal.south);
    
    \draw ($(x1)+(-1,0)$) to[C, l=33pF] ++(0,-1) node[ground] {};
    \draw ($(x2)+(-1,0)$) to[C, l=33pF] ++(0,1) node[ground] {};
    
    % Reset Circuit
    \coordinate (rst) at ($(mcu.north)+(0.5,0)$);
    \node [above] at (rst) {RST};
    
    \draw (rst) -- ++(0,1) coordinate (j1);
    \draw (j1) to[C, l=10$\mu$F] ++(0,1.5) node[vcc] {+5V};
    \draw (j1) to[R, l=8.2k$\Omega$] ++(0,-1.5) node[ground] {};
    \draw (j1) -- ++(1,0) to[push button, l=Reset] ++(0,1.5) node[vcc] {+5V};
    
\end{tikzpicture}
\captionof{figure}{Clock and Reset Circuit}
\end{center}

\begin{itemize}
    \item \textbf{Clock Circuit}: 11.0592 MHz crystal નો સામાન્ય રીતે serial communication માટે ઉપયોગ થાય છે.
    \item \textbf{Reset Circuit}: Power-on reset માટે capacitor (10$\mu$F) અને resistor (8.2k$\Omega$) નો ઉપયોગ થાય છે.
    \item \textbf{Manual Reset}: Button press કરવાથી RST pin પર high pulse મળે છે.
\end{itemize}

\begin{mnemonicbox}
Crystal Clocks Count, Reset Restarts Running
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(b)}{4}{8051 માઇક્રોકંટ્રોલર નું ઇન્ટરનલ રેમ ઓર્ગેનાઇઝેશન સમજાવો.}

\begin{solutionbox}
8051 માં 128 bytes ની internal RAM હોય છે જે ત્રણ મુખ્ય sections માં વહેંચાયેલી છે.

\begin{answertable}{RAM Organization}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Address} & \textbf{Area Name} & \textbf{Purpose} \\ \hline
\textbf{00H - 1FH} & Register Banks & 4 Banks (0-3), દરેક માં R0-R7 \\ \hline
\textbf{20H - 2FH} & Bit Addressable & 128 bit locations logic operations માટે \\ \hline
\textbf{30H - 7FH} & General Purpose & User data અને stack માટે scratch pad \\ \hline
\end{tabulary}
\end{answertable}

\begin{center}
\begin{tikzpicture}[xscale=2, yscale=0.5]
    \draw (0,0) rectangle (2,8);
    \node at (1,8.5) {Internal RAM (128 Bytes)};
    
    \draw (0,2) -- (2,2);
    \draw (0,4) -- (2,4);
    
    \node at (1,1) {General Purpose RAM\\(80 Bytes)};
    \node [right] at (2,0) {30H};
    \node [right] at (2,2) {30H}; % Correction: Should range
    \node [right] at (2,2) {2FH};
    
    \node at (1,3) {Bit Addressable RAM\\(16 Bytes)};
    \node [right] at (2,4) {20H};
    
    \node at (1,6) {Register Banks 0-3\\(32 Bytes)};
    \node [right] at (2,8) {00H};
    \node [right] at (2,8) {00H};
    \node [left] at (0,0) {7FH};
\end{tikzpicture}
\captionof{figure}{Internal RAM Map}
\end{center}

\begin{itemize}
    \item \textbf{Register Banks}: Context switching માટે bank switching નો ઉપયોગ થાય છે.
    \item \textbf{Bit Addressable}: Single bit manipulation (SETB, CLR) માટે પરવાનગી આપે છે.
    \item \textbf{Scratch Pad}: Temporary data storage અને stack operations માટે વપરાય છે.
\end{itemize}

\begin{mnemonicbox}
Banks Bottom, Bits Between, General Ground
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3(c)}{7}{8051 નો બ્લોક ડાયાગ્રામ દોરી તેના મુખ્ય ફીચર્સ સમજાવો.}

\begin{solutionbox}
8051 એ 40-pin microcontroller છે જેમાં CPU, RAM, ROM, I/O ports, અને timers એક ચિપ પર ઇન્ટિગ્રેટેડ હોય છે.

\begin{center}
\begin{tikzpicture}[scale=0.8, transform shape]
    % Central Bus
    \draw [double, double distance=2pt, thick] (2,1) -- (2,9); 
    \node [right, rotate=90] at (2.3, 5) {Internal System Bus};
    
    % Blocks Left
    \node [gtu block] (cpu) at (0,8) {CPU};
    \node [gtu block] (osc) at (0,6) {Oscillator};
    \node [gtu block] (int) at (0,4) {Interrupts};
    \node [gtu block] (rom) at (0,2) {4KB ROM};
    
    % Blocks Right
    \node [gtu block] (ram) at (4,8) {128B RAM};
    \node [gtu block] (timer) at (4,6) {Timer 0/1};
    \node [gtu block] (serial) at (4,4) {Serial Port};
    \node [gtu block] (io) at (4,2) {I/O Ports\\P0-P3};
    
    % Connections
    \foreach \n in {cpu, osc, int, rom} \draw [->, thick] (\n.east) -- (2, 0 |- \n.east);
    \foreach \n in {ram, timer, serial, io} \draw [<-, thick] (\n.west) -- (2, 0 |- \n.west);
    
\end{tikzpicture}
\captionof{figure}{8051 Block Diagram}
\end{center}

\begin{answertable}{8051 Main Features}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Feature} & \textbf{Specification} \\ \hline
\textbf{CPU} & 8-bit CPU \\ \hline
\textbf{Memory} & 4KB Internal ROM, 128 Bytes Internal RAM \\ \hline
\textbf{I/O} & 4 Ports (P0-P3), Total 32 pins \\ \hline
\textbf{Timers} & 2 x 16-bit Timers/Counters \\ \hline
\textbf{Serial} & 1 Full Duplex UART \\ \hline
\textbf{Interrupts} & 5 Interrupt Sources \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Integrated Design}: System on Chip concept.
    \item \textbf{Harvard Architecture}: Separate program અને data memory spaces.
    \item \textbf{Bit Processing}: Boolean processor single-bit operations માટે.
\end{itemize}

\begin{mnemonicbox}
Chip Contains CPU, RAM, ROM, I/O, Timers, Serial
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{3(c)}{7}{8051 નું interrupt structure સમજાવો.}

\begin{solutionbox}
8051 પાસે 5 interrupt sources છે જે normal program execution ને interrupt કરી શકે છે.

\begin{answertable}{8051 Interrupt Sources}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Priority} & \textbf{Interrupt} & \textbf{Vector Address} & \textbf{Trigger} \\ \hline
1 (High) & IE0 (External 0) & 0003H & Low Level/Edge \\ \hline
2 & TF0 (Timer 0) & 000BH & Overflow \\ \hline
3 & IE1 (External 1) & 0013H & Low Level/Edge \\ \hline
4 & TF1 (Timer 1) & 001BH & Overflow \\ \hline
5 (Low) & RI/TI (Serial) & 0023H & Rx/Tx Complete \\ \hline
\end{tabulary}
\end{answertable}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm]
    \node [gtu block] (cpu) {CPU};
    \coordinate (bus) at ($(cpu.west)+(-1,0)$);
    
    \node [gtu state, above left=1cm and 2cm of cpu] (ie0) {IE0};
    \node [gtu state, below=0.5cm of ie0] (tf0) {TF0};
    \node [gtu state, below=0.5cm of tf0] (ie1) {IE1};
    \node [gtu state, below=0.5cm of ie1] (tf1) {TF1};
    \node [gtu state, below=0.5cm of tf1] (ser) {Serial};
    
    \draw [->, thick] (ie0) -| (bus) -- (cpu.west);
    \draw [->, thick] (tf0) -| (bus);
    \draw [->, thick] (ie1) -| (bus);
    \draw [->, thick] (tf1) -| (bus);
    \draw [->, thick] (ser) -| (bus);
    
    \node [right=0.2cm of cpu] (vec) {Vector Table};
    \draw [dotted, ->] (cpu) -- (vec);
\end{tikzpicture}
\captionof{figure}{Interrupt Structure}
\end{center}

\begin{itemize}
    \item \textbf{Vector Address}: જ્યાં interrupt service routine (ISR) શરૂ થાય છે.
    \item \textbf{Priority Logic}: એકસાથે interrupts આવે ત્યારે priority નક્કી કરે છે.
    \item \textbf{Enable Control}: IE (Interrupt Enable) register દ્વારા enable/disable થાય છે.
\end{itemize}

\begin{mnemonicbox}
Five Factors Force Interrupts: EXT0, T0, EXT1, T1, Serial
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(a)}{3}{Machine cycle ની વ્યાખ્યા આપો.}

\begin{solutionbox}
Machine cycle એ CPU દ્વારા memory અથવા I/O device ને access કરવા માટે લાગતો સમય છે.

\begin{itemize}
    \item \textbf{Clock Periods}: 8051 માં, 1 Machine Cycle = 12 Oscillator Periods.
    \item \textbf{Execute Operation}: એક instruction ને execute કરતા 1 થી 4 machine cycles લાગે છે.
    \item \textbf{T-States}: દરેક machine cycle માં 6 states (S1-S6) હોય છે.
\end{itemize}

\textbf{ગણતરી:}
જો Crystal Frequency = 11.0592 MHz હોય,
Machine Cycle Frequency = 11.0592 / 12 = 921.6 kHz.
Time = 1 / 921.6 kHz = 1.085 $\mu$s.

\begin{mnemonicbox}
Machine Cycle = Memory Access Time
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(b)}{4}{8051 ના વિવિધ એડ્રેસિંગ મોડ્સ સમજાવો.}

\begin{solutionbox}
Addressing modes ડેટાને એક્સેસ કરવાની વિવિધ રીતો વ્યાખ્યાયિત કરે છે.

\begin{answertable}{8051 Addressing Modes}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Mode} & \textbf{Description} & \textbf{Example} \\ \hline
\textbf{Immediate} & Data instruction માં જ આપેલો હોય છે & MOV A, \#25H \\ \hline
\textbf{Register} & Data register માં હોય છે & MOV A, R0 \\ \hline
\textbf{Direct} & Direct memory address નો ઉપયોગ થાય છે & MOV A, 30H \\ \hline
\textbf{Register Indirect} & Register address hold કરે છે (@) & MOV A, @R0 \\ \hline
\textbf{Indexed} & Base + Offset address & MOVC A, @A+DPTR \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Flexible Access}: વિવિધ programming needs માટે data access આપે છે.
    \item \textbf{Code Efficiency}: યોગ્ય mode પસંદ કરવાથી code size અને speed સુધરે છે.
    \item \textbf{Restrictions}: અમુક instructions માત્ર specific modes સપોર્ટ કરે છે.
\end{itemize}

\begin{mnemonicbox}
Modes Means Methods of Moving Memory
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4(c)}{7}{8051 નું instruction set સમજાવો.}

\begin{solutionbox}
8051 instruction set ને તેમના કાર્ય મુજબ પાંચ જૂથોમાં વર્ગીકૃત કરવામાં આવે છે.

\begin{answertable}{Instruction Groups}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Group} & \textbf{Function} & \textbf{Examples} \\ \hline
\textbf{Data Transfer} & Data ને move કરે છે (Copy) & MOV, PUSH, POP, XCH \\ \hline
\textbf{Arithmetic} & Mathematical operations & ADD, SUBB, INC, DEC, MUL \\ \hline
\textbf{Logical} & Boolean operations & ANL, ORL, XRL, CPL, RL \\ \hline
\textbf{Boolean} & Bit oriented operations & CLR, SETB, CPL, JC, JB \\ \hline
\textbf{Branching} & Flow control operations & LJMP, LCALL, RET, JZ, CJNE \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Data Transfer}: Memory અને register data movement માટે.
    \item \textbf{Arithmetic/Logical}: Processing અને calculation માટે.
    \item \textbf{Boolean}: 8051 ની વિશેષતા - single bit manipulation.
    \item \textbf{Branching}: Loops અને decision making માટે.
\end{itemize}

\begin{mnemonicbox}
Data, Math, Logic, Bits, Branch - 5 Groups
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{4(c)}{7}{Stack એટલે શું? તે માઇક્રોકંટ્રોલરમાં કેવી રીતે કામ કરે છે?}

\begin{solutionbox}
Stack એ RAM માં આવેલો કામચલાઉ ડેટા સ્ટોરેજ વિસ્તાર છે જે LIFO (Last In First Out) સિદ્ધાંત પર કાર્ય કરે છે.

\begin{answertable}{Stack Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Description} & \textbf{SP Action} \\ \hline
\textbf{PUSH} & Data ને stack પર મૂકે છે & SP = SP + 1, પછી Store Data \\ \hline
\textbf{POP} & Data ને stack માંથી દૂર કરે છે & Retrieve Data, પછી SP = SP - 1 \\ \hline
\end{tabulary}
\end{answertable}

\begin{center}
\begin{tikzpicture}[scale=0.9, transform shape]
    \draw (0,0) rectangle (2,4);
    \node at (1,4.5) {Stack Memory};
    
    \draw (0,1) -- (2,1);
    \draw (0,2) -- (2,2);
    \draw (0,3) -- (2,3);
    
    \node at (1,0.5) {Empty};
    \node at (1,1.5) {Data 1};
    \node at (1,2.5) {Data 2 (Top)};
    \node at (1,3.5) {Empty};
    
    \draw [->, thick] (2.5, 2.5) -- (2, 2.5);
    \node [right] at (2.5, 2.5) {SP Points Here};
    
    \draw [->] (-1, 3.5) -- node[above] {PUSH} (0, 3.5);
    \draw [<-] (-1, 2.5) -- node[below] {POP} (0, 2.5);
\end{tikzpicture}
\captionof{figure}{Stack LIFO Operation}
\end{center}

\textbf{Example Code:}
\begin{lstlisting}
MOV SP,#30H         ; Stack pointer initialize કરો
PUSH ACC            ; Save accumulator
PUSH B              ; Save B register
POP B               ; Restore B register
POP ACC             ; Restore accumulator
\end{lstlisting}

\begin{itemize}
    \item \textbf{LIFO Structure}: છેલ્લે ઉમેરેલો ડેટા પહેલા બહાર આવે છે.
    \item \textbf{SP Auto-increment}: PUSH વખતે SP આપમેળે વધે છે.
    \item \textbf{Subroutine Calls}: CALL વખતે return address stack પર save થાય છે.
    \item \textbf{Register Preservation}: Interrupts દરમિયાન registers save કરવા માટે ઉપયોગી.
\end{itemize}

\begin{mnemonicbox}
PUSH Puts Up, Stack Holds, POP Pulls Out
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(a)}{3}{Branching instruction ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
Branching instructions કન્ડિશન અથવા અનકન્ડિશનલી પ્રોગ્રામ ફ્લો બદલે છે.

\begin{answertable}{Branching Instructions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Type} & \textbf{Instruction} & \textbf{Example} \\ \hline
\textbf{Unconditional} & LJMP address & LJMP 2000H \\ \hline
\textbf{Conditional} & JZ address & JZ ZERO\_LABEL \\ \hline
\textbf{Call/Return} & LCALL address & LCALL SUBROUTINE \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example:}
\begin{lstlisting}
MOV A,#00H          ; Load zero
JZ ZERO_FOUND       ; Jump if A is zero
LJMP CONTINUE       ; Jump to continue
ZERO_FOUND:
    MOV R0,#01H     ; Set flag
CONTINUE:
    NOP             ; Continue execution
\end{lstlisting}

\begin{itemize}
    \item \textbf{Program Control}: Execution sequence બદલે છે.
    \item \textbf{Conditional Jumps}: Flag register status પર આધારિત છે.
    \item \textbf{Address Range}: કોઈપણ program memory location પર jump કરી શકે છે.
\end{itemize}

\begin{mnemonicbox}
Jump Changes Control Flow
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(b)}{4}{માઇક્રોકંટ્રોલર સાથે 8 leds ઇન્ટરફેસ કરો અને તેને ચાલુ અને બંધ કરવા માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}
8 LEDs ને સામાન્ય રીતે Port 1 સાથે current limiting resistors મારફતે કનેક્ટ કરવામાં આવે છે.

\begin{center}
\begin{tikzpicture}[scale=0.9, transform shape]
    \node [gtu block, minimum height=4cm] (mcu) {8051\\Port 1};
    
    \foreach \y in {0,...,7} {
        \draw (mcu.east) ++(0, 1.75 - \y*0.5) -- ++(1,0) to[R, l=330$\Omega$] ++(1.5,0) node[right, circle, fill=red, inner sep=2pt, label=right:LED\y] (led\y) {};
        \draw (led\y) -- ++(0.5,0) node[vcc] {+5V};
    }
\end{tikzpicture}
\captionof{figure}{LED Interfacing}
\end{center}

\textbf{Program:}
\begin{lstlisting}
ORG 0000H
MAIN:
    MOV P1,#0FFH        ; Turn ON all LEDs
    CALL DELAY          ; Wait
    MOV P1,#00H         ; Turn OFF all LEDs  
    CALL DELAY          ; Wait
    SJMP MAIN           ; Repeat

DELAY:
    MOV R0,#0FFH        ; Outer loop counter
LOOP1:
    MOV R1,#0FFH        ; Inner loop counter  
LOOP2:
    DJNZ R1,LOOP2       ; Inner delay loop
    DJNZ R0,LOOP1       ; Outer delay loop
    RET                 ; Return
END
\end{lstlisting}

\begin{answertable}{Components}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Component} & \textbf{Value} & \textbf{Purpose} \\ \hline
\textbf{Resistor} & 330$\Omega$ & Current limiting માટે \\ \hline
\textbf{LEDs} & 8 pieces & Visual indicators તરીકે \\ \hline
\textbf{Port} & P1 & 8-bit output port \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Current Limiting}: Resistors LEDs ને નુકસાન થતા અટકાવે છે.
    \item \textbf{Port Configuration}: P1 નો ઉપયોગ LED control માટે થાય છે.
    \item \textbf{Active Low}: Code માં logic 0 LED ને ચાલુ કરે છે (Common Anode connection).
\end{itemize}

\begin{mnemonicbox}
Port Controls LEDs with Resistance and Delay
\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5(c)}{7}{માઇક્રોકંટ્રોલર સાથે LCD ઇન્ટરફેસ કરો અને "welcome" ડિસ્પ્લે કરવા માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}
16x2 LCD ને 8051 સાથે 4-bit અથવા 8-bit mode માં interface કરી શકાય છે.

\begin{center}
\begin{tikzpicture}[scale=0.9, transform shape]
    \node [gtu block, minimum height=3cm] (mcu) {8051};
    \node [gtu block, minimum height=3cm, right=3cm of mcu] (lcd) {16x2 LCD};
    
    % Data Lines
    \draw [->, thick] ($(mcu.east)+(0,1)$) -- node[above] {P2.0-P2.3} node[below] {Data} ($(lcd.west)+(0,1)$);
    \node [right] at ($(lcd.west)+(0,1)$) {D4-D7};
    
    % Control Lines
    \draw [->] ($(mcu.east)+(0,0)$) -- node[above] {P1.0} ($(lcd.west)+(0,0)$);
    \node [right] at ($(lcd.west)+(0,0)$) {RS};
    
    \draw [->] ($(mcu.east)+(0,-0.5)$) -- node[above] {P1.1} ($(lcd.west)+(0,-0.5)$);
    \node [right] at ($(lcd.west)+(0,-0.5)$) {EN};
    
    % Ground
    \draw ($(lcd.west)+(0,-1)$) -- ++(-0.5,0) node[ground] {};
    \node [right] at ($(lcd.west)+(0,-1)$) {R/W, Vss};
    
\end{tikzpicture}
\captionof{figure}{LCD Interfacing}
\end{center}

\textbf{Program:}
\begin{lstlisting}
ORG 0000H
    CALL LCD_INIT       ; Initialize LCD
    CALL DISPLAY_MSG    ; Display message
    SJMP $              ; Stop here

LCD_INIT:
    MOV P2,#38H         ; Function set: 8-bit, 2-line
    CALL COMMAND
    MOV P2,#0EH         ; Display ON, Cursor ON
    CALL COMMAND  
    MOV P2,#01H         ; Clear display
    CALL COMMAND
    MOV P2,#06H         ; Entry mode set
    CALL COMMAND
    RET

DISPLAY_MSG:
    MOV DPTR,#MESSAGE   ; Point to message
NEXT_CHAR:
    CLR A
    MOVC A,@A+DPTR      ; Read character
    JZ DONE             ; If zero, end of string
    CALL SEND_CHAR      ; Send character to LCD
    INC DPTR            ; Next character
    SJMP NEXT_CHAR
DONE:
    RET

COMMAND:
    CLR P1.0            ; RS = 0 for command
    SETB P1.1           ; EN = 1
    CLR P1.1            ; EN = 0 (pulse)
    CALL DELAY
    RET

SEND_CHAR:
    MOV P2,A            ; Put character on data lines
    SETB P1.0           ; RS = 1 for data
    SETB P1.1           ; EN = 1
    CLR P1.1            ; EN = 0 (pulse)
    CALL DELAY
    RET

DELAY:
    MOV R0,#50          ; Delay routine
DELAY_LOOP:
    MOV R1,#255
DELAY_INNER:
    DJNZ R1,DELAY_INNER
    DJNZ R0,DELAY_LOOP
    RET

MESSAGE:
    DB "WELCOME",0       ; Message string with null terminator
END
\end{lstlisting}

\begin{answertable}{LCD Interface Pins}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{8051 Pin} & \textbf{LCD Pin} & \textbf{Function} \\ \hline
\textbf{P2.0-P2.3} & D4-D7 & 4-bit data lines \\ \hline
\textbf{P1.0} & RS & Register select (0=command, 1=data) \\ \hline
\textbf{P1.1} & EN & Enable pulse \\ \hline
\textbf{GND} & R/W & Read/Write (grounded) \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{4-bit Mode}: Pins બચાવવા માટે માત્ર upper 4 data lines વપરાય છે.
    \item \textbf{Control Signals}: RS command/data select કરે છે, EN timing pulse આપે છે.
    \item \textbf{Initialization}: યોગ્ય કાર્ય માટે ચોક્કસ command sequence જરૂરી છે.
\end{itemize}

\begin{mnemonicbox}
LCD Displays Characters with Commands and Data
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5(a)}{3}{Logical instruction ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
Logical instructions data પર bitwise operations કરે છે.

\begin{answertable}{Logical Instructions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Instruction} & \textbf{Example} & \textbf{Function} \\ \hline
\textbf{ANL} & ANL A,\#0FH & Bitwise AND operation \\ \hline
\textbf{ORL} & ORL A,\#F0H & Bitwise OR operation \\ \hline
\textbf{XRL} & XRL A,\#FFH & Bitwise XOR operation \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example:}
\begin{lstlisting}
MOV A,#55H          ; A = 01010101B
ANL A,#0FH          ; A = 00000101B (mask upper bits)
ORL A,#F0H          ; A = 11110101B (set upper bits)
XRL A,#FFH          ; A = 00001010B (complement all bits)
\end{lstlisting}

\begin{itemize}
    \item \textbf{Bit Manipulation}: Bits ને set, clear અથવા test કરવા માટે વપરાય છે.
    \item \textbf{Masking Operations}: ANL unwanted bits ને clear કરે છે.
    \item \textbf{Flag Effects}: Parity flag update કરે છે.
\end{itemize}

\begin{mnemonicbox}
AND Masks, OR Sets, XOR Toggles
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5(b)}{4}{માઇક્રોકંટ્રોલર સાથે 7 segment ઇન્ટરફેસ કરો.}

\begin{solutionbox}
7-segment display માં 8 LEDs હોય છે (a-g અને dp) જે numbers દર્શાવવા માટે વપરાય છે.

\begin{center}
\begin{tikzpicture}[scale=0.9, transform shape]
    \node [gtu block, minimum height=4cm] (mcu) {8051\\Port 1};
    \node [right=3cm of mcu, draw, thick, rectangle, minimum size=2cm] (seg) {7-Segment};
    
    \foreach \y in {0,...,7} {
        \draw (mcu.east) ++(0, 1.75 - \y*0.5) -- ++(1,0) to[R, l=330$\Omega$] ++(1,0) -- (seg.west |- {0, 1.75 - \y*0.5});
    }
    
    \node [right=0.2cm] at (seg.east) {a-g, dp};
\end{tikzpicture}
\captionof{figure}{7-Segment Interfacing}
\end{center}

\textbf{Program to Display 0-9:}
\begin{lstlisting}
ORG 0000H
    MOV DPTR,#DIGIT_TABLE   ; Point to lookup table
    MOV R0,#0               ; Start with digit 0

MAIN_LOOP:
    MOV A,R0                ; Get current digit
    MOVC A,@A+DPTR          ; Get 7-segment code
    MOV P1,A                ; Display on 7-segment
    CALL DELAY              ; Wait 1 second
    INC R0                  ; Next digit
    CJNE R0,#10,MAIN_LOOP   ; Check if reached 10
    MOV R0,#0               ; Reset to 0
    SJMP MAIN_LOOP          ; Repeat

DIGIT_TABLE:
    DB 3FH, 06H, 5BH, 4FH, 66H    ; 0,1,2,3,4
    DB 6DH, 7DH, 07H, 7FH, 6FH    ; 5,6,7,8,9
END
\end{lstlisting}

\begin{answertable}{7-Segment Codes}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Digit} & \textbf{Hex Code} & \textbf{Binary} & \textbf{Segments Lit} \\ \hline
\textbf{0} & 3FH & 00111111 & a,b,c,d,e,f \\ \hline
\textbf{1} & 06H & 00000110 & b,c \\ \hline
\textbf{2} & 5BH & 01011011 & a,b,g,e,d \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Common Cathode}: જયારે port pin high હોય ત્યારે segments પ્રકાશિત થાય છે.
    \item \textbf{Current Limiting}: Resistors segments ને નુકસાન થતા અટકાવે છે.
    \item \textbf{Lookup Table}: Segment patterns ને store કરવાની કાર્યક્ષમ રીત.
\end{itemize}

\begin{mnemonicbox}
Seven Segments Show Digits Clearly
\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5(c)}{7}{માઇક્રોકંટ્રોલર સાથે LM 35 ઇન્ટરફેસ કરો અને temperature controller નો બ્લોક ડાયાગ્રામ સમજાવો.}

\begin{solutionbox}
Temperature controller system માં temperature sense કરવા, process કરવા અને control કરવા માટે components હોય છે.

\begin{center}
\begin{tikzpicture}[node distance=2.5cm, transform shape, scale=0.8]
    % Interfacing Diagram
    \node [gtu block] (lm35) {LM35\\Sensor};
    \node [gtu block, right=1.5cm of lm35] (adc) {ADC0804};
    \node [gtu block, right=1.5cm of adc] (mcu) {8051};
    \node [gtu block, right=1.5cm of mcu] (relay) {Relay\\Driver};
    \node [gtu block, below=1cm of relay] (load) {Heater/Fan};
    
    \draw [gtu arrow, ->] (lm35) -- node[above] {Analog} (adc);
    \draw [gtu arrow, ->] (adc) -- node[above] {Digital} (mcu);
    \draw [gtu arrow, ->] (mcu) -- (relay);
    \draw [gtu arrow, ->] (relay) -- (load);
    
    \node [below=2cm of adc, font=\bfseries] {Block Diagram};
    
    % Block Diagram Flow
    \node [gtu state, below=3cm of lm35] (s1) {Sensor};
    \node [gtu state, right=1cm of s1] (s2) {ADC};
    \node [gtu state, right=1cm of s2] (s3) {Control};
    \node [gtu state, right=1cm of s3] (s4) {Actuator};
    \node [gtu state, right=1cm of s4] (s5) {Process};
    
    \draw [->, thick] (s1) -- (s2);
    \draw [->, thick] (s2) -- (s3);
    \draw [->, thick] (s3) -- (s4);
    \draw [->, thick] (s4) -- (s5);
    \draw [->, thick] (s5) -- ++(0,-1) -| (s1);
    
\end{tikzpicture}
\captionof{figure}{Temperature Controller}
\end{center}

\textbf{Control Program:}
\begin{lstlisting}
ORG 0000H
MAIN:
    CALL READ_TEMP      ; Read temperature from ADC
    CALL DISPLAY_TEMP   ; Show temperature on display
    CALL TEMP_CONTROL   ; Control heating/cooling
    CALL DELAY          ; Wait before next reading
    SJMP MAIN

READ_TEMP:
    CLR P2.0            ; Start ADC conversion
    SETB P2.0           ; Pulse to start
    JNB P2.1,$          ; Wait for conversion complete
    MOV A,P1            ; Read temperature data
    RET

TEMP_CONTROL:
    CJNE A,#30,CHECK_HIGH   ; Compare with setpoint (30 C)
CHECK_HIGH:
    JC TEMP_LOW             ; If A < 30, temperature is low
    SETB P3.0               ; Turn ON cooling (fan)
    CLR P3.1                ; Turn OFF heating
    RET
TEMP_LOW:
    CLR P3.0                ; Turn OFF cooling
    SETB P3.1               ; Turn ON heating
    RET
END
\end{lstlisting}

\begin{answertable}{System Components}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Component} & \textbf{Function} \\ \hline
\textbf{LM35} & Temperature sensor (10mV/degree C) \\ \hline
\textbf{ADC0804} & Analog to digital converter \\ \hline
\textbf{8051} & Main controller \\ \hline
\textbf{Relay} & High power loads ને switch કરવા \\ \hline
\end{tabulary}
\end{answertable}

\begin{itemize}
    \item \textbf{Temperature Sensing}: LM35 દરેક degree Celsius માટે 10mV output આપે છે.
    \item \textbf{ADC Conversion}: Analog voltage ને digital value માં convert કરે છે.
    \item \textbf{Control Logic}: Setpoint સાથે compare કરીને relay control કરે છે.
    \item \textbf{Feedback System}: સતત monitoring અને adjustment કરે છે.
\end{itemize}

\begin{mnemonicbox}
Sense, Convert, Compare, Control Temperature Automatically
\end{mnemonicbox}
\end{solutionbox}



\end{document}
