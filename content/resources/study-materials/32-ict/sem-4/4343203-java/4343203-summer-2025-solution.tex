\documentclass{article}
% Adjust the relative path to point to the latex-templates directory from:
% content/resources/study-materials/32-ict/sem-4/4343203-java/
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}
\input{../../../../../../latex-templates/gtu-solutions/commands.tex}

\title{Java Programming (4343203) - Summer 2025 Solution}
\date{May 13, 2025}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{List out the rules to name an identifier in Java with valid and invalid examples.}

\begin{solutionbox}
\textbf{Rules for Java Identifiers:}

\begin{center}
\captionof{table}{Identifier Rules}
\begin{tabularx}{\linewidth}{|l|X|l|l|}
\hline
\textbf{Rule} & \textbf{Description} & \textbf{Valid Example} & \textbf{Invalid Example} \\ \hline
Start Character & Must begin with letter, underscore, or dollar sign & \code{name}, \code{\_value}, \code{\$cost} & \code{2name}, \code{\#id} \\ \hline
Following Characters & Can contain letters, digits, underscore, dollar & \code{student123}, \code{user\_name} & \code{my-var}, \code{class@} \\ \hline
Keywords Restriction & Cannot use Java reserved words & \code{myClass}, \code{userName} & \code{class}, \code{int} \\ \hline
Case Sensitivity & Identifiers are case-sensitive & \code{Name} $\neq$ \code{name} & - \\ \hline
Length & No length limit (practically reasonable) & \code{verylongvariablename} & - \\ \hline
\end{tabularx}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LKC: Letters First, Keywords Never, Case Counts}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{List out different types of operators in Java. Explain Arithmetic and Logical Operators in detail.}

\begin{solutionbox}
\textbf{Java Operator Types:}

\begin{center}
\captionof{table}{Operator Types}
\begin{tabularx}{\linewidth}{|l|X|}
\hline
\textbf{Operator Type} & \textbf{Examples} \\ \hline
Arithmetic & \code{+}, \code{-}, \code{*}, \code{/}, \code{\%} \\ \hline
Relational & \code{==}, \code{!=}, \code{<}, \code{>}, \code{<=}, \code{>=} \\ \hline
Logical & \code{\&\&}, \code{||}, \code{!} \\ \hline
Assignment & \code{=}, \code{+=}, \code{-=}, \code{*=}, \code{/=} \\ \hline
Unary & \code{++}, \code{--}, \code{+}, \code{-}, \code{!} \\ \hline
Bitwise & \code{\&}, \code{|}, \code{\textasciicircum}, \code{\textasciitilde}, \code{<<}, \code{>>} \\ \hline
Ternary & \code{condition ? value1 : value2} \\ \hline
\end{tabularx}
\end{center}

\textbf{Arithmetic Operators:}
\begin{itemize}
    \item \keyword{Addition (+)}: Adds two operands
    \item \keyword{Subtraction (-)}: Subtracts second from first
    \item \keyword{Multiplication (*)}: Multiplies two operands
    \item \keyword{Division (/)}: Divides first by second
    \item \keyword{Modulus (\%)}: Returns remainder of division
\end{itemize}

\textbf{Logical Operators:}
\begin{itemize}
    \item \keyword{AND (\&\&)}: Returns true if both conditions are true
    \item \keyword{OR (||)}: Returns true if at least one condition is true
    \item \keyword{NOT (!)}: Reverses the logical state
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{AMDR-AON: Add Subtract Multiply Divide Remainder, And Or Not}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Write a program in Java to reverse the digits of a number for number having three digits. Like reverse of 653 is 356.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Reverse Digits Program}]
import java.util.Scanner;

public class ReverseNumber {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        System.out.print("Enter 3-digit number: ");
        int num = sc.nextInt();
        
        int reverse = 0;
        int temp = num;
        
        while (temp > 0) {
            reverse = reverse * 10 + temp % 10;
            temp = temp / 10;
        }
        
        System.out.println("Original: " + num);
        System.out.println("Reversed: " + reverse);
    }
}
\end{lstlisting}

\textbf{Algorithm:}
\begin{itemize}
    \item \keyword{Extract last digit}: Use modulus operator (\%)
    \item \keyword{Build reversed number}: Multiply by 10 and add digit
    \item \keyword{Remove last digit}: Use integer division (/)
    \item \keyword{Repeat}: Until original number becomes 0
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EBRR: Extract, Build, Remove, Repeat}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Write a program in Java to add two 3*3 matrices.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Matrix Addition}]
import java.util.Scanner;

public class MatrixAddition {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] matrix1 = new int[3][3];
        int[][] matrix2 = new int[3][3];
        int[][] result = new int[3][3];
        
        // Input first matrix
        System.out.println("Enter first matrix:");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix1[i][j] = sc.nextInt();
            }
        }
        
        // Input second matrix
        System.out.println("Enter second matrix:");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix2[i][j] = sc.nextInt();
            }
        }
        
        // Add matrices
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                result[i][j] = matrix1[i][j] + matrix2[i][j];
            }
        }
        
        // Display result
        System.out.println("Sum of matrices:");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(result[i][j] + " ");
            }
            System.out.println();
        }
    }
}
\end{lstlisting}

\textbf{Matrix Addition Steps:}
\begin{itemize}
    \item \keyword{Create arrays}: Three 3x3 integer arrays
    \item \keyword{Input matrices}: Read values for both matrices
    \item \keyword{Add corresponding elements}: \code{result[i][j] = matrix1[i][j] + matrix2[i][j]}
    \item \keyword{Display result}: Print the sum matrix
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CIAD: Create, Input, Add, Display}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{Write a program in Java that shows the use of parameterized Constructor.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Parameterized Constructor}]
class Student {
    private String name;
    private int rollNo;
    
    // Parameterized Constructor
    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }
    
    public void display() {
        System.out.println("Name: " + name);
        System.out.println("Roll No: " + rollNo);
    }
}

public class ParameterizedConstructor {
    public static void main(String[] args) {
        Student s1 = new Student("John", 101);
        s1.display();
    }
}
\end{lstlisting}

\textbf{Parameterized Constructor Features:}
\begin{itemize}
    \item \keyword{Takes parameters}: Accepts values during object creation
    \item \keyword{Initializes instance variables}: Sets object state
    \item \keyword{Same name as class}: Constructor name matches class name
    \item \keyword{No return type}: Constructors don't have return type
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PISN: Parameters Initialize Same-name No-return}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Give the basic syntax of the following terms with an example: (1) To create a Class, (2) To create an Object, (3) To define a Method, (4) To declare a Variable.}

\begin{solutionbox}
\textbf{Java Basic Syntax:}

\begin{center}
\captionof{table}{Syntax Examples}
\begin{tabularx}{\linewidth}{|l|X|l|}
\hline
\textbf{Component} & \textbf{Syntax} & \textbf{Example} \\ \hline
Class Creation & \code{class ClassName \{ \}} & \code{class Car \{ \}} \\ \hline
Object Creation & \code{ClassName obj = new ClassName();} & \code{Car car = new Car();} \\ \hline
Method Definition & \code{returnType method(params) \{ \}} & \code{void start() \{ \}} \\ \hline
Variable Decl. & \code{dataType variableName;} & \code{int age;} \\ \hline
\end{tabularx}
\end{center}

\begin{lstlisting}[language=Java,caption={Complete Syntax Example}]
class Car {                           // Class Creation
    int speed;                        // Variable Declaration
    
    public void accelerate() {        // Method Definition
        speed += 10;
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();        // Object Creation
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{COMV: Class Object Method Variable}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Write a program in Java which has a class Student having two instance variables enrollmentNo and name. Create 3 objects of Student class in main method and display student's name.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Student Class Example}]
class Student {
    String enrollmentNo;
    String name;
    
    // Constructor to initialize student data
    public Student(String enrollmentNo, String name) {
        this.enrollmentNo = enrollmentNo;
        this.name = name;
    }
    
    // Method to display student name
    public void displayName() {
        System.out.println("Student Name: " + name);
    }
}

public class StudentDemo {
    public static void main(String[] args) {
        // Creating 3 objects of Student class
        Student s1 = new Student("CS001", "Alice");
        Student s2 = new Student("CS002", "Bob");
        Student s3 = new Student("CS003", "Charlie");
        
        // Displaying student names
        s1.displayName();
        s2.displayName();
        s3.displayName();
    }
}
\end{lstlisting}

\textbf{Program Structure:}
\begin{itemize}
    \item \keyword{Class definition}: Student class with instance variables
    \item \keyword{Constructor}: Initialize enrollmentNo and name
    \item \keyword{Method}: \code{displayName()} to show student name
    \item \keyword{Object creation}: Three Student objects in main method
    \item \keyword{Method calling}: Display names using \code{displayName()}
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DID-CC: Define Initialize Display Create Call}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{Write a program in Java that shows the use of Default Constructor.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Default Constructor}]
class Rectangle {
    int length;
    int width;
    
    // Default Constructor
    public Rectangle() {
        length = 5;
        width = 3;
        System.out.println("Default constructor called");
    }
    
    public void displayArea() {
        System.out.println("Area: " + (length * width));
    }
}

public class DefaultConstructor {
    public static void main(String[] args) {
        Rectangle r1 = new Rectangle();
        r1.displayArea();
    }
}
\end{lstlisting}

\textbf{Default Constructor Features:}
\begin{itemize}
    \item \keyword{No parameters}: Takes no arguments
    \item \keyword{Default values}: Sets default values for instance variables
    \item \keyword{Automatic call}: Called when object is created
    \item \keyword{Same name as class}: Constructor name matches class name
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NDAS: No-parameters Default Automatic Same-name}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{Give four Difference between Procedure Oriented Programming and Object-Oriented Programming.}

\begin{solutionbox}
\textbf{POP vs OOP Comparison:}

\begin{center}
\captionof{table}{POP vs OOP}
\begin{tabularx}{\linewidth}{|l|X|X|}
\hline
\textbf{Aspect} & \textbf{POP} & \textbf{OOP} \\ \hline
Approach & Top-down approach & Bottom-up approach \\ \hline
Focus & Functions and procedures & Objects and classes \\ \hline
Data Security & No data hiding, global access & Data encapsulation and hiding \\ \hline
Problem Solving & Divide into functions & Divide into objects \\ \hline
Code Reusability & Limited reusability & High reusability (Inheritance) \\ \hline
Maintenance & Difficult to maintain & Easy to maintain and modify \\ \hline
\end{tabularx}
\end{center}

\textbf{Key Differences:}
\begin{itemize}
    \item \keyword{Structure}: POP uses functions, OOP uses classes
    \item \keyword{Security}: OOP provides better data protection
    \item \keyword{Reusability}: OOP supports inheritance and polymorphism
    \item \keyword{Maintenance}: OOP code is easier to maintain
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SSRM: Structure Security Reusability Maintenance}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Write a program in Java which has a class Shape having 2 overloaded methods area (float radius) and area (float length, float width). Display the area of circle and rectangle using overloaded methods.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Method Overloading}]
class Shape {
    // Method to calculate area of circle
    public void area(float radius) {
        float circleArea = 3.14f * radius * radius;
        System.out.println("Area of Circle: " + circleArea);
    }
    
    // Overloaded method to calculate area of rectangle
    public void area(float length, float width) {
        float rectangleArea = length * width;
        System.out.println("Area of Rectangle: " + rectangleArea);
    }
}

public class MethodOverloading {
    public static void main(String[] args) {
        Shape shape = new Shape();
        
        // Calculate area of circle with radius 5
        shape.area(5.0f);
        
        // Calculate area of rectangle with length 4 and width 6
        shape.area(4.0f, 6.0f);
    }
}
\end{lstlisting}

\textbf{Method Overloading Concepts:}
\begin{itemize}
    \item \keyword{Same method name}: Both methods named \code{area}
    \item \keyword{Different parameters}: One takes radius, other takes length and width
    \item \keyword{Compile-time polymorphism}: Method selected at compile time
    \item \keyword{Parameter differentiation}: Different number or type of parameters
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SDCP: Same-name Different-params Compile-time Params-diff}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Write a program in Java to demonstrate single inheritance.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Single Inheritance}]
// Parent class
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
    
    public void sleep() {
        System.out.println("Animal is sleeping");
    }
}

// Child class inheriting from Animal
class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class SingleInheritance {
    public static void main(String[] args) {
        Dog dog = new Dog();
        
        // Inherited methods from Animal class
        dog.eat();
        dog.sleep();
        
        // Own method of Dog class
        dog.bark();
    }
}
\end{lstlisting}

\textbf{Single Inheritance Features:}
\begin{itemize}
    \item \keyword{One parent}: Child class inherits from one parent class
    \item \keyword{extends keyword}: Used to establish inheritance relationship
    \item \keyword{Method inheritance}: Child class inherits parent methods
    \item \keyword{IS-A relationship}: Dog IS-A Animal
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{OEMI: One-parent Extends Method IS-A}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Define abstract class in JAVA with example.}

\begin{solutionbox}
An abstract class is a class that cannot be instantiated and may contain abstract methods (methods without implementation).

\begin{lstlisting}[language=Java,caption={Abstract Class Example}]
// Abstract class
abstract class Vehicle {
    String brand;
    
    // Regular method
    public void displayBrand() {
        System.out.println("Brand: " + brand);
    }
    
    // Abstract method (no implementation)
    public abstract void start();
    public abstract void stop();
}

// Concrete class extending abstract class
class Car extends Vehicle {
    public Car(String brand) {
        this.brand = brand;
    }
    
    // Must implement abstract methods
    public void start() {
        System.out.println("Car started with key");
    }
    
    public void stop() {
        System.out.println("Car stopped with brake");
    }
}

public class AbstractDemo {
    public static void main(String[] args) {
        Car car = new Car("Toyota");
        car.displayBrand();
        car.start();
        car.stop();
    }
}
\end{lstlisting}

\textbf{Abstract Class Features:}
\begin{itemize}
    \item \keyword{Cannot instantiate}: Cannot create objects directly
    \item \keyword{Abstract methods}: Methods without body
    \item \keyword{Concrete methods}: Regular methods with implementation
    \item \keyword{Must extend}: Child classes must implement abstract methods
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CACM: Cannot-instantiate Abstract Concrete Must-extend}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Write a program in Java to implement multiple inheritance using interfaces.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Multiple Inheritance with Interfaces}]
// First interface
interface Flyable {
    void fly();
}

// Second interface  
interface Swimmable {
    void swim();
}

// Class implementing multiple interfaces
class Duck implements Flyable, Swimmable {
    private String name;
    
    public Duck(String name) {
        this.name = name;
    }
    
    // Implementing fly method
    public void fly() {
        System.out.println(name + " is flying in the sky");
    }
    
    // Implementing swim method
    public void swim() {
        System.out.println(name + " is swimming in water");
    }
    
    public void walk() {
        System.out.println(name + " is walking on land");
    }
}

public class MultipleInheritance {
    public static void main(String[] args) {
        Duck duck = new Duck("Donald");
        
        // Methods from interfaces
        duck.fly();
        duck.swim();
        
        // Own method
        duck.walk();
    }
}
\end{lstlisting}

\textbf{Multiple Inheritance via Interfaces:}
\begin{itemize}
    \item \keyword{Multiple interfaces}: Class can implement multiple interfaces
    \item \keyword{implements keyword}: Used to implement interfaces
    \item \keyword{Must implement all}: All interface methods must be implemented
    \item \keyword{Solves diamond problem}: Avoids ambiguity of multiple inheritance
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MIMS: Multiple Implements Must-implement Solves-diamond}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{Write a program in Java to demonstrate multilevel inheritance.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Multilevel Inheritance}]
// Grandparent class
class Animal {
    public void breathe() {
        System.out.println("Animal is breathing");
    }
}

// Parent class inheriting from Animal
class Mammal extends Animal {
    public void giveBirth() {
        System.out.println("Mammal gives birth to babies");
    }
}

// Child class inheriting from Mammal
class Dog extends Mammal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class MultilevelInheritance {
    public static void main(String[] args) {
        Dog dog = new Dog();
        
        // Method from Animal class (grandparent)
        dog.breathe();
        
        // Method from Mammal class (parent)
        dog.giveBirth();
        
        // Own method of Dog class
        dog.bark();
    }
}
\end{lstlisting}

\textbf{Multilevel Inheritance Features:}
\begin{itemize}
    \item \keyword{Chain of inheritance}: Child $\rightarrow$ Parent $\rightarrow$ Grandparent
    \item \keyword{Multiple levels}: More than two levels of inheritance
    \item \keyword{Transitive inheritance}: Properties passed through levels
    \item \keyword{extends keyword}: Each level uses extends
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CMTE: Chain Multiple Transitive Extends}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Define package and write the syntax to create a package with example.}

\begin{solutionbox}
A package is a namespace that organizes related classes and interfaces, providing access protection and namespace management.

\textbf{Syntax:} \code{package packageName;}

\begin{lstlisting}[language=Java,caption={Package Implementation}]
// File: mypackage/Calculator.java
package mypackage;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int subtract(int a, int b) {
        return a - b;
    }
}

// File: TestCalculator.java
import mypackage.Calculator;

class TestCalculator {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println("Sum: " + calc.add(10, 5));
    }
}
\end{lstlisting}

\textbf{Package Benefits:}
\begin{itemize}
    \item \keyword{Namespace management}: Avoids naming conflicts
    \item \keyword{Access control}: Controls class visibility
    \item \keyword{Code organization}: Groups related classes
    \item \keyword{Reusability}: Easy to reuse packaged classes
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NAOR: Namespace Access Organization Reusability}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{Write a program in Java to demonstrate method overriding.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Method Overriding}]
// Parent class
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
    public void move() {
        System.out.println("Animal moves");
    }
}

// Child class overriding parent methods
class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks: Woof!");
    }
    
    @Override
    public void move() {
        System.out.println("Dog runs on four legs");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows: Meow!");
    }
    
    @Override
    public void move() {
        System.out.println("Cat walks silently");
    }
}

public class MethodOverriding {
    public static void main(String[] args) {
        Animal animal;
        
        animal = new Dog();
        animal.makeSound();  // Calls Dog's method
        
        animal = new Cat();
        animal.makeSound();  // Calls Cat's method
    }
}
\end{lstlisting}

\textbf{Method Overriding Features:}
\begin{itemize}
    \item \keyword{Same method signature}: Same name, parameters, and return type
    \item \keyword{Runtime polymorphism}: Method decided at runtime
    \item \keyword{@Override annotation}: Optional but recommended
    \item \keyword{IS-A relationship}: Child class overrides parent method
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SROI: Same-signature Runtime Override IS-A}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{List and explain different types of errors in Java.}

\begin{solutionbox}
\textbf{Java Error Types:}

\begin{center}
\captionof{table}{Error Types}
\begin{tabularx}{\linewidth}{|l|X|}
\hline
\textbf{Error Type} & \textbf{Description} \\ \hline
Compile-time & Detected during compilation (Syntax errors, missing semicolons) \\ \hline
Runtime & Occur during program execution (Division by zero, null pointer) \\ \hline
Logical & Program runs but gives wrong output (Incorrect algorithm logic) \\ \hline
\end{tabularx}
\end{center}

\begin{itemize}
    \item \keyword{Compile-time}: Prevented by compiler, must fix before running
    \item \keyword{Runtime}: Program crashes during execution, handled by exceptions
    \item \keyword{Logical}: Hardest to find, program works but results are incorrect
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CRL: Compile Runtime Logic}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{What is wrapper class? Explain use of any two wrapper class.}

\begin{solutionbox}
Wrapper classes provide object representation of primitive data types, converting primitives into objects.

\begin{center}
\captionof{table}{Wrapper Classes}
\begin{tabular}{|l|l|}
\hline
\textbf{Primitive} & \textbf{Wrapper Class} \\ \hline
int & Integer \\ \hline
double & Double \\ \hline
boolean & Boolean \\ \hline
char & Character \\ \hline
\end{tabular}
\end{center}

\begin{lstlisting}[language=Java,caption={Wrapper Class Usage}]
// Integer Wrapper
int num = 100;
Integer intObj = Integer.valueOf(num);  // Boxing
int value = intObj.intValue();          // Unboxing
int parsed = Integer.parseInt("123");   // Parsing

// Double Wrapper
Double doubleObj = Double.valueOf(45.67);
double val = Double.parseDouble("123.45");
boolean isNaN = Double.isNaN(doubleObj);
\end{lstlisting}

\textbf{Wrapper Class Uses:}
\begin{itemize}
    \item \keyword{Collections}: Store primitives in collections
    \item \keyword{Null values}: Can store null unlike primitives
    \item \keyword{Utility methods}: Parsing, conversion methods
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CNUG: Collections Null Utility Generics}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Write a program in Java to develop Banking Application in which user deposits the amount Rs 25000 and then start withdrawing of Rs 20000, Rs 4000 and it throws exception "Not Sufficient Fund" when user withdraws Rs. 2000 thereafter.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Banking Application with Exception}]
// Custom Exception class
class InsufficientFundException extends Exception {
    public InsufficientFundException(String message) {
        super(message);
    }
}

// Bank Account class
class BankAccount {
    private double balance;
    
    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }
    
    public void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited: Rs." + amount);
        System.out.println("Current Balance: Rs." + balance);
    }
    
    public void withdraw(double amount) throws InsufficientFundException {
        if (amount > balance) {
            throw new InsufficientFundException("Not Sufficient Fund");
        }
        balance -= amount;
        System.out.println("Withdrawn: Rs." + amount);
        System.out.println("Remaining Balance: Rs." + balance);
    }
    
    public double getBalance() { return balance; }
}

public class BankingApplication {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(0);
        
        try {
            account.deposit(25000);
            account.withdraw(20000);
            account.withdraw(4000);
            // This will throw exception
            account.withdraw(2000);
            
        } catch (InsufficientFundException e) {
            System.out.println("Exception: " + e.getMessage());
            System.out.println("Available Balance: Rs." + account.getBalance());
        }
    }
}
\end{lstlisting}

\textbf{Exception Handling Components:}
\begin{itemize}
    \item \keyword{Custom Exception}: \code{InsufficientFundException} extends \code{Exception}
    \item \keyword{throw keyword}: Throws exception when balance insufficient
    \item \keyword{try-catch}: Handles the exception to prevent crash
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CTTM: Custom Throw Try-catch Message}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{Describe the complete lifecycle of a thread.}

\begin{solutionbox}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (new) {New};
    \node [gtu state, right=of new] (runnable) {Runnable};
    \node [gtu state, right=of runnable] (running) {Running};
    \node [gtu state, below=of running] (blocked) {Blocked};
    \node [gtu state, right=of running] (dead) {Dead};

    \path [gtu arrow] (new) -- node[font=\tiny] {start()} (runnable);
    \path [gtu arrow] (runnable) -- node[font=\tiny] {scheduler} (running);
    \path [gtu arrow] (running) -- node[font=\tiny] {yield} (runnable);
    \path [gtu arrow] (running) -- node[font=\tiny, left] {wait/sleep} (blocked);
    \path [gtu arrow] (blocked) -| node[font=\tiny, near start] {notify/timeout} (runnable);
    \path [gtu arrow] (running) -- node[font=\tiny] {end} (dead);
\end{tikzpicture}
\captionof{figure}{Thread Lifecycle}
\end{center}

\textbf{Thread States:}
\begin{itemize}
    \item \keyword{New}: Thread created but not started
    \item \keyword{Runnable}: Ready to run, waiting for CPU
    \item \keyword{Running}: Currently executing
    \item \keyword{Blocked}: Waiting for resource or condition
    \item \keyword{Dead}: Execution completed
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NRRBD: New Runnable Running Blocked Dead}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{List access specifiers and describe their purpose in JAVA.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Access Specifiers}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Specifier} & \textbf{Class} & \textbf{Package} & \textbf{Subclass} & \textbf{World} \\ \hline
private & $\checkmark$ & $\times$ & $\times$ & $\times$ \\ \hline
default & $\checkmark$ & $\checkmark$ & $\times$ & $\times$ \\ \hline
protected & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\times$ \\ \hline
public & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ \\ \hline
\end{tabular}
\end{center}

\begin{itemize}
    \item \keyword{Private}: Encapsulates data within class
    \item \keyword{Default}: Package-private access (no keyword)
    \item \keyword{Protected}: Package + Inheritance access
    \item \keyword{Public}: Universal access for APIs
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PDPP: Private Default Protected Public}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{Write a program that executes two threads. One thread displays ``Thread1'' every 1000 milliseconds, and the other displays ``Thread2'' every 2000 milliseconds. Create the threads by extending the Thread class.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={Multithreading Example}]
class Thread1 extends Thread {
    public void run() {
        try {
            for (int i = 1; i <= 10; i++) {
                System.out.println("Thread1 - Count: " + i);
                Thread.sleep(1000); // 1000ms delay
            }
        } catch (InterruptedException e) {
            System.out.println("Thread1 interrupted");
        }
    }
}

class Thread2 extends Thread {
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Thread2 - Count: " + i);
                Thread.sleep(2000); // 2000ms delay
            }
        } catch (InterruptedException e) {
            System.out.println("Thread2 interrupted");
        }
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        Thread1 t1 = new Thread1();
        Thread2 t2 = new Thread2();
        
        System.out.println("Starting threads...");
        t1.start();
        t2.start();
        
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            System.out.println("Main interrupted");
        }
        System.out.println("Done");
    }
}
\end{lstlisting}

\textbf{Multithreading Concepts:}
\begin{itemize}
    \item \keyword{Thread class extension}: Both classes extend \code{Thread}
    \item \keyword{run()}: Contains execution logic
    \item \keyword{sleep()}: Pauses thread for specified milliseconds
    \item \keyword{start()}: Begins execution
    \item \keyword{join()}: Waits for thread completion
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ERSSJ: Extend Run Sleep Start Join}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{What is stream class? How are the stream classes classified?}

\begin{solutionbox}
Stream classes represent a flow of data from source to destination.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu class] (S) {Stream Classes};
    \node [gtu class, below left=of S] (I) {Input};
    \node [gtu class, below right=of S] (O) {Output};
    
    \node [gtu class, below left=1cm and -1cm of I] (IB) {Byte};
    \node [gtu class, below right=1cm and -1cm of I] (IC) {Char};
    
    \node [gtu class, below left=1cm and -1cm of O] (OB) {Byte};
    \node [gtu class, below right=1cm and -1cm of O] (OC) {Char};
    
    \path [gtu arrow] (S) -- (I);
    \path [gtu arrow] (S) -- (O);
    \path [gtu arrow] (I) -- (IB);
    \path [gtu arrow] (I) -- (IC);
    \path [gtu arrow] (O) -- (OB);
    \path [gtu arrow] (O) -- (OC);
\end{tikzpicture}
\captionof{figure}{Stream Classification}
\end{center}

\textbf{Stream Types:}
\begin{center}
\begin{tabularx}{\linewidth}{|l|X|X|}
\hline
\textbf{Type} & \textbf{Purpose} & \textbf{Examples} \\ \hline
Input & Read data & FileInputStream, Reader \\ \hline
Output & Write data & FileOutputStream, Writer \\ \hline
Byte & 8-bit bytes & InputStream, OutputStream \\ \hline
Char & 16-bit unicode & Reader, Writer \\ \hline
\end{tabularx}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DDF: Direction Data-type Functionality}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Illustrate purpose of method overriding with example.}

\begin{solutionbox}
Method overriding allows a subclass to provide specific implementation of a method defined in its parent class, enabling runtime polymorphism.

\begin{lstlisting}[language=Java,caption={Method Overriding Purpose}]
class Shape {
    public void draw() {
        System.out.println("Drawing generic shape");
    }
}

class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing circle");
    }
}

class Rectangle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing rectangle");
    }
}

public class Demo {
    public static void main(String[] args) {
        Shape s;
        s = new Circle();
        s.draw(); // Calls Circle's draw
        
        s = new Rectangle();
        s.draw(); // Calls Rectangle's draw
    }
}
\end{lstlisting}

\textbf{Benefits:}
\begin{itemize}
    \item \keyword{Runtime polymorphism}: Method selection at runtime
    \item \keyword{Specific implementation}: Customized behavior for subclasses
    \item \keyword{Code flexibility}: Common interface, different implementations
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RSFD: Runtime Specific Flexibility Dynamic}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Write a program in Java to perform read and write operations on a Text file named Abc.txt.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={File Read/Write Operations}]
import java.io.*;

public class FileOperations {
    public static void main(String[] args) {
        String fileName = "Abc.txt";
        
        // Write Operation
        try {
            FileWriter writer = new FileWriter(fileName);
            writer.write("Hello, this is Java file handling.\n");
            writer.write("End of file content.");
            writer.close();
            System.out.println("Data written successfully.");
        } catch (IOException e) {
            System.out.println("Write error: " + e.getMessage());
        }
        
        // Read Operation
        try {
            FileReader reader = new FileReader(fileName);
            BufferedReader buffReader = new BufferedReader(reader);
            
            String line;
            System.out.println("Reading from file:");
            while ((line = buffReader.readLine()) != null) {
                System.out.println(line);
            }
            buffReader.close();
            reader.close();
        } catch (IOException e) {
            System.out.println("Read error: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\textbf{File Operation Steps:}
\begin{itemize}
    \item \keyword{Create stream}: \code{FileWriter} or \code{FileReader}
    \item \keyword{Perform operation}: \code{write()} or \code{readLine()}
    \item \keyword{Handle exceptions}: \code{try-catch} blocks for IOException
    \item \keyword{Close resources}: \code{close()} to prevent leaks
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CPHC: Create Perform Handle Close}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{Explain InputStream.}

\begin{solutionbox}
InputStream is an abstract class representing an input stream of bytes.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu class] (IS) {InputStream};
    \node [gtu class, below left=of IS] (FIS) {FileInputStream};
    \node [gtu class, below=of IS] (BAIS) {ByteArrayInput};
    \node [gtu class, below right=of IS] (Filter) {FilterInput};
    \node [gtu class, below left=1cm of Filter] (Buf) {Buffered};
    \node [gtu class, below right=1cm of Filter] (Data) {Data};
    
    \path [gtu arrow] (FIS) -- (IS);
    \path [gtu arrow] (BAIS) -- (IS);
    \path [gtu arrow] (Filter) -- (IS);
    \path [gtu arrow] (Buf) -- (Filter);
    \path [gtu arrow] (Data) -- (Filter);
\end{tikzpicture}
\captionof{figure}{InputStream Hierarchy}
\end{center}

\textbf{Common Methods:}
\begin{itemize}
    \item \code{read()}: Reads single byte
    \item \code{read(byte[])}: Reads bytes into array
    \item \code{close()}: Closes the stream
    \item \code{available()}: Returns estimated available bytes
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ABIR: Abstract Byte Input Resource}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{Define package in JAVA. Write how package can be implemented in Java with proper syntax and one example.}

\begin{solutionbox}
A package is a namespace organizing related classes.

\textbf{Steps to Implement:}
\begin{itemize}
    \item \keyword{Create directory}: Folder matching package name
    \item \keyword{Declare package}: \code{package name;} as first line
    \item \keyword{Compile}: Use \code{javac -d . File.java}
    \item \keyword{Run}: Use \code{java package.File}
\end{itemize}

\begin{lstlisting}[language=Java,caption={Package Syntax Example}]
// File: utilities/MathOps.java
package utilities;

public class MathOps {
    public static int add(int a, int b) {
        return a + b;
    }
}

// File: Test.java
import utilities.MathOps;

public class Test {
    public static void main(String[] args) {
        System.out.println(MathOps.add(5, 10));
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NAOR: Namespace Access Organization Reusability}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{Write a program in Java to demonstrate use of List. 1) Create ArrayList and add weekdays (in string form), 2) Create LinkedList and add months (in string form). Display both List.}

\begin{solutionbox}
\begin{lstlisting}[language=Java,caption={List Demonstration}]
import java.util.*;

public class ListDemo {
    public static void main(String[] args) {
        // 1. ArrayList for Weekdays
        ArrayList<String> weekdays = new ArrayList<>();
        weekdays.add("Monday");
        weekdays.add("Tuesday");
        weekdays.add("Wednesday");
        
        System.out.println("Weekdays (ArrayList):");
        for(String day : weekdays) {
            System.out.println(day);
        }
        
        // 2. LinkedList for Months
        LinkedList<String> months = new LinkedList<>();
        months.add("January");
        months.add("February");
        months.add("March");
        
        System.out.println("\nMonths (LinkedList):");
        for(String month : months) {
            System.out.println(month);
        }
        
        // Operations
        System.out.println("\nFirst Month: " + months.getFirst());
        System.out.println("ArrayList Size: " + weekdays.size());
    }
}
\end{lstlisting}

\textbf{List Features:}
\begin{center}
\captionof{table}{ArrayList vs LinkedList}
\begin{tabularx}{\linewidth}{|l|X|X|}
\hline
\textbf{Feature} & \textbf{ArrayList} & \textbf{LinkedList} \\ \hline
Structure & Dynamic Array & Doubly Linked List \\ \hline
Access & Fast O(1) & Slow O(n) \\ \hline
Insert/Delete & Slow (Shift needed) & Fast (Ptr change) \\ \hline
\end{tabularx}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DODI: Dynamic Ordered Duplicate Index-based}
\end{mnemonicbox}

\end{document}
