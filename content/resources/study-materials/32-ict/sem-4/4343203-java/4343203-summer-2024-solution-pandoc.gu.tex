\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4343203 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{જાવામાં Garbage collection સમજાવો.}

\begin{solutionbox}
જાવામાં Garbage collection વણવપરાયેલા ઓબ્જેક્ટ્સને દૂર કરીને આપમેળે
મેમરી ખાલી કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Garbage Collection પ્રક્રિયા}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
તબક્કો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Mark & JVM મેમરીમાં બધા live ઓબ્જેક્ટ્સને ઓળખે છે \\
Sweep & વણવપરાયેલા ઓબ્જેક્ટ્સ દૂર કરવામાં આવે છે \\
Compact & બાકીના ઓબ્જેક્ટ્સને જગ્યા ખાલી કરવા માટે પુનર્ગઠિત કરવામાં આવે છે \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{આપમેળે}: મેન્યુઅલ મેમરી મેનેજમેન્ટની જરૂર નથી
\item
  \textbf{બેકગ્રાઉન્ડ}: અલગ ઓછી પ્રાથમિકતાવાળા થ્રેડમાં ચાલે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``MSC: Mark-Sweep-Compact આપમેળે મેમરી ખાલી કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{JVM ને વિગતવાર સમજાવો.}

\begin{solutionbox}
JVM (Java Virtual Machine) એક વર્ચ્યુઅલ મશીન છે જે bytecode ને
મશીન કોડમાં રૂપાંતરિત કરીને જાવાની પ્લેટફોર્મ સ્વતંત્રતા આપે છે.

\textbf{આકૃતિ: JVM આર્કિટેક્ચર}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-19613ee3.pdf}

\begin{itemize}
\tightlist
\item
  \textbf{પ્લેટફોર્મ સ્વતંત્રતા}: એકવાર લખો, બધે ચલાવો
\item
  \textbf{સુરક્ષા}: Bytecode વેરિફિકેશન ખતરનાક કામગીરીને રોકે છે
\item
  \textbf{ઓપ્ટિમાઈઝેશન}: Just-in-time કમ્પાઈલેશન કામગીરી સુધારે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CLASS: Class Loader સુરક્ષિત સિસ્ટમ સંચાલન કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{Fibonacci series પ્રિન્ટ કરવા માટેનો જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}
Fibonacci series એવી શ્રેણી બનાવે છે જેમાં દરેક સંખ્યા તેના અગાઉની
બે સંખ્યાઓનો સરવાળો હોય.

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
import java.util.Scanner;

public class FibonacciSeries {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print("Enter number of terms: ");
        int n = input.nextInt();
        
        int first = 0, second = 1;
        
        System.out.print("Fibonacci Series: ");
        
for (int

i = 1; i <= n; i++) {

            System.out.print(first + " ");
            
            int next = first + second;
            first = second;
            second = next;
        }
        
        input.close();
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રારંભિક}: 0 અને 1 થી શરૂઆત કરો
\item
  \textbf{લૂપ}: શ્રેણી બનાવવા માટે N વખત પુનરાવર્તન કરો
\item
  \textbf{ગણતરી}: દરેક સંખ્યા પાછલી બે સંખ્યાનો સરવાળો છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FSN: પ્રથમ + બીજી = આગળની સંખ્યા શ્રેણીમાં''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{કમાન્ડ લાઇન arguments નો ઉપયોગ કરીને કોઈપણ દસ સંખ્યાઓ માંથી ન્યૂનતમ
શોધવા માટે જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}
કમાન્ડ લાઇન આર્ગ્યુમેન્ટ્સ જાવા પ્રોગ્રામ ચલાવતી વખતે સીધા ઇનપુટ
આપવાની સુવિધા આપે છે.

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class FindMinimum {
    public static void main(String[] args) {
        if (args.length < 10) {
            System.out.println("Please provide 10 numbers");
            return;
        }
        
        int min = Integer.parseInt(args[0]);
        
        for (int i = 1; i < 10; i++) {
            int current = Integer.parseInt(args[i]);
            if (current < min) {
                min = current;
            }
        }
        
        System.out.println("Minimum number is: " + min);
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{આર્ગ્યુમેન્ટ્સ પારસિંગ}: સ્ટ્રિંગ આર્ગ્યુમેન્ટ્સને ઇન્ટીજરમાં રૂપાંતરિત કરો
\item
  \textbf{પ્રારંભિક}: પ્રથમ સંખ્યાને ન્યૂનતમ તરીકે સેટ કરો
\item
  \textbf{તુલના}: દરેક સંખ્યાને વર્તમાન ન્યૂનતમ સાથે ચકાસો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ICU: શરૂઆત, ચકાસણી, અપડેટ ન્યૂનતમ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{Java OOP ના મૂળભૂત ખ્યાલોની યાદી બનાવો. કોઈપણ એક વિગતવાર સમજાવો.}

\begin{solutionbox}
જાવા ઓબ્જેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગ વાસ્તવિક દુનિયાની વસ્તુઓને મોડેલિંગ
કરવા માટે મૂળભૂત સિદ્ધાંતો પર આધારિત છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{જાવામાં OOP ખ્યાલો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ખ્યાલ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Encapsulation & ડેટા અને મેથડને એક એકમ તરીકે જોડવું \\
Inheritance & હાલના class માંથી નવા class બનાવવા \\
Polymorphism & એક ઇન્ટરફેસ, વિવિધ અમલીકરણો \\
Abstraction & અમલીકરણની વિગતો છુપાવવી, કાર્યક્ષમતા બતાવવી \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Encapsulation}: એક્સેસ કંટ્રોલ દ્વારા ડેટાનું રક્ષણ કરે છે
\item
  \textbf{ડેટા છુપાવવો}: ખાનગી વેરિયેબલ્સ મેથડ્સ દ્વારા એક્સેસ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PEAI: પ્રોગ્રામિંગ Encapsulates Abstracts Inherits''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{final કી-વર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
જાવામાં final કી-વર્ડ ફેરફાર, વારસો અને ઓવરરાઇડિંગને મર્યાદિત
કરવા માટે વપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{final કી-વર્ડના ઉપયોગો}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઉપયોગ & અસર & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
final variable & બદલી શકાતું નથી &
\passthrough{\lstinline!final int MAX = 100;!} \\
final method & ઓવરરાઇડ કરી શકાતી નથી &
\passthrough{\lstinline!final void display() \{\}!} \\
final class & વારસામાં લઈ શકાતો નથી &
\passthrough{\lstinline!final class Math \{\}!} \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class FinalDemo {
    final int MAX_VALUE = 100;  // નિયતાંક
    
    final void display() {
        System.out.println("This method cannot be overridden");
    }
}

final class MathOperations {
    // આ class નો વારસો મળી શકતો નથી
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``VCM: Variables Constants Methods બદલી શકાતા નથી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{કન્સ્ટ્રક્ટર શું છે? Parameterized કન્સ્ટ્રક્ટર ને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
કન્સ્ટ્રક્ટર એ ઓબ્જેક્ટ બનાવતી વખતે તેને શરૂઆતી મૂલ્યો આપવા માટેની વિશેષ
મેથડ છે.

\textbf{આકૃતિ: કન્સ્ટ્રક્ટરના પ્રકારો}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-f17d38c4.pdf}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class Student {
    String name;
    int age;
    
    // Parameterized constructor
    Student(String n, int a) {
        name = n;
        age = a;
    }
    
    void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
    
    public static void main(String[] args) {
        // Object creation using parameterized constructor
        Student s1 = new Student("John", 20);
        s1.display();
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{પેરામીટર્સ}: ઓબ્જેક્ટ બનાવતી વખતે કિંમતો સ્વીકારે છે
\item
  \textbf{પ્રારંભિક}: પાસ કરેલા મૂલ્યો સાથે ઓબ્જેક્ટ પ્રોપર્ટી સેટ કરે છે
\item
  \textbf{ઓવરલોડિંગ}: અલગ અલગ પેરામીટર્સ સાથે ઘણા કન્સ્ટ્રક્ટર્સ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SPO: વિદ્યાર્થી પેરામીટર્સ ઓબ્જેક્ટ પ્રોપર્ટી શરૂ કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{ઉદાહરણ સાથે જાવા પ્રોગ્રામ સ્ટ્રક્ચર સમજાવો.}

\begin{solutionbox}
જાવા પ્રોગ્રામ સ્ટ્રક્ચર તાર્કિક રીતે ગોઠવાયેલા તત્વોના વિશિષ્ટ
ક્રમને અનુસરે છે.

\textbf{આકૃતિ: જાવા પ્રોગ્રામ સ્ટ્રક્ચર}

\begin{lstlisting}
+--------------------+
| Documentation      |
| package statement  |
| import statements  |
+--------------------+
| Class declaration  |
|  +----------------+|
|  | Variables      ||
|  | Constructors   ||
|  | Methods        ||
|  +----------------+|
+--------------------+
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Package}: સંબંધિત ક્લાસને જૂથમાં રાખે છે
\item
  \textbf{Import}: બાહ્ય ક્લાસને સમાવે છે
\item
  \textbf{Class}: વેરિયેબલ્સ અને મેથડ્સ ધરાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PIC: દરેક પ્રોગ્રામમાં Package Imports Class''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે static કી-વર્ડ સમજાવો.}

\begin{solutionbox}
Static કી-વર્ડ ક્લાસ-લેવલ વેરિયેબલ્સ અને મેથડ્સ બનાવે છે જે બધા
ઓબ્જેક્ટ્સ વચ્ચે શેર થાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Static vs Non-Static}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફીચર & Static & Non-Static \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
મેમરી & એક કોપી & ઘણી કોપીઓ \\
એક્સેસ & ઓબ્જેક્ટ વગર & ઓબ્જેક્ટ દ્વારા \\
રેફરન્સ & ક્લાસ નામ & ઓબ્જેક્ટ નામ \\
લોડ થવાનો સમય & ક્લાસ લોડિંગ & ઓબ્જેક્ટ બનાવટ \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class Counter {
    static int count = 0;  // બધા ઓબ્જેક્ટ્સ માટે શેર
    int instanceCount = 0; // દરેક ઓબ્જેક્ટ માટે અલગ
    
    Counter() {
        count++;
        instanceCount++;
    }
    
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        
        System.out.println("Static count: " + Counter.count);
        System.out.println("c1's instance count: " + c1.instanceCount);
        System.out.println("c2's instance count: " + c2.instanceCount);
    }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``SCM: Static બધા ઓબ્જેક્ટ માટે એકવાર મેમરી બનાવે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{ઇનહેરીટન્સ વ્યાખ્યાયિત કરો. તેના પ્રકારોની યાદી બનાવો. Multilevel અને
Hierarchical ઇનહેરીટન્સ ને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
ઇનહેરીટન્સ એ OOP સિદ્ધાંત છે જેમાં નવો ક્લાસ હાલના ક્લાસની સંપત્તિઓ
અને વર્તનને મેળવે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{જાવામાં ઇનહેરીટન્સના પ્રકારો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Single & એક સબક્લાસ એક સુપરક્લાસથી વિસ્તરે છે \\
Multilevel & ઇનહેરીટન્સની સાંકળ (A\rightarrowB\rightarrowC) \\
Hierarchical & ઘણા સબક્લાસ એક સુપરક્લાસથી વિસ્તરે છે \\
Multiple & એક ક્લાસ ઘણા ક્લાસથી વિસ્તરે છે (ઇન્ટરફેસ દ્વારા) \\
\end{longtable}
}

\textbf{આકૃતિ: Multilevel vs Hierarchical ઇનહેરીટન્સ}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-593f65e9.pdf}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
// Multilevel inheritance
class Animal {
    void eat() { System.out.println("eating"); }
}

class Dog extends Animal {
    void bark() { System.out.println("barking"); }
}

class Labrador extends Dog {
    void color() { System.out.println("golden"); }
}

// Hierarchical inheritance
class Vehicle {
    void move() { System.out.println("moving"); }
}

class Car extends Vehicle {
    void wheels() { System.out.println("4 wheels"); }
}

class Bike extends Vehicle {
    void wheels() { System.out.println("2 wheels"); }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``SMHM: Single Multilevel Hierarchical ઇનહેરીટન્સના
પ્રકારો છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{this કી-વર્ડને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
જાવામાં `this' કી-વર્ડ વર્તમાન ઓબ્જેક્ટનો સંદર્ભ આપે છે, જે ઇન્સ્ટન્સ
વેરિયેબલ્સ અને પેરામીટર્સ વચ્ચે તફાવત પાડે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{`this' કી-વર્ડના ઉપયોગો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઉપયોગ & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
this.variable & ઇન્સ્ટન્સ વેરિયેબલ્સ એક્સેસ કરવા \\
this() & વર્તમાન ક્લાસના કન્સ્ટ્રક્ટરને કોલ કરવા \\
return this & વર્તમાન ઓબ્જેક્ટ પાછો આપવા \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class Student {
    String name;
    
    Student(String name) {
        this.name = name;  // ઇન્સ્ટન્સ વેરિયેબલનો સંદર્ભ આપે છે
    }
    
    void display() {
        System.out.println("Name: " + this.name);
    }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``VAR: Variables Access Resolution this નો ઉપયોગ
કરીને''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{જાવામાં વિવિધ એક્સેસ કંટ્રોલ સમજાવો.}

\begin{solutionbox}
જાવામાં એક્સેસ કંટ્રોલ ક્લાસેસ, મેથડ્સ અને વેરિયેબલ્સની દૃશ્યતા અને પહોંચને
નિયંત્રિત કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{જાવા એક્સેસ મોડિફાયર્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
મોડિફાયર & ક્લાસ & પેકેજ & સબક્લાસ & જગત \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
private & ✓ & ✗ & ✗ & ✗ \\
default & ✓ & ✓ & ✗ & ✗ \\
protected & ✓ & ✓ & ✓ & ✗ \\
public & ✓ & ✓ & ✓ & ✓ \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{Private}: માત્ર તે જ ક્લાસની અંદર
\item
  \textbf{Default}: તે જ પેકેજની અંદર
\item
  \textbf{Protected}: પેકેજ અને સબક્લાસમાં
\item
  \textbf{Public}: બધે જ પહોંચ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PDPP: Private Default Protected Public સંકુચિતથી
વિશાળ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{ઈન્ટરફેસ શું છે? ઈન્ટરફેસ દ્વારા ઉદાહરણ સાથે multiple inheritance
સમજાવો.}

\begin{solutionbox}
ઈન્ટરફેસ એક એવો કરાર છે જે ક્લાસે શું કરવું જોઈએ તે નિર્દિષ્ટ કરે છે,
જેમાં abstract મેથડ્સ, નિયતાંકો અને (Java 8થી) default મેથડ્સ હોય છે.

\textbf{આકૃતિ: ઈન્ટરફેસથી Multiple Inheritance}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-2b8980a4.pdf}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
interface Printable {
    void print();
}

interface Scannable {
    void scan();
}

// Multiple inheritance using interfaces
class Printer implements Printable, Scannable {
    public void print() {
        System.out.println("Printing...");
    }
    
    public void scan() {
        System.out.println("Scanning...");
    }
    
    public static void main(String[] args) {
        Printer p = new Printer();
        p.print();
        p.scan();
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{કરાર}: અમલીકરણ વગર વર્તન વ્યાખ્યાયિત કરે છે
\item
  \textbf{Implements}: ક્લાસ કરાર પૂર્ણ કરે છે
\item
  \textbf{Multiple}: ઘણા ઈન્ટરફેસ લાગુ કરી શકાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CIM: કરાર Implements Multiple ઈન્ટરફેસ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{super કી-વર્ડ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
super કી-વર્ડ પેરન્ટ ક્લાસનો સંદર્ભ આપે છે, જે પેરન્ટ મેથડ્સ,
કન્સ્ટ્રક્ટર્સ અને વેરિયેબલ્સ એક્સેસ કરવા વપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{super કી-વર્ડના ઉપયોગો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઉપયોગ & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
super.variable & પેરન્ટ વેરિયેબલ એક્સેસ કરવા \\
super.method() & પેરન્ટ મેથડ કોલ કરવા \\
super() & પેરન્ટ કન્સ્ટ્રક્ટર કોલ કરવા \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
class Vehicle {
    String color = "white";
    
    void display() {
        System.out.println("Vehicle class");
    }
}

class Car extends Vehicle {
    String color = "black";
    
    void display() {
        super.display();  // પેરન્ટ મેથડ કોલ કરે છે
        System.out.println("Car color: " + color);
        System.out.println("Vehicle color: " + super.color);
    }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``VMC: Variables Methods Constructors super દ્વારા
એક્સેસ થાય છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{પેકેજ શું છે? પેકેજ બનાવવાના પગલાં લખો અને તેનું ઉદાહરણ આપો.}

\begin{solutionbox}
પેકેજ એ જાવામાં સંબંધિત ક્લાસ અને ઈન્ટરફેસને સંગઠિત કરતું નેમસ્પેસ છે, જે
નામકરણ સંઘર્ષને રોકે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{પેકેજ બનાવવાના પગલાં}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પગલું & ક્રિયા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & ફાઈલની ટોચે પેકેજ નામ જાહેર કરો \\
2 & પેકેજ નામને અનુરૂપ ડિરેક્ટરી સ્ટ્રક્ચર બનાવો \\
3 & જાવા ફાઈલને ડિરેક્ટરીમાં સેવ કરો \\
4 & -d વિકલ્પ સાથે કમ્પાઈલ કરો \\
5 & ઉપયોગ કરવા માટે પેકેજ ઈમ્પોર્ટ કરો \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
// પગલું 1: પેકેજ જાહેર કરો (Calculator.java તરીકે સેવ કરો)
package mathematics;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

// બીજી ફાઈલમાં (UseCalculator.java)
import mathematics.Calculator;

class UseCalculator {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(10, 20));
    }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``DISCO: Declare Import Save Compile Organize''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{વ્યાખ્યાયિત કરો: થ્રેડ ઓવરરાઇડિંગ. થ્રેડ ઓવરરાઇડિંગ માટેના નિયમોની યાદી
બનાવો. થ્રેડ ઓવરરાઇડિંગને ઇમ્પલેમેન્ટ કરતો જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}
મેથડ ઓવરરાઈડિંગ ત્યારે થાય છે જ્યારે સબક્લાસ તેના પેરન્ટ ક્લાસમાં
વ્યાખ્યાયિત મેથડ માટે ચોક્કસ અમલીકરણ આપે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{મેથડ ઓવરરાઈડિંગના નિયમો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
નિયમ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
એક જ નામ & મેથડનું નામ સરખું હોવું જોઈએ \\
એક જ પેરામીટર્સ & પેરામીટર સંખ્યા અને પ્રકાર મેળ ખાવા જોઈએ \\
એક જ રિટર્ન પ્રકાર & રિટર્ન પ્રકાર સરખો અથવા સબટાઈપ હોવો જોઈએ \\
એક્સેસ મોડિફાયર & વધુ પ્રતિબંધિત ન હોઈ શકે \\
એક્સેપ્શન્સ & વધુ વિસ્તૃત checked exception ફેંકી ન શકે \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    // મેથડ ઓવરરાઈડિંગ
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    // મેથડ ઓવરરાઈડિંગ
    @Override
    void makeSound() {
        System.out.println("Cat meows");
    }
}

public class MethodOverridingDemo {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Animal dog = new Dog();
        Animal cat = new Cat();
        
        animal.makeSound();  // Output: Animal makes a sound
        dog.makeSound();     // Output: Dog barks
        cat.makeSound();     // Output: Cat meows
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{રનટાઈમ પોલિમોર્ફિઝમ}: રનટાઈમ પર મેથડનું રિઝોલ્યુશન થાય છે
\item
  \textbf{@Override}: એનોટેશન ખાતરી કરે છે કે મેથડ ઓવરરાઈડ થઈ રહી છે
\item
  \textbf{ઇનહેરીટન્સ}: IS-A સંબંધની જરૂર છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SPARE: એક જ પેરામીટર્સ, એક્સેસ, રિટર્ન, એક્સેપ્શન્સ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે abstract class સમજાવો.}

\begin{solutionbox}
Abstract class ને ઈન્સ્ટન્સ બનાવી ન શકાય અને તેમાં abstract મેથડ્સ
હોઈ શકે જે સબક્લાસમાં અમલીકરણ કરવી જરૂરી છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Abstract Class vs Interface}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફીચર & Abstract Class & Interface \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ઈન્સ્ટન્સ & બનાવી ન શકાય & બનાવી ન શકાય \\
મેથડ્સ & કોન્ક્રીટ અને abstract & Abstract (+ Java 8થી default) \\
વેરિયેબલ્સ & કોઈપણ પ્રકાર & માત્ર નિયતાંકો \\
કન્સ્ટ્રક્ટર & ધરાવે છે & ધરાવતું નથી \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
abstract class Shape {
    // Abstract મેથડ - અમલીકરણ નથી
    abstract double area();
    
    // કોન્ક્રીટ મેથડ
    void display() {
        System.out.println("This is a shape");
    }
}

class Circle extends Shape {
    double radius;
    
    Circle(double r) {
        radius = r;
    }
    
    // Abstract મેથડનું અમલીકરણ
    double area() {
        return 3.14 * radius * radius;
    }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``PAI: આંશિક Abstract અમલીકરણ મુખ્ય છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{થ્રેડ શું છે? થ્રેડ જીવનચક્ર સમજાવો.}

\begin{solutionbox}
થ્રેડ એ લાઈટવેઈટ સબપ્રોસેસ છે, જે પ્રોસેસિંગની સૌથી નાની એકમ છે જે એક
સાથે ચાલતી પ્રક્રિયાઓની મંજૂરી આપે છે.

\textbf{આકૃતિ: થ્રેડ જીવનચક્ર}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-20370008.pdf}

\begin{itemize}
\tightlist
\item
  \textbf{New}: થ્રેડ બનેલ છે પણ શરૂ થયેલ નથી
\item
  \textbf{Runnable}: CPU સમય મળે ત્યારે ચાલવા તૈયાર
\item
  \textbf{Running}: હાલમાં ચાલી રહ્યું છે
\item
  \textbf{Blocked/Waiting}: અસ્થાયી રૂપે નિષ્ક્રિય
\item
  \textbf{Terminated}: કાર્ય પૂર્ણ થયેલ છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``NRRBT: New Runnable Running Blocked Terminated''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{જાવામાં એક પ્રોગ્રામ લખો જે Thread Class નો અમલ કરીને બહુવિધ થ્રેડો બનાવે
છે.}

\begin{solutionbox}
Thread class ને અમલ કરીને થ્રેડ બનાવવાથી ઘણા કાર્યો એક સાથે
ચલાવી શકાય છે.

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
class MyThread extends Thread {
    private String threadName;
    
    MyThread(String name) {
        this.threadName = name;
    }
    
    @Override
    public void run() {
        try {
for (int

i = 1; i <= 5; i++) {

                System.out.println(threadName + ": " + i);
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println(threadName + " interrupted");
        }
        System.out.println(threadName + " completed");
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread("Thread-1");
        MyThread thread2 = new MyThread("Thread-2");
        MyThread thread3 = new MyThread("Thread-3");
        
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Thread વિસ્તારો}: Thread class વિસ્તારી થ્રેડ બનાવો
\item
  \textbf{run() ઓવરરાઈડ}: run મેથડમાં કાર્ય વ્યાખ્યાયિત કરો
\item
  \textbf{start()}: થ્રેડ ચલાવવાનું શરૂ કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ERS: Extend Run Start થ્રેડ બનાવવા માટે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે final class સમજાવો.}

\begin{solutionbox}
Final class નો વારસો મળી શકતો નથી, જેથી તેના ડિઝાઈનમાં ફેરફાર
અને વિસ્તરણ અટકાવે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Final Class લક્ષણો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફીચર & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ઇનહેરીટન્સ & સબક્લાસ બનાવી શકાતો નથી \\
મેથડ્સ & અંતર્નિહિત final છે \\
સુરક્ષા & ડિઝાઈન ફેરફારને રોકે છે \\
ઉદાહરણ & String, Math ક્લાસ \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
final class Security {
    void secureMethod() {
        System.out.println("Secure implementation");
    }
}

// Error: Cannot extend final class
// class HackAttempt extends Security { }
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{સુરક્ષા}: સંવેદનશીલ અમલીકરણનું રક્ષણ કરે છે
\item
  \textbf{અપરિવર્તનશીલતા}: અપરિવર્તનશીલ ક્લાસ બનાવવામાં મદદ કરે છે
\item
  \textbf{ઓપ્ટિમાઈઝેશન}: JVM final ક્લાસને ઓપ્ટિમાઈઝ કરી શકે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SIO: સુરક્ષા અપરિવર્તનશીલતા ઓપ્ટિમાઈઝેશન''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{યોગ્ય ઉદાહરણ સાથે thread ની પ્રાથમિકતાઓ સમજાવો.}

\begin{solutionbox}
થ્રેડ પ્રાથમિકતાઓ નક્કી કરે છે કે થ્રેડ્સને અમલીકરણ માટે કયા ક્રમમાં
શેડ્યુલ કરવા, 1 (ન્યૂનતમ) થી 10 (ઉચ્ચતમ).


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{થ્રેડ પ્રાયોરિટી નિયતાંકો}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
નિયતાંક & મૂલ્ય & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
MIN\_PRIORITY & 1 & ન્યૂનતમ પ્રાથમિકતા \\
NORM\_PRIORITY & 5 & ડિફોલ્ટ પ્રાથમિકતા \\
MAX\_PRIORITY & 10 & ઉચ્ચતમ પ્રાથમિકતા \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
class PriorityThread extends Thread {
    PriorityThread(String name) {
        super(name);
    }
    
    public void run() {
        System.out.println("Running: " + getName() + 
                          " with priority: " + getPriority());
    }
}

public class ThreadPriorityDemo {
    public static void main(String[] args) {
        PriorityThread low = new PriorityThread("Low Priority");
        PriorityThread norm = new PriorityThread("Normal Priority");
        PriorityThread high = new PriorityThread("High Priority");
        
        low.setPriority(Thread.MIN_PRIORITY);
        high.setPriority(Thread.MAX_PRIORITY);
        
        low.start();
        norm.start();
        high.start();
    }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``HNL: ઉચ્ચ સામાન્ય નિમ્ન પ્રાથમિકતાઓ થ્રેડ્સમાં''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{Exception શું છે? Arithmetic Exception નો ઉપયોગ દર્શાવતો પ્રોગ્રામ
લખો.}

\begin{solutionbox}
Exception એ અસામાન્ય સ્થિતિ છે જે પ્રોગ્રામના સામાન્ય પ્રવાહને
વિક્ષેપિત કરે છે.

\textbf{આકૃતિ: Exception હાયરાર્કી}

\includegraphics[width=1\linewidth,height=\textheight,keepaspectratio]{mermaid-2e8b0f36.pdf}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class ArithmeticExceptionDemo {
    public static void main(String[] args) {
        try {
            // આ ArithmeticException ઉત્પન્ન કરશે
            int result = 100 / 0;
            System.out.println("Result: " + result);
        } 
        catch (ArithmeticException e) {
            System.out.println("ArithmeticException caught: " + e.getMessage());
            System.out.println("Cannot divide by zero");
        }
        finally {
            System.out.println("This block always executes");
        }
        
        System.out.println("Program continues after exception handling");
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Try Block}: એવો કોડ ધરાવે છે જે exception ફેંકી શકે છે
\item
  \textbf{Catch Block}: ચોક્કસ exception હેન્ડલ કરે છે
\item
  \textbf{Finally Block}: exception ફેંકાય કે ન ફેંકાય, હંમેશા ચાલે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TCF: Try Catch Finally exceptions હેન્ડલ કરે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{એરેની 10 સંખ્યાઓનો સરવાળો અને સરેરાશ શોધવા માટેનો જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}
એરે એક જ પ્રકારની ઘણી કિંમતો સંગ્રહે છે, જે તત્વોની ક્રમિક પ્રક્રિયા
કરવાની મંજૂરી આપે છે.

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class ArraySumAverage {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
        
        int sum = 0;
        
        // સરવાળો ગણો
        for (int i = 0; i < numbers.length; i++) {
            sum += numbers[i];
        }
        
        // સરેરાશ ગણો
        double average = (double) sum / numbers.length;
        
        System.out.println("Sum = " + sum);
        System.out.println("Average = " + average);
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{ઘોષણા}: નિશ્ચિત-કદના સંગ્રહ બનાવે છે
\item
  \textbf{પુનરાવર્તન}: તત્વોનો ક્રમિક એક્સેસ
\item
  \textbf{ગણતરી}: પરિણામો માટે મૂલ્યો પર પ્રક્રિયા કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DIC: Declare Iterate Calculate એરે પ્રોસેસિંગ માટે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{`DivideByZero' એરર માટે યુઝર ડિફાઈન્ડ Exception હેન્ડલ કરવા માટે જાવા
પ્રોગ્રામ લખો.}

\begin{solutionbox}
યુઝર-ડિફાઈન્ડ exception ચોક્કસ એપ્લિકેશન જરૂરિયાતો માટે કસ્ટમ
exception પ્રકારો બનાવવાની મંજૂરી આપે છે.

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
// કસ્ટમ exception ક્લાસ
class DivideByZeroException extends Exception {
    public DivideByZeroException(String message) {
        super(message);
    }
}

public class CustomExceptionDemo {
    // કસ્ટમ exception ફેંકતી મેથડ
    static double divide(int numerator, int denominator) throws DivideByZeroException {
        if (denominator == 0) {
            throw new DivideByZeroException("Cannot divide by zero!");
        }
        return (double) numerator / denominator;
    }
    
    public static void main(String[] args) {
        try {
            System.out.println(divide(10, 2));
            System.out.println(divide(20, 0));
        } catch (DivideByZeroException e) {
            System.out.println("Custom exception caught: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{કસ્ટમ ક્લાસ}: Exception ક્લાસ વિસ્તારે છે
\item
  \textbf{ફેંકવું}: throw કીવર્ડનો નવા ઇન્સ્ટન્સ સાથે ઉપયોગ કરો
\item
  \textbf{હેન્ડલિંગ}: ચોક્કસ exception પ્રકાર પકડો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CTE: Create Throw Exception જ્યારે જરૂર હોય''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{ટેક્સ્ટ ફાઇલ બનાવવા માટે જાવા પ્રોગ્રામ લખો અને ટેક્સ્ટ ફાઇલ પર રીડ ઑપરેશન
કરો.}

\begin{solutionbox}
જાવા I/O ક્લાસ ફાઇલો સાથે કામ કરવા માટે સગવડ આપે છે, જે સર્જન,
લેખન અને વાંચન ઓપરેશન્સની મંજૂરી આપે છે.

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
import java.io.FileWriter;
import java.io.FileReader;
import java.io.IOException;
import java.io.BufferedReader;

public class FileOperationsDemo {
    public static void main(String[] args) {
        try {
            // ફાઇલ બનાવો અને લખો
            FileWriter writer = new FileWriter("sample.txt");
            writer.write("Hello World!\n");
            writer.write("Welcome to Java File Handling.\n");
            writer.write("This is the third line.");
            writer.close();
            System.out.println("Successfully wrote to the file.");
            
            // ફાઇલમાંથી વાંચો
            FileReader reader = new FileReader("sample.txt");
            BufferedReader buffReader = new BufferedReader(reader);
            
            String line;
            System.out.println("\nFile contents:");
            while ((line = buffReader.readLine()) != null) {
                System.out.println(line);
            }
            
            reader.close();
            
        } catch (IOException e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{FileWriter}: ફાઇલો બનાવે અને લખે છે
\item
  \textbf{FileReader}: ફાઇલોમાંથી અક્ષર ડેટા વાંચે છે
\item
  \textbf{BufferedReader}: લાઇન દ્વારા ટેક્સ્ટ કાર્યક્ષમતાથી વાંચે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``WRC: Write Read Close ફાઇલ ઓપરેશન્સ માટે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{Java I/O પ્રક્રિયા સમજાવો.}

\begin{solutionbox}
Java I/O પ્રક્રિયામાં સ્ટ્રીમ્સનો ઉપયોગ કરીને વિવિધ સ્રોતોથી ડેટા
ટ્રાન્સફર કરવાનો સમાવેશ થાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{Java I/O સ્ટ્રીમ પ્રકારો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વર્ગીકરણ & પ્રકારો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
દિશા & ઇનપુટ, આઉટપુટ \\
ડેટા પ્રકાર & બાઇટ સ્ટ્રીમ્સ, કેરેક્ટર સ્ટ્રીમ્સ \\
કાર્યક્ષમતા & બેઝિક, બફર્ડ, ડેટા, ઓબ્જેક્ટ \\
\end{longtable}
}

\textbf{આકૃતિ: Java I/O હાયરાર્કી}

\begin{lstlisting}
   +-----------+
   |  Stream   |
   +-----------+
        |
   +----+----+
   |         |
+-----+   +------+
|Input|   |Output|
+-----+   +------+
   |         |
+------+  +------+
| Byte |  | Char |
+------+  +------+
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{સ્ટ્રીમ}: સ્રોત અને લક્ષ્ય વચ્ચે વહેતા ડેટાની શ્રેણી
\item
  \textbf{બફરિંગ}: ડિસ્ક એક્સેસ ઘટાડીને કાર્યક્ષમતા સુધારે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SBI: સ્ટ્રીમ બફર્ડ ઇનપુટ/આઉટપુટ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{Exception હેન્ડલિંગમાં throw અને finally ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
Exception હેન્ડલિંગ મેકેનિઝમ્સ ભૂલો દરમિયાન પ્રોગ્રામ ફ્લોને નિયંત્રિત
કરે છે, સુંદર અમલીકરણ સુનિશ્ચિત કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{throw vs finally}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફીચર & throw & finally \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
હેતુ & સ્પષ્ટપણે exception ફેંકે છે & કોડ અમલીકરણ સુનિશ્ચિત કરે છે \\
સ્થાન & મેથડની અંદર & try-catch બ્લોક્સ પછી \\
અમલીકરણ & શરત પૂરી થાય ત્યારે & return હોય તો પણ હંમેશા \\
ઉપયોગ & કંટ્રોલ ફ્લો & રિસોર્સ ક્લીનઅપ \\
\end{longtable}
}

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
public class ThrowFinallyDemo {
    public static void validateAge(int age) {
        try {
            if (age < 18) {
                throw new ArithmeticException("Not eligible to vote");
            } else {
                System.out.println("Welcome to vote");
            }
        } catch (ArithmeticException e) {
            System.out.println("Exception caught: " + e.getMessage());
        } finally {
            System.out.println("Validation process completed");
        }
    }
    
    public static void main(String[] args) {
        validateAge(15);
        System.out.println("---------");
        validateAge(20);
    }
}
\end{lstlisting}

\end{solutionbox}
\begin{mnemonicbox}
``TERA: Throw Exception, Regardless Always, finally
હંમેશા ચાલે છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{ટેક્સ્ટ ફાઇલ ના કન્ટેન્ટ ડિસ્પ્લે કરવા અને ટેક્સ્ટ ફાઇલ પર એપેન્ડ ઓપરેશન કરવા
માટે જાવા પ્રોગ્રામ લખો.}

\begin{solutionbox}
જાવામાં ફાઇલ ઓપરેશન્સ ફાઇલ કન્ટેન્ટને હેરફેર કરવાની મંજૂરી આપે છે, નવા
ડેટા ઉમેરવા સહિત.

\textbf{કોડ બ્લોક:}

\begin{lstlisting}[language=Java]
import java.io.*;

public class FileAppendDemo {
    public static void main(String[] args) {
        try {
            // પ્રારંભિક ફાઇલ બનાવો
            FileWriter writer = new FileWriter("example.txt");
            writer.write("Original content line 1\n");
            writer.write("Original content line 2\n");
            writer.close();
            
            // ફાઇલ કન્ટેન્ટ દર્શાવો
            System.out.println("Original file content:");
            readFile("example.txt");
            
            // ફાઇલમાં ઉમેરો
            FileWriter appendWriter = new FileWriter("example.txt", true);
            appendWriter.write("Appended content line 1\n");
            appendWriter.write("Appended content line 2\n");
            appendWriter.close();
            
            // અપડેટ થયેલ કન્ટેન્ટ દર્શાવો
            System.out.println("\nFile content after append:");
            readFile("example.txt");
            
        } catch (IOException e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
    
    // ફાઇલ કન્ટેન્ટ વાંચવા અને દર્શાવવા માટેની મેથડ
    public static void readFile(String fileName) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            reader.close();
        } catch (IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{FileWriter(file, true)}: બીજો પેરામીટર એપેન્ડ મોડ સક્ષમ કરે છે
\item
  \textbf{BufferedReader}: લાઇન દ્વારા ટેક્સ્ટને કાર્યક્ષમતાથી વાંચે છે
\item
  \textbf{ફરીથી વાપરી શકાય તેવી મેથડ}: વાચન કાર્યક્ષમતાને સંકલિત કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CAD: Create Append Display ફાઇલ ઓપરેશન્સ''

\end{mnemonicbox}

\end{document}
