\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{જાવા પ્રોગ્રામિંગ (4343203) – સમર 2025 સોલ્યુશન}
\date{May 13, 2025}

\begin{document}
\maketitle

\questionmarks{1(અ)}{3}{Java માં identifier ને નામ આપવાના નિયમોની યાદી માન્ય અને અમાન્ય ઉદાહરણો સાથે બનાવો.}

\begin{solutionbox}
\textbf{Java Identifier ના નિયમો:}

\begin{center}
\captionof{table}{Identifier નિયમો}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{નિયમ} & \textbf{વર્ણન} & \textbf{માન્ય ઉદાહરણ} & \textbf{અમાન્ય ઉદાહરણ} \\ \hline
શરૂઆતી અક્ષર & letter, underscore અથવા dollar sign થી શરૂ & \code{name}, \code{\_value}, \code{\$cost} & \code{2name}, \code{\#id} \\ \hline
પછીના અક્ષરો & letters, digits, underscore, dollar હોઈ શકે & \code{student123}, \code{user\_name} & \code{my-var}, \code{class@} \\ \hline
Keyword પ્રતિબંધ & Java reserved words વાપરી શકાતા નથી & \code{myClass}, \code{userName} & \code{class}, \code{int} \\ \hline
Case Sensitivity & Identifier case-sensitive છે & \code{Name} $\neq$ \code{name} & -- \\ \hline
લંબાઈ & કોઈ લંબાઈની મર્યાદા નથી & \code{verylongvariablename} & -- \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Letters First, Keywords Never, Case Counts}
\end{mnemonicbox}

\questionmarks{1(બ)}{4}{Java ના operator ની યાદી બનાવો. Arithmetic અને Logical operator ને સમજાવો.}

\begin{solutionbox}
\textbf{Java Operator ના પ્રકારો:}

\begin{center}
\captionof{table}{Operator ના પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Operator નો પ્રકાર} & \textbf{ઉદાહરણો} \\ \hline
Arithmetic & \code{+}, \code{-}, \code{*}, \code{/}, \code{\%} \\ \hline
Relational & \code{==}, \code{!=}, \code{<}, \code{>}, \code{<=}, \code{>=} \\ \hline
Logical & \code{\&\&}, \code{||}, \code{!} \\ \hline
Assignment & \code{=}, \code{+=}, \code{-=}, \code{*=}, \code{/=} \\ \hline
Unary & \code{++}, \code{--}, \code{+}, \code{-}, \code{!} \\ \hline
Bitwise & \code{\&}, \code{|}, \code{\^}, \code{\~}, \code{<<}, \code{>>} \\ \hline
Ternary & \code{condition ? value1 : value2} \\ \hline
\end{tabulary}
\end{center}

\textbf{Arithmetic Operators:}
\begin{itemize}
    \item \textbf{Addition (+)}: બે operand નો સરવાળો કરે છે
    \item \textbf{Subtraction (-)}: પહેલામાંથી બીજો બાદ કરે છે
    \item \textbf{Multiplication (*)}: બે operand નો ગુણાકાર કરે છે
    \item \textbf{Division (/)}: પહેલાને બીજા વડે ભાગ આપે છે
    \item \textbf{Modulus (\%)}: ભાગાકારનો શેષ આપે છે
\end{itemize}

\textbf{Logical Operators:}
\begin{itemize}
    \item \textbf{AND (\&\&)}: બંને શરતો સાચી હોય તો true આપે છે
    \item \textbf{OR (||)}: ઓછામાં ઓછી એક શરત સાચી હોય તો true આપે છે
    \item \textbf{NOT (!)}: logical state ને ઉલટાવે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Add Subtract Multiply Divide Remainder, And Or Not}
\end{mnemonicbox}

\questionmarks{1(ક)}{7}{3 આંકડાની સંખ્યાને વિપરીત કરવા માટે Java પ્રોગ્રામ લખો. ઉદાહરણ તરીકે, સંખ્યા 653 છે તો તેની વિપરીત સંખ્યા 356 છે.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Reverse Number}]
import java.util.Scanner;

public class ReverseNumber {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        System.out.print("3 આંકડાની સંખ્યા દાખલ કરો: ");
        int num = sc.nextInt();
        
        int reverse = 0;
        int temp = num;
        
        while (temp > 0) {
            reverse = reverse * 10 + temp % 10;
            temp = temp / 10;
        }
        
        System.out.println("મૂળ સંખ્યા: " + num);
        System.out.println("વિપરીત સંખ્યા: " + reverse);
    }
}
\end{lstlisting}

\textbf{Algorithm:}
\begin{itemize}
    \item \textbf{છેલ્લો આંકડો કાઢો}: Modulus operator (\%) નો ઉપયોગ કરો
    \item \textbf{વિપરીત સંખ્યા બનાવો}: 10 થી ગુણો અને આંકડો ઉમેરો
    \item \textbf{છેલ્લો આંકડો દૂર કરો}: Integer division (/) નો ઉપયોગ કરો
    \item \textbf{પુનરાવર્તન કરો}: મૂળ સંખ્યા 0 થાય ત્યાં સુધી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Extract, Build, Remove, Repeat}
\end{mnemonicbox}

\questionmarks{1(ક OR)}{7}{3*3 મેટ્રિક્સનો સરવાળો કરવા માટેનો Java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Matrix Addition}]
import java.util.Scanner;

public class MatrixAddition {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[][] matrix1 = new int[3][3];
        int[][] matrix2 = new int[3][3];
        int[][] result = new int[3][3];
        
        // પહેલું મેટ્રિક્સ દાખલ કરો
        System.out.println("પહેલું મેટ્રિક્સ દાખલ કરો:");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix1[i][j] = sc.nextInt();
            }
        }
        
        // બીજું મેટ્રિક્સ દાખલ કરો
        System.out.println("બીજું મેટ્રિક્સ દાખલ કરો:");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix2[i][j] = sc.nextInt();
            }
        }
        
        // મેટ્રિક્સનો સરવાળો
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                result[i][j] = matrix1[i][j] + matrix2[i][j];
            }
        }
        
        // પરિણામ દર્શાવો
        System.out.println("મેટ્રિક્સનો સરવાળો:");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(result[i][j] + " ");
            }
            System.out.println();
        }
    }
}
\end{lstlisting}

\textbf{Matrix Addition ના પગલાં:}
\begin{itemize}
    \item \textbf{Array બનાવો}: ત્રણ $3 \times 3$ integer array
    \item \textbf{મેટ્રિક્સ દાખલ કરો}: બંને મેટ્રિક્સ માટે values વાંચો
    \item \textbf{સંબંધિત elements ઉમેરો}: \code{result[i][j] = matrix1[i][j] + matrix2[i][j]}
    \item \textbf{પરિણામ દર્શાવો}: સરવાળાનું મેટ્રિક્સ print કરો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Create, Input, Add, Display}
\end{mnemonicbox}

\questionmarks{2(અ)}{3}{પેરામીટરાઇઝ્ડ કન્સ્ટ્રક્ટર નો ઉપયોગ દર્શાવતો Java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Parameterized Constructor}]
class Student {
    private String name;
    private int rollNo;
    
    // Parameterized Constructor
    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }
    
    public void display() {
        System.out.println("નામ: " + name);
        System.out.println("રોલ નંબર: " + rollNo);
    }
}

public class ParameterizedConstructor {
    public static void main(String[] args) {
        Student s1 = new Student("જોન", 101);
        s1.display();
    }
}
\end{lstlisting}

\textbf{Parameterized Constructor ની વિશેષતાઓ:}
\begin{itemize}
    \item \textbf{પેરામીટર લે છે}: Object બનાવતી વખતે values સ્વીકારે છે
    \item \textbf{Instance variables initialize કરે છે}: Object ની state સેટ કરે છે
    \item \textbf{Class જેવું જ નામ}: Constructor નું નામ class સાથે મેળ ખાય છે
    \item \textbf{Return type નથી}: Constructor નો return type હોતો નથી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Parameters Initialize Same-name No-return}
\end{mnemonicbox}

\questionmarks{2(બ)}{4}{ઉદાહરણ સાથે નીચેના શબ્દોની બેસીક સીન્ટેક્સ આપો: (1) ક્લાસ બનાવવા માટે, (2) ઓબ્જેક્ટ બનાવવા માટે, (3) મેથડને વ્યાખ્યાયિત કરવા માટે, (4) ચલ(વેરીએબલ)ને ડિક્લેર કરવા માટે.}

\begin{solutionbox}
\textbf{Java Basic Syntax:}

\begin{center}
\captionof{table}{Basic Syntax}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઘટક} & \textbf{Syntax} & \textbf{ઉદાહરણ} \\ \hline
Class બનાવવું & \code{class ClassName \{ \}} & \code{class Car \{ \}} \\ \hline
Object બનાવવું & \code{ClassName obj = new ClassName();} & \code{Car c = new Car();} \\ \hline
Method વ્યાખ્યા & \code{returnType method(params) \{ \}} & \code{void start() \{ \}} \\ \hline
Variable declaration & \code{dataType varName;} & \code{int age;} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java, caption={Syntax Example}]
class Car {                           // Class બનાવવું
    int speed;                        // Variable Declaration
    
    public void accelerate() {        // Method વ્યાખ્યા
        speed += 10;
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();        // Object બનાવવું
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Class Object Method Variable - COMV}
\end{mnemonicbox}

\questionmarks{2(ક)}{7}{Java માં એક પ્રોગ્રામ લખો જેમાં Student નામનો Class છે. જેમાં enrollmentNo અને name નામ ના બે ઇન્સ્ટન્ટ વેરીએબલ હોય. Student Class ના 3 ઓબ્જેક્ટ main મેથડમાં બનાવો અને Student's ના નામ દર્શાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Student Class Demo}]
class Student {
    String enrollmentNo;
    String name;
    
    // Student data initialize કરવા માટે constructor
    public Student(String enrollmentNo, String name) {
        this.enrollmentNo = enrollmentNo;
        this.name = name;
    }
    
    // Student નું નામ display કરવા માટે method
    public void displayName() {
        System.out.println("વિદ્યાર્થીનું નામ: " + name);
    }
}

public class StudentDemo {
    public static void main(String[] args) {
        // Student class ના 3 objects બનાવવા
        Student s1 = new Student("CS001", "અલિસ");
        Student s2 = new Student("CS002", "બોબ");
        Student s3 = new Student("CS003", "ચાર્લી");
        
        // વિદ્યાર્થીઓના નામ દર્શાવવા
        s1.displayName();
        s2.displayName();
        s3.displayName();
    }
}
\end{lstlisting}

\textbf{પ્રોગ્રામની રચના:}
\begin{itemize}
    \item \textbf{Class વ્યાખ્યા}: Instance variables સાથે Student class
    \item \textbf{Constructor}: enrollmentNo અને name initialize કરવા માટે
    \item \textbf{Method}: displayName() વિદ્યાર્થીનું નામ બતાવવા માટે
    \item \textbf{Object બનાવવું}: main method માં ત્રણ Student objects
    \item \textbf{Method calling}: displayName() વાપરીને નામ દર્શાવવા
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Define Initialize Display Create Call}
\end{mnemonicbox}

\questionmarks{2(અ OR)}{3}{ડિફોલ્ટ કન્સ્ટ્રક્ટર નો ઉપયોગ દર્શાવતો Java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Default Constructor}]
class Rectangle {
    int length;
    int width;
    
    // Default Constructor
    public Rectangle() {
        length = 5;
        width = 3;
        System.out.println("Default constructor કોલ થયો");
    }
    
    public void displayArea() {
        System.out.println("વિસ્તાર: " + (length * width));
    }
}

public class DefaultConstructor {
    public static void main(String[] args) {
        Rectangle r1 = new Rectangle();
        r1.displayArea();
    }
}
\end{lstlisting}

\textbf{Default Constructor ની વિશેષતાઓ:}
\begin{itemize}
    \item \textbf{કોઈ પેરામીટર નથી}: કોઈ arguments લેતો નથી
    \item \textbf{Default values}: Instance variables માટે default values સેટ કરે છે
    \item \textbf{આપોઆપ કોલ}: Object બનાવતી વખતે કોલ થાય છે
    \item \textbf{Class જેવું જ નામ}: Constructor નું નામ class સાથે મેળ ખાય છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{No-parameters Default Automatic Same-name}
\end{mnemonicbox}

\questionmarks{2(બ OR)}{4}{પ્રોસિજર-ઓરિએન્ટેડ પ્રોગ્રામિંગ અને ઓબ્જેક્ટ-ઓરિએન્ટેડ પ્રોગ્રામિંગ વચ્ચે ચાર તફાવત આપો.}

\begin{solutionbox}
\textbf{POP vs OOP તુલના:}

\begin{center}
\captionof{table}{POP vs OOP}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{Procedure Oriented Programming} & \textbf{Object-Oriented Programming} \\ \hline
અભિગમ & Top-down approach & Bottom-up approach \\ \hline
ધ્યાન & Functions અને procedures પર & Objects અને classes પર \\ \hline
Data સુરક્ષા & Data hiding નથી, global access & Data encapsulation અને hiding \\ \hline
સમસ્યા ઉકેલ & Functions માં વહેંચવું & Objects માં વહેંચવું \\ \hline
Code પુનઃઉપયોગ & મર્યાદિત પુનઃઉપયોગ & Inheritance દ્વારા ઉચ્ચ પુનઃઉપયોગ \\ \hline
જાળવણી & જાળવવું મુશ્કેલ & જાળવવું અને સુધારવું સરળ \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Structure Security Reusability Maintenance}
\end{mnemonicbox}

\questionmarks{2(ક OR)}{7}{Java માં એક પ્રોગ્રામ લખો જેમાં Shape નામની Class હોય જે 2 ઓવરલોડ મેથડ area (ફ્લોટ radius) અને area (ફ્લોટ length, ફ્લોટ width) ધરાવતો હોય. ઓવરલોડ પદ્ધતિઓનો ઉપયોગ કરીને વર્તુળ અને લંબચોરસનો area (વિસ્તાર) દર્શાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Method Overloading}]
class Shape {
    // વર્તુળનો વિસ્તાર કેલ્ક્યુલેટ કરવા માટે method
    public void area(float radius) {
        float circleArea = 3.14f * radius * radius;
        System.out.println("વર્તુળનો વિસ્તાર: " + circleArea);
    }
    
    // લંબચોરસનો વિસ્તાર કેલ્ક્યુલેટ કરવા માટે overloaded method
    public void area(float length, float width) {
        float rectangleArea = length * width;
        System.out.println("લંબચોરસનો વિસ્તાર: " + rectangleArea);
    }
}

public class MethodOverloading {
    public static void main(String[] args) {
        Shape shape = new Shape();
        
        // radius 5 સાથે વર્તુળનો વિસ્તાર કેલ્ક્યુલેટ કરો
        shape.area(5.0f);
        
        // length 4 અને width 6 સાથે લંબચોરસનો વિસ્તાર કેલ્ક્યુલેટ કરો
        shape.area(4.0f, 6.0f);
    }
}
\end{lstlisting}

\textbf{Method Overloading ની વિભાવનાઓ:}
\begin{itemize}
    \item \textbf{સમાન method નામ}: બંને methods નું નામ ``area''
    \item \textbf{ને પેરામીટર}: એક radius લે છે, બીજો length અને width લે છે
    \item \textbf{Compile-time polymorphism}: Method compile time પર પસંદ થાય છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Same-name Different-parameters Compile-time Parameter-differentiation}
\end{mnemonicbox}

\questionmarks{3(અ)}{3}{સિંગલ ઇનહેરીટેન્સ દર્શાવવા માટે Java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Single Inheritance}]
// Parent class
class Animal {
    public void eat() {
        System.out.println("પ્રાણી ખાય છે");
    }
    
    public void sleep() {
        System.out.println("પ્રાણી સૂય છે");
    }
}

// Animal માંથી inherit કરતો Child class
class Dog extends Animal {
    public void bark() {
        System.out.println("કૂતરો ભસે છે");
    }
}

public class SingleInheritance {
    public static void main(String[] args) {
        Dog dog = new Dog();
        
        // Animal class માંથી inherited methods
        dog.eat();
        dog.sleep();
        
        // Dog class નો પોતાનો method
        dog.bark();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{One-parent Extends Method IS-A}
\end{mnemonicbox}

\questionmarks{3(બ)}{4}{Java માં એબ્સ્ટ્રેક્ટ ક્લાસને ઉદાહરણ સાથે વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
\textbf{Abstract Class વ્યાખ્યા:} Abstract class એ એવો class છે જેનો instantiate કરી શકાતો નથી અને તેમાં abstract methods (implementation વિનાના methods) હોઈ શકે છે.

\begin{lstlisting}[language=Java, caption={Abstract Class}]
abstract class Vehicle {
    String brand;
    public void displayBrand() {
        System.out.println("બ્રાન્ડ: " + brand);
    }
    public abstract void start();
    public abstract void stop();
}

class Car extends Vehicle {
    public Car(String brand) {
        this.brand = brand;
    }
    public void start() {
        System.out.println("કાર ચાવી વડે સ્ટાર્ટ થયો");
    }
    public void stop() {
        System.out.println("કાર બ્રેક વડે બંધ થયો");
    }
}

public class AbstractDemo {
    public static void main(String[] args) {
        Car car = new Car("ટોયોટા");
        car.displayBrand();
        car.start();
        car.stop();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Cannot-instantiate Abstract-methods Concrete-methods Must-extend}
\end{mnemonicbox}

\questionmarks{3(ક)}{7}{ઇન્ટરફેસનો ઉપયોગ કરીને મલ્ટીપલ ઇનહેરીટન્સને ઇમ્પ્લીમેંટ કરવા માટે Java માં પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Interface Multiple Inheritance}]
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    private String name;
    
    public Duck(String name) {
        this.name = name;
    }
    
    public void fly() {
        System.out.println(name + " આકાશમાં ઉડે છે");
    }
    
    public void swim() {
        System.out.println(name + " પાણીમાં સ્વિમ કરે છે");
    }
    
    public void walk() {
        System.out.println(name + " જમીન પર ચાલે છે");
    }
}

public class MultipleInheritance {
    public static void main(String[] args) {
        Duck duck = new Duck("ડોનાલ્ડ");
        duck.fly();
        duck.swim();
        duck.walk();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Multiple-interfaces Implements Must-implement Solves-diamond}
\end{mnemonicbox}

\questionmarks{3(અ OR)}{3}{મલ્ટીલેવલ ઇનહેરીટેન્સ દર્શાવવા માટે Java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Multilevel Inheritance}]
class Animal {
    public void breathe() {
        System.out.println("પ્રાણી શ્વાસ લે છે");
    }
}

class Mammal extends Animal {
    public void giveBirth() {
        System.out.println("સ્તનધારી બચ્ચાંને જન્મ આપે છે");
    }
}

class Dog extends Mammal {
    public void bark() {
        System.out.println("કૂતરો ભસે છે");
    }
}

public class MultilevelInheritance {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.breathe();
        dog.giveBirth();
        dog.bark();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Chain Multiple Transitive Extends}
\end{mnemonicbox}

\questionmarks{3(બ OR)}{4}{પેકેજ વ્યાખ્યાયિત કરો અને ઉદાહરણ સાથે પેકેજ બનાવવા માટે સીન્ટેક્સ લખો.}

\begin{solutionbox}
\textbf{Package વ્યાખ્યા:} Package એ namespace છે જે સંબંધિત classes અને interfaces ને organize કરે છે.

\textbf{Package Syntax:}
\code{package packageName;}

\begin{lstlisting}[language=Java, caption={Package Implementation}]
package mypackage;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

// બીજી ફાઈલમાં
import mypackage.Calculator;

public class TestCalculator {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println("સરવાળો: " + calc.add(10, 5));
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Namespace Access Organization Reusability}
\end{mnemonicbox}

\questionmarks{3(ક OR)}{7}{મેથડ ઓવરરાઇડિંગ દર્શાવવા માટે Java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Method Overriding}]
class Animal {
    public void makeSound() {
        System.out.println("પ્રાણી અવાજ કરે છે");
    }
    public void move() {
        System.out.println("પ્રાણી ફરે છે");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("કૂતરો ભસે છે: ભવ! ભવ!");
    }
    @Override
    public void move() {
        System.out.println("કૂતરો ચાર પગ પર દોડે છે");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("બિલાડી મ્યાઉં કરે છે: મ્યાઉં! મ્યાઉં!");
    }
    @Override
    public void move() {
        System.out.println("બિલાડી શાંતિથી ચાલે છે");
    }
}

public class MethodOverriding {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.makeSound();
        animal.move();
        
        animal = new Cat();
        animal.makeSound();
        animal.move();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Same-signature Runtime Override IS-A}
\end{mnemonicbox}

\questionmarks{4(અ)}{3}{Java માં વિવિધ પ્રકારની એરરની યાદી બનાવો અને સમજાવો.}

\begin{solutionbox}
\textbf{Java Error ના પ્રકારો:}

\begin{center}
\captionof{table}{Error Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Error નો પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
Compile-time & Compilation દરમિયાન શોધાય છે & Syntax errors, missing semicolons \\ \hline
Runtime & Program execution દરમિયાન થાય છે & Division by zero, null pointer \\ \hline
Logical & Program ચાલે છે પણ ખોટું output આપે છે & ખોટા algorithm logic \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Compile Runtime Logic - CRL}
\end{mnemonicbox}

\questionmarks{4(બ)}{4}{રેપર ક્લાસ શું છે? કોઈપણ બે રેપર ક્લાસનો ઉપયોગ સમજાવો.}

\begin{solutionbox}
Wrapper classes primitive data types ના object representation પ્રદાન કરે છે.

\begin{center}
\captionof{table}{Wrapper Classes}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Primitive} & \textbf{Wrapper Class} \\ \hline
int & Integer \\ \hline
double & Double \\ \hline
boolean & Boolean \\ \hline
char & Character \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java, caption={Wrapper Examples}]
// Integer Wrapper
int num = 100;
Integer intObj = Integer.valueOf(num); // Boxing
int value = intObj.intValue(); // Unboxing
int parsed = Integer.parseInt("123"); // Parsing

// Double Wrapper
Double doubleObj = Double.valueOf(45.67);
double val = Double.parseDouble("123.45");
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Collections Null Utility Generics}
\end{mnemonicbox}

\questionmarks{4(ક)}{7}{બેંકિંગ એપ્લિકેશન વિકસાવવા માટે Java માં એક પ્રોગ્રામ લખો જેમાં વપરાશકર્તા 25000 રૂપિયા જમા કરે અને પછી 20000, 4000 રૂપિયા ઉપાડવાનું શરૂ કરે અને ત્યારબાદ જ્યારે વપરાશકર્તા રૂ. 2000 ઉપાડે તો પ્રોગ્રામ ``પૂરતું ભંડોળ નથી'' એક્સેપ્શન(exception) આપે.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Banking Application}]
class InsufficientFundException extends Exception {
    public InsufficientFundException(String message) {
        super(message);
    }
}

class BankAccount {
    private double balance;
    
    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }
    
    public void deposit(double amount) {
        balance += amount;
        System.out.println("જમા કર્યું: રૂ." + amount);
        System.out.println("વર્તમાન બેલેન્સ: રૂ." + balance);
    }
    
    public void withdraw(double amount) throws InsufficientFundException {
        if (amount > balance) {
            throw new InsufficientFundException("પૂરતું ભંડોળ નથી");
        }
        balance -= amount;
        System.out.println("ઉપાડ્યું: રૂ." + amount);
        System.out.println("બાકી બેલેન્સ: રૂ." + balance);
    }
    
    public double getBalance() { return balance; }
}

public class BankingApplication {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(0);
        try {
            account.deposit(25000);
            account.withdraw(20000);
            account.withdraw(4000);
            account.withdraw(2000); // Throws exception
        } catch (InsufficientFundException e) {
            System.out.println("Exception: " + e.getMessage());
            System.out.println("ઉપલબ્ધ બેલેન્સ: રૂ." + account.getBalance());
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Custom Throw Try-catch Message, Deposit Withdraw Check Handle}
\end{mnemonicbox}

\questionmarks{4(અ OR)}{3}{થ્રેડના સંપૂર્ણ જીવનચક્રનું વર્ણન કરો.}

\begin{solutionbox}
\textbf{Thread Lifecycle States:}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (new) {New};
    \node [gtu state, right=of new] (runnable) {Runnable};
    \node [gtu state, right=of runnable] (running) {Running};
    \node [gtu state, below=of running] (blocked) {Blocked};
    \node [gtu state, right=of running] (dead) {Dead};

    \path [gtu arrow] (new) -- node[font=\tiny] {start()} (runnable);
    \path [gtu arrow] (runnable) -- node[font=\tiny] {scheduler} (running);
    \path [gtu arrow] (running) -- node[font=\tiny] {yield} (runnable);
    \path [gtu arrow] (running) -- node[font=\tiny, left] {wait/sleep} (blocked);
    \path [gtu arrow] (blocked) -| node[font=\tiny, near start] {notify/timeout} (runnable);
    \path [gtu arrow] (running) -- node[font=\tiny] {end} (dead);
\end{tikzpicture}
\captionof{figure}{Thread Lifecycle}
\end{center}

\begin{itemize}
    \item \textbf{New}: Thread object બન્યો પણ start થયો નથી
    \item \textbf{Runnable}: Thread run થવા માટે તૈયાર
    \item \textbf{Running}: Thread હાલમાં execute થઈ રહ્યો છે
    \item \textbf{Blocked}: Thread રાહ જોઈ રહ્યો
    \item \textbf{Dead}: Thread execution પૂર્ણ થયું
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{New Runnable Running Blocked Dead}
\end{mnemonicbox}

\questionmarks{4(બ OR)}{4}{એક્સેસ સ્પેસીફાયરની યાદી બનાવો અને Java માં તેમના હેતુનું વર્ણન કરો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{એક્સેસ સ્પેસિફાયર}
\begin{tabulary}{\linewidth}{|L|C|C|C|C|}
\hline
\textbf{એક્સેસ સ્પેસિફાયર} & \textbf{ક્લાસ} & \textbf{પેકેજ} & \textbf{સબક્લાસ} & \textbf{જગત} \\ \hline
private & \checkmark{} & $\times$ & $\times$ & $\times$ \\ \hline
default & \checkmark{} & \checkmark{} & $\times$ & $\times$ \\ \hline
protected & \checkmark{} & \checkmark{} & \checkmark{} & $\times$ \\ \hline
public & \checkmark{} & \checkmark{} & \checkmark{} & \checkmark{} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Private Encapsulates, Default Packages, Protected inherits, Public Universal}
\end{mnemonicbox}

\questionmarks{4(ક OR)}{7}{Java પ્રોગ્રામ લખો જે 2 થ્રેડો ચલાવે છે દર થ્રેડ એક 1000 મીલીસેકન્ડે ``થ્રેડ --I'' ને પ્રિન્ટ કરે છે, બીજો થ્રેડ દર 2000 મીલીસેકન્ડે -- થ્રેડ ``II'' ને પ્રિન્ટ કરે છે. થ્રેડ Class ને એક્સટેન્ડ કરીને થ્રેડ બનાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={Multithreading Demo}]
class Thread1 extends Thread {
    public void run() {
        try {
            for (int i = 1; i <= 10; i++) {
                System.out.println("Thread1 - Count: " + i);
                Thread.sleep(1000); // 1000 ms
            }
        } catch (InterruptedException e) {
            System.out.println("Thread1 interrupted");
        }
    }
}

class Thread2 extends Thread {
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Thread2 - Count: " + i);
                Thread.sleep(2000); // 2000 ms
            }
        } catch (InterruptedException e) {
            System.out.println("Thread2 interrupted");
        }
    }
}

public class MultiThreadDemo {
    public static void main(String[] args) {
        Thread1 t1 = new Thread1();
        Thread2 t2 = new Thread2();
        
        System.out.println("Starting threads...");
        t1.start();
        t2.start();
        
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            System.out.println("Main interrupted");
        }
        System.out.println("Done");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Extend Run Sleep Start Join}
\end{mnemonicbox}

\questionmarks{5(અ)}{3}{સ્ટ્રીમ ક્લાસ શું છે? સ્ટ્રીમ ક્લાસ કેવી રીતે વર્ગીકૃત કરવામાં આવે છે?}

\begin{solutionbox}
\textbf{Stream Class વ્યાખ્યા:} Java માં Stream classes input અને output operations handle કરે છે.

\textbf{Stream Classification:}
\begin{itemize}
    \item \textbf{Direction}: Input vs Output
    \item \textbf{Data Type}: Byte vs Character
\end{itemize}

\begin{center}
\captionof{table}{Stream Types}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Type} & \textbf{Purpose} & \textbf{Examples} \\ \hline
InputStream & Bytes વાંચવા & FileInputStream \\ \hline
OutputStream & Bytes લખવા & FileOutputStream \\ \hline
Reader & Characters વાંચવા & FileReader \\ \hline
Writer & Characters લખવા & FileWriter \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Direction Data-type Functionality}
\end{mnemonicbox}

\questionmarks{5(બ)}{4}{ઉદાહરણ સાથે મેથડ ઓવરરાઇડિંગનો હેતુ સમજાવો.}

\begin{solutionbox}
\textbf{Method Overriding નો હેતુ:} Subclass ને specific implementation આપવા માટે.

\begin{lstlisting}[language=Java, caption={Overriding Purpose}]
class Shape {
    public void draw() { System.out.println("Drawing generic shape"); }
}

class Circle extends Shape {
    @Override
    public void draw() { System.out.println("Drawing circle"); }
}

class Rectangle extends Shape {
    @Override
    public void draw() { System.out.println("Drawing rectangle"); }
}

public class OverridingDemo {
    public static void main(String[] args) {
        Shape s1 = new Circle();
        Shape s2 = new Rectangle();
        s1.draw(); // Calls Circle's draw
        s2.draw(); // Calls Rectangle's draw
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Runtime Specific Flexibility Dynamic}
\end{mnemonicbox}

\questionmarks{5(ક)}{7}{Abc.txt નામની ટેક્સ્ટ ફાઇલ પર વાંચવા અને લખવાની કામગીરી કરવા માટેનો Java પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={File Operations}]
import java.io.*;

public class FileOperations {
    public static void main(String[] args) {
        String fileName = "Abc.txt";
        
        try {
            // Write
            FileWriter writer = new FileWriter(fileName);
            writer.write("Hello, this is Java file handling.\n");
            writer.write("End of file content.");
            writer.close();
            System.out.println("Data written successfully.");
            
            // Read
            FileReader reader = new FileReader(fileName);
            BufferedReader bufferedReader = new BufferedReader(reader);
            System.out.println("Reading from file:");
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                System.out.println(line);
            }
            bufferedReader.close();
        } catch (IOException e) {
            System.out.println("IO Error: " + e.getMessage());
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Create Perform Handle Close}
\end{mnemonicbox}

\questionmarks{5(અ OR)}{3}{ઇનપુટ સ્ટ્રીમ સમજાવો.}

\begin{solutionbox}
\textbf{InputStream}: Abstract class જે bytes ના input stream ને represent કરે છે.

\textbf{Methods:}
\begin{itemize}
    \item \code{read()}: Reads single byte
    \item \code{read(byte[])}: Reads bytes into array
    \item \code{close()}: Closes the stream
    \item \code{available()}: Returns estimated available bytes
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Abstract Byte Input Resource}
\end{mnemonicbox}

\questionmarks{5(બ OR)}{4}{Java માં પેકેજ વ્યાખ્યાયિત કરો. યોગ્ય સીન્ટેક્સ અને એક ઉદાહરણ સાથે Java માં પેકેજ કેવી રીતે ઇમ્પ્લીમેન્ટ કરી શકાય તે લખો.}

\begin{solutionbox}
\textbf{Package}: Namespace જે classes organize કરે છે.

\textbf{Steps:}
\begin{itemize}
    \item \textbf{Declare}: \code{package name;}
    \item \textbf{Directory}: Create folder matching package name
    \item \textbf{Compile}: Use \code{javac -d . File.java}
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Namespace Access Organization Reusability}
\end{mnemonicbox}

\questionmarks{5(ક OR)}{7}{List નો ઉપયોગ દર્શાવવા માટે Java મા પ્રોગ્રામ લખો. 1) ArrayList બનાવો અને અઠવાડિયાના દિવસો ઉમેરો (સ્ટ્રિંગ સ્વરૂપમા) 2) LinkedList બનાવો અને મહિના ઉમેરો (સ્ટ્રિંગ સ્વરૂપમા) બંને List ને ડિસ્પ્લે કરો.}

\begin{solutionbox}
\begin{lstlisting}[language=Java, caption={List Demo}]
import java.util.*;

public class ListDemo {
    public static void main(String[] args) {
        // 1. ArrayList for Weekdays
        ArrayList<String> weekdays = new ArrayList<>();
        weekdays.add("Monday");
        weekdays.add("Tuesday");
        weekdays.add("Wednesday");
        
        System.out.println("Weekdays (ArrayList):");
        for(String day : weekdays) System.out.println(day);
        
        // 2. LinkedList for Months
        LinkedList<String> months = new LinkedList<>();
        months.add("January");
        months.add("February");
        months.add("March");
        
        System.out.println("\nMonths (LinkedList):");
        for(String month : months) System.out.println(month);
        
        // Extra operations
        System.out.println("\nFirst Month: " + months.getFirst());
        System.out.println("ArrayList Size: " + weekdays.size());
    }
}
\end{lstlisting}

\begin{center}
\captionof{table}{ArrayList vs LinkedList}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{ArrayList} & \textbf{LinkedList} \\ \hline
Structure & Dynamic Array & Doubly Linked List \\ \hline
Access & Fast O(1) & Slow O(n) \\ \hline
Insert/Delete & Slow (Shift needed) & Fast (Ptr change) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Dynamic Ordered Duplicate Index-based}
\end{mnemonicbox}

\end{document}
