\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/english-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{Java Programming (4343203) -- Winter 2024 Solution}
\date{November 22, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{List out various Primitive data types in Java.}

\begin{solutionbox}
Java offers eight primitive data types for storing simple values directly in memory.

\begin{center}
\captionof{table}{Java Primitive Data Types}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Data Type} & \textbf{Size} & \textbf{Description} & \textbf{Range} \\ \hline
byte & 8 bits & Integer type & -128 to 127 \\ \hline
short & 16 bits & Integer type & -32,768 to 32,767 \\ \hline
int & 32 bits & Integer type & -$2^{31}$ to $2^{31}-1$ \\ \hline
long & 64 bits & Integer type & -$2^{63}$ to $2^{63}-1$ \\ \hline
float & 32 bits & Floating-point & Single precision \\ \hline
double & 64 bits & Floating-point & Double precision \\ \hline
char & 16 bits & Character & Unicode characters \\ \hline
boolean & 1 bit & Logical & true or false \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BILFDC-B: Byte Int Long Float Double Char Boolean types}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Explain Structure of Java Program with suitable example.}

\begin{solutionbox}
Java program structure follows a specific organization with package declarations, imports, class definitions, and methods.

\begin{center}
\begin{tikzpicture}[
    node distance=0.5cm,
    box/.style={draw, rectangle, minimum width=5cm, align=left, fill=white, inner sep=5pt}
]
    \node[box] (doc) {Documentation Comments};
    \node[box, below=of doc] (pkg) {Package Declaration};
    \node[box, below=of pkg] (imp) {Import Statements};
    
    \node[box, below=of imp, minimum height=3cm] (cls) {};
    \node[anchor=north west] at (cls.north west) {\textbf{Class Declaration}};
    
    \node[box, minimum width=4cm, below=0.5cm of cls.north] (vars) {Variables};
    \node[box, minimum width=4cm, below=0cm of vars] (cons) {Constructors};
    \node[box, minimum width=4cm, below=0cm of cons] (meth) {Methods};

    \path [gtu arrow] (doc) -- (pkg);
    \path [gtu arrow] (pkg) -- (imp);
    \path [gtu arrow] (imp) -- (cls);
\end{tikzpicture}
\captionof{figure}{Java Program Structure}
\end{center}

\begin{lstlisting}[language=Java,caption={Java Program Structure Example}]
// Documentation comment
/**
 * Simple program to demonstrate Java structure
 * @author GTU Student
 */

// Package declaration
package com.example;

// Import statements
import java.util.Scanner;

// Class declaration
public class HelloWorld {
    // Variable declaration
    private String message;
    
    // Constructor
    public HelloWorld() {
        message = "Hello, World!";
    }
    
    // Method
    public void displayMessage() {
        System.out.println(message);
    }
    
    // Main method
    public static void main(String[] args) {
        HelloWorld obj = new HelloWorld();
        obj.displayMessage();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PICOM: Package Import Class Objects Methods in order}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{List arithmetic operators in Java. Develop a Java program using any three arithmetic operators and show the output of program.}

\begin{solutionbox}
Arithmetic operators in Java perform mathematical operations on numeric values.

\begin{center}
\captionof{table}{Java Arithmetic Operators}
\begin{tabulary}{\linewidth}{|C|L|L|}
\hline
\textbf{Operator} & \textbf{Description} & \textbf{Example} \\ \hline
+ & Addition & a + b \\ \hline
- & Subtraction & a - b \\ \hline
* & Multiplication & a * b \\ \hline
/ & Division & a / b \\ \hline
\% & Modulus (Remainder) & a \% b \\ \hline
++ & Increment & a++ or ++a \\ \hline
-- & Decrement & a-- or --a \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Arithmetic Operators Demo}]
public class ArithmeticDemo {
    public static void main(String[] args) {
        int a = 10;
        int b = 3;
        
        // Addition
        int sum = a + b;
        
        // Multiplication
        int product = a * b;
        
        // Modulus
        int remainder = a % b;
        
        // Display results
        System.out.println("Values: a = " + a + ", b = " + b);
        System.out.println("Addition (a + b): " + sum);
        System.out.println("Multiplication (a * b): " + product);
        System.out.println("Modulus (a % b): " + remainder);
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SAME: Sum Addition Multiply Exponentiation basic operations}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{Write syntax of Java for loop statement. Develop a Java program to find out prime number between 1 to 10.}

\begin{solutionbox}
The for loop in Java provides a compact way to iterate over a range of values.

\textbf{Syntax:}
\begin{lstlisting}[language=Java,caption={For Loop Syntax},numbers=none]
for (initialization; condition; increment/decrement) {
    // statements to be executed
}
\end{lstlisting}

\begin{lstlisting}[language=Java,caption={Prime Numbers Program}]
public class PrimeNumbers {
    public static void main(String[] args) {
        System.out.println("Prime numbers between 1 and 10:");
        
        // Check each number from 1 to 10
        for (int num = 1; num <= 10; num++) {
            boolean isPrime = true;
            
            // Check if num is divisible by any number from 2 to num-1
            if (num > 1) {
                for (int i = 2; i < num; i++) {
                    if (num % i == 0) {
                        isPrime = false;
                        break;
                    }
                }
                
                // Print if prime
                if (isPrime) {
                    System.out.print(num + " ");
                }
            }
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ICE: Initialize, Check, Execute steps of for loop}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{List the differences between Procedure-Oriented Programming (POP) and Object-Oriented Programming (OOP).}

\begin{solutionbox}
Procedure-Oriented and Object-Oriented Programming represent fundamentally different programming paradigms.

\begin{center}
\captionof{table}{POP vs OOP}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{Procedure-Oriented} & \textbf{Object-Oriented} \\ \hline
Focus & Functions/Procedures & Objects \\ \hline
Data & Separate from functions & Encapsulated in objects \\ \hline
Security & Less secure & More secure with access control \\ \hline
Inheritance & Not supported & Supported \\ \hline
Reusability & Less reusable & Highly reusable \\ \hline
Complexity & Simpler for small programs & Better for complex systems \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Organization}: POP divides into functions; OOP groups into objects
    \item \keyword{Approach}: POP follows top-down; OOP follows bottom-up
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FIOS: Functions In Objects Structure key difference}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Explain static keyword with example.}

\begin{solutionbox}
The \code{static} keyword in Java creates class-level members shared across all objects of that class.

\begin{center}
\captionof{table}{Uses of static Keyword}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Use} & \textbf{Purpose} & \textbf{Example} \\ \hline
static variable & Shared across all objects & \code{static int count;} \\ \hline
static method & Can be called without object & \code{static void display()} \\ \hline
static block & Executed when class loads & \code{static \{ // code \}} \\ \hline
static nested class & Associated with outer class & \code{static class Inner \{\}} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Static Keyword Example}]
public class Counter {
    // Static variable shared by all objects
    static int count = 0;
    
    // Instance variable unique to each object
    int instanceCount = 0;
    
    // Constructor
    Counter() {
        count++;         // Increments the shared count
        instanceCount++; // Increments this object's count
    }
    
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
        Counter c3 = new Counter();
        
        System.out.println("Static count: " + Counter.count);
        System.out.println("c1's instance count: " + c1.instanceCount);
        System.out.println("c2's instance count: " + c2.instanceCount);
        System.out.println("c3's instance count: " + c3.instanceCount);
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CBMS: Class-level, Before objects, Memory single, Shared by all}
\end{mnemonicbox}


\questionmarks{2(c)}{7}{Define Constructor. List types of Constructors. Develop a java code to explain Parameterized constructor.}

\begin{solutionbox}
A constructor is a special method with the same name as its class, used to initialize objects when created.

\textbf{Types of Constructors:}
\begin{center}
\captionof{table}{Constructor Types in Java}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Type} & \textbf{Description} & \textbf{Example} \\ \hline
Default & No parameters, created by compiler & \code{Student() \{\}} \\ \hline
No-arg & Explicitly defined, no parameters & \code{Student() \{ name = ``Unk''; \}} \\ \hline
Parameterized & Accepts parameters & \code{Student(String n) \{ name = n; \}} \\ \hline
Copy & Creates object from another object & \code{Student(Student s) \{ \ldots \}} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Parameterized Constructor Example}]
public class Student {
    // Instance variables
    private String name;
    private int age;
    private String course;
    
    // Parameterized constructor
    public Student(String name, int age, String course) {
        this.name = name;
        this.age = age;
        this.course = course;
    }
    
    // Method to display student details
    public void displayDetails() {
        System.out.println("Student Details:");
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("Course: " + course);
    }
    
    // Main method for demonstration
    public static void main(String[] args) {
        // Creating object using parameterized constructor
        Student student1 = new Student("John", 20, "Computer Science");
        student1.displayDetails();
        
        // Another student
        Student student2 = new Student("Lisa", 22, "Engineering");
        student2.displayDetails();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{IDCR: Initialize Data Create Ready objects}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{List the basic OOP concepts in Java and explain any one.}

\begin{solutionbox}
Java implements Object-Oriented Programming through several fundamental concepts.

\begin{center}
\captionof{table}{Basic OOP Concepts in Java}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Concept} & \textbf{Description} \\ \hline
Encapsulation & Binding data and methods together \\ \hline
Inheritance & Creating new classes from existing ones \\ \hline
Polymorphism & One interface, multiple implementations \\ \hline
Abstraction & Hiding implementation details \\ \hline
Association & Relationship between objects \\ \hline
\end{tabulary}
\end{center}

\textbf{Encapsulation Example:}
\begin{lstlisting}[language=Java,caption={Encapsulation Example}]
public class Person {
    // Private data - hidden from outside
    private String name;
    private int age;
    
    // Public methods - interface to access data
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setAge(int age) {
        // Validation ensures data integrity
        if (age > 0 && age < 120) {
            this.age = age;
        } else {
            System.out.println("Invalid age");
        }
    }
}
\end{lstlisting}

\begin{itemize}
    \item \keyword{Data Hiding}: Private variables inaccessible from outside
    \item \keyword{Controlled Access}: Through public methods (getters/setters)
    \item \keyword{Integrity}: Data validation ensures correct values
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EIPA: Encapsulate Inherit Polymorphize Abstract}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{Explain final keyword with example.}

\begin{solutionbox}
The \code{final} keyword in Java restricts changes to entities, creating constants, unchangeable methods, and non-inheritable classes.

\begin{center}
\captionof{table}{Uses of final Keyword}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Use} & \textbf{Effect} & \textbf{Example} \\ \hline
final variable & Cannot be modified & \code{final int MAX = 100;} \\ \hline
final method & Cannot be overridden & \code{final void display() \{\}} \\ \hline
final class & Cannot be extended & \code{final class Math \{\}} \\ \hline
final parameter & Cannot be changed & \code{void m(final int x) \{\}} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Final Keyword Usage}]
public class FinalDemo {
    // Final variable (constant)
    final int MAX_SPEED = 120;
    
    // Final method cannot be overridden
    final void showLimit() {
        System.out.println("Speed limit: " + MAX_SPEED);
    }
    
    public static void main(String[] args) {
        FinalDemo car = new FinalDemo();
        car.showLimit();
        
        // car.MAX_SPEED = 150; // Compile error
    }
}

// Final class cannot be extended
final class MathUtil {
    public int square(int num) { return num * num; }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{VMP: Variables Methods Permanence with final}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Write scope of java access modifier. Develop a java code to explain public modifier.}

\begin{solutionbox}
Access modifiers in Java control visibility and accessibility of classes, methods, and variables.

\begin{center}
\captionof{table}{Java Access Modifier Scope}
\begin{tabulary}{\linewidth}{|L|C|C|C|C|}
\hline
\textbf{Modifier} & \textbf{Class} & \textbf{Package} & \textbf{Subclass} & \textbf{World} \\ \hline
private & $\checkmark$ & $\times$ & $\times$ & $\times$ \\ \hline
default & $\checkmark$ & $\checkmark$ & $\times$ & $\times$ \\ \hline
protected & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\times$ \\ \hline
public & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Public Modifier Example}]
// File: PublicDemo.java
package com.example;

public class PublicDemo {
    public String message = "Hello, World!";
    
    public void displayMessage() {
        System.out.println(message);
    }
}

// File: Main.java
package com.test;
import com.example.PublicDemo;

public class Main {
    public static void main(String[] args) {
        // Creating object of class from different package
        PublicDemo demo = new PublicDemo();
        
        // Accessing public variable and method
        System.out.println("Message: " + demo.message);
        demo.displayMessage();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEPM: Class Everywhere Public Most accessible}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{List out different types of inheritance and explain any one with example.}

\begin{solutionbox}
Inheritance enables a class to inherit attributes and behaviors from another class.

\begin{center}
\captionof{table}{Types of Inheritance in Java}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Type} & \textbf{Description} \\ \hline
Single & One class extends one class \\ \hline
Multilevel & Chain of inheritance (A$\rightarrow$B$\rightarrow$C) \\ \hline
Hierarchical & Multiple classes extend one class \\ \hline
Multiple & One class inherits from multiple classes (via interfaces) \\ \hline
Hybrid & Combination of multiple inheritance types \\ \hline
\end{tabulary}
\end{center}

\textbf{Single Inheritance Example:}
\begin{lstlisting}[language=Java,caption={Single Inheritance}]
// Parent class
class Animal {
    protected String name;
    public Animal(String name) { this.name = name; }
    public void eat() { System.out.println(name + " is eating"); }
}

// Child class
class Dog extends Animal {
    private String breed;
    public Dog(String name, String breed) {
        super(name);
        this.breed = breed;
    }
    public void bark() { System.out.println(name + " is barking"); }
}

public class InheritanceDemo {
    public static void main(String[] args) {
        Dog dog = new Dog("Max", "Labrador");
        dog.eat();     // Inherited method
        dog.bark();    // Own method
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SMHMH: Single Multilevel Hierarchical Multiple Hybrid types}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Explain any two String buffer class methods with suitable example.}

\begin{solutionbox}
StringBuffer is a mutable sequence of characters used for modifying strings, offering various manipulation methods.

\begin{center}
\captionof{table}{Two StringBuffer Methods}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Method} & \textbf{Purpose} & \textbf{Syntax} \\ \hline
append() & Adds string at the end & \code{sb.append(String str)} \\ \hline
insert() & Adds string at specified position & \code{sb.insert(int offset, String str)} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={StringBuffer Methods}]
public class StringBufferMethodsDemo {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("Hello");
        
        // append() method
        sb.append(" World");
        System.out.println("After append: " + sb);
        
        // insert() method
        sb.insert(0, "Java ");
        System.out.println("After insert: " + sb);
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{AIMS: Append Insert Modify StringBuffer}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Define Interface. Write a java program to demonstrate multiple inheritance using interface.}

\begin{solutionbox}
An interface is a contract that declares methods a class must implement, enabling multiple inheritance in Java. It contains only constants, method signatures, default methods, and static methods.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu interface] (P) {\textit{$\ll$interface$\gg$}\\Printable};
    \node [gtu interface, right=2cm of P] (S) {\textit{$\ll$interface$\gg$}\\Scannable};
    \node [gtu class, below right=1.5cm and -1cm of P] (D) {Device};

    \path [gtu dashed arrow] (D) -- (P);
    \path [gtu dashed arrow] (D) -- (S);
\end{tikzpicture}
\captionof{figure}{Multiple Inheritance using Interfaces}
\end{center}

\begin{lstlisting}[language=Java,caption={Multiple Inheritance Example}]
interface Printable {
    void print();
}

interface Scannable {
    void scan();
}

class Device implements Printable, Scannable {
    private String model;
    
    public Device(String model) { this.model = model; }
    
    @Override
    public void print() {
        System.out.println(model + " is printing");
    }
    
    @Override
    public void scan() {
        System.out.println(model + " is scanning");
    }
}

public class MultipleInheritanceDemo {
    public static void main(String[] args) {
        Device device = new Device("HP LaserJet");
        device.print();
        device.scan();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{IMAC: Interface Multiple Abstract Contract}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{Give differences between Abstract class and Interface.}

\begin{solutionbox}
Abstract classes and interfaces are both used for abstraction but differ in several key aspects.

\begin{center}
\captionof{table}{Abstract Class vs Interface}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{Abstract Class} & \textbf{Interface} \\ \hline
Keyword & \code{abstract} & \code{interface} \\ \hline
Methods & Both abstract and concrete & Abstract (and default since Java 8) \\ \hline
Variables & Any type & Only public static final \\ \hline
Constructor & Has & Doesn't have \\ \hline
Inheritance & Single & Multiple \\ \hline
Access Modifiers & Any & Only public \\ \hline
Purpose & Partial implementation & Complete abstraction \\ \hline
\end{tabulary}
\end{center}

\begin{itemize}
    \item \keyword{Implementation}: Abstract classes can provide partial implementation; interfaces traditionally provide none
    \item \keyword{Relationship}: Abstract class says ``is-a''; interface says ``can-do-this''
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MAPS: Methods Access Purpose Single vs multiple}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Explain any two String class methods with suitable example.}

\begin{solutionbox}
The String class offers various methods for string manipulation, comparison, and transformation.

\begin{center}
\captionof{table}{Two String Methods}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Method} & \textbf{Purpose} & \textbf{Syntax} \\ \hline
substring() & Extracts portion of string & \code{str.substring(int begin, int end)} \\ \hline
equals() & Compares string content & \code{str1.equals(str2)} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={String Methods Example}]
public class StringMethodsDemo {
    public static void main(String[] args) {
        String message = "Java Programming";
        
        // substring() method
        String sub1 = message.substring(0, 4); // "Java"
        System.out.println("Substring: " + sub1);
        
        // equals() method
        String str1 = "Hello";
        String str2 = new String("Hello");
        
        System.out.println("equals(): " + str1.equals(str2)); // true
        System.out.println("== operator: " + (str1 == str2)); // false
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SEC: Substring Equals Compare string content}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{Explain package and list out steps to create package with suitable example.}

\begin{solutionbox}
A package in Java is a namespace that organizes related classes and interfaces, preventing naming conflicts.

\textbf{Steps to Create a Package:}
\begin{center}
\captionof{table}{Package Creation Steps}
\begin{tabulary}{\linewidth}{|C|L|}
\hline
\textbf{Step} & \textbf{Action} \\ \hline
1 & Declare package name at the top of source files \\ \hline
2 & Create proper directory structure matching package name \\ \hline
3 & Save Java file in the appropriate directory \\ \hline
4 & Compile with \code{javac -d} option to create package directory \\ \hline
5 & Run the program with fully qualified name \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Package Example}]
// File: Calculator.java
package com.example.math;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

// File: CalculatorApp.java
package com.example.app;
import com.example.math.Calculator;

public class CalculatorApp {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println("Addition: " + calc.add(10, 5));
    }
}
\end{lstlisting}

\textbf{Compilation Commands:}
\begin{lstlisting}[language=bash,caption={Terminal Commands}]
javac -d . Calculator.java
javac -d . CalculatorApp.java
java com.example.app.CalculatorApp
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DISCO: Declare Import Save Compile Organize}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{List types of errors in Java.}

\begin{solutionbox}
Java programs can encounter various errors during development and execution.

\begin{center}
\captionof{table}{Types of Errors in Java}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Error Type} & \textbf{When Occurs} & \textbf{Example} \\ \hline
Compile-time & During compilation & Syntax errors, type errors \\ \hline
Runtime & During execution & NullPointerException \\ \hline
Logical & During execution & Incorrect calculation \\ \hline
Linkage & During class loading & NoClassDefFoundError \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CRLLT: Compile Runtime Logical Linkage Thread errors}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Explain try catch block with example.}

\begin{solutionbox}
The try-catch block in Java handles exceptions, allowing programs to continue executing despite errors.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu block] (try) {Try Block};
    \node [diamond, draw, fill=yellow!10, text width=1.5cm, align=center, below=of try] (dec) {Exception?};
    \node [gtu block, right=2cm of dec] (catch) {Catch Block};
    \node [gtu block, below=2cm of dec] (finally) {Finally Block};

    \path [gtu arrow] (try) -- (dec);
    \path [gtu arrow] (dec) -- node[above] {Yes} (catch);
    \path [gtu arrow] (dec) -- node[right] {No} (finally);
    \path [gtu arrow] (catch) |- (finally);
\end{tikzpicture}
\captionof{figure}{Try-Catch Flow}
\end{center}

\begin{lstlisting}[language=Java,caption={Try-Catch Example}]
public class TryCatchDemo {
    public static void main(String[] args) {
        try {
            int[] numbers = {1, 2, 3};
            System.out.println(numbers[10]); // IndexOutOfBounds
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Exception: " + e.getMessage());
        } finally {
            System.out.println("Finally always executes");
        }
        System.out.println("Program continues");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TCFE: Try Catch Finally Execute despite errors}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{List out any four differences between method overloading and overriding. Write a java code to explain method overriding.}

\begin{solutionbox}
Method overloading and overriding are both forms of polymorphism but differ in functionality and implementation.

\begin{center}
\captionof{table}{Method Overloading vs Overriding}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{Overloading} & \textbf{Overriding} \\ \hline
Occurrence & Same class & Parent \& child classes \\ \hline
Parameters & Different parameters & Same parameters \\ \hline
Return Type & Can be different & Same or covariant \\ \hline
Binding & Compile-time (static) & Runtime (dynamic) \\ \hline
Purpose & Multiple behaviors & Specific implementation \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Method Overriding Example}]
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks");
    }
}

public class OverridingDemo {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound(); // Outputs: Dog barks
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SBRE: Same-name, Base-derived, Runtime-resolution, Extend functionality}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{List any four inbuilt exceptions.}

\begin{solutionbox}
Java provides many built-in exception classes that represent various error conditions.

\begin{center}
\captionof{table}{Four Common Inbuilt Exceptions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Exception} & \textbf{Cause} & \textbf{Package} \\ \hline
NullPointerException & Accessing null reference & java.lang \\ \hline
ArrayIndexOutOfBounds & Invalid array index & java.lang \\ \hline
ArithmeticException & Division by zero & java.lang \\ \hline
ClassCastException & Invalid type casting & java.lang \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NAAC: Null Array Arithmetic Cast common exceptions}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{Explain ``throw'' keyword with suitable example.}

\begin{solutionbox}
The \code{throw} keyword in Java manually generates exceptions for exceptional conditions in programs.

\begin{center}
\captionof{table}{throw Keyword Usage}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Usage} & \textbf{Purpose} \\ \hline
throw new Exception() & Create and throw exception \\ \hline
throw new Exception(msg) & Create with custom message \\ \hline
Inside method & Used to explicitly throw \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Throw Example}]
public class ThrowDemo {
    static void validateAge(int age) {
        if (age < 18) {
            throw new ArithmeticException("Not eligible");
        }
        System.out.println("Eligible to vote");
    }
    
    public static void main(String[] args) {
        try {
            validateAge(15);
        } catch (ArithmeticException e) {
            System.out.println("Exception: " + e.getMessage());
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CET: Create Exception Throw for error handling}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{Compare `this' keyword Vs `Super' keyword. Explain super keyword with suitable Example.}

\begin{solutionbox}
The \code{this} and \code{super} keywords are used for referencing in Java, with distinct purposes and behaviors.

\begin{center}
\captionof{table}{this vs super Comparison}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{this Keyword} & \textbf{super Keyword} \\ \hline
Reference & Current class object & Parent class object \\ \hline
Usage & Access current members & Access parent members \\ \hline
Constructor & \code{this()} calls own & \code{super()} calls parent \\ \hline
Variables & \code{this.var} & \code{super.var} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Java,caption={Super Keyword Example}]
class Vehicle {
    String color = "White";
    Vehicle() { System.out.println("Vehicle created"); }
}

class Car extends Vehicle {
    String color = "Black";
    
    Car() {
        super(); // Call parent constructor
        System.out.println("Car created");
    }
    
    void displayColor() {
        System.out.println("Car color: " + this.color);
        System.out.println("Vehicle color: " + super.color);
    }
}

public class SuperDemo {
    public static void main(String[] args) {
        Car c = new Car();
        c.displayColor();
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PCIM: Parent Class Inheritance Members with super}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{List Different Stream Classes.}

\begin{solutionbox}
Java I/O provides various stream classes for handling input and output operations.

\begin{center}
\captionof{table}{Java Stream Classes}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Category} & \textbf{Stream Classes} \\ \hline
Byte Streams & FileInputStream, FileOutputStream \\ \hline
Character Streams & FileReader, FileWriter \\ \hline
Buffered Streams & BufferedInputStream, BufferedReader \\ \hline
Data Streams & DataInputStream, DataOutputStream \\ \hline
Object Streams & ObjectInputStream, ObjectOutputStream \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BCDOP: Byte Character Data Object Print streams}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Write a java program to develop user defined exception for ``Divide by zero'' error.}

\begin{solutionbox}
User-defined exceptions allow creating custom exception types for application-specific error conditions.

\begin{lstlisting}[language=Java,caption={Custom Exception Example}]
class DivideByZeroException extends Exception {
    public DivideByZeroException(String s) {
        super(s);
    }
}

public class CustomExceptionDemo {
    static int divide(int a, int b) throws DivideByZeroException {
        if (b == 0) throw new DivideByZeroException("Div by 0");
        return a / b;
    }
    
    public static void main(String[] args) {
        try {
            divide(10, 0);
        } catch (DivideByZeroException e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ETC: Extend Throw Catch custom exceptions}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Write a program in Java that reads the content of a file byte by byte and copy it into another file.}

\begin{solutionbox}
File I/O operations in Java allow reading from and writing to files, with byte streams handling binary data.

\begin{lstlisting}[language=Java,caption={File Copy Byte by Byte}]
import java.io.*;

public class FileCopyDemo {
    public static void main(String[] args) {
        FileInputStream in = null;
        FileOutputStream out = null;
        
        try {
            in = new FileInputStream("input.txt");
            out = new FileOutputStream("output.txt");
            
            int c;
            while ((c = in.read()) != -1) {
                out.write(c);
            }
            System.out.println("File copied.");
        } catch(IOException e) {
            System.out.println("Error: " + e);
        } finally {
            try {
                if (in != null) in.close();
                if (out != null) out.close();
            } catch(IOException e) {}
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CROW: Create Read Open Write file operations}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{List different file operations in Java.}

\begin{solutionbox}
Java provides comprehensive file handling capabilities through various file operations.

\begin{center}
\captionof{table}{File Operations in Java}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Operation} & \textbf{Classes Used} \\ \hline
File Creation & File, FileOutputStream, FileWriter \\ \hline
File Reading & FileInputStream, FileReader \\ \hline
File Writing & FileOutputStream, FileWriter \\ \hline
File Deletion & File.delete() \\ \hline
File Rename & File.renameTo() \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CRWD: Create Read Write Delete basic operations}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{Write a java program to explain finally block in exception handling.}

\begin{solutionbox}
The finally block in exception handling ensures code execution regardless of whether an exception occurs.

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu block] (try) {Try Block};
    \node [diamond, draw, fill=yellow!10, text width=1.5cm, align=center, below=of try] (dec) {Exception?};
    \node [gtu block, right=2cm of dec] (catch) {Catch Block};
    \node [gtu block, below=2cm of dec] (finally) {Finally Block};

    \path [gtu arrow] (try) -- (dec);
    \path [gtu arrow] (dec) -- node[above] {Yes} (catch);
    \path [gtu arrow] (dec) -- node[right] {No} (finally);
    \path [gtu arrow] (catch) |- (finally);
\end{tikzpicture}
\captionof{figure}{Finally Block Flow}
\end{center}

\begin{lstlisting}[language=Java,caption={Finally Block Example}]
public class FinallyDemo {
    public static void main(String[] args) {
        try {
            int data = 25 / 0;
            System.out.println(data);
        } catch (ArithmeticException e) {
            System.out.println(e);
        } finally {
            System.out.println("finally block is always executed");
        }
        System.out.println("rest of the code...");
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ACRE: Always Cleanup Resources Executes}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{Write a java program to create a file and perform write operation on this file.}

\begin{solutionbox}
Java provides several ways to create files and write data to them using character or byte streams.

\begin{lstlisting}[language=Java,caption={File Write Example}]
import java.io.FileWriter;
import java.io.IOException;

public class FileWriteDemo {
    public static void main(String[] args) {
        try {
            FileWriter writer = new FileWriter("output.txt");
            writer.write("Hello World!\n");
            writer.write("This is a Java file write operation.");
            writer.close();
            System.out.println("Successfully wrote to the file.");
        } catch (IOException e) {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{COWS: Create Open Write Save file operations}
\end{mnemonicbox}

\end{document}
