\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}

\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{પાયથોન પ્રોગ્રામિંગ (1323203) - શિયાળુ 2023 સોલ્યુશન}
\date{20 જાન્યુઆરી, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{આપેલ નંબર પોઝિટિવ છે કે નેગેટિવ તે તપાસવા માટે સ્યૂડો કોડ લખો}

\begin{solutionbox}
\begin{lstlisting}[caption={Pseudocode for Number Check}]
BEGIN
    Input number
    IF number > 0 THEN
        Display "Number is positive"
    ELSE IF number < 0 THEN
        Display "Number is negative"
    ELSE
        Display "Number is zero"
    END IF
END
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{શૂન્ય સાથે સરખાવો}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{એલ્ગોરિધમ વ્યાખ્યાયિત કરો અને ત્રણ નંબર માંથી મહત્તમ નંબર શોધવાનો એલ્ગોરિધમ બનાવો.}

\begin{solutionbox}
\textbf{Algorithm વ્યાખ્યા}: એલ્ગોરિધમ એટલે ચોક્કસ સમસ્યાને ઉકેલવા માટે અથવા ગણતરી કરવા માટે બનાવેલ સ્ટેપ-બાય-સ્ટેપ પ્રક્રિયા અથવા નિયમોનો સેટ.

\textbf{ત્રણ નંબરમાંથી મહત્તમ શોધવાનો એલ્ગોરિધમ}:

\begin{lstlisting}[caption={Algorithm for Maximum of Three Numbers}]
BEGIN
    Input num1, num2, num3
    Set max = num1
    IF num2 > max THEN
        Set max = num2
    END IF
    IF num3 > max THEN
        Set max = num3
    END IF
    Display max
END
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=of start] (input) {Input num1, num2, num3};
    \node [gtu block, below=of input] (init) {Set max = num1};
    \node [gtu decision, below=of init] (cond1) {Is num2 $>$ max?};
    \node [gtu block, right=of cond1] (set2) {Set max = num2};
    \node [gtu decision, below=of cond1] (cond2) {Is num3 $>$ max?};
    \node [gtu block, right=of cond2] (set3) {Set max = num3};
    \node [gtu block, below=of cond2] (disp) {Display max};
    \node [gtu state, below=of disp] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (init);
    \path [gtu arrow] (init) -- (cond1);
    \path [gtu arrow] (cond1) -- node {Yes} (set2);
    \path [gtu arrow] (cond1) -- node {No} (cond2);
    \path [gtu arrow] (set2) |- (cond2);
    \path [gtu arrow] (cond2) -- node {Yes} (set3);
    \path [gtu arrow] (cond2) -- node {No} (disp);
    \path [gtu arrow] (set3) |- (disp);
    \path [gtu arrow] (disp) -- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart to Find Maximum of Three Numbers}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{સરખામણી અને બદલો}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{તાપમાન ના સેલ્સિયસ ને ફેરનહાઇટ માં કન્વર્ટ કરવાનો પાયથોન કોડ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Celsius to Fahrenheit Conversion}]
# સેલ્સિયસથી ફેરનહાઇટ રૂપાંતરનો પ્રોગ્રામ

# યુઝર પાસેથી સેલ્સિયસ તાપમાન મેળવો
celsius = float(input("સેલ્સિયસમાં તાપમાન દાખલ કરો: "))

# સૂત્ર વાપરીને ફેરનહાઇટમાં રૂપાંતરિત કરો: F = (C * 9/5) + 32
fahrenheit = (celsius * 9/5) + 32

# પરિણામ દર્શાવો
print(f"{celsius}\u00B0C એ {fahrenheit}\u00B0F ની બરાબર છે")
\end{lstlisting}

\begin{center}
\captionof{table}{તાપમાન રૂપાંતરણ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઘટક} & \textbf{વર્ણન} \\ \hline
\textbf{ઇનપુટ} & સેલ્સિયસમાં તાપમાન \\ \hline
\textbf{સૂત્ર} & F = (C $\times$ 9/5) + 32 \\ \hline
\textbf{આઉટપુટ} & ફેરનહાઇટમાં તાપમાન \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{9થી ગુણાકાર, 5થી ભાગાકાર, 32 ઉમેરો}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{કંપેરિઝન ઓપરેટર નું લિસ્ટ આપો અને દરેકને પાયથોન કોડના ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{પાયથોન કંપેરિઝન ઓપરેટર્સ}
\begin{tabulary}{\linewidth}{|C|L|L|C|}
\hline
\textbf{ઓપરેટર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\ \hline
\textbf{==} & બરાબર છે & \code{5 == 5} & \code{True} \\ \hline
\textbf{!=} & બરાબર નથી & \code{5 != 6} & \code{True} \\ \hline
\textbf{>} & કરતાં મોટું & \code{6 > 3} & \code{True} \\ \hline
\textbf{<} & કરતાં નાનું & \code{3 < 6} & \code{True} \\ \hline
\textbf{>=} & કરતાં મોટું અથવા બરાબર & \code{5 >= 5} & \code{True} \\ \hline
\textbf{<=} & કરતાં નાનું અથવા બરાબર & \code{5 <= 5} & \code{True} \\ \hline
\end{tabulary}
\end{center}

\textbf{Code Example}:

\begin{lstlisting}[language=Python, caption={Comparison Operators Example}]
# પાયથોન કંપેરિઝન ઓપરેટર્સ ઉદાહરણ
a = 10
b = 5

# બરાબર છે
print(f"{a} == {b}: {a == b}")  # False

# બરાબર નથી
print(f"{a} != {b}: {a != b}")  # True

# કરતાં મોટું
print(f"{a} > {b}: {a > b}")    # True

# કરતાં નાનું
print(f"{a} < {b}: {a < b}")    # False

# કરતાં મોટું અથવા બરાબર
print(f"{a} >= {b}: {a >= b}")  # True

# કરતાં નાનું અથવા બરાબર
print(f"{a} <= {b}: {a <= b}")  # False
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{સરખાવો}
\end{mnemonicbox}


\questionmarks{2(a)}{3}{પાયથોન ના ડેટા ટાઇપ સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{પાયથોન ડેટા ટાઇપ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ડેટા ટાઇપ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{int} & પૂર્ણાંક મૂલ્યો & \code{x = 10} \\ \hline
\textbf{float} & દશાંશ બિંદુ મૂલ્યો & \code{y = 10.5} \\ \hline
\textbf{str} & ટેક્સ્ટ અથવા અક્ષર મૂલ્યો & \code{name = "Python"} \\ \hline
\textbf{bool} & તાર્કિક મૂલ્યો (True/False) & \code{is\_valid = True} \\ \hline
\textbf{list} & ક્રમબદ્ધ, બદલી શકાય તેવો સંગ્રહ & \code{nums = [1, 2, 3]} \\ \hline
\textbf{tuple} & ક્રમબદ્ધ, ન બદલી શકાય તેવો સંગ્રહ & \code{point = (5, 10)} \\ \hline
\textbf{dict} & કી-વેલ્યુ જોડી & \code{student = \{"name": "John"\}} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NIFTY SLD: નંબર્સ, ઇન્ટીજર્સ, ફ્લોટ્સ, ટેક્સ્ટ, યસ/નો, સીક્વન્સીસ, લિસ્ટ્સ, ડિક્શનરીઝ}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Nested If પાયથોન કોડ ના ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{Nested if}: એક conditional statement ની અંદર બીજું conditional statement લખવાને nested if કહેવામાં આવે છે. તે ઘણી શરતોને ક્રમમાં તપાસવાની મંજૂરી આપે છે.

\begin{lstlisting}[language=Python, caption={Nested If Example}]
# નંબર પોઝિટિવ, નેગેટિવ કે શૂન્ય છે તે ચકાસવા માટેનો nested if ઉદાહરણ
# અને જો પોઝિટિવ હોય, તો તે સમ છે કે વિષમ તે ચકાસો

num = int(input("એક નંબર દાખલ કરો: "))

if num > 0:
    print("પોઝિટિવ નંબર")
    # nested if જે ચકાસે છે કે પોઝિટિવ નંબર સમ છે કે વિષમ
    if num % 2 == 0:
        print("સમ નંબર")
    else:
        print("વિષમ નંબર")
elif num < 0:
    print("નેગેટિવ નંબર")
else:
    print("શૂન્ય")
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=of start] (input) {Input num};
    \node [gtu decision, below=of input] (cond1) {શું num $>$ 0?};
    \node [gtu block, left=of cond1] (neg) {Print Negative \\ number};
    \node [gtu decision, below=of neg] (cond3) {શું num $<$ 0?};
    \node [gtu block, below=of cond3] (zero) {Print Zero};
    
    \node [gtu block, right=of cond1] (pos) {Print Positive \\ number};
    \node [gtu decision, below=of pos] (cond2) {શું num \% 2 == 0?};
    \node [gtu block, right=of cond2] (even) {Print Even \\ number};
    \node [gtu block, left=of cond2] (odd) {Print Odd \\ number};
    \node [gtu state, below=of zero, yshift=-2cm] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (cond1);
    
    % Positive branch
    \path [gtu arrow] (cond1) -- node {Yes} (pos);
    \path [gtu arrow] (pos) -- (cond2);
    \path [gtu arrow] (cond2) -- node {Yes} (even);
    \path [gtu arrow] (cond2) -- node {No} (odd);
    
    % Negative/Zero branch
    \path [gtu arrow] (cond1) -- node {No} (cond3);
    \path [gtu arrow] (cond3) -- node {Yes} (neg);
    \path [gtu arrow] (cond3) -- node {No} (zero);
    
    \path [gtu arrow] (even) |- (end);
    \path [gtu arrow] (odd) |- (end);
    \path [gtu arrow] (neg) |- (end);
    \path [gtu arrow] (zero) -- (end);
\end{tikzpicture}
\captionof{figure}{Nested If Flowchart}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ચેક અંદર ચેક}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{ઉદાહરણ સાથે વિવિધ પ્રકારના પસંદગી/નિર્ણય લેવાના ફ્લો-ઓફ-કંટ્રોલ સ્ટ્રક્ચર ઉપયોગ સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{પાયથોનમાં સિલેક્શન કંટ્રોલ સ્ટ્રક્ચર્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{સ્ટ્રક્ચર} & \textbf{હેતુ} & \textbf{વપરાશ} \\ \hline
\textbf{if} & શરત સાચી હોય ત્યારે કોડ ચલાવવા & સરળ શરત ચકાસણી \\ \hline
\textbf{if-else} & સાચી શરત માટે એક કોડ, ખોટી માટે બીજો & દ્વિ નિર્ણય લેવા \\ \hline
\textbf{if-elif-else} & ઘણી શરતો ચકાસવી & ઘણા સંભવિત પરિણામો \\ \hline
\textbf{Nested if} & શરત અંદર બીજી શરત & જટિલ શ્રેણીબદ્ધ નિર્ણયો \\ \hline
\textbf{Ternary operator} & એક લાઇન if-else & સરળ શરતી નિયુક્તિ \\ \hline
\end{tabulary}
\end{center}

\textbf{Code Example}:

\begin{lstlisting}[language=Python, caption={Selection Structures Example}]
# વિવિધ સિલેક્શન સ્ટ્રક્ચર્સનું ઉદાહરણ
score = int(input("તમારો સ્કોર દાખલ કરો: "))

# સાદું if
if score >= 90:
    print("ઉત્તમ!")

# if-else
if score >= 60:
    print("તમે પાસ થયા છો.")
else:
    print("તમે નાપાસ થયા છો.")

# if-elif-else
if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
elif score >= 60:
    grade = "D"
else:
    grade = "F"
print(f"તમારો ગ્રેડ {grade} છે")

# Ternary operator
result = "પાસ" if score >= 60 else "નાપાસ"
print(result)
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SCENE: સિમ્પલ if, કન્ડિશન્સ વિથ else, Elif ફોર મલ્ટિપલ, Nested ફોર કોમ્પ્લેક્સ, એક્સપ્રેસ વિથ ટર્નરી}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{વેરિયેબલ વ્યાખ્યાયિત કરવાના નિયમો લિસ્ટ કરો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{પાયથોનમાં વેરિએબલ્સ વ્યાખ્યાયિત કરવાના નિયમો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{નિયમ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{અક્ષર અથવા અન્ડરસ્કોરથી શરૂ કરો} & પ્રથમ અક્ષર એક લેટર અથવા અન્ડરસ્કોર હોવો જોઈએ & \code{name = "John"}, \code{\_count = 10} \\ \hline
\textbf{કોઈ ખાસ અક્ષરો નહીં} & માત્ર અક્ષરો, અંકો અને અન્ડરસ્કોર માન્ય & \code{user\_name} (માન્ય), \code{user-name} (અમાન્ય) \\ \hline
\textbf{કેસ સેન્સિટિવ} & મોટા અક્ષરો અને નાના અક્ષરો અલગ & \code{age} અને \code{Age} અલગ વેરિએબલ્સ છે \\ \hline
\textbf{રિઝર્વ્ડ કીવર્ડ્સ નહીં} & પાયથોન કીવર્ડ્સને વેરિએબલ નામ તરીકે ઉપયોગ ન કરી શકાય & \code{if}, \code{for}, \code{while}, વગેરે \\ \hline
\textbf{સ્પેસ નહીં} & સ્પેસને બદલે અન્ડરસ્કોર વાપરો & \code{first\_name} (\code{first name} નહીં) \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SILKS: શરૂઆત યોગ્ય રીતે, ઇગ્નોર સ્પેશિયલ કેરેક્ટર, લૂક એટ કેસ, કીવર્ડ્સ અવોઇડ, સ્પેસ નોટ અલાઉડ}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{ફોર લૂપ ને જરૂરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{પાયથોનમાં For Loop}: for લૂપનો ઉપયોગ કોઈ sequence (લિસ્ટ, ટપલ, સ્ટ્રીંગ) અથવા અન્ય iterable ઓબ્જેક્ટ પર પુનરાવર્તન કરવા માટે થાય છે. તે sequence ના દરેક આઇટમ માટે કોડનો એક બ્લોક ચલાવે છે.

\begin{lstlisting}[language=Python, caption={For Loop Example}]
# પાયથોનમાં for લૂપનો ઉદાહરણ
# લિસ્ટના દરેક એલિમેન્ટને પ્રિન્ટ કરવા
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# range ફંક્શનનો for લૂપ સાથે ઉપયોગ
print("1 થી 5 સુધીના નંબર:")
for i in range(1, 6):
    print(i)

# સ્ટ્રિંગ સાથે for લૂપનો ઉપયોગ
name = "Python"
for char in name:
    print(char)
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=of start] (init) {Initialize sequence};
    \node [gtu block, below=of init] (get) {Get next item};
    \node [gtu decision, below=of get] (check) {More items?};
    \node [gtu block, right=of check] (exec) {Execute code block};
    \node [gtu state, below=of check] (end) {End};

    \path [gtu arrow] (start) -- (init);
    \path [gtu arrow] (init) -- (get);
    \path [gtu arrow] (get) -- (check);
    \path [gtu arrow] (check) -- node {Yes} (exec);
    \path [gtu arrow] (exec) |- (get);
    \path [gtu arrow] (check) -- node {No} (end);
\end{tikzpicture}
\captionof{figure}{For Loop Flowchart}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ITEM: દરેક સભ્ય પર પુનરાવર્તન કરો}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{Break અને continue સ્ટેટમેન્ટને સંક્ષિપ્તમાં સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Break અને Continue સ્ટેટમેન્ટ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ટેટમેન્ટ} & \textbf{હેતુ} & \textbf{અસર} \\ \hline
\textbf{break} & લૂપમાંથી તરત જ બહાર નીકળો & વર્તમાન લૂપને અટકાવે છે અને લૂપ પછીના સ્ટેટમેન્ટ પર કંટ્રોલ ટ્રાન્સફર કરે છે \\ \hline
\textbf{continue} & વર્તમાન પુનરાવર્તન છોડી દો & લૂપના આગલા પુનરાવર્તન પર જાય છે, continue સ્ટેટમેન્ટ પછીના કોઈપણ કોડને છોડી દે છે \\ \hline
\end{tabulary}
\end{center}

\textbf{Code Example}:

\begin{lstlisting}[language=Python, caption={Break and Continue Example}]
# Break સ્ટેટમેન્ટ ઉદાહરણ
print("Break ઉદાહરણ:")
for i in range(1, 11):
    if i == 6:
        print("i =", i, "પર લૂપ તોડીએ છીએ")
        break
    print(i, end=" ")
print("\nલૂપ સમાપ્ત થઈ")

# Continue સ્ટેટમેન્ટ ઉદાહરણ
print("\nContinue ઉદાહરણ:")
for i in range(1, 11):
    if i % 2 == 0:
        continue
    print(i, end=" ")
print("\nમાત્ર વિષમ નંબરો પ્રિન્ટ થયા")
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (start) {Start Loop};
    \node [gtu decision, below=of start] (cond_break) {Break માટે શરત?};
    \node [gtu block, right=of cond_break] (exit) {Loop માંથી બહાર નીકળો};
    \node [gtu decision, below=of cond_break] (cond_cont) {Continue માટે શરત?};
    \node [gtu block, right=of cond_cont] (skip) {આગળના iteration \\ પર જાઓ};
    \node [gtu block, below=of cond_cont] (exec) {બાકીનો code ચલાવો};
    \node [gtu block, below=of exit] (after) {Execution ચાલુ રાખો};
    
    \path [gtu arrow] (start) -- (cond_break);
    \path [gtu arrow] (cond_break) -- node {Yes} (exit);
    \path [gtu arrow] (cond_break) -- node {No} (cond_cont);
    \path [gtu arrow] (cond_cont) -- node {Yes} (skip);
    \path [gtu arrow] (cond_cont) -- node {No} (exec);
    
    \path [gtu arrow] (skip) |- (start);
    \path [gtu arrow] (exec) -- ++(0,-1) -| (start);
    \path [gtu arrow] (exit) -- (after);
\end{tikzpicture}
\captionof{figure}{Break and Continue Flowchart}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EXIT SKIP: EXIT with break, SKIP with continue}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{1 થી 10 નંબર ને લૂપથી પ્રિન્ટ કરવા માટેનો પાયથન કોડ બનાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Printing 1 to 10}]
# 1 થી 10 સુધીના નંબર પ્રિન્ટ કરવા for લૂપનો ઉપયોગ
print("for લૂપનો ઉપયોગ કરીને:")
for i in range(1, 11):
    print(i, end=" ")

print("\n\nwhile લૂપનો ઉપયોગ કરીને:")
# 1 થી 10 સુધીના નંબર પ્રિન્ટ કરવા while લૂપનો ઉપયોગ
counter = 1
while counter <= 10:
    print(counter, end=" ")
    counter += 1
\end{lstlisting}

\begin{center}
\captionof{table}{લૂપ અભિગમ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{અભિગમ} & \textbf{ફાયદો} \\ \hline
\textbf{range સાથે For લૂપ} & સરળ, સંક્ષિપ્ત, આપોઆપ કાઉન્ટર મેનેજ કરે છે \\ \hline
\textbf{While લૂપ} & જટિલ શરતો માટે વધુ લવચીક \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{COUNT UP: Counter દરેક પુનરાવર્તનમાં અપડેટ થાય છે}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{નીચેની પેટર્ન પ્રિન્ટ કરવા માટેનો પાયથન કોડ લખો: \newline \texttt{* \newline ** \newline *** \newline **** \newline *****}}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Star Pattern Program}]
# for લૂપનો ઉપયોગ કરીને સ્ટાર પેટર્ન પ્રિન્ટ કરો
rows = 5

for i in range(1, rows + 1):
    # દરેક રો માં i જેટલા સ્ટાર પ્રિન્ટ કરો
    print("*" * i)
\end{lstlisting}

\textbf{વૈકલ્પિક ઉકેલ નેસ્ટેડ લૂપ્સ સાથે}:

\begin{lstlisting}[language=Python, caption={Star Pattern Nested Loop}]
# નેસ્ટેડ લૂપ્સનો ઉપયોગ કરીને સ્ટાર પેટર્ન પ્રિન્ટ કરો
rows = 5

for i in range(1, rows + 1):
    for j in range(1, i + 1):
        print("*", end="")
    print()  # દરેક રો પછી ન્યુ લાઇન
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=of start] (set) {rows = 5 સેટ કરો};
    \node [gtu block, below=of set] (init) {i = 1 સેટ કરો};
    \node [gtu decision, below=of init] (cond) {શું i $\le$ rows?};
    \node [gtu block, right=of cond] (print) {"*" * i પ્રિન્ટ કરો};
    \node [gtu block, below=of print] (inc) {i માં વધારો કરો};
    \node [gtu state, below=of cond, yshift=-1.5cm] (end) {End};

    \path [gtu arrow] (start) -- (set);
    \path [gtu arrow] (set) -- (init);
    \path [gtu arrow] (init) -- (cond);
    \path [gtu arrow] (cond) -- node {Yes} (print);
    \path [gtu arrow] (print) -- (inc);
    \path [gtu arrow] (inc) |- (cond);
    \path [gtu arrow] (cond) -- node {No} (end);
\end{tikzpicture}
\captionof{figure}{Pattern Printing Flowchart}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RISE UP: રો વધે છે, સ્ટાર ઊપર તરફ વિસ્તરે છે}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{આપેલા નંબર નો factorial શોધવા માટેનું યુઝર ડિફાઇન ફંક્શન બનાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Factorial Function}]
# આપેલા નંબરનો ફેક્ટોરિયલ શોધવા માટેનું ફંક્શન
def factorial(n):
    # ઇનપુટ માન્ય છે કે નહીં તે ચકાસો
    if not isinstance(n, int) or n < 0:
        return "અમાન્ય ઇનપુટ. કૃપા કરીને નોન-નેગેટિવ ઇન્ટીજર દાખલ કરો."
    
    # બેઝ કેસ: 0 અથવા 1 નો ફેક્ટોરિયલ 1 છે
    if n == 0 or n == 1:
        return 1
    
    # ઇટરેશન વાપરીને ફેક્ટોરિયલ ગણતરી
    result = 1
    for i in range(2, n + 1):
        result *= i
    
    return result

# ફંક્શન ટેસ્ટ કરો
number = int(input("ફેક્ટોરિયલ શોધવા માટે એક નંબર દાખલ કરો: "))
print(f"{number} નો ફેક્ટોરિયલ {factorial(number)} છે")
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=of start] (def) {factorial(n) વ્યાખ્યાયિત કરો};
    \node [gtu decision, below=of def] (check) {શું n માન્ય છે?};
    \node [gtu block, right=of check] (err) {Error રિટર્ન કરો};
    \node [gtu decision, below=of check] (base) {શું n == 0 અથવા 1?};
    \node [gtu block, right=of base] (ret1) {1 રિટર્ન કરો};
    \node [gtu block, below=of base] (init) {result = 1 સેટ કરો};
    \node [gtu block, below=of init] (loop) {2 થી n લૂપ};
    \node [gtu block, below=of loop] (calc) {result *= i};
    \node [gtu block, below=of calc] (ret) {result રિટર્ન કરો};
    \node [gtu state, below=of ret] (end) {End};

    \path [gtu arrow] (start) -- (def);
    \path [gtu arrow] (def) -- (check);
    \path [gtu arrow] (check) -- node {Invalid} (err);
    \path [gtu arrow] (check) -- node {Valid} (base);
    \path [gtu arrow] (base) -- node {Yes} (ret1);
    \path [gtu arrow] (base) -- node {No} (init);
    \path [gtu arrow] (init) -- (loop);
    \path [gtu arrow] (loop) -- (calc);
    \path [gtu arrow] (calc) -- (ret);
    \path [gtu arrow] (ret) -- (end);
    \path [gtu arrow] (ret1) |- (end);
\end{tikzpicture}
\captionof{figure}{Factorial Function Flowchart}
\end{center}

\begin{center}
\captionof{table}{ફેક્ટોરિયલ ઉદાહરણો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{નંબર} & \textbf{ગણતરી} & \textbf{ફેક્ટોરિયલ} \\ \hline
0 & 0! = 1 & 1 \\ \hline
1 & 1! = 1 & 1 \\ \hline
3 & 3! = 3 $\times$ 2 $\times$ 1 & 6 \\ \hline
5 & 5! = 5 $\times$ 4 $\times$ 3 $\times$ 2 $\times$ 1 & 120 \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{1 સુધી ગુણાકાર કરો: બધા આંકડાને 1 સુધી ગુણાકાર કરો}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{1 થી N માંથી odd અને even નંબર શોધવાનો પાયથન કોડ બનાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Odd and Even Numbers Loop}]
# 1 થી N સુધીના odd અને even નંબર શોધવાનો પ્રોગ્રામ

# યુઝર પાસેથી ઇનપુટ લો
N = int(input("N ની કિંમત દાખલ કરો: "))

print("1 થી", N, "સુધીના even નંબર છે:")
for i in range(1, N + 1):
    if i % 2 == 0:
        print(i, end=" ")

print("\n1 થી", N, "સુધીના odd નંબર છે:")
for i in range(1, N + 1):
    if i % 2 != 0:
        print(i, end=" ")
\end{lstlisting}

\begin{center}
\captionof{table}{Even અને Odd ચેક}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{નંબર} & \textbf{ચેક} & \textbf{પ્રકાર} \\ \hline
Even નંબર & \code{number \% 2 == 0} & 2, 4, 6, ... \\ \hline
Odd નંબર & \code{number \% 2 != 0} & 1, 3, 5, ... \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MOD-2: Modulo 2 જે even કે odd નક્કી કરે છે}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{Nested લિસ્ટ અને તેના એલિમેન્ટ ડિસ્પ્લે કરવા માટેનો પાયથન કોડ બનાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Nested List Example}]
# Nested લિસ્ટ બનાવવા અને ડિસ્પ્લે કરવાનો પ્રોગ્રામ

# Nested લિસ્ટ બનાવો
nested_list = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Nested લિસ્ટ ડિસ્પ્લે કરો
print("Nested લિસ્ટ:", nested_list)

# Nested લૂપ્સનો ઉપયોગ કરીને દરેક એલિમેન્ટ ડિસ્પ્લે કરો
print("\nNested લિસ્ટના એલિમેન્ટ્સ:")
for i in range(len(nested_list)):
    for j in range(len(nested_list[i])):
        print(f"nested_list[{i}][{j}] = {nested_list[i][j]}")

# enumerate નો ઉપયોગ કરીને વૈકલ્પિક રીત
print("\nenumerate નો ઉપયોગ કરીને:")
for i, inner_list in enumerate(nested_list):
    for j, value in enumerate(inner_list):
        print(f"પોઝિશન ({i}, {j}): {value}")
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (root) {Nested લિસ્ટ};
    \node [gtu block, below left=of root] (row0) {રો 0};
    \node [gtu block, below=of root] (row1) {રો 1};
    \node [gtu block, below right=of root] (row2) {રો 2};
    
    \node [gtu block, below=of row0, xshift=-0.5cm] (r0i1) {1};
    \node [gtu block, right=0.2cm of r0i1] (r0i2) {2};
    \node [gtu block, right=0.2cm of r0i2] (r0i3) {3};
    
    \node [gtu block, below=of row1, xshift=-0.5cm] (r1i1) {4};
    \node [gtu block, right=0.2cm of r1i1] (r1i2) {5};
    \node [gtu block, right=0.2cm of r1i2] (r1i3) {6};
    
    \node [gtu block, below=of row2, xshift=-0.5cm] (r2i1) {7};
    \node [gtu block, right=0.2cm of r2i1] (r2i2) {8};
    \node [gtu block, right=0.2cm of r2i2] (r2i3) {9};
    
    \path [gtu arrow] (root) -- (row0);
    \path [gtu arrow] (root) -- (row1);
    \path [gtu arrow] (root) -- (row2);
    
    \path [gtu arrow] (row0) -- (r0i2);
    \path [gtu arrow] (row1) -- (r1i2);
    \path [gtu arrow] (row2) -- (r2i2);
\end{tikzpicture}
\captionof{figure}{Nested List Structure}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ROWS COLS: રો અને કોલમ માળખું બનાવે છે}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{Local અને Global વેરિયેબલ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{Local vs Global વેરિએબલ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{સ્કોપ} & \textbf{એક્સેસિબિલિટી} & \textbf{ઘોષણા} \\ \hline
\textbf{Local વેરિએબલ્સ} & માત્ર જે ફંક્શનમાં ઘોષિત થયા છે ત્યાં & માત્ર ઘોષિત કરનાર ફંક્શનની અંદર & ફંક્શનની અંદર \\ \hline
\textbf{Global વેરિએબલ્સ} & સમગ્ર પ્રોગ્રામમાં & બધા ફંક્શન એક્સેસ કરી શકે & કોઈપણ ફંક્શનની બહાર \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python, caption={Global vs Local Variables}]
# Global વેરિએબલ
total = 0

def add_numbers(a, b):
    # Local વેરિએબલ્સ
    sum_result = a + b
    print(f"Local વેરિએબલ sum_result: {sum_result}")
    
    # Global વેરિએબલ એક્સેસ કરવું
    print(f"Global વેરિએબલ total મોડિફિકેશન પહેલાં: {total}")
    
    # ફંક્શનની અંદર Global વેરિએબલ મોડિફાય કરવા
    global total
    total = sum_result
    print(f"Global વેરિએબલ total મોડિફિકેશન પછી: {total}")
    
    return sum_result

# મુખ્ય પ્રોગ્રામ
x = 5  # મુખ્ય પ્રોગ્રામમાં Local
y = 10  # મુખ્ય પ્રોગ્રામમાં Local

result = add_numbers(x, y)
print(f"પરિણામ: {result}")
print(f"અપડેટેડ global total: {total}")
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node [gtu state] (prog) {પ્રોગ્રામ સ્કોપ};
    \node [gtu block, below=of prog] (glob) {Global વેરિએબલ્સ: total};
    \node [gtu block, left=of glob, xshift=-1cm] (func) {ફંક્શન સ્કોપ: \code{add\_numbers}};
    \node [gtu block, below=of func] (local) {Local વેરિએબલ્સ: \code{sum\_result}, \code{a}, \code{b}};
    \node [gtu block, right=of glob, xshift=1cm] (main) {મુખ્ય પ્રોગ્રામ વેરિએબલ્સ: \code{x}, \code{y}, \code{result}};
    
    \path [gtu arrow] (prog) -- (glob);
    \path [gtu arrow] (prog) -- (func);
    \path [gtu arrow] (prog) -- (main);
    \path [gtu arrow] (func) -- (local);
    
    \path [dashed] (glob) edge[bend right] node[above] {Access} (func);
\end{tikzpicture}
\captionof{figure}{Variable Scoops}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{GLOBAL SEES ALL: Global વેરિએબલ્સ બધે જોઈ શકે છે}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{પાયથન ની સ્ટાન્ડર્ડ લાઇબ્રેરી ના મેથેમેટિકલ ફંક્શન લિસ્ટ કરો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{પાયથોન Math મોડ્યુલ ફંક્શન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફંક્શન} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{abs()} & એબ્સોલ્યુટ વેલ્યુ આપે છે & \code{abs(-5)} $\rightarrow$ \code{5} \\ \hline
\textbf{pow()} & x ને y ની ઘાત આપે છે & \code{pow(2, 3)} $\rightarrow$ \code{8} \\ \hline
\textbf{max()} & સૌથી મોટી વેલ્યુ આપે છે & \code{max(5, 10, 15)} $\rightarrow$ \code{15} \\ \hline
\textbf{min()} & સૌથી નાની વેલ્યુ આપે છે & \code{min(5, 10, 15)} $\rightarrow$ \code{5} \\ \hline
\textbf{round()} & નજીકના પૂર્ણાંક સુધી રાઉન્ડ કરે છે & \code{round(4.6)} $\rightarrow$ \code{5} \\ \hline
\textbf{math.sqrt()} & વર્ગમૂળ & \code{math.sqrt(16)} $\rightarrow$ \code{4.0} \\ \hline
\textbf{math.sin()} & સાઇન ફંક્શન & \code{math.sin(math.pi/2)} $\rightarrow$ \code{1.0} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PEARS Math: Power, Exponents, Arithmetic, Roots, Sine functions in Math}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{પાયથન મોડ્યુલ કોડ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{મોડ્યુલ}: પાયથોનમાં મોડ્યુલ એટલે પાયથોન વ્યાખ્યાઓ અને સ્ટેટમેન્ટ્સ ધરાવતી ફાઇલ. ફાઇલનું નામ .py સફિક્સ સાથેનું મોડ્યુલનું નામ છે.

\begin{lstlisting}[language=Python, caption={Module Usage Example}]
# math મોડ્યુલના ઉપયોગનું ઉદાહરણ
import math

# math મોડ્યુલમાંથી ગાણિતિક ફંક્શન્સનો ઉપયોગ
radius = 5
area = math.pi * math.pow(radius, 2)
print(f"ત્રિજ્યા {radius} વાળા વર્તુળનું ક્ષેત્રફળ {area:.2f} છે")

# વિવિધ import ટેકનિક્સનો ઉપયોગ
from math import sqrt, sin
angle = math.pi / 4
print(f"25 નું વર્ગમૂળ {sqrt(25)} છે")
print(f"{angle} રેડિયન્સનો સાઇન {sin(angle):.4f} છે")

# alias સાથે import
import random as rnd
random_number = rnd.randint(1, 100)
print(f"1 અને 100 વચ્ચેનો રેન્ડમ નંબર: {random_number}")
\end{lstlisting}

\begin{center}
\captionof{table}{મોડ્યુલ Import ટેકનિક્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પદ્ધતિ} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} \\ \hline
\textbf{આખો મોડ્યુલ import કરો} & \code{import module\_name} & \code{import math} \\ \hline
\textbf{ચોક્કસ આઇટમ્સ import કરો} & \code{from module\_name import item1, item2} & \code{from math import sqrt, sin} \\ \hline
\textbf{alias સાથે import કરો} & \code{import module\_name as alias} & \code{import random as rnd} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CODE-LIB: Code Libraries for reuse - ફરીથી ઉપયોગ માટે કોડ લાઇબ્રેરીઓ}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{એક પાયથન પ્રોગ્રામ લખો જે નિર્ધારિત કરે છે કે આપેલ નંબર 'આર્મસ્ટ્રોંગ નંબર' છે કે વપરાશકર્તા-વ્યાખ્યાયિત કાર્યનો ઉપયોગ કરીને પેલિન્ડ્રોમ છે.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Armstrong and Palindrome Check}]
# નંબર આર્મસ્ટ્રોંગ છે કે નહીં તે ચેક કરવા માટેનું ફંક્શન
def is_armstrong(num):
    # અંકોની સંખ્યા ગણવા માટે નંબરને સ્ટ્રિંગમાં રૂપાંતરિત કરો
    num_str = str(num)
    n = len(num_str)
    
    # દરેક અંકને અંકોની સંખ્યાની ઘાત સુધી ઉગામેલા સરવાળાની ગણતરી
    armstrong_sum = 0
    for digit in num_str:
        armstrong_sum += int(digit) ** n
    
    # ચેક કરો કે સરવાળો મૂળ નંબર સાથે મેળ ખાય છે
    return armstrong_sum == num

# નંબર પેલિન્ડ્રોમ છે કે નહીં તે ચેક કરવા માટેનું ફંક્શન
def is_palindrome(num):
    # નંબરને સ્ટ્રિંગમાં રૂપાંતરિત કરો અને ચેક કરો કે તે આગળથી અને પાછળથી એક સરખો વંચાય છે
    num_str = str(num)
    return num_str == num_str[::-1]

# મુખ્ય પ્રોગ્રામ
number = int(input("એક નંબર દાખલ કરો: "))

# ચેક કરો કે નંબર આર્મસ્ટ્રોંગ છે કે નહીં
if is_armstrong(number):
    print(f"{number} એક આર્મસ્ટ્રોંગ નંબર છે")
else:
    print(f"{number} આર્મસ્ટ્રોંગ નંબર નથી")

# ચેક કરો કે નંબર પેલિન્ડ્રોમ છે કે નહીં
if is_palindrome(number):
    print(f"{number} એક પેલિન્ડ્રોમ છે")
else:
    print(f"{number} પેલિન્ડ્રોમ નથી")
\end{lstlisting}

\begin{center}
\captionof{table}{ઉદાહરણો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{નંબર} & \textbf{આર્મસ્ટ્રોંગ ચેક} & \textbf{પેલિન્ડ્રોમ ચેક} \\ \hline
153 & $1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153$ \checkmark & $153 \neq 351$ \ding{55} \\ \hline
121 & $1^3 + 2^3 + 1^3 = 1 + 8 + 1 = 10 \neq 121$ \ding{55} & $121 = 121$ \checkmark \\ \hline
1634 & $1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634$ \checkmark & $1634 \neq 4361$ \ding{55} \\ \hline
\end{tabulary}
\end{center}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (start) {Start};
    \node [gtu block, below=of start] (input) {Input number};
    \node [gtu decision, below=of input] (checkArm) {Armstrong ચેક};
    \node [gtu decision, right=of checkArm, xshift=2cm] (checkPal) {Palindrome ચેક};
    
    \node [gtu block, below left=of checkArm] (isArm) {પ્રિન્ટ - આર્મસ્ટ્રોંગ છે};
    \node [gtu block, below right=of checkArm] (notArm) {પ્રિન્ટ - આર્મસ્ટ્રોંગ નથી};
    
    \node [gtu block, below left=of checkPal] (isPal) {પ્રિન્ટ - પેલિન્ડ્રોમ છે};
    \node [gtu block, below right=of checkPal] (notPal) {પ્રિન્ટ - પેલિન્ડ્રોમ નથી};
    
    \node [gtu state, below=of isPal, yshift=-1.5cm] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (checkArm);
    \path [gtu arrow] (checkArm) -- node {Yes} (isArm);
    \path [gtu arrow] (checkArm) -- node {No} (notArm);
    
    \path [dashed] (isArm) -- (checkPal);
    \path [dashed] (notArm) -- (checkPal);
    
    \path [gtu arrow] (checkPal) -- node {Yes} (isPal);
    \path [gtu arrow] (checkPal) -- node {No} (notPal);
    
    \path [gtu arrow] (isPal) -- (end);
    \path [gtu arrow] (notPal) |- (end);
\end{tikzpicture}
\captionof{figure}{Armstrong Palindrome Flowchart}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SAME SUM: SAME આગળ-પાછળ પેલિન્ડ્રોમ માટે, SUM ઘાતના અંકોનો આર્મસ્ટ્રોંગ માટે}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{પાયથોનમાં બિલ્ટ ઇન ફંક્શન સમજાવો.}

\begin{solutionbox}
\textbf{Built-in Functions}: આ ફંક્શન્સ પાયથોનના સ્ટાન્ડર્ડ લાઇબ્રેરીનો ભાગ છે અને કોઈપણ મોડ્યુલ import કર્યા વિના ઉપલબ્ધ છે.

\begin{center}
\captionof{table}{સામાન્ય પાયથોન Built-in Functions}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફંક્શન} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\ \hline
\textbf{print()} & આઉટપુટ ડિસ્પ્લે & \code{print("Hello")} \\ \hline
\textbf{input()} & યુઝર ઇનપુટ લે & \code{name = input("Name: ")} \\ \hline
\textbf{len()} & ઓબ્જેક્ટની લંબાઈ આપે & \code{len([1, 2, 3])} $\rightarrow$ \code{3} \\ \hline
\textbf{type()} & ઓબ્જેક્ટનો પ્રકાર આપે & \code{type(5)} $\rightarrow$ \code{<class 'int'>} \\ \hline
\textbf{int(), float(), str()} & ચોક્કસ પ્રકારમાં રૂપાંતર & \code{int("5")} $\rightarrow$ \code{5} \\ \hline
\textbf{range()} & સીક્વન્સ જનરેટ કરે & \code{list(range(3))} $\rightarrow$ \code{[0, 1, 2]} \\ \hline
\textbf{sum()} & સરવાળો ગણે & \code{sum([1, 2, 3])} $\rightarrow$ \code{6} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PITS LCR: Print, Input, Type, Sum, Len, Convert, Range}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{એક પાયથોન કોડનું ઉદાહરણ આપીને પાયથોન મેથ મોડ્યુલનું વર્ણન કરો.}

\begin{solutionbox}
\textbf{પાયથોન Math મોડ્યુલ}: math મોડ્યુલ C સ્ટાન્ડર્ડ દ્વારા વ્યાખ્યાયિત ગાણિતિક ફંક્શન્સની એક્સેસ પ્રદાન કરે છે.

\begin{lstlisting}[language=Python, caption={Math Module Example}]
# math મોડ્યુલનો ઉપયોગ કરતો ઉદાહરણ
import math

# મૂળભૂત સ્થિરાંકો
print(f"pi ની કિંમત: {math.pi}")
print(f"e ની કિંમત: {math.e}")

# ત્રિકોણમિતિ ફંક્શન્સ (આર્ગ્યુમેન્ટ રેડિયન્સમાં)
angle = math.pi / 3  # 60 ડિગ્રી
print(f"{angle:.2f} રેડિયન્સનો સાઇન: {math.sin(angle):.4f}")
print(f"{angle:.2f} રેડિયન્સનો કોસાઇન: {math.cos(angle):.4f}")
print(f"{angle:.2f} રેડિયન્સનો ટેન્જન્ટ: {math.tan(angle):.4f}")

# લોગરિધમિક અને એક્સપોનેન્શિયલ ફંક્શન્સ
x = 10
print(f"{x} નો નેચરલ લોગરિધમ: {math.log(x):.4f}")
print(f"{x} નો લોગરિધમ બેઝ 10: {math.log10(x):.4f}")
print(f"e ની {x} ઘાત: {math.exp(x):.4f}")

# અન્ય ફંક્શન્સ
print(f"25 નું વર્ગમૂળ: {math.sqrt(25)}")
print(f"4.3 નો સીલિંગ: {math.ceil(4.3)}")
print(f"4.7 નો ફ્લોર: {math.floor(4.7)}")
\end{lstlisting}

\begin{center}
\captionof{table}{Math મોડ્યુલ કેટેગરીઝ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કેટેગરી} & \textbf{ફંક્શન્સ} \\ \hline
\textbf{સ્થિરાંકો} & \code{math.pi}, \code{math.e} \\ \hline
\textbf{ત્રિકોણમિતિ} & \code{sin()}, \code{cos()}, \code{tan()} \\ \hline
\textbf{લોગરિધમિક} & \code{log()}, \code{log10()}, \code{exp()} \\ \hline
\textbf{ન્યુમેરિક} & \code{sqrt()}, \code{ceil()}, \code{floor()} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PENT: Pi/constants, Exponents, Numbers, Trigonometry}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{પાયથોનમાં વેરીએબલના અવકાશનો કોન્સેપ્ટ સમજાવો અને પાયથોન પ્રોગ્રામમાં વૈશ્વિક અને સ્થાનિક વેરીએબલ કોન્સેપ્ટ લાગુ કરો.}

\begin{solutionbox}
\textbf{પાયથોનમાં વેરિએબલનો સ્કોપ}: વેરિએબલનો સ્કોપ નક્કી કરે છે કે પ્રોગ્રામમાં ક્યાં વેરિએબલ એક્સેસિબલ કે દેખાય છે.

\begin{center}
\captionof{table}{વેરિએબલ સ્કોપના પ્રકારો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{સ્કોપ} & \textbf{વર્ણન} & \textbf{એક્સેસ} \\ \hline
\textbf{Local} & ફંક્શનની અંદર વ્યાખ્યાયિત વેરિએબલ્સ & માત્ર ફંક્શનની અંદર \\ \hline
\textbf{Global} & ટોપ લેવલ પર વ્યાખ્યાયિત વેરિએબલ્સ & સમગ્ર પ્રોગ્રામમાં \\ \hline
\textbf{Enclosing} & નેસ્ટેડ ફંક્શન્સના બાહ્ય ફંક્શનના વેરિએબલ્સ & બાહ્ય અને અંદરના ફંક્શનમાં \\ \hline
\textbf{Built-in} & પાયથોનમાં પહેલેથી વ્યાખ્યાયિત વેરિએબલ્સ & સમગ્ર પ્રોગ્રામમાં \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python, caption={Variable Scope Demonstration}]
# વેરિએબલ સ્કોપ ડેમોન્સ્ટ્રેશન

# Global વેરિએબલ
count = 0

def outer_function():
    # Enclosing સ્કોપ વેરિએબલ
    name = "Python"
    
    def inner_function():
        # Local વેરિએબલ
        age = 30
        # Global વેરિએબલ એક્સેસ કરવું
        global count
        count += 1
        # Enclosing વેરિએબલ એક્સેસ કરવું
        print(f"inner_function ની અંદર: name is {name}")
        print(f"inner_function ની અંદર: age is {age}")
        print(f"inner_function ની અંદર: count is {count}")
    
    # outer_function માટે Local વેરિએબલ
    language = "Programming"
    print(f"outer_function ની અંદર: name is {name}")
    print(f"outer_function ની અંદર: language is {language}")
    print(f"outer_function ની અંદર: count is {count}")
    
    # ઇનર ફંક્શન કોલ કરો
    inner_function()
    
    # આ ભૂલ આપશે - age એ inner_function માટે Local છે
    # print(age)

# મુખ્ય પ્રોગ્રામ
print(f"Global સ્કોપ: count is {count}")
outer_function()
print(f"ફંક્શન કોલ પછી Global સ્કોપ: count is {count}")

# આ ભૂલ આપશે - તેઓ ફંક્શન્સ માટે Local છે
# print(name)
# print(language)
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=2cm, auto]
    \node [gtu state] (glob) {Global સ્કોપ};
    \node [gtu block, below=of glob] (gvars) {count};
    
    \node [gtu block, right=of glob, xshift=1cm] (outer) {outer\_function};
    \node [gtu block, below=of outer] (enc) {Enclosing સ્કોપ: name, language};
    
    \node [gtu block, right=of outer, xshift=1cm] (inner) {inner\_function};
    \node [gtu block, below=of inner] (local) {Local સ્કોપ: age};
    
    \path [gtu arrow] (glob) -- (gvars);
    \path [gtu arrow] (glob) -- (outer);
    \path [gtu arrow] (outer) -- (enc);
    \path [gtu arrow] (outer) -- (inner);
    \path [gtu arrow] (inner) -- (local);
    
    \path [dashed] (gvars) edge[bend right] node[above] {Access} (inner);
    \path [dashed] (enc) edge[bend right] node[above] {Access} (inner);
\end{tikzpicture}
\captionof{figure}{Variable Scope Hierarchy}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LEGB: Local, Enclosing, Global, Built-in - સ્કોપ લુકઅપનો ક્રમ}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{આપેલ સૂચિમાં બે ઘટકોને સ્વેપ કરવા માટે પાયથોન પ્રોગ્રામ બનાવો.}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Swapping List Elements}]
# લિસ્ટમાં બે એલિમેન્ટ્સ સ્વેપ કરવાનો પ્રોગ્રામ

# એક લિસ્ટ બનાવો
my_list = [10, 20, 30, 40, 50]
print("મૂળ લિસ્ટ:", my_list)

# સ્વેપ કરવા માટેની પોઝિશન મેળવો
pos1 = int(input("પ્રથમ પોઝિશન દાખલ કરો (ઇન્ડેક્સ 0 થી શરૂ થાય છે): "))
pos2 = int(input("બીજી પોઝિશન દાખલ કરો (ઇન્ડેક્સ 0 થી શરૂ થાય છે): "))

# ટેમ્પરરી વેરિએબલનો ઉપયોગ કરીને એલિમેન્ટ્સ સ્વેપ કરો
if 0 <= pos1 < len(my_list) and 0 <= pos2 < len(my_list):
    # સ્વેપિંગ
    temp = my_list[pos1]
    my_list[pos1] = my_list[pos2]
    my_list[pos2] = temp
    
    print(f"પોઝિશન {pos1} અને {pos2} પર એલિમેન્ટ્સ સ્વેપ કર્યા પછી લિસ્ટ:", my_list)
else:
    print("અમાન્ય પોઝિશન! પોઝિશન લિસ્ટની રેન્જની અંદર હોવી જોઈએ.")
\end{lstlisting}

\textbf{વૈકલ્પિક પદ્ધતિ}:

\begin{lstlisting}[language=Python, caption={Pythonic Swap}]
# પાયથોનની tuple અનપેકિંગનો ઉપયોગ કરીને સ્વેપ (વધુ પાયથોનિક)
if 0 <= pos1 < len(my_list) and 0 <= pos2 < len(my_list):
    my_list[pos1], my_list[pos2] = my_list[pos2], my_list[pos1]
    print(f"પોઝિશન {pos1} અને {pos2} પર એલિમેન્ટ્સ સ્વેપ કર્યા પછી લિસ્ટ:", my_list)
\end{lstlisting}

\begin{center}
\captionof{table}{સ્વેપિંગ પદ્ધતિઓ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પદ્ધતિ} & \textbf{કોડ} \\ \hline
\textbf{ટેમ્પ વેરિએબલનો ઉપયોગ} & \code{temp = a; a = b; b = temp} \\ \hline
\textbf{પાયથોન ટપલ અનપેકિંગ} & \code{a, b = b, a} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TEMP SWAP: Temporary variable helps safe swapping}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{ઉદાહરણ આપીને નેસ્ટેડ લિસ્ટ સમજાવો.}

\begin{solutionbox}
\textbf{Nested List}: નેસ્ટેડ લિસ્ટ એ એક લિસ્ટ છે જે તેના ઘટકો તરીકે અન્ય લિસ્ટ્સ ધરાવે છે, જે મલ્ટી-ડાયમેન્શનલ ડેટા સ્ટ્રક્ચર બનાવે છે.

\begin{lstlisting}[language=Python, caption={Nested List Operations}]
# નેસ્ટેડ લિસ્ટ બનાવવું (3x3 મેટ્રિક્સ)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# એલિમેન્ટ્સ એક્સેસ કરવા
print("સંપૂર્ણ મેટ્રિક્સ:", matrix)
print("પ્રથમ રો:", matrix[0])
print("રો 1, કોલમ 2 પર એલિમેન્ટ:", matrix[0][1])  # આઉટપુટ: 2

# એલિમેન્ટ્સ મોડિફાય કરવા
matrix[1][1] = 50
print("મોડિફિકેશન પછી મેટ્રિક્સ:", matrix)

# નેસ્ટેડ લિસ્ટ માં લૂપ ફેરવવું
print("\nમેટ્રિક્સ પ્રિન્ટ કરવું:")
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()  # દરેક રો પછી નવી લાઇન
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (matrix) {matrix};
    \node [gtu block, below left=of matrix] (row0) {Row 0};
    \node [gtu block, below=of matrix] (row1) {Row 1};
    \node [gtu block, below right=of matrix] (row2) {Row 2};
    
    \node [gtu block, below=of row1, yshift=-0.5cm] (val) {Values: 4, 50, 6};
    \path [gtu arrow] (matrix) -- (row0);
    \path [gtu arrow] (matrix) -- (row1);
    \path [gtu arrow] (matrix) -- (row2);
    \path [gtu arrow] (row1) -- (val);
\end{tikzpicture}
\captionof{figure}{Nested List Structure}
\end{center}

\begin{center}
\captionof{table}{Nested List Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} \\ \hline
\textbf{એલિમેન્ટ એક્સેસ} & \code{list[row][col]} & \code{matrix[0][1]} \\ \hline
\textbf{એલિમેન્ટ મોડિફાય} & \code{list[row][col] = new\_value} & \code{matrix[1][1] = 50} \\ \hline
\textbf{નવી રો ઉમેરવી} & \code{list.append([...])} & \code{matrix.append([10, 11, 12])} \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MARS: Matrix Access with Row and column Structure - મેટ્રિક્સ એક્સેસ રો અને કોલમ માળખા સાથે}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{ઉદાહરણો સાથે સ્ટ્રિંગ ઓપરેશન્સ સમજાવો.}

\begin{solutionbox}
\begin{center}
\captionof{table}{પાયથોનમાં સ્ટ્રિંગ ઓપરેશન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{Concatenation} & સ્ટ્રિંગ્સ જોડવા & \code{"Hello" + " World"} $\rightarrow$ \code{"Hello World"} \\ \hline
\textbf{Repetition} & સ્ટ્રિંગ્સ રિપીટ કરવા & \code{"Python" * 3} $\rightarrow$ \code{"PythonPythonPython"} \\ \hline
\textbf{Slicing} & સબસ્ટ્રિંગ એક્સટ્રેક્ટ કરવું & \code{"Python"[1:4]} $\rightarrow$ \code{"yth"} \\ \hline
\textbf{Indexing} & કેરેક્ટર એક્સેસ કરવું & \code{"Python"[0]} $\rightarrow$ \code{"P"} \\ \hline
\textbf{Length} & કેરેક્ટર્સ ગણવા & \code{len("Python")} $\rightarrow$ \code{6} \\ \hline
\textbf{Membership} & હાજરી ચેક કરવી & \code{"P" in "Python"} $\rightarrow$ \code{True} \\ \hline
\textbf{Comparison} & સ્ટ્રિંગ્સ સરખાવવા & \code{"apple" < "banana"} $\rightarrow$ \code{True} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python, caption={String Operations Example}]
# સ્ટ્રિંગ ઓપરેશન્સ ડેમોન્સ્ટ્રેશન
text = "Python Programming"

# Indexing
print("ર પ્રથમ કેરેક્ટર:", text[0])
print("છેલ્લો કેરેક્ટર:", text[-1])

# Slicing
print("પ્રથમ શબ્દ:", text[:6])
print("બીજો શબ્દ:", text[7:])
print("મધ્ય કેરેક્ટર્સ:", text[3:10])
print("ઉલટું (Reverse):", text[::-1])

# સ્ટ્રિંગ મેથડ્સ
print("અપરકેસ:", text.upper())
print("લોઅરકેસ:", text.lower())
print("'P' ને 'J' સાથે બદલો:", text.replace("P", "J"))
print("સ્પેસ દ્વારા સ્પ્લિટ:", text.split())
print("'m' ગણો:", text.count('m'))
print("'gram' શોધો:", text.find("gram"))

# ચેક ઓપરેશન્સ
print("શું આલ્ફાન્યુમેરિક છે?", text.isalnum())
print("શું 'Py' થી શરૂ થાય છે?", text.startswith("Py"))
print("શું 'ing' થી સમાપ્ત થાય છે?", text.endswith("ing"))
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (str) {"Python Programming"};
    \node [gtu block, below left=of str] (idx) {Indexing};
    \node [gtu block, below=of str] (slice) {Slicing};
    \node [gtu block, below right=of str] (meth) {Methods};
    
    \node [gtu block, below=of idx] (idx_ex) {P (0), g (-1)};
    \node [gtu block, below=of slice] (slice_ex) {Python (0:6)};
    \node [gtu block, below=of meth] (meth_ex) {upper(), split()};
    
    \path [gtu arrow] (str) -- (idx);
    \path [gtu arrow] (str) -- (slice);
    \path [gtu arrow] (str) -- (meth);
    \path [gtu arrow] (idx) -- (idx_ex);
    \path [gtu arrow] (slice) -- (slice_ex);
    \path [gtu arrow] (meth) -- (meth_ex);
\end{tikzpicture}
\captionof{figure}{String Operations}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SCREAM: Slice, Concat, Replace, Extract, Access, Methods}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{આપેલ સૂચિમાં તમામ ઘટકોનો સરવાળો શોધવા માટે પાયથોન પ્રોગ્રામ બનાવો}

\begin{solutionbox}
\begin{lstlisting}[language=Python, caption={Sum of List Elements}]
# લિસ્ટમાં રહેલા તમામ એલિમેન્ટ્સનો સરવાળો શોધવાનો પ્રોગ્રામ

# પદ્ધતિ 1: બિલ્ટ-ઇન sum() ફંક્શનનો ઉપયોગ કરીને
def sum_list_builtin(numbers):
    return sum(numbers)

# પદ્ધતિ 2: લૂપનો ઉપયોગ કરીને
def sum_list_loop(numbers):
    total = 0
    for num in numbers:
        total += num
    return total

# એક સેમ્પલ લિસ્ટ બનાવો
my_list = [10, 20, 30, 40, 50]
print("લિસ્ટ:", my_list)

# બિલ્ટ-ઇન ફંક્શનનો ઉપયોગ કરીને સરવાળો ગણો
print("બિલ્ટ-ઇન ફંક્શનનો ઉપયોગ કરીને સરવાળો:", sum_list_builtin(my_list))

# લૂપનો ઉપયોગ કરીને સરવાળો ગણો
print("લૂપનો ઉપયોગ કરીને સરવાળો:", sum_list_loop(my_list))
\end{lstlisting}

\begin{center}
\captionof{table}{સરવાળા પદ્ધતિઓની તુલના}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{પદ્ધતિ} & \textbf{ફાયદો} \\ \hline
\textbf{Built-in sum()} & સરળ, કાર્યક્ષમ, ઝડપી \\ \hline
\textbf{Loop approach} & કસ્ટમ સરવાળા લોજિક માટે કામ કરે છે \\ \hline
\end{tabulary}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ADD ALL: દરેક એલિમેન્ટને ઉમેરો}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{પાયથોન લિસ્ટમાં ઈન્ડેક્સીંગ અને સ્લાઇસિંગ ઓપરેશન્સ સમજાવો}

\begin{solutionbox}
\begin{center}
\captionof{table}{ઇન્ડેક્સિંગ અને સ્લાઇસિંગ ઓપરેશન્સ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{સિન્ટેક્સ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\ \hline
\textbf{Positive Indexing} & \code{list[i]} & i પોઝિશન પર આઈટમ એક્સેસ કરો & \code{fruits[0]} \\ \hline
\textbf{Negative Indexing} & \code{list[-i]} & છેલ્લેથી આઈટમ એક્સેસ કરો & \code{fruits[-1]} \\ \hline
\textbf{Basic Slicing} & \code{list[s:e]} & start થી end-1 સુધીની આઈટમ્સ & \code{fruits[1:3]} \\ \hline
\textbf{Slice with Step} & \code{list[s:e:st]} & સ્ટેપના અંતરાલ સાથે આઈટમ્સ & \code{nums[1:6:2]} \\ \hline
\textbf{Reverse} & \code{list[::-1]} & લિસ્ટને ઉલટું કરો & \code{fruits[::-1]} \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python, caption={Indexing and Slicing Demo}]
# ઇન્ડેક્સિંગ અને સ્લાઇસિંગ ડેમોન્સ્ટ્રેશન
fruits = ["apple", "banana", "cherry", "date", "elderberry", "fig"]
print("મૂળ લિસ્ટ:", fruits)

# Indexing
print("\nઇન્ડેક્સિંગ ઉદાહરણો:")
print("પ્રથમ આઈટમ:", fruits[0])  # apple
print("છેલ્લી આઈટમ:", fruits[-1])  # fig

# Slicing
print("\nસ્લાઇસિંગ ઉદાહરણો:")
print("પ્રથમ ત્રણ આઈટમ્સ:", fruits[:3])
print("છેલ્લી ત્રણ આઈટમ્સ:", fruits[-3:])
print("મધ્ય આઈટમ્સ:", fruits[2:4])
print("દરેક બીજી આઈટમ:", fruits[::2])
print("ઉલટું લિસ્ટ:", fruits[::-1])
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (list) {List: fruits};
    \node [gtu block, below left=of list] (idx) {Indexing};
    \node [gtu block, below right=of list] (slice) {Slicing};
    
    \node [gtu block, below=of idx] (idx_ex) {fruits[0], fruits[-1]};
    \node [gtu block, below=of slice] (slice_ex) {fruits[1:3], fruits[::-1]};
    
    \path [gtu arrow] (list) -- (idx);
    \path [gtu arrow] (list) -- (slice);
    \path [gtu arrow] (idx) -- (idx_ex);
    \path [gtu arrow] (slice) -- (slice_ex);
\end{tikzpicture}
\captionof{figure}{Indexing and Slicing}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{START-END-STEP: સ્લાઇસિંગ સિન્ટેક્સ: [start:end:step]}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{જરૂરી ઉદાહરણ સાથે tuple ને ટૂંકમાં સમજાવો.}

\begin{solutionbox}
\textbf{Tuple}: Tuple એ એલિમેન્ટ્સનું ઓર્ડર્ડ, અપરિવર્તનીય (immutable) કલેક્શન છે. એકવાર બનાવ્યા પછી, એલિમેન્ટ્સ બદલી શકાતા નથી.

\begin{center}
\captionof{table}{Tuple vs List}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ફીચર} & \textbf{Tuple} & \textbf{List} \\ \hline
\textbf{સિન્ટેક્સ} & \code{(item1, item2)} & \code{[item1, item2]} \\ \hline
\textbf{મ્યુટેબિલિટી} & Immutable (બદલી શકાતું નથી) & Mutable (બદલી શકાય છે) \\ \hline
\textbf{પરફોર્મન્સ} & ઝડપી & ધીમું \\ \hline
\textbf{ઉપયોગ} & ફિક્સ્ડ ડેટા, કીઝ & ડાયનેમિક ડેટા \\ \hline
\end{tabulary}
\end{center}

\begin{lstlisting}[language=Python, caption={Tuple Example}]
# Tuples બનાવવા
empty_tuple = ()
single_item_tuple = (1,)  # એક આઈટમ માટે અલ્પવિરામ જરૂરી છે
mixed_tuple = (1, "Hello", 3.14, True)
nested_tuple = (1, 2, (3, 4), 5)

# Tuple એલિમેન્ટ્સ એક્સેસ કરવા
print("પ્રથમ આઈટમ:", mixed_tuple[0])  # 1
print("નેસ્ટેડ ટપલ એલિમેન્ટ:", nested_tuple[2][0])  # 3

# Tuple ઓપરેશન્સ
combined_tuple = mixed_tuple + nested_tuple
print("સંયુક્ત ટપલ:", combined_tuple)

# આ ભૂલ આપશે કારણ કે tuples અપરિવર્તનીય છે
# mixed_tuple[0] = 100  # TypeError
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node [gtu state] (tuple) {Tuple: (1, 2, 3)};
    \node [gtu block, below left=of tuple] (access) {Access};
    \node [gtu block, below=of tuple] (props) {Properties};
    \node [gtu block, below right=of tuple] (ops) {Operations};
    
    \node [gtu block, below=of access] (acc_ex) {tuple[0] $\rightarrow$ 1};
    \node [gtu block, below=of props] (prop_ex) {Immutable};
    \node [gtu block, below=of ops] (ops_ex) {Concatenation (+)};
    
    \path [gtu arrow] (tuple) -- (access);
    \path [gtu arrow] (tuple) -- (props);
    \path [gtu arrow] (tuple) -- (ops);
    
    \path [gtu arrow] (access) -- (acc_ex);
    \path [gtu arrow] (props) -- (prop_ex);
    \path [gtu arrow] (ops) -- (ops_ex);
\end{tikzpicture}
\captionof{figure}{Tuple Concepts}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{IPAC: Immutable, Parentheses, Access only, Cannot modify - અપરિવર્તનીય, કૌંસ, માત્ર એક્સેસ, મોડિફાય ન કરી શકાય}
\end{mnemonicbox}

\end{document}
