\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 1323203 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{ફ્લોચાર્ટને વ્યાખ્યાયિત કરો અને ફ્લોચાર્ટના કોઈપણ ચાર પ્રતીકોની સૂચિ
બનાવો.}

\begin{solutionbox}
ફ્લોચાર્ટ એ એક પ્રક્રિયા, એલ્ગોરિધમ અથવા પ્રોગ્રામમાં પગલાંઓના
ક્રમને દર્શાવવા માટે માનક પ્રતીકોનો ઉપયોગ કરતું ચિત્રાત્મક પ્રતિનિધિત્વ છે.

\textbf{સામાન્ય ફ્લોચાર્ટ પ્રતીકો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રતીક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
નામ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લંબગોળ/ગોળાકાર આયત & Terminal/Start/End & પ્રક્રિયાની શરૂઆત અથવા અંત દર્શાવે
છે \\
આયત & Process & ગણતરી અથવા ડેટા પ્રોસેસિંગનું પ્રતિનિધિત્વ કરે છે \\
હીરા આકાર & Decision & શરતી શાખાના બિંદુને દર્શાવે છે \\
સમાંતર ચતુષ્કોણ & Input/Output & ડેટા ઈનપુટ અથવા આઉટપુટનું પ્રતિનિધિત્વ કરે છે \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``TP-DI'' (Terminal-Process-Decision-Input/Output)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{પાયથોનમાં વિવિધ ડેટા પ્રકારોની યાદી બનાવો. કોઈપણ ત્રણ ડેટા પ્રકારો
ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
પાયથોનના ડેટા પ્રકારો વિવિધ પ્રકારની ડેટા કિંમતોને વર્ગીકૃત કરે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ડેટા પ્રકાર & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Integer & દશાંશ બિંદુઓ વિનાના સંપૂર્ણ સંખ્યાઓ & \texttt{x\ =\ 10} \\
Float & દશાંશ બિંદુઓ સાથેની સંખ્યાઓ & \texttt{y\ =\ 3.14} \\
String & અક્ષરોની શ્રેણી & \texttt{name\ =\ "Python"} \\
Boolean & સાચું અથવા ખોટું મૂલ્યો & \texttt{is\_valid\ =\ True} \\
List & ક્રમબદ્ધ, પરિવર્તનશીલ સંગ્રહ &
\texttt{colors\ =\ ["red",\ "green"]} \\
Tuple & ક્રમબદ્ધ, અપરિવર્તનીય સંગ્રહ & \texttt{point\ =\ (5,\ 10)} \\
Dictionary & કી-વેલ્યુ જોડીઓ & \texttt{person\ =\ \{"name":\ "John"\}} \\
Set & અવ્યવસ્થિત અનન્ય આઈટમોનો સંગ્રહ & \texttt{unique\ =\ \{1,\ 2,\ 3\}} \\
\end{longtable}
}

\textbf{Integer:} દશાંશ બિંદુઓ વિનાની સંપૂર્ણ સંખ્યાઓનું પ્રતિનિધિત્વ કરે છે.

\begin{verbatim}
age = 25
count = {-}10
\end{verbatim}

\textbf{String:} અવતરણ ચિહ્નોમાં બંધ અક્ષરોના ક્રમનું પ્રતિનિધિત્વ કરે છે.

\begin{verbatim}
name = "Python"
message = {Hello World}
\end{verbatim}

\textbf{List:} વિવિધ પ્રકારની વસ્તુઓનો ક્રમબદ્ધ, પરિવર્તનશીલ સંગ્રહ.

\begin{verbatim}
numbers = [1, 2, 3, 4]
mixed = [1, "Python", True, 3.14]
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``FIBS-LTDS''
(Float-Integer-Boolean-String-List-Tuple-Dictionary-Set)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{પ્રથમ વીસ સમાન પ્રાકૃતિક સંખ્યાઓના સરવાળાની ગણતરી કરવા માટે ફ્લોચાર્ટ
ડિઝાઈન કરો.}

\begin{solutionbox}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B[/sum = 0, count = 0, num = 2 પ્રારંભ કરો/]}
    B {-{-} C\{શું count  20?\}}
    C {-{-}|હા| D[sum = sum + num]}
    D {-{-} E[count = count + 1]}
    E {-{-} F[num = num + 2]}
    F {-{-} C}
    C {-{-}|ના| G[/sum પ્રિન્ટ કરો/]}
    G {-{-} H([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{ચલોનો પ્રારંભ}: sum=0, count=0 (મળેલ સમ સંખ્યાઓને ટ્રેક કરવા માટે),
  num=2 (પ્રથમ સમ સંખ્યા)
\item
  \textbf{લૂપ શરત}: 20 સમ સંખ્યાઓ મળે ત્યાં સુધી ચાલુ રાખો
\item
  \textbf{પ્રક્રિયા}: વર્તમાન સમ સંખ્યાને સરવાળામાં ઉમેરો
\item
  \textbf{અપડેટ}: કાઉન્ટર વધારો અને આગળની સમ સંખ્યા પર જાઓ
\item
  \textbf{આઉટપુટ}: લૂપ પૂર્ણ થાય ત્યારે અંતિમ સરવાળો પ્રિન્ટ કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SCNL-20'' (Sum-Count-Number-Loop until 20)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) અથવા [7
ગુણ]}\label{q1c}

\textbf{1 થી 20 ની વચ્ચેની વિષમ સંખ્યાઓ પ્રિન્ટ કરવા માટે એલ્ગોરિધમ બનાવો.}

\begin{solutionbox}

\textbf{એલ્ગોરિધમ:}

\begin{enumerate}
\tightlist
\item
  ચલ num = 1 (પ્રથમ વિષમ સંખ્યાથી શરૂ કરીને) પ્રારંભ કરો
\item
  જ્યાં સુધી num \leq 20, પગલાં 3-5 કરો
\item
  num ની કિંમત પ્રિન્ટ કરો
\item
  num ને 2 વધારો (આગળની વિષમ સંખ્યા મેળવવા માટે)
\item
  પગલું 2 થી પુનરાવર્તન કરો
\item
  સમાપ્ત
\end{enumerate}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B[/num = 1 પ્રારંભ કરો/]}
    B {-{-} C\{શું num  20?\}}
    C {-{-}|હા| D[/num પ્રિન્ટ કરો/]}
    D {-{-} E[num = num + 2]}
    E {-{-} C}
    C {-{-}|ના| F([સમાપ્ત])}
\end{verbatim}

\textbf{કોડ અમલીકરણ:}

\begin{verbatim}
\# 1 થી 20 સુધીની વિષમ સંખ્યાઓ પ્રિન્ટ કરો
num = 1
while num {=} 20:
    print(num)
    num += 2
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SOLO-20'' (Start Odd Loop Output until 20)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{પાયથોનના સભ્યપદ ઓપરેટર વિશે ચર્ચા કરો.}

\begin{solutionbox}
પાયથોનમાં સભ્યપદ ઓપરેટરનો ઉપયોગ કોઈ મૂલ્ય અથવા ચલ અનુક્રમમાં
અસ્તિત્વમાં છે કે નહીં તેનું પરીક્ષણ કરવા માટે થાય છે.

\textbf{સભ્યપદ ઓપરેટરની સારણી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેટર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આઉટપુટ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{in} & જો મૂલ્ય અનુક્રમમાં અસ્તિત્વમાં હોય તો True પરત કરે છે &
\texttt{5\ in\ [1,2,5]} & \texttt{True} \\
\texttt{not\ in} & જો મૂલ્ય અસ્તિત્વમાં ન હોય તો True પરત કરે છે &
\texttt{4\ not\ in\ [1,2,5]} & \texttt{True} \\
\end{longtable}
}

\textbf{સામાન્ય ઉપયોગ:}

\begin{itemize}
\tightlist
\item
  લિસ્ટમાં તત્વ અસ્તિત્વમાં છે કે નહીં તેની તપાસ કરવી:
  \texttt{if\ item\ in\ my\_list:}
\item
  શબ્દકોશમાં કી અસ્તિત્વમાં છે કે નહીં તેની તપાસ કરવી:
  \texttt{if\ key\ in\ my\_dict:}
\item
  સબસ્ટ્રિંગ અસ્તિત્વમાં છે કે નહીં તેની તપાસ કરવી:
  \texttt{if\ "py"\ in\ "python":}
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``IM-NOT'' (In Membership - NOT in Membership)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{continue અને break સ્ટેટમેન્ટની જરૂરિયાત સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
સ્ટેટમેન્ટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ કેસ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{break} & લૂપને તાત્કાલિક સમાપ્ત કરે છે & જ્યારે શરત પૂરી થાય ત્યારે લૂપમાંથી
બહાર નીકળો & તત્વ શોધવું \\
\texttt{continue} & વર્તમાન પુનરાવર્તનને છોડી આગળના પર જાય છે & અમુક મૂલ્યોને
છોડી આગળ વધવું & ફિલ્ટરિંગ મૂલ્યો \\
\end{longtable}
}

\textbf{Break સ્ટેટમેન્ટ:}

\begin{itemize}
\tightlist
\item
  \textbf{હેતુ}: તાત્કાલિક લૂપમાંથી બહાર નીકળે છે
\item
  \textbf{ક્યારે ઉપયોગ કરવો}: જ્યારે જરૂરી શરત હાંસલ થાય અને વધુ પ્રક્રિયાની જરૂર ન
  હોય
\item
  \textbf{ઉદાહરણ}: લિસ્ટમાં ચોક્કસ તત્વ શોધવું
\end{itemize}

\begin{verbatim}
for num in range(1, 10):
    if num == 5:
        print("Found 5!")
        break
    print(num)
\end{verbatim}

\textbf{Continue સ્ટેટમેન્ટ:}

\begin{itemize}
\tightlist
\item
  \textbf{હેતુ}: વર્તમાન પુનરાવર્તનને છોડી આગળના પર જાય છે
\item
  \textbf{ક્યારે ઉપયોગ કરવો}: જ્યારે અમુક મૂલ્યોને છોડવાના હોય પરંતુ લૂપ ચાલુ
  રાખવાનો હોય
\item
  \textbf{ઉદાહરણ}: લૂપમાં સમ સંખ્યાઓને છોડવી
\end{itemize}

\begin{verbatim}
for num in range(1, 10):
    if num \% 2 == 0:
        continue
    print(num)  \# માત્ર વિષમ સંખ્યાઓ પ્રિન્ટ કરે છે
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``BS-CE'' (Break Stops, Continue Excepts)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{યુઝર તરફથી ઇનપુટ તરીકે લેવામાં આવેલા ચાર વિષયના ગુણના આધારે કુલ અને સરેરાશ
ગુણની ગણતરી કરવા માટે એક પ્રોગ્રામ બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# કુલ અને સરેરાશ ગુણની ગણતરી કરવાનો પ્રોગ્રામ
\# ચાર વિષયો માટે ગુણ ઇનપુટ લો
subject1 = float(input("વિષય 1 માટે ગુણ દાખલ કરો: "))
subject2 = float(input("વિષય 2 માટે ગુણ દાખલ કરો: "))
subject3 = float(input("વિષય 3 માટે ગુણ દાખલ કરો: "))
subject4 = float(input("વિષય 4 માટે ગુણ દાખલ કરો: "))

\# કુલ અને સરેરાશની ગણતરી કરો
total\_marks = subject1 + subject2 + subject3 + subject4
average\_marks = total\_marks / 4

\# પરિણામો પ્રદર્શિત કરો
print(f"કુલ ગુણ: \{total\_marks\}")
print(f"સરેરાશ ગુણ: \{average\_marks\}")
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B[/subject1, subject2, subject3, subject4 ઇનપુટ લો/]}
    B {-{-} C[total\_marks = subject1 + subject2 + subject3 + subject4]}
    C {-{-} D[average\_marks = total\_marks / 4]}
    D {-{-} E[/total\_marks, average\_marks પ્રદર્શિત કરો/]}
    E {-{-} F([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનપુટ}: યુઝર પાસેથી ચાર વિષયોના ગુણ મેળવો
\item
  \textbf{પ્રક્રિયા}: બધા વિષયના ગુણને ઉમેરીને કુલ અને વિષયોની સંખ્યા વડે ભાગીને
  સરેરાશની ગણતરી કરો
\item
  \textbf{આઉટપુટ}: કુલ અને સરેરાશ ગુણ પ્રદર્શિત કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``IAPO'' (Input-Add-Process-Output)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) અથવા [3
ગુણ]}\label{q2a}

\textbf{અસાઇનમેન્ટ ઓપરેટર પર ટૂંકી નોંધ લખો.}

\begin{solutionbox}
પાયથોનમાં અસાઇનમેન્ટ ઓપરેટરનો ઉપયોગ ચલોને મૂલ્યો સોંપવા માટે થાય
છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેટર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
નામ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{=} & સરળ અસાઇનમેન્ટ & જમણા ઓપરન્ડ મૂલ્યને ડાબા ઓપરન્ડને સોંપે છે &
\texttt{x\ =\ 10} \\
\texttt{+=} & ઉમેરો અને સોંપો & જમણા ઓપરન્ડને ડાબામાં ઉમેરે અને પરિણામ સોંપે છે &
\texttt{x\ +=\ 5} (\texttt{x\ =\ x\ +\ 5} સમાન) \\
\texttt{-=} & બાદ કરો અને સોંપો & જમણા ઓપરન્ડને ડાબામાંથી બાદ કરે અને સોંપે છે &
\texttt{x\ -=\ 3} (\texttt{x\ =\ x\ -\ 3} સમાન) \\
\texttt{*=} & ગુણાકાર અને સોંપો & ડાબાને જમણા વડે ગુણાકાર કરે અને સોંપે છે &
\texttt{x\ *=\ 2} (\texttt{x\ =\ x\ *\ 2} સમાન) \\
\texttt{/=} & ભાગાકાર અને સોંપો & ડાબાને જમણા વડે ભાગે અને સોંપે છે &
\texttt{x\ /=\ 4} (\texttt{x\ =\ x\ /\ 4} સમાન) \\
\end{longtable}
}

\textbf{મિશ્રિત અસાઇનમેન્ટ ઓપરેટર} અંકગણિતીય ઓપરેશન અને અસાઇનમેન્ટને જોડે છે, જેથી
કોડ વધુ સંક્ષિપ્ત અને વાંચવા યોગ્ય બને છે.

\end{solutionbox}
\begin{mnemonicbox}
``SAME'' (Simple Assignment Makes Easy)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) અથવા [4
ગુણ]}\label{q2b}

\textbf{for લૂપનો ઉપયોગ સિન્ટેક્સ, ફ્લોચાર્ટ અને ઉદાહરણ આપીને સમજાવો.}

\begin{solutionbox}

\textbf{For લૂપનો સિન્ટેક્સ:}

\begin{verbatim}
for variable in sequence:
    \# કોડ બ્લોક જે અમલમાં મૂકવાનો છે
\end{verbatim}

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B[/લૂપ ચલને સિક્વન્સની પહેલી આઇટમથી શરૂ કરો/]}
    B {-{-} C\{શું હજી આઇટમ બાકી છે?\}}
    C {-{-}|હા| D[લૂપના શરીરને અમલમાં મૂકો]}
    D {-{-} E[સિક્વન્સમાં આગળની આઇટમ પર જાઓ]}
    E {-{-} C}
    C {-{-}|ના| F([સમાપ્ત])}
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\# 1 થી 5 સુધીની સંખ્યાઓના વર્ગ પ્રિન્ટ કરો
for num in range(1, 6):
    square = num ** 2
    print(f"\{num\} નો વર્ગ = \{square\}")
\end{verbatim}

પાયથોનમાં \texttt{for} લૂપનો ઉપયોગ સિક્વન્સ (લિસ્ટ, ટપલ, સ્ટ્રિંગ, વગેરે) અથવા અન્ય
ઇટરેબલ ઓબ્જેક્ટ્સ પર ચોક્કસ પુનરાવર્તન માટે થાય છે. તે ખાસ કરીને ત્યારે ઉપયોગી છે જ્યારે
તમે પુનરાવર્તનોની સંખ્યા અગાઉથી જાણતા હો.

\end{solutionbox}
\begin{mnemonicbox}
``SIFE'' (Sequence Iteration For Each item)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) અથવા [7
ગુણ]}\label{q2c}

\textbf{યુઝર દ્વારા આપેલ નંબરનો વર્ગ અને ઘન શોધવા માટે કોડ વિકસાવો.}

\begin{solutionbox}

\begin{verbatim}
\# નંબરનો વર્ગ અને ઘન શોધવાનો પ્રોગ્રામ
\# યુઝર પાસેથી નંબર ઇનપુટ લો
num = float(input("એક નંબર દાખલ કરો: "))

\# વર્ગ અને ઘનની ગણતરી કરો
square = num ** 2
cube = num ** 3

\# પરિણામો પ્રદર્શિત કરો
print(f"દાખલ કરેલ નંબર: \{num\}")
print(f"\{num\} નો વર્ગ: \{square\}")
print(f"\{num\} નો ઘન: \{cube\}")
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B[/num ઇનપુટ લો/]}
    B {-{-} C[square = num ** 2]}
    C {-{-} D[cube = num ** 3]}
    D {-{-} E[/num, square, cube પ્રદર્શિત કરો/]}
    E {-{-} F([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનપુટ}: યુઝર પાસેથી નંબર મેળવો
\item
  \textbf{પ્રક્રિયા}: 2ની ઘાત પર ઉઠાવીને વર્ગ, 3ની ઘાત પર ઉઠાવીને ઘનની ગણતરી
  કરો
\item
  \textbf{આઉટપુટ}: ઇનપુટ નંબર, તેનો વર્ગ અને ઘન પ્રદર્શિત કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ISCO'' (Input-Square-Cube-Output)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{if-elif-else સ્ટેટમેન્ટને ફ્લોચાર્ટ અને યોગ્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
પાયથોનમાં if-elif-else સ્ટેટમેન્ટ એ એવી શરતી ક્રિયા માટે છે જ્યાં
ઘણા અભિવ્યક્તિઓનું મૂલ્યાંકન કરવામાં આવે છે.

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B\{શું condition1 સાચું છે?\}}
    B {-{-}|હા| C[if બ્લોક અમલમાં મૂકો]}
    B {-{-}|ના| D\{શું condition2 સાચું છે?\}}
    D {-{-}|હા| E[elif બ્લોક અમલમાં મૂકો]}
    D {-{-}|ના| F[else બ્લોક અમલમાં મૂકો]}
    C {-{-} G([સમાપ્ત])}
    E {-{-} G}
    F {-{-} G}
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\# ગુણ આધારિત ગ્રેડ આપવું
marks = 75

if marks {=} 90:
    grade = "A"
elif marks {=} 80:
    grade = "B"
elif marks {=} 70:
    grade = "C"
elif marks {=} 60:
    grade = "D"
else:
    grade = "F"

print(f"તમારો ગ્રેડ: \{grade\}")
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CITE'' (Check If Then Else)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{યુઝર ડિફાઇન ફંકશન વ્યાખ્યાયિત કરો અને કેવી રીતે યુસર ડિફાઇન ફંકશન કોલ કરવું
તે યોગ્ય ઉદાહરણ આપીને સમજાવો.}

\begin{solutionbox}

\textbf{ફંકશન વ્યાખ્યા અને કોલિંગ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
વ્યાખ્યા & \texttt{def\ function\_name(parameters):} & પુન:ઉપયોગી કોડનો
બ્લોક બનાવે છે \\
ફંકશન બોડી & ઇન્ડેન્ટેડ કોડ બ્લોક & ફંકશનનો લોજિક ધરાવે છે \\
રિટર્ન સ્ટેટમેન્ટ & \texttt{return\ [expression]} & કૉલરને મૂલ્ય પાછું મોકલે
છે \\
ફંકશન કોલ & \texttt{function\_name(arguments)} & ફંકશન કોડ ચલાવે છે \\
\end{longtable}
}

\textbf{ફંકશન વ્યાખ્યાયિત અને કોલ કરવાનું ઉદાહરણ:}

\begin{verbatim}
\# લંબચોરસનો ક્ષેત્રફળ ગણવા માટે ફંકશન વ્યાખ્યાયિત કરો
def calculate\_area(length, width):
    """આપેલ લંબાઈ અને પહોળાઈ સાથે લંબચોરસનો ક્ષેત્રફળ ગણો"""
    area = length * width
    return area

\# ફંકશન કોલ કરો
result = calculate\_area(5, 3)
print(f"લંબચોરસનો ક્ષેત્રફળ: \{result\}")
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{ફંકશન વ્યાખ્યા}: \texttt{def} કીવર્ડનો ઉપયોગ કરીને ફંકશન નામ અને
  પેરામીટર્સ સાથે
\item
  \textbf{ડોક્યુમેન્ટેશન}: ફંકશનનું વર્ણન કરતું વૈકલ્પિક ડોકસ્ટ્રિંગ
\item
  \textbf{ફંકશન બોડી}: કાર્ય કરતો કોડ
\item
  \textbf{રીટર્ન સ્ટેટમેન્ટ}: કૉલરને પરિણામ પાછું મોકલે છે
\item
  \textbf{ફંકશન કોલ}: ફંકશન ચલાવવા માટે આર્ગ્યુમેન્ટ્સ પસાર કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DBRCA'' (Define-Body-Return-Call-Arguments)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{આપેલ નંબરનો ફેક્ટોરીયલ શોધવા માટે કોડ વિકસાવો.}

\begin{solutionbox}

\begin{verbatim}
\# નંબરનો ફેક્ટોરીયલ શોધવાનો પ્રોગ્રામ
\# યુઝર પાસેથી નંબર ઇનપુટ લો
num = int(input("એક સકારાત્મક પૂર્ણાંક દાખલ કરો: "))

\# ફેક્ટોરીયલ પ્રારંભ કરો
factorial = 1

\# તપાસો કે નંબર નકારાત્મક, શૂન્ય કે સકારાત્મક છે
if num {} 0:
    print("નકારાત્મક સંખ્યાઓ માટે ફેક્ટોરીયલ અસ્તિત્વમાં નથી")
elif num == 0:
    print("0 નો ફેક્ટોરીયલ 1 છે")
else:
    \# ફેક્ટોરીયલની ગણતરી કરો
    for i in range(1, num + 1):
        factorial *= i
    print(f"\{num\} નો ફેક્ટોરીયલ \{factorial\} છે")
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B[/num ઇનપુટ લો/]}
    B {-{-} C[factorial = 1 પ્રારંભ કરો]}
    C {-{-} D\{શું num  0?\}}
    D {-{-}|હા| E[/ભૂલ સંદેશ પ્રદર્શિત કરો/]}
    D {-{-}|ના| F\{શું num == 0?\}}
    F {-{-}|હા| G[/0 નો ફેક્ટોરીયલ 1 છે એમ પ્રદર્શિત કરો/]}
    F {-{-}|ના| H[i = 1 થી num સુધી લૂપ]}
    H {-{-} I[factorial = factorial * i]}
    I {-{-} J[/ફેક્ટોરીયલ પ્રદર્શિત કરો/]}
    E {-{-} K([સમાપ્ત])}
    G {-{-} K}
    J {-{-} K}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનપુટ}: યુઝર પાસેથી નંબર મેળવો
\item
  \textbf{ચકાસણી}: તપાસો કે નંબર નકારાત્મક (ફેક્ટોરીયલ વ્યાખ્યાયિત નથી), શૂન્ય
  (ફેક્ટોરીયલ 1 છે), અથવા સકારાત્મક છે
\item
  \textbf{પ્રક્રિયા}: સકારાત્મક નંબરો માટે, ફેક્ટોરીયલને 1 થી num સુધીના દરેક નંબર
  સાથે ગુણાકાર કરો
\item
  \textbf{આઉટપુટ}: ફેક્ટોરીયલ પરિણામ પ્રદર્શિત કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``MICE'' (Multiply Incrementally, Check Edge-cases)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) અથવા [3
ગુણ]}\label{q3a}

\textbf{યોગ્ય ઉદાહરણનો ઉપયોગ કરીને નેસ્ટેડ લૂપ સમજાવો.}

\begin{solutionbox}
નેસ્ટેડ લૂપ એ એક લૂપની અંદર બીજું લૂપ છે. બાહ્ય લૂપના દરેક પુનરાવર્તન
માટે આંતરિક લૂપ તેના બધા પુનરાવર્તનો પૂર્ણ કરે છે.

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B\{બાહ્ય લૂપ શરત\}}
    B {-{-}|સાચું| C\{આંતરિક લૂપ શરત\}}
    C {-{-}|સાચું| D[આંતરિક લૂપ બોડી અમલમાં મૂકો]}
    D {-{-} E[આંતરિક લૂપ કાઉન્ટર અપડેટ કરો]}
    E {-{-} C}
    C {-{-}|ખોટું| F[બાહ્ય લૂપ કાઉન્ટર અપડેટ કરો]}
    F {-{-} B}
    B {-{-}|ખોટું| G([સમાપ્ત])}
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\# 1 થી 3 સુધીના ગુણાકાર કોષ્ટક પ્રિન્ટ કરો
for i in range(1, 4):  \# બાહ્ય લૂપ: 1 થી 3
    print(f"\{i\} માટે ગુણાકાર કોષ્ટક:")
    for j in range(1, 6):  \# આંતરિક લૂપ: 1 થી 5
        print(f"\{i\} x \{j\} = \{i*j\}")
    print()  \# દરેક કોષ્ટક પછી ખાલી લાઇન
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LOFI'' (Loop Outside, Finish Inside)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) અથવા [4
ગુણ]}\label{q3b}

\textbf{ફંકશન હેન્ડલિંગમાં રિટર્ન સ્ટેટમેન્ટ સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પાસું & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
હેતુ & કૉલરને મૂલ્ય પાછું મોકલો & \texttt{return\ result} \\
મલ્ટિપલ રિટર્ન & ટપલ તરીકે ઘણા મૂલ્યો પાછા મોકલો &
\texttt{return\ x,\ y,\ z} \\
અર્લી એક્ઝિટ & અંત પહેલા ફંકશનમાંથી બહાર નીકળો &
\texttt{if\ error:\ return\ None} \\
નો રિટર્ન & ફંકશન મૂળભૂત રીતે None પાછું મોકલે છે &
\texttt{def\ show():\ print("Hi")} \\
\end{longtable}
}

પાયથોન ફંકશનોમાં \texttt{return} સ્ટેટમેન્ટ:

\begin{enumerate}
\tightlist
\item
  ફંકશન એક્ઝિક્યુશન સમાપ્ત કરે છે
\item
  ફંકશન કૉલરને મૂલ્ય પાછું મોકલે છે
\item
  ઘણા મૂલ્યો (ટપલ તરીકે) પાછા મોકલી શકે છે
\item
  વૈકલ્પિક છે (જો છોડવામાં આવે, તો ફંકશન None પાછું મોકલે છે)
\end{enumerate}

\textbf{ઉદાહરણ:}

\begin{verbatim}
def calculate\_circle(radius):
    """વર્તુળનું ક્ષેત્રફળ અને પરિધિ ગણો"""
    if radius {} 0:
        return None  \# અમાન્ય ઇનપુટ માટે અર્લી એક્ઝિટ
    
    area = 3.14 * radius ** 2
    circumference = 2 * 3.14 * radius
    
    return area, circumference  \# ઘણા મૂલ્યો પાછા મોકલો
    
\# ફંકશન કોલ
result = calculate\_circle(5)
print(f"ક્ષેત્રફળ અને પરિધિ: \{result\}")
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``TERM'' (Terminate Execution, Return Multiple
values)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) અથવા [7
ગુણ]}\label{q3c}

\textbf{લૂપ કોન્સેપ્ટનો ઉપયોગ કરીને નીચેની પેટર્ન દર્શાવવા માટે એક પ્રોગ્રામ બનાવો}

\begin{verbatim}
A
AB
ABC
ABCD
ABCDE
\end{verbatim}

\begin{solutionbox}

\begin{verbatim}
\# અક્ષર પેટર્ન પ્રિન્ટ કરવાનો પ્રોગ્રામ
\# પ્રથમ પેટર્ન: A થી E ત્રિકોણ આકારમાં

\# પંક્તિઓ (1 થી 5) દ્વારા લૂપ કરો
for i in range(1, 6):
    \# દરેક પંક્તિ માટે, {A થી જરૂરી અક્ષર સુધીના અક્ષરો પ્રિન્ટ કરો}
    for j in range(i):
        \# {A ની ASCII કિંમત 65 છે, અનુગામી અક્ષરો મેળવવા માટે j ઉમેરો}
        print(chr(65 + j), end="")
    \# દરેક પંક્તિ પછી આગળની લાઇન પર જાઓ
    print()
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B["i = 1"]}
    B {-{-} C\{"શું i = 5?"\}}
    C {-{-}|હા| D["j = 0"]}
    D {-{-} E\{"શું j  i?"\}}
    E {-{-}|હા| F["chr(65 + j) પ્રિન્ટ કરો"]}
    F {-{-} G["j = j + 1"]}
    G {-{-} E}
    E {-{-}|ના| H["નવી લાઇન પ્રિન્ટ કરો"]}
    H {-{-} I["i = i + 1"]}
    I {-{-} C}
    C {-{-}|ના| J([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{બાહ્ય લૂપ}: પંક્તિઓની સંખ્યા (1 થી 5) નિયંત્રિત કરે છે
\item
  \textbf{આંતરિક લૂપ}: દરેક પંક્તિ i માટે, `A' થી શરૂ કરીને i અક્ષરો પ્રિન્ટ કરે છે
\item
  \textbf{અક્ષર જનરેશન}: ASCII મૂલ્ય રૂપાંતર (chr(65+j) `A', `B', વગેરે આપે છે)
\item
  \textbf{આઉટપુટ ફોર્મેટિંગ}: દરેક પંક્તિ માટે end=``\,'' નો ઉપયોગ કરીને અક્ષરો એક
  જ લાઇનમાં પ્રિન્ટ કરવા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``OICE'' (Outer-Inner-Character-Endline)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{નીચેના બિલ્ટ-ઈન ફંકશનો યોગ્ય ઉદાહરણ સાથે વર્ણન કરો.} \textbf{i) max()
ii) input() iii) pow()}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંકશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{max()} & ઇટરેબલમાં સૌથી મોટી વસ્તુ અથવા બે અથવા વધુ આર્ગ્યુમેન્ટમાંથી સૌથી
મોટી વસ્તુ પાછી મોકલે છે & \texttt{max(iterable)} અથવા
\texttt{max(arg1,\ arg2,\ ...)} & \texttt{max([1,\ 5,\ 3])}
\texttt{5} પાછું મોકલે છે \\
\texttt{input()} & ઇનપુટમાંથી એક લાઇન વાંચે છે અને સ્ટ્રિંગ તરીકે પાછી મોકલે છે &
\texttt{input([prompt])} & \texttt{input("નામ\ દાખલ\ કરો:\ ")} \\
\texttt{pow()} & x ને y ની ઘાત પર ઉઠાવેલું પાછું મોકલે છે & \texttt{pow(x,\ y)}
& \texttt{pow(2,\ 3)} \texttt{8} પાછું મોકલે છે \\
\end{longtable}
}

\textbf{કોડમાં ઉદાહરણો:}

\begin{verbatim}
\# max() ફંકશન ઉદાહરણ
numbers = [10, 5, 20, 15]
maximum = max(numbers)
print(f"મહત્તમ મૂલ્ય: \{maximum\}")  \# આઉટપુટ: મહત્તમ મૂલ્ય: 20

\# input() ફંકશન ઉદાહરણ
name = input("તમારું નામ દાખલ કરો: ")
print(f"નમસ્તે, \{name\}!")

\# pow() ફંકશન ઉદાહરણ
result = pow(2, 4)
print(f"2 ને 4 ની ઘાત પર ઉઠાવતા: \{result\}")  \# આઉટપુટ: 2 ને 4 ની ઘાત પર ઉઠાવતા: 16
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``MIP'' (Max-Input-Power)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{યોગ્ય ઉદાહરણ આપીને સ્ટ્રિંગના સ્લાઇસિંગને સમજાવો.}

\begin{solutionbox}

પાયથોનમાં સ્ટ્રિંગ સ્લાઇસિંગનો ઉપયોગ સ્ટ્રિંગમાંથી સબસ્ટ્રિંગ બહાર કાઢવા માટે થાય છે.

\textbf{સિન્ટેક્સ:} \texttt{string[start:end:step]}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પેરામીટર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ડિફોલ્ટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{start} & પ્રારંભિક ઇન્ડેક્સ (સમાવેશીત) & 0 & \texttt{"Python"[1:]}
\rightarrow \texttt{"ython"} \\
\texttt{end} & અંતિમ ઇન્ડેક્સ (અસમાવેશીત) & સ્ટ્રિંગની લંબાઈ &
\texttt{"Python"[:3]} \rightarrow \texttt{"Pyt"} \\
\texttt{step} & અક્ષરો વચ્ચે વધારો & 1 & \texttt{"Python"[::2]} \rightarrow
\texttt{"Pto"} \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{verbatim}
text = "Python Programming"

\# મૂળભૂત સ્લાઇસિંગ
print(text[0:6])     \# આઉટપુટ: "Python"
print(text[7:])      \# આઉટપુટ: "Programming"
print(text[:6])      \# આઉટપુટ: "Python"

\# સ્ટેપ સાથે
print(text[::2])     \# આઉટપુટ: "Pto rgamn"
print(text[0:10:2])  \# આઉટપુટ: "Pto r"

\# નકારાત્મક ઇન્ડિસેસ (અંતથી ગણતરી)
print(text[{-}11:])    \# આઉટપુટ: "Programming"
print(text[:{-}12])    \# આઉટપુટ: "Python"

\# સ્ટ્રિંગને ઉલટાવો
print(text[::{-}1])    \# આઉટપુટ: "gnimmargorP nohtyP"
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SES'' (Start-End-Step)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{1 થી 7 ની વચ્ચેની તમામ વિષમ સંખ્યાઓના ક્યુબને પ્રિન્ટ કરતું યુઝર ડિફાઇન ફંકશન
બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# શ્રેણીમાં વિષમ સંખ્યાઓના ક્યુબ પ્રિન્ટ કરવાનું ફંકશન
def print\_odd\_cubes(start, end):
    """
    શરૂઆત અને અંત (સમાવેશીત) વચ્ચેની બધી વિષમ સંખ્યાઓના ક્યુબ પ્રિન્ટ કરો
    """
    print(f"\{start\} અને \{end\} વચ્ચેની વિષમ સંખ્યાઓના ક્યુબ:")
    
    \# શ્રેણી દ્વારા લૂપ કરો
    for num in range(start, end + 1):
        \# તપાસો કે નંબર વિષમ છે કે નહીં
        if num \% 2 != 0:
            \# ક્યુબની ગણતરી કરો અને પ્રિન્ટ કરો
            cube = num ** 3
            print(f"\{num\} નો ક્યુબ \{cube\} છે")

\# 1 થી 7 સુધીના વિષમ ક્યુબ પ્રિન્ટ કરવા માટે ફંકશન કોલ કરો
print\_odd\_cubes(1, 7)
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart TD
    A([શરૂઆત]) {-{-} B[print\_odd\_cubes ફંકશન વ્યાખ્યાયિત કરો]}
    B {-{-} C["print\_odd\_cubes(1, 7) કોલ કરો"]}
    C {-{-} D["શીર્ષક પ્રદર્શિત કરો"]}
    D {-{-} E[start થી end સુધી num માટે લૂપ]}
    E {-{-} F\{શું num \% 2 != 0?\}}
    F {-{-}|હા| G[cube = num ** 3]}
    G {-{-} H["num અને cube પ્રદર્શિત કરો"]}
    F {-{-}|ના| I[લૂપ ચાલુ રાખો]}
    H {-{-} I}
    I {-{-} J\{શું લૂપ પૂર્ણ છે?\}}
    J {-{-}|ના| E}
    J {-{-}|હા| K([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{ફંકશન વ્યાખ્યા}: શ્રેણીમાં વિષમ સંખ્યાઓને પ્રોસેસ કરવા માટે ફંકશન બનાવો
\item
  \textbf{લૂપ}: શરૂઆતથી અંત સુધીના નંબરો પર પુનરાવર્તન કરો
\item
  \textbf{શરત}: મોડ્યુલો ઓપરેટરનો ઉપયોગ કરીને તપાસો કે નંબર વિષમ છે કે નહીં
\item
  \textbf{પ્રોસેસિંગ}: વિષમ સંખ્યાઓના ક્યુબની ગણતરી કરો
\item
  \textbf{આઉટપુટ}: દરેક વિષમ સંખ્યા અને તેનો ક્યુબ પ્રદર્શિત કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FLOOP'' (Function-Loop-Odd-Output-Power)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) અથવા [3
ગુણ]}\label{q4a}

\textbf{વિવિધ ફંકશનો સાથે random મોડ્યુલ સમજાવો.}

\begin{solutionbox}

પાયથોનમાં random મોડ્યુલ રેન્ડમ નંબર જનરેટ કરવા અને રેન્ડમ પસંદગીઓ કરવા માટે ફંકશનો
પ્રદાન કરે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંકશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પરિણામ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{random()} & 0 અને 1 વચ્ચે રેન્ડમ ફ્લોટ પાછું મોકલે છે &
\texttt{random.random()} & \texttt{0.7134346335849448} \\
\texttt{randint(a,\ b)} & a અને b (સમાવેશીત) વચ્ચે રેન્ડમ પૂર્ણાંક પાછું મોકલે છે &
\texttt{random.randint(1,\ 10)} & \texttt{7} \\
\texttt{choice(seq)} & સિક્વન્સમાંથી રેન્ડમ તત્વ પાછું મોકલે છે &
\texttt{random.choice([\textquotesingle{}red\textquotesingle{},\ \textquotesingle{}green\textquotesingle{},\ \textquotesingle{}blue\textquotesingle{}])}
& \texttt{\textquotesingle{}green\textquotesingle{}} \\
\texttt{shuffle(seq)} & સિક્વન્સને ઇન-પ્લેસ શફલ કરે છે &
\texttt{random.shuffle(my\_list)} & કોઈ રિટર્ન મૂલ્ય નહીં \\
\texttt{sample(seq,\ k)} & સિક્વન્સમાંથી k અનન્ય રેન્ડમ તત્વો પાછા મોકલે છે &
\texttt{random.sample(range(1,\ 30),\ 5)} &
\texttt{[3,\ 12,\ 21,\ 7,\ 25]} \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
import random

\# 0 અને 1 વચ્ચે રેન્ડમ ફ્લોટ જનરેટ કરો
print(random.random())  

\# 1 અને 10 વચ્ચે રેન્ડમ પૂર્ણાંક જનરેટ કરો
print(random.randint(1, 10))  

\# લિસ્ટમાંથી રેન્ડમ તત્વ પસંદ કરો
colors = ["red", "green", "blue", "yellow"]
print(random.choice(colors))  

\# ઇન{-પ્લેસ લિસ્ટને શફલ કરો}
random.shuffle(colors)
print(colors)  

\# 2 અનન્ય રેન્ડમ તત્વો પસંદ કરો
print(random.sample(colors, 2))  
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``RICES'' (Random-Integer-Choice-Elements-Shuffle)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) અથવા [4
ગુણ]}\label{q4b}

\textbf{નીચેના લિસ્ટ ફંકશનોની ચર્ચા કરો.} \textbf{i. len() ii. sum() iii.
sort() iv. index()}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંકશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આઉટપુટ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{len()} & લિસ્ટમાં આઇટમોની સંખ્યા પાછી મોકલે છે & \texttt{len(list)} &
\texttt{len([1,\ 2,\ 3])} & \texttt{3} \\
\texttt{sum()} & લિસ્ટની બધી આઇટમોનો સરવાળો પાછો મોકલે છે &
\texttt{sum(list)} & \texttt{sum([1,\ 2,\ 3])} & \texttt{6} \\
\texttt{sort()} & લિસ્ટને ઇન-પ્લેસ સોર્ટ કરે છે & \texttt{list.sort()} &
\texttt{[3,\ 1,\ 2].sort()} & None (મૂળને સંશોધિત કરે છે) \\
\texttt{index()} & પ્રથમ ઘટનાનો ઇન્ડેક્સ પાછો મોકલે છે &
\texttt{list.index(value)} & \texttt{[10,\ 20,\ 30].index(20)} &
\texttt{1} \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{verbatim}
\# len() ફંકશન
numbers = [5, 10, 15, 20, 25]
print(f"લિસ્ટની લંબાઈ: \{len(numbers)\}")  \# આઉટપુટ: 5

\# sum() ફંકશન
print(f"બધી આઇટમોનો સરવાળો: \{sum(numbers)\}")  \# આઉટપુટ: 75

\# sort() ફંકશન
mixed = [3, 1, 4, 2]
mixed.sort()  \# ઇન{-પ્લેસ સોર્ટ થાય છે}
print(f"સોર્ટેડ લિસ્ટ: \{mixed\}")  \# આઉટપુટ: [1, 2, 3, 4]
mixed.sort(reverse=True)
print(f"રિવર્સ સોર્ટેડ: \{mixed\}")  \# આઉટપુટ: [4, 3, 2, 1]

\# index() ફંકશન
fruits = ["apple", "banana", "cherry", "apple"]
print(f"{banana નો ઇન્ડેક્સ: }\{fruits.index({banana})\}")  \# આઉટપુટ: 1
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LSSI'' (Length-Sum-Sort-Index)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) અથવા [7
ગુણ]}\label{q4c}

\textbf{0 થી N સંખ્યાઓની ફિબોનાક્કી શ્રેણીને પ્રિન્ટ કરવા માટે યુઝર-ડિફાઇન ફંકશન
બનાવો. (જ્યાં N એક પૂર્ણાંક સંખ્યા છે અને આર્ગ્યુમેન્ટ તરીકે પસાર થાય છે)}

\begin{solutionbox}

\begin{verbatim}
\# N સુધીની ફિબોનાક્કી શ્રેણીને પ્રિન્ટ કરવાનું ફંકશન
def print\_fibonacci(n):
    """
    n પદો સુધીની ફિબોનાક્કી શ્રેણી પ્રિન્ટ કરો
    જ્યાં 0મું પદ 0 અને 1લું પદ 1 છે
    """
    \# તપાસો કે ઇનપુટ માન્ય છે
    if n {} 0:
        print("કૃપા કરીને એક સકારાત્મક પૂર્ણાંક દાખલ કરો")
        return
    
    \# પ્રથમ બે પદોને પ્રારંભ કરો
    a, b = 0, 1
    count = 0
    
    print(f"\{n\} પદો સુધીની ફિબોનાક્કી શ્રેણી:")
    
    \# ફિબોનાક્કી શ્રેણી પ્રિન્ટ કરો
    while count {} n:
        print(a, end=" ")
        \# આગળના પુનરાવર્તન માટે ચલો અપડેટ કરો
        next\_term = a + b
        a = b
        b = next\_term
        count += 1
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart TD
    A([શરૂઆત]) {-{-} B["print\_fibonacci ફંકશન વ્યાખ્યાયિત કરો"]}
    B {-{-} C\{"શું n  0?"\}}
    C {-{-}|હા| D["ભૂલ સંદેશ પ્રદર્શિત કરો"]}
    D {-{-} E([રિટર્ન])}
C {-{-}|ના| F["a=0,

b=1, count=0 પ્રારંભ કરો"]}

    F {-{-} G["શીર્ષક પ્રદર્શિત કરો"]}
    G {-{-} H\{"શું count  n?"\}}
    H {-{-}|હા| I["a પ્રિન્ટ કરો"]}
    I {-{-} J["next\_term = a + b"]}
    J {-{-} K["a = b"]}
    K {-{-} L["b = next\_term"]}
    L {-{-} M["count += 1"]}
    M {-{-} H}
    H {-{-}|ના| N([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનપુટ વેલિડેશન}: તપાસો કે N એક માન્ય સકારાત્મક પૂર્ણાંક છે
\item
  \textbf{ચલો પ્રારંભ કરો}: પ્રથમ બે ફિબોનાક્કી પદો સેટ કરો
\item
  \textbf{શ્રેણી પ્રિન્ટ કરો}: ફિબોનાક્કી નંબરોને પ્રિન્ટ કરવા માટે લૂપ
\item
  \textbf{પદો અપડેટ કરો}: આગળના પદની ગણતરી કરો અને આગળના પુનરાવર્તન માટે મૂલ્યો
  શિફ્ટ કરો
\item
  \textbf{સમાપ્તિ}: જ્યારે કાઉન્ટ N સુધી પહોંચે ત્યારે અટકો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FIST'' (Fibonacci-Initialize-Shift-Terminate)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{આપેલ સ્ટ્રિંગ મેથડ્સ સમજાવો:} \textbf{i. count() ii. upper() iii.
replace()}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આઉટપુટ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{count()} & સબસ્ટ્રિંગની ઘટનાઓની ગણતરી કરે છે &
\texttt{str.count(substring)} & \texttt{"hello".count("l")} &
\texttt{2} \\
\texttt{upper()} & સ્ટ્રિંગને અપરકેસમાં રૂપાંતરિત કરે છે & \texttt{str.upper()} &
\texttt{"hello".upper()} & \texttt{"HELLO"} \\
\texttt{replace()} & સબસ્ટ્રિંગની બધી ઘટનાઓને બદલે છે &
\texttt{str.replace(old,\ new)} & \texttt{"hello".replace("l",\ "r")} &
\texttt{"herro"} \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{verbatim}
text = "Python programming is fun and Python is easy to learn"

\# count() મેથડ
print(f"{Python ની ગણતરી: }\{text.count({Python})\}")  \# આઉટપુટ: 2
print(f"{is ની ગણતરી: }\{text.count({is})\}")  \# આઉટપુટ: 2

\# upper() મેથડ
print(f"અપરકેસ: \{text.upper()\}")  \# આઉટપુટ: "PYTHON PROGRAMMING IS FUN AND PYTHON IS EASY TO LEARN"

\# replace() મેથડ
print(f"{Python ને Java સાથે બદલો: }\{text.replace({Python}, {Java})\}")
\# આઉટપુટ: "Java programming is fun and Java is easy to learn"
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CUR'' (Count-Upper-Replace)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{ટપલ ઓપરેશન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

પાયથોનમાં ટપલ્સ એ ક્રમમાં રહેલા, અપરિવર્તનીય સંગ્રહો છે જે કૌંસમાં બંધ થાય છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પરિણામ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સર્જન & મૂલ્યો સાથે ટપલ વ્યાખ્યાયિત કરો & \texttt{t\ =\ (1,\ 2,\ 3)} & 3 આઇટમો
સાથે ટપલ \\
ઇન્ડેક્સિંગ & સ્થિતિ દ્વારા આઇટમને એક્સેસ કરો & \texttt{t[0]} & \texttt{1} \\
સ્લાઇસિંગ & ટપલનો ભાગ બહાર કાઢો & \texttt{t[1:3]} &
\texttt{(2,\ 3)} \\
કેટેનેશન & બે ટપલ્સને જોડો & \texttt{t1\ +\ t2} & સંયુક્ત ટપલ \\
રિપિટિશન & ટપલ તત્વોને પુનરાવર્તિત કરો & \texttt{t\ *\ 2} & ડુપ્લિકેટેડ તત્વો \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{verbatim}
\# ટપલ બનાવો
fruits = ("apple", "banana", "cherry")
print(f"ફળોનું ટપલ: \{fruits\}")

\# ટપલ આઇટમોને એક્સેસ કરો
print(f"પ્રથમ ફળ: \{fruits[0]\}")  \# આઉટપુટ: "apple"
print(f"છેલ્લું ફળ: \{fruits[{-}1]\}")  \# આઉટપુટ: "cherry"

\# ટપલ સ્લાઇસિંગ
print(f"પ્રથમ બે ફળો: \{fruits[:2]\}")  \# આઉટપુટ: ("apple", "banana")

\# ટપલ કેટેનેશન
more\_fruits = ("orange", "kiwi")
all\_fruits = fruits + more\_fruits
print(f"બધા ફળો: \{all\_fruits\}")  \# આઉટપુટ: ("apple", "banana", "cherry", "orange", "kiwi")

\# ટપલ રિપિટિશન
duplicated = fruits * 2
print(f"ડુપ્લિકેટેડ: \{duplicated\}")  \# આઉટપુટ: ("apple", "banana", "cherry", "apple", "banana", "cherry")

\# ટપલ ફંકશનો
print(f"લંબાઈ: \{len(fruits)\}")  \# આઉટપુટ: 3
print(f"મહત્તમ: \{max(fruits)\}")  \# આઉટપુટ: "cherry" (મૂળાક્ષર તુલના)
print(f"ન્યૂનતમ: \{min(fruits)\}")  \# આઉટપુટ: "apple" (મૂળાક્ષર તુલના)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ICSM'' (Immutable-Create-Slice-Merge)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{બે સેટ બનાવવા અને આ બનાવેલા સેટ સાથે આપેલ ઓપરેશન કરવા માટે કોડ વિકસાવો:}
\textbf{i) સેટ પર યુનિયન ઓપરેશન} \textbf{ii) સેટ પર ઇન્ટરસેક્શન ઓપરેશન}
\textbf{iii) સેટ પર ડિફરન્સ ઓપરેશન} \textbf{iv) બે સેટનો સિમેટ્રિક ડિફરન્સ}

\begin{solutionbox}

\begin{verbatim}
\# સેટ ઓપરેશન દર્શાવવાનો પ્રોગ્રામ

\# બે સેટ બનાવો
set\_A = \{1, 2, 3, 4, 5\}
set\_B = \{4, 5, 6, 7, 8\}

print(f"સેટ A: \{set\_A\}")
print(f"સેટ B: \{set\_B\}")

\# i) યુનિયન ઓપરેશન (A  B)
\# A અથવા B અથવા બંનેમાં હાજર તત્વો
union\_result = set\_A.union(set\_B)  \# અથવા set\_A | set\_B
print(f"{n}i) A અને B નો યુનિયન (A  B): \{union\_result\}")

\# ii) ઇન્ટરસેક્શન ઓપરેશન (A  B)
\# A અને B બંનેમાં હાજર તત્વો
intersection\_result = set\_A.intersection(set\_B)  \# અથવા set\_A \& set\_B
print(f"ii) A અને B નો ઇન્ટરસેક્શન (A  B): \{intersection\_result\}")

\# iii) ડિફરન્સ ઓપરેશન (A {- B)}
\# A માં હાજર પરંતુ B માં નહીં એવા તત્વો
difference\_result = set\_A.difference(set\_B)  \# અથવા set\_A {- set\_B}
print(f"iii) ડિફરન્સ (A {- B): }\{difference\_result\}")

\# વૈકલ્પિક ડિફરન્સ (B {- A)}
difference\_alt = set\_B.difference(set\_A)  \# અથવા set\_B {- set\_A}
print(f"    ડિફરન્સ (B {- A): }\{difference\_alt\}")

\# iv) સિમેટ્રિક ડિફરન્સ (A △ B)
\# A અથવા B માં હાજર પરંતુ બંનેમાં નહીં એવા તત્વો
symmetric\_difference = set\_A.symmetric\_difference(set\_B)  \# અથવા set\_A \^{ set\_B}
print(f"iv) સિમેટ્રિક ડિફરન્સ (A △ B): \{symmetric\_difference\}")
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart TD
    A([શરૂઆત]) {-{-} B["set\_A = \{1,2,3,4,5\} બનાવો"]}
    B {-{-} C["set\_B = \{4,5,6,7,8\} બનાવો"]}
    C {-{-} D["સેટ A અને B પ્રિન્ટ કરો"]}
    D {-{-} E["union\_result = set\_A.union(set\_B)"]}
    E {-{-} F["union\_result પ્રિન્ટ કરો"]}
    F {-{-} G["intersection\_result = set\_A.intersection(set\_B)"]}
    G {-{-} H["intersection\_result પ્રિન્ટ કરો"]}
    H {-{-} I["difference\_result = set\_A.difference(set\_B)"]}
    I {-{-} J["difference\_result પ્રિન્ટ કરો"]}
    J {-{-} K["difference\_alt = set\_B.difference(set\_A)"]}
    K {-{-} L["difference\_alt પ્રિન્ટ કરો"]}
    L {-{-} M["symmetric\_difference = set\_A.symmetric\_difference(set\_B)"]}
    M {-{-} N["symmetric\_difference પ્રિન્ટ કરો"]}
    N {-{-} O([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{યુનિયન}: ડુપ્લિકેટ વિના બંને સેટના બધા તત્વો (1, 2, 3, 4, 5, 6, 7, 8)
\item
  \textbf{ઇન્ટરસેક્શન}: બંને સેટમાં સામાન્ય તત્વો (4, 5)
\item
  \textbf{ડિફરન્સ (A-B)}: A માં પરંતુ B માં નહીં એવા તત્વો (1, 2, 3)
\item
  \textbf{ડિફરન્સ (B-A)}: B માં પરંતુ A માં નહીં એવા તત્વો (6, 7, 8)
\item
  \textbf{સિમેટ્રિક ડિફરન્સ}: A અથવા B માં પરંતુ બંનેમાં નહીં એવા તત્વો (1, 2, 3,
  6, 7, 8)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``UIDS'' (Union-Intersection-Difference-Symmetric)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) અથવા [3
ગુણ]}\label{q5a}

\textbf{લિસ્ટને વ્યાખ્યાયિત કરો અને તે પાયથોનમાં કેવી રીતે બનાવવામાં આવે છે?}

\begin{solutionbox}
પાયથોનમાં લિસ્ટ એ ક્રમબદ્ધ, પરિવર્તનશીલ વસ્તુઓનો સંગ્રહ છે જે વિવિધ
ડેટા પ્રકારોના હોઈ શકે છે, જે ચોરસ કૌંસમાં બંધ હોય છે.

\textbf{લિસ્ટ સર્જન પદ્ધતિઓની સારણી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ્ધતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લિટરલ & ચોરસ કૌંસનો ઉપયોગ કરીને બનાવો &
\texttt{my\_list\ =\ [1,\ 2,\ 3]} \\
કન્સ્ટ્રક્ટર & list() ફંકશનનો ઉપયોગ કરીને બનાવો &
\texttt{my\_list\ =\ list((1,\ 2,\ 3))} \\
કોમ્પ્રિહેન્શન & એક લાઇન એક્સપ્રેશનનો ઉપયોગ કરીને બનાવો &
\texttt{my\_list\ =\ [x\ for\ x\ in\ range(5)]} \\
ઇટરેબલથી & અન્ય ઇટરેબલ્સને લિસ્ટમાં રૂપાંતરિત કરો &
\texttt{my\_list\ =\ list("abc")} \\
ખાલી લિસ્ટ & ખાલી લિસ્ટ બનાવો અને પછીથી ઉમેરો &
\texttt{my\_list\ =\ []} \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{verbatim}
\# લિટરલ્સનો ઉપયોગ કરીને લિસ્ટ બનાવો
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True]

\# list() કન્સ્ટ્રક્ટરનો ઉપયોગ કરીને બનાવો
tuple\_to\_list = list((10, 20, 30))
string\_to\_list = list("Python")

\# લિસ્ટ કોમ્પ્રિહેન્શનનો ઉપયોગ કરીને બનાવો
squares = [x**2 for x in range(1, 6)]

\# ખાલી લિસ્ટ બનાવો અને મૂલ્યો ઉમેરો
empty\_list = []
empty\_list.append("first")
empty\_list.append("second")

print(f"સંખ્યાઓ: \{numbers\}")
print(f"મિશ્ર: \{mixed\}")
print(f"ટપલથી: \{tuple\_to\_list\}")
print(f"સ્ટ્રિંગથી: \{string\_to\_list\}")
print(f"વર્ગો: \{squares\}")
print(f"નિર્મિત લિસ્ટ: \{empty\_list\}")
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LCMIE'' (Literal-Constructor-Mixed-Iterable-Empty)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) અથવા [4
ગુણ]}\label{q5b}

\textbf{ડિક્શનરી બિલ્ટ-ઇન ફંકશન અને મેથડ્સ સમજાવો.}

\begin{solutionbox}

ડિક્શનરી એ કર્લી બ્રેસિઝ \texttt{\{\}} માં બંધ કી-વેલ્યુ જોડીઓનો સંગ્રહ છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંકશન/મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પરિણામ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{dict()} & ડિક્શનરી બનાવે છે &
\texttt{dict(name=\textquotesingle{}John\textquotesingle{},\ age=25)} &
\texttt{\{\textquotesingle{}name\textquotesingle{}:\ \textquotesingle{}John\textquotesingle{},\ \textquotesingle{}age\textquotesingle{}:\ 25\}} \\
\texttt{len()} & આઇટમોની સંખ્યા પાછી મોકલે છે & \texttt{len(my\_dict)} &
પૂર્ણાંક ગણતરી \\
\texttt{keys()} & બધી કીનું વ્યૂ પાછું મોકલે છે & \texttt{my\_dict.keys()} &
ડિક્શનરી વ્યૂ ઓબ્જેક્ટ \\
\texttt{values()} & બધા મૂલ્યોનું વ્યૂ પાછું મોકલે છે & \texttt{my\_dict.values()}
& ડિક્શનરી વ્યૂ ઓબ્જેક્ટ \\
\texttt{items()} & (કી, મૂલ્ય) જોડીઓનું વ્યૂ પાછું મોકલે છે &
\texttt{my\_dict.items()} & ડિક્શનરી વ્યૂ ઓબ્જેક્ટ \\
\texttt{get()} & કી માટે મૂલ્ય, અથવા ડિફોલ્ટ પાછું મોકલે છે &
\texttt{my\_dict.get(\textquotesingle{}key\textquotesingle{},\ \textquotesingle{}default\textquotesingle{})}
& મૂલ્ય અથવા ડિફોલ્ટ \\
\texttt{update()} & બીજા ડિક્શનરીથી કી/મૂલ્યો સાથે ડિક્શનરી અપડેટ કરે છે &
\texttt{my\_dict.update(other\_dict)} & None (ઇન-પ્લેસ અપડેટ કરે છે) \\
\texttt{pop()} & કી સાથેની આઇટમ દૂર કરે છે અને મૂલ્ય પાછું મોકલે છે &
\texttt{my\_dict.pop(\textquotesingle{}key\textquotesingle{})} & દૂર કરેલી
આઇટમનું મૂલ્ય \\
\end{longtable}
}

\textbf{ઉદાહરણો:}

\begin{verbatim}
\# ડિક્શનરી બનાવો
student = \{
    {name}: {John},
    {age}: 20,
    {courses}: [{Math}, {Science}]
\}

\# બિલ્ટ{-ઇન ફંકશનો}
print(f"લંબાઈ: \{len(student)\}")  \# આઉટપુટ: 3

\# ડિક્શનરી મેથડ્સ
print(f"કીઝ: \{student.keys()\}")
print(f"વેલ્યુઝ: \{student.values()\}")
print(f"આઇટમ્સ: \{student.items()\}")

\# ડિફોલ્ટ સાથે get મેથડ
print(f"ગ્રેડ મેળવો (ડિફોલ્ટ સાથે): \{student.get({grade}, {N/A})\}")

\# ડિક્શનરી અપડેટ કરો
student.update(\{{grade}: {A}, {age}: 21\)}
print(f"અપડેટ પછી: \{student\}")

\# પોપ મેથડ
removed\_item = student.pop({age})
print(f"દૂર કરેલી આઇટમ: \{removed\_item\}")
print(f"પોપ પછી: \{student\}")
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LKVIGUP''
(Length-Keys-Values-Items-Get-Update-Pop)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) અથવા [7
ગુણ]}\label{q5c}

\textbf{1 થી 50 શ્રેણીમાં અવિભાજ્ય અને સંયુક્ત સંખ્યાઓની સૂચિ બનાવવા માટે પાયથોન કોડ
વિકસાવો.}

\begin{solutionbox}

\begin{verbatim}
\# 1 થી 50 સુધી અવિભાજ્ય અને સંયુક્ત સંખ્યાઓની સૂચિ બનાવવાનો પ્રોગ્રામ

def is\_prime(num):
    """
    સંખ્યા અવિભાજ્ય છે કે નહીં તે તપાસો
    અવિભાજ્ય હોય તો True, અન્યથા False પાછું મોકલે છે
    """
    \# 1 અવિભાજ્ય સંખ્યા નથી
    if num {=} 1:
        return False
    
    \# 2 અવિભાજ્ય સંખ્યા છે
    if num == 2:
        return True
    
    \# 2 થી મોટી બેકી સંખ્યાઓ અવિભાજ્ય નથી
    if num \% 2 == 0:
        return False
    
    \# num ના વર્ગમૂળ સુધીના વિષમ ભાજકોની તપાસ કરો
    \# (ઓપ્ટિમાઇઝેશન: આપણે માત્ર sqrt(num) સુધી તપાસવાની જરૂર છે)
    for i in range(3, int(num**0.5) + 1, 2):
if num \%

i == 0:

            return False
    
    return True

\# અવિભાજ્ય અને સંયુક્ત સંખ્યાઓ માટે ખાલી લિસ્ટ પ્રારંભ કરો
prime\_numbers = []
non\_prime\_numbers = []

\# 1 થી 50 સુધીની દરેક સંખ્યાની તપાસ કરો
for num in range(1, 51):
    if is\_prime(num):
        prime\_numbers.append(num)
    else:
        non\_prime\_numbers.append(num)

\# પરિણામો પ્રદર્શિત કરો
print(f"1 થી 50 સુધીની અવિભાજ્ય સંખ્યાઓ: \{prime\_numbers\}")
print(f"1 થી 50 સુધીની સંયુક્ત સંખ્યાઓ: \{non\_prime\_numbers\}")
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([શરૂઆત]) {-{-} B["is\_prime ફંકશન વ્યાખ્યાયિત કરો"]}
    B {-{-} C["prime\_numbers = [ ], non\_prime\_numbers = [ ] પ્રારંભ કરો"]}
    C {-{-} D["num = 1 થી 50 સુધી લૂપ"]}
    D {-{-} E\{"શું is\_prime(num) True છે?"\}}
    E {-{-}|હા| F["num ને prime\_numbers માં ઉમેરો"]}
    E {-{-}|ના| G["num ને non\_prime\_numbers માં ઉમેરો"]}
    F {-{-} H\{"લૂપ પૂર્ણ?"\}}
    G {-{-} H}
    H {-{-}|ના| D}
    H {-{-}|હા| I["prime\_numbers અને non\_prime\_numbers પ્રિન્ટ કરો"]}
    I {-{-} J([સમાપ્ત])}
\end{verbatim}

\textbf{સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{હેલ્પર ફંકશન}: \texttt{is\_prime()} કાર્યક્ષમ રીતે તપાસે છે કે સંખ્યા
  અવિભાજ્ય છે કે નહીં
\item
  \textbf{ઓપ્ટિમાઇઝેશન}: સંખ્યાના વર્ગમૂળ સુધી જ વિભાજ્યતા તપાસે છે
\item
  \textbf{વર્ગીકરણ}: સંખ્યાઓને અવિભાજ્ય અથવા સંયુક્ત સૂચિમાં વર્ગીકૃત કરે છે
\item
  \textbf{આઉટપુટ}: અંતે બંને સૂચિઓ પ્રદર્શિત કરે છે
\end{itemize}

\textbf{અવિભાજ્ય સંખ્યાઓ (1 થી 50):} 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
31, 37, 41, 43, 47 \textbf{સંયુક્ત સંખ્યાઓ (1 થી 50):} 1, 4, 6, 8, 9, 10, 12,
14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36,
38, 39, 40, 42, 44, 45, 46, 48, 49, 50

\end{solutionbox}
\begin{mnemonicbox}
``POEMS''
(Prime-Optimization-Efficient-Modulo-Sorting)

\end{mnemonicbox}

\end{document}
