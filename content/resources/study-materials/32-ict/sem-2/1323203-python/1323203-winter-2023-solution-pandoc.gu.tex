\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 1323203 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{આપેલ નંબર પોઝિટિવ છે કે નેગેટિવ તે તપાસવા માટે સ્યૂડો કોડ લખો}

\begin{solutionbox}

\begin{verbatim}
BEGIN
    Input number
    IF number > 0 THEN
        Display "Number is positive"
    ELSE IF number < 0 THEN
        Display "Number is negative"
    ELSE
        Display "Number is zero"
    END IF
END
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``શૂન્ય સાથે સરખાવો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{એલ્ગોરિધમ વ્યાખ્યાયિત કરો અને ત્રણ નંબર માંથી મહત્તમ નંબર શોધવાનો
એલ્ગોરિધમ બનાવો.}

\begin{solutionbox}

\textbf{Algorithm વ્યાખ્યા}: એલ્ગોરિધમ એટલે ચોક્કસ સમસ્યાને ઉકેલવા માટે અથવા
ગણતરી કરવા માટે બનાવેલ સ્ટેપ-બાય-સ્ટેપ પ્રક્રિયા અથવા નિયમોનો સેટ.

\textbf{ત્રણ નંબરમાંથી મહત્તમ શોધવાનો એલ્ગોરિધમ}:

\begin{verbatim}
BEGIN
    Input num1, num2, num3
    Set max = num1
    IF num2 > max THEN
        Set max = num2
    END IF
    IF num3 > max THEN
        Set max = num3
    END IF
    Display max
END
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Input num1, num2, num3]}
    B {-{-} C[Set max = num1]}
    C {-{-} D\{Is num2  max?\}}
    D {-{-} Yes {-}{-} E[Set max = num2]}
    D {-{-} No {-}{-} F\{Is num3  max?\}}
    E {-{-} F}
    F {-{-} Yes {-}{-} G[Set max = num3]}
    F {-{-} No {-}{-} H[Display max]}
    G {-{-} H}
    H {-{-} I[End]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``સરખામણી અને બદલો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{તાપમાન ના સેલ્સિયસ ને ફેરનહાઇટ માં કન્વર્ટ કરવાનો પાયથોન કોડ લખો.}

\begin{solutionbox}

\begin{verbatim}
\# સેલ્સિયસથી ફેરનહાઇટ રૂપાંતરનો પ્રોગ્રામ

\# યુઝર પાસેથી સેલ્સિયસ તાપમાન મેળવો
celsius = float(input("સેલ્સિયસમાં તાપમાન દાખલ કરો: "))

\# સૂત્ર વાપરીને ફેરનહાઇટમાં રૂપાંતરિત કરો: F = (C * 9/5) + 32
fahrenheit = (celsius * 9/5) + 32

\# પરિણામ દર્શાવો
print(f"\{celsius\}^ એ \{fahrenheit\}^ ની બરાબર છે")
\end{verbatim}

\textbf{ટેબલ: તાપમાન રૂપાંતરણ}:

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઘટક & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઇનપુટ} & સેલ્સિયસમાં તાપમાન \\
\textbf{સૂત્ર} & F = (C \times 9/5) + 32 \\
\textbf{આઉટપુટ} & ફેરનહાઇટમાં તાપમાન \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``9થી ગુણાકાર, 5થી ભાગાકાર, 32 ઉમેરો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1c-or-7-uxa97uxaa3}

\textbf{કંપેરિઝન ઓપરેટર નું લિસ્ટ આપો અને દરેકને પાયથોન કોડના ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: પાયથોન કંપેરિઝન ઓપરેટર્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & વર્ણન & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{==} & બરાબર છે & \texttt{5\ ==\ 5} & \texttt{True} \\
\textbf{!=} & બરાબર નથી & \texttt{5\ !=\ 6} & \texttt{True} \\
\textbf{\textgreater{}} & કરતાં મોટું & \texttt{6\ \textgreater{}\ 3} &
\texttt{True} \\
\textbf{\textless{}} & કરતાં નાનું & \texttt{3\ \textless{}\ 6} &
\texttt{True} \\
\textbf{\textgreater=} & કરતાં મોટું અથવા બરાબર &
\texttt{5\ \textgreater{}=\ 5} & \texttt{True} \\
\textbf{\textless=} & કરતાં નાનું અથવા બરાબર & \texttt{5\ \textless{}=\ 5}
& \texttt{True} \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# પાયથોન કંપેરિઝન ઓપરેટર્સ ઉદાહરણ
a = 10
b = 5

\# બરાબર છે
print(f"\{a\} == \{b\}: \{a == b\}")  \# False

\# બરાબર નથી
print(f"\{a\} != \{b\}: \{a != b\}")  \# True

\# કરતાં મોટું
print(f"\{a\} { }\{b\}: \{a {} b\}")    \# True

\# કરતાં નાનું
print(f"\{a\} { }\{b\}: \{a {} b\}")    \# False

\# કરતાં મોટું અથવા બરાબર
print(f"\{a\} {= }\{b\}: \{a {=} b\}")  \# True

\# કરતાં નાનું અથવા બરાબર
print(f"\{a\} {= }\{b\}: \{a {=} b\}")  \# False
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``સરખાવો'' (સમાન, રિલેશનલ, ખાસ સરખામણી, અસમાનતા, વધુ
ઓછું)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{પાયથોન ના ડેટા ટાઇપ સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: પાયથોન ડેટા ટાઇપ્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ડેટા ટાઇપ & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{int} & પૂર્ણાંક મૂલ્યો & \texttt{x\ =\ 10} \\
\textbf{float} & દશાંશ બિંદુ મૂલ્યો & \texttt{y\ =\ 10.5} \\
\textbf{str} & ટેક્સ્ટ અથવા અક્ષર મૂલ્યો & \texttt{name\ =\ "Python"} \\
\textbf{bool} & તાર્કિક મૂલ્યો (True/False) &
\texttt{is\_valid\ =\ True} \\
\textbf{list} & ક્રમબદ્ધ, બદલી શકાય તેવો સંગ્રહ &
\texttt{nums\ =\ [1,\ 2,\ 3]} \\
\textbf{tuple} & ક્રમબદ્ધ, ન બદલી શકાય તેવો સંગ્રહ &
\texttt{point\ =\ (5,\ 10)} \\
\textbf{dict} & કી-વેલ્યુ જોડી &
\texttt{student\ =\ \{"name":\ "John"\}} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``NIFTY SLD'' (નંબર્સ, ઇન્ટીજર્સ, ફ્લોટ્સ, ટેક્સ્ટ, યસ/નો,
સીક્વન્સીસ, લિસ્ટ્સ, ડિક્શનરીઝ)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{Nested If પાયથોન કોડ ના ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{Nested if}: એક conditional statement ની અંદર બીજું conditional
statement લખવાને nested if કહેવામાં આવે છે. તે ઘણી શરતોને ક્રમમાં તપાસવાની મંજૂરી
આપે છે.

\begin{verbatim}
\# નંબર પોઝિટિવ, નેગેટિવ કે શૂન્ય છે તે ચકાસવા માટેનો nested if ઉદાહરણ
\# અને જો પોઝિટિવ હોય, તો તે સમ છે કે વિષમ તે ચકાસો

num = int(input("એક નંબર દાખલ કરો: "))

if num {} 0:
    print("પોઝિટિવ નંબર")
    \# nested if જે ચકાસે છે કે પોઝિટિવ નંબર સમ છે કે વિષમ
    if num \% 2 == 0:
        print("સમ નંબર")
    else:
        print("વિષમ નંબર")
elif num {} 0:
    print("નેગેટિવ નંબર")
else:
    print("શૂન્ય")
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Input num]}
    B {-{-} C\{Is num  0?\}}
    C {-{-} Yes {-}{-} D[Print Positive number]}
    D {-{-} E\{Is num \% 2 == 0?\}}
    E {-{-} Yes {-}{-} F[Print Even number]}
    E {-{-} No {-}{-} G[Print Odd number]}
    C {-{-} No {-}{-} H\{Is num  0?\}}
    H {-{-} Yes {-}{-} I[Print Negative number]}
    H {-{-} No {-}{-} J[Print Zero]}
    F {-{-} K[End]}
    G {-{-} K}
    I {-{-} K}
    J {-{-} K}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ચેક અંદર ચેક''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{ઉદાહરણ સાથે વિવિધ પ્રકારના પસંદગી/નિર્ણય લેવાના ફ્લો-ઓફ-કંટ્રોલ સ્ટ્રક્ચર
ઉપયોગ સમજાવો}

\begin{solutionbox}

\textbf{ટેબલ: પાયથોનમાં સિલેક્શન કંટ્રોલ સ્ટ્રક્ચર્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
સ્ટ્રક્ચર & હેતુ & વપરાશ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{if} & શરત સાચી હોય ત્યારે કોડ ચલાવવા & સરળ શરત ચકાસણી \\
\textbf{if-else} & સાચી શરત માટે એક કોડ, ખોટી માટે બીજો & દ્વિ નિર્ણય લેવા \\
\textbf{if-elif-else} & ઘણી શરતો ચકાસવી & ઘણા સંભવિત પરિણામો \\
\textbf{Nested if} & શરત અંદર બીજી શરત & જટિલ શ્રેણીબદ્ધ નિર્ણયો \\
\textbf{Ternary operator} & એક લાઇન if-else & સરળ શરતી નિયુક્તિ \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# વિવિધ સિલેક્શન સ્ટ્રક્ચર્સનું ઉદાહરણ
score = int(input("તમારો સ્કોર દાખલ કરો: "))

\# સાદું if
if score {=} 90:
    print("ઉત્તમ!")

\# if{-else}
if score {=} 60:
    print("તમે પાસ થયા છો.")
else:
    print("તમે નાપાસ થયા છો.")

\# if{-elif{-}else}
if score {=} 90:
    grade = "A"
elif score {=} 80:
    grade = "B"
elif score {=} 70:
    grade = "C"
elif score {=} 60:
    grade = "D"
else:
    grade = "F"
print(f"તમારો ગ્રેડ \{grade\} છે")

\# Ternary operator
result = "પાસ" if score {=} 60 else "નાપાસ"
print(result)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SCENE'' (સિમ્પલ if, કન્ડિશન્સ વિથ else, Elif ફોર
મલ્ટિપલ, Nested ફોર કોમ્પ્લેક્સ, એક્સપ્રેસ વિથ ટર્નરી)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3 ગુણ] - OR
ઓપ્શન}\label{q2a}

\textbf{વેરિયેબલ વ્યાખ્યાયિત કરવાના નિયમો લિસ્ટ કરો.}

\begin{solutionbox}

\textbf{ટેબલ: પાયથોનમાં વેરિએબલ્સ વ્યાખ્યાયિત કરવાના નિયમો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4643}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
નિયમ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{અક્ષર અથવા અન્ડરસ્કોરથી શરૂ કરો} & પ્રથમ અક્ષર એક લેટર અથવા અન્ડરસ્કોર
હોવો જોઈએ & \texttt{name\ =\ "John"}, \texttt{\_count\ =\ 10} \\
\textbf{કોઈ ખાસ અક્ષરો નહીં} & માત્ર અક્ષરો, અંકો અને અન્ડરસ્કોર માન્ય &
\texttt{user\_name} (માન્ય), \texttt{user-name} (અમાન્ય) \\
\textbf{કેસ સેન્સિટિવ} & મોટા અક્ષરો અને નાના અક્ષરો અલગ & \texttt{age} અને
\texttt{Age} અલગ વેરિએબલ્સ છે \\
\textbf{રિઝર્વ્ડ કીવર્ડ્સ નહીં} & પાયથોન કીવર્ડ્સને વેરિએબલ નામ તરીકે ઉપયોગ ન કરી
શકાય & \texttt{if}, \texttt{for}, \texttt{while}, વગેરે ઉપયોગ ન કરી
શકાય \\
\textbf{સ્પેસ નહીં} & સ્પેસને બદલે અન્ડરસ્કોર વાપરો & \texttt{first\_name}
(\texttt{first\ name} નહીં) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``SILKS'' (શરૂઆત યોગ્ય રીતે, ઇગ્નોર સ્પેશિયલ કેરેક્ટર, લૂક એટ
કેસ, કીવર્ડ્સ અવોઇડ, સ્પેસ નોટ અલાઉડ)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4 ગુણ] - OR
ઓપ્શન}\label{q2b}

\textbf{ફોર લૂપ ને જરૂરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{પાયથોનમાં For Loop}: for લૂપનો ઉપયોગ કોઈ sequence (લિસ્ટ, ટપલ,
સ્ટ્રીંગ) અથવા અન્ય iterable ઓબ્જેક્ટ પર પુનરાવર્તન કરવા માટે થાય છે. તે sequence ના
દરેક આઇટમ માટે કોડનો એક બ્લોક ચલાવે છે.

\begin{verbatim}
\# પાયથોનમાં for લૂપનો ઉદાહરણ
\# લિસ્ટના દરેક એલિમેન્ટને પ્રિન્ટ કરવા
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

\# range ફંક્શનનો for લૂપ સાથે ઉપયોગ
print("1 થી 5 સુધીના નંબર:")
for i in range(1, 6):
    print(i)

\# સ્ટ્રિંગ સાથે for લૂપનો ઉપયોગ
name = "Python"
for char in name:
    print(char)
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Initialize sequence]}
    B {-{-} C[Get first item]}
    C {-{-} D[Execute code block]}
    D {-{-} E\{More items?\}}
    E {-{-} Yes {-}{-} F[Get next item]}
    F {-{-} D}
    E {-{-} No {-}{-} G[End]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ITEM'' (Iterate Through Each Member) - દરેક સભ્ય પર
પુનરાવર્તન કરો

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7 ગુણ] - OR
ઓપ્શન}\label{q2c}

\textbf{Break અને continue સ્ટેટમેન્ટને સંક્ષિપ્તમાં સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Break અને Continue સ્ટેટમેન્ટ્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3929}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
સ્ટેટમેન્ટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
અસર
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{break} & લૂપમાંથી તરત જ બહાર નીકળો & વર્તમાન લૂપને અટકાવે છે અને લૂપ
પછીના સ્ટેટમેન્ટ પર કંટ્રોલ ટ્રાન્સફર કરે છે \\
\textbf{continue} & વર્તમાન પુનરાવર્તન છોડી દો & લૂપના આગલા પુનરાવર્તન પર જાય
છે, continue સ્ટેટમેન્ટ પછીના કોઈપણ કોડને છોડી દે છે \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# Break સ્ટેટમેન્ટ ઉદાહરણ
print("Break ઉદાહરણ:")
for i in range(1, 11):
if

i == 6:

        print("i =", i, "પર લૂપ તોડીએ છીએ")
        break
    print(i, end=" ")
print("{n}લૂપ સમાપ્ત થઈ")

\# Continue સ્ટેટમેન્ટ ઉદાહરણ
print("{n}Continue ઉદાહરણ:")
for i in range(1, 11):
    if i \% 2 == 0:
        continue
    print(i, end=" ")
print("{n}માત્ર વિષમ નંબરો પ્રિન્ટ થયા")
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Start Loop] {-{-} B\{Condition met for break?\}}
    B {-{-} Yes {-}{-} C[Exit Loop]}
    B {-{-} No {-}{-} D\{Condition met for continue?\}}
    D {-{-} Yes {-}{-} E[Skip to next iteration]}
    E {-{-} A}
    D {-{-} No {-}{-} F[Execute remaining code in loop body]}
    F {-{-} A}
    C {-{-} G[Continue execution after loop]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``EXIT SKIP'' (EXIT with break, SKIP with continue)
- બ્રેક સાથે બહાર નીકળો, કન્ટિન્યુ સાથે છોડી દો

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{1 થી 10 નંબર ને લૂપથી પ્રિન્ટ કરવા માટેનો પાયથન કોડ બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# 1 થી 10 સુધીના નંબર પ્રિન્ટ કરવા for લૂપનો ઉપયોગ
print("for લૂપનો ઉપયોગ કરીને:")
for i in range(1, 11):
    print(i, end=" ")

print("{nn}while લૂપનો ઉપયોગ કરીને:")
\# 1 થી 10 સુધીના નંબર પ્રિન્ટ કરવા while લૂપનો ઉપયોગ
counter = 1
while counter {=} 10:
    print(counter, end=" ")
    counter += 1
\end{verbatim}

\textbf{ટેબલ: લૂપ અભિગમ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
અભિગમ & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{range સાથે For લૂપ} & સરળ, સંક્ષિપ્ત, આપોઆપ કાઉન્ટર મેનેજ કરે છે \\
\textbf{While લૂપ} & જટિલ શરતો માટે વધુ લવચીક \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``COUNT UP'' (Counter દરેક પુનરાવર્તનમાં અપડેટ થાય છે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{નીચેની પેટર્ન પ્રિન્ટ કરવા માટેનો પાયથન કોડ લખો.}

\begin{verbatim}
*
**
***
****
*****
\end{verbatim}

\begin{solutionbox}

\begin{verbatim}
\# for લૂપનો ઉપયોગ કરીને સ્ટાર પેટર્ન પ્રિન્ટ કરો
rows = 5

for i in range(1, rows + 1):
    \# દરેક રો માં i જેટલા સ્ટાર પ્રિન્ટ કરો
    print("*" * i)
\end{verbatim}

\textbf{વૈકલ્પિક ઉકેલ નેસ્ટેડ લૂપ્સ સાથે}:

\begin{verbatim}
\# નેસ્ટેડ લૂપ્સનો ઉપયોગ કરીને સ્ટાર પેટર્ન પ્રિન્ટ કરો
rows = 5

for i in range(1, rows + 1):
    for j in range(1, i + 1):
        print("*", end="")
    print()  \# દરેક રો પછી ન્યુ લાઇન
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Set rows = 5]}
    B {-{-} C[Initialize i = 1]}
    C {-{-} D\{"Is i = rows?"\}}
    D {-{-} Yes {-}{-} E["Print * * i"]}
    E {-{-} F[Increment i]}
    F {-{-} D}
    D {-{-} No {-}{-} G[End]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``RISE UP'' (Row Increases, Stars Expand Upward
Progressively) - રો વધે છે, સ્ટાર ઊપર તરફ વિસ્તરે છે

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{આપેલા નંબર નો factorial શોધવા માટેનું યુઝર ડિફાઇન ફંક્શન બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# આપેલા નંબરનો ફેક્ટોરિયલ શોધવા માટેનું ફંક્શન
def factorial(n):
    \# ઇનપુટ માન્ય છે કે નહીં તે ચકાસો
    if not isinstance(n, int) or n {} 0:
        return "અમાન્ય ઇનપુટ. કૃપા કરીને નોન{-નેગેટિવ ઇન્ટીજર દાખલ કરો."}
    
    \# બેઝ કેસ: 0 અથવા 1 નો ફેક્ટોરિયલ 1 છે
if

n == 0 or

n == 1:

        return 1
    
    \# ઇટરેશન વાપરીને ફેક્ટોરિયલ ગણતરી
    result = 1
    for i in range(2, n + 1):
        result *= i
    
    return result

\# ફંક્શન ટેસ્ટ કરો
number = int(input("ફેક્ટોરિયલ શોધવા માટે એક નંબર દાખલ કરો: "))
print(f"\{number\} નો ફેક્ટોરિયલ \{factorial(number)\} છે")
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Define factorial function]}
    B {-{-} C[Check if n is valid]}
    C {-{-} Invalid {-}{-} D[Return error message]}
    C {-{-} Valid {-}{-} E\{Is n 0 or 1?\}}
    E {-{-} Yes {-}{-} F[Return 1]}
    E {-{-} No {-}{-} G[Set result = 1]}
    G {-{-} H[Loop from 2 to n]}
    H {-{-} I[result = result * i]}
    I {-{-} J[Return result]}
    J {-{-} K[End]}
\end{verbatim}

\textbf{ટેબલ: ફેક્ટોરિયલ ઉદાહરણો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
નંબર & ગણતરી & ફેક્ટોરિયલ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 0! = 1 & 1 \\
1 & 1! = 1 & 1 \\
3 & 3! = 3 \times 2 \times 1 & 6 \\
5 & 5! = 5 \times 4 \times 3 \times 2 \times 1 & 120 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``1 સુધી ગુણાકાર કરો'' (બધા આંકડાને 1 સુધી ગુણાકાર કરો)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3 ગુણ] - OR
ઓપ્શન}\label{q3a}

\textbf{1 થી N માંથી odd અને even નંબર શોધવાનો પાયથન કોડ બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# 1 થી N સુધીના odd અને even નંબર શોધવાનો પ્રોગ્રામ

\# યુઝર પાસેથી ઇનપુટ લો
N = int(input("N ની કિંમત દાખલ કરો: "))

print("1 થી", N, "સુધીના even નંબર છે:")
for i in range(1, N + 1):
    if i \% 2 == 0:
        print(i, end=" ")

print("{n}1 થી", N, "સુધીના odd નંબર છે:")
for i in range(1, N + 1):
    if i \% 2 != 0:
        print(i, end=" ")
\end{verbatim}

\textbf{ટેબલ: Even અને Odd ચેક}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
નંબર & ચેક & પ્રકાર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Even નંબર & \texttt{number\ \%\ 2\ ==\ 0} & 2, 4, 6, \ldots{} \\
Odd નંબર & \texttt{number\ \%\ 2\ !=\ 0} & 1, 3, 5, \ldots{} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``MOD-2'' (Modulo 2 જે even કે odd નક્કી કરે છે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4 ગુણ] - OR
ઓપ્શન}\label{q3b}

\textbf{Nested લિસ્ટ અને તેના એલિમેન્ટ ડિસ્પ્લે કરવા માટેનો પાયથન કોડ બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# Nested લિસ્ટ બનાવવા અને ડિસ્પ્લે કરવાનો પ્રોગ્રામ

\# Nested લિસ્ટ બનાવો
nested\_list = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

\# Nested લિસ્ટ ડિસ્પ્લે કરો
print("Nested લિસ્ટ:", nested\_list)

\# Nested લૂપ્સનો ઉપયોગ કરીને દરેક એલિમેન્ટ ડિસ્પ્લે કરો
print("{n}Nested લિસ્ટના એલિમેન્ટ્સ:")
for i in range(len(nested\_list)):
    for j in range(len(nested\_list[i])):
        print(f"nested\_list[\{i\}][\{j\}] = \{nested\_list[i][j]\}")

\# enumerate નો ઉપયોગ કરીને વૈકલ્પિક રીત
print("{n}enumerate નો ઉપયોગ કરીને:")
for i, inner\_list in enumerate(nested\_list):
    for j, value in enumerate(inner\_list):
        print(f"પોઝિશન (\{i\}, \{j\}): \{value\}")
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart TD
    A[Nested List] {-{-} B[Row 0]}
    A {-{-} C[Row 1]}
    A {-{-} D[Row 2]}
    B {-{-} B1[1]}
    B {-{-} B2[2]}
    B {-{-} B3[3]}
    C {-{-} C1[4]}
    C {-{-} C2[5]}
    C {-{-} C3[6]}
    D {-{-} D1[7]}
    D {-{-} D2[8]}
    D {-{-} D3[9]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ROWS COLS'' (રો અને કોલમ માળખું બનાવે છે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7 ગુણ] - OR
ઓપ્શન}\label{q3c}

\textbf{Local અને Global વેરિયેબલ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{ટેબલ: Local vs Global વેરિએબલ્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1463}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1707}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3659}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3171}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્કોપ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
એક્સેસિબિલિટી
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઘોષણા
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Local વેરિએબલ્સ} & માત્ર જે ફંક્શનમાં ઘોષિત થયા છે ત્યાં & માત્ર ઘોષિત
કરનાર ફંક્શનની અંદર & ફંક્શનની અંદર \\
\textbf{Global વેરિએબલ્સ} & સમગ્ર પ્રોગ્રામમાં & બધા ફંક્શન એક્સેસ કરી શકે & કોઈપણ
ફંક્શનની બહાર \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# Global વેરિએબલ
total = 0

def add\_numbers(a, b):
    \# Local વેરિએબલ્સ
    sum\_result = a + b
    print(f"Local વેરિએબલ sum\_result: \{sum\_result\}")
    
    \# Global વેરિએબલ એક્સેસ કરવું
    print(f"Global વેરિએબલ total મોડિફિકેશન પહેલાં: \{total\}")
    
    \# ફંક્શનની અંદર Global વેરિએબલ મોડિફાય કરવા
    global total
    total = sum\_result
    print(f"Global વેરિએબલ total મોડિફિકેશન પછી: \{total\}")
    
    return sum\_result

\# મુખ્ય પ્રોગ્રામ
x = 5  \# મુખ્ય પ્રોગ્રામમાં Local
y = 10  \# મુખ્ય પ્રોગ્રામમાં Local

result = add\_numbers(x, y)
print(f"પરિણામ: \{result\}")
print(f"અપડેટેડ global total: \{total\}")

\# આ ભૂલ આપશે કારણ કે sum\_result એ add\_numbers માટે Local છે
\# print(sum\_result)  \# NameError: name {sum\_result is not defined}
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Program Scope] {-{-} B[Global Variables: total]}
    A {-{-} C[Function Scope: add\_numbers]}
    C {-{-} D[Local Variables: sum\_result, a, b]}
    A {-{-} E[Main Program Variables: x, y, result]}
    B {{-}.{-} C}
    D {-.{-} C}
    E {-.{-} A}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``GLOBAL SEES ALL'' (Global વેરિએબલ્સ બધે જોઈ શકે છે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{પાયથન ની સ્ટાન્ડર્ડ લાઇબ્રેરી ના મેથેમેટિકલ ફંક્શન લિસ્ટ કરો.}

\begin{solutionbox}

\textbf{ટેબલ: પાયથોન Math મોડ્યુલ ફંક્શન્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફંક્શન & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{abs()} & એબ્સોલ્યુટ વેલ્યુ આપે છે & \texttt{abs(-5)} \rightarrow \texttt{5} \\
\textbf{pow()} & x ને y ની ઘાત આપે છે & \texttt{pow(2,\ 3)} \rightarrow \texttt{8} \\
\textbf{max()} & સૌથી મોટી વેલ્યુ આપે છે & \texttt{max(5,\ 10,\ 15)} \rightarrow
\texttt{15} \\
\textbf{min()} & સૌથી નાની વેલ્યુ આપે છે & \texttt{min(5,\ 10,\ 15)} \rightarrow
\texttt{5} \\
\textbf{round()} & નજીકના પૂર્ણાંક સુધી રાઉન્ડ કરે છે & \texttt{round(4.6)} \rightarrow
\texttt{5} \\
\textbf{math.sqrt()} & વર્ગમૂળ & \texttt{math.sqrt(16)} \rightarrow \texttt{4.0} \\
\textbf{math.sin()} & સાઇન ફંક્શન & \texttt{math.sin(math.pi/2)} \rightarrow
\texttt{1.0} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``PEARS Math'' (Power, Exponents, Arithmetic, Roots,
Sine functions in Math)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{પાયથન મોડ્યુલ કોડ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{મોડ્યુલ}: પાયથોનમાં મોડ્યુલ એટલે પાયથોન વ્યાખ્યાઓ અને સ્ટેટમેન્ટ્સ ધરાવતી
ફાઇલ. ફાઇલનું નામ .py સફિક્સ સાથેનું મોડ્યુલનું નામ છે.

\begin{verbatim}
\# math મોડ્યુલના ઉપયોગનું ઉદાહરણ
import math

\# math મોડ્યુલમાંથી ગાણિતિક ફંક્શન્સનો ઉપયોગ
radius = 5
area = math.pi * math.pow(radius, 2)
print(f"ત્રિજ્યા \{radius\} વાળા વર્તુળનું ક્ષેત્રફળ \{area:.2f\} છે")

\# વિવિધ import ટેકનિક્સનો ઉપયોગ
from math import sqrt, sin
angle = math.pi / 4
print(f"25 નું વર્ગમૂળ \{sqrt(25)\} છે")
print(f"\{angle\} રેડિયન્સનો સાઇન \{sin(angle):.4f\} છે")

\# alias સાથે import
import random as rnd
random\_number = rnd.randint(1, 100)
print(f"1 અને 100 વચ્ચેનો રેન્ડમ નંબર: \{random\_number\}")
\end{verbatim}

\textbf{ટેબલ: મોડ્યુલ Import ટેકનિક્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ્ધતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{આખો મોડ્યુલ import કરો} & \texttt{import\ module\_name} &
\texttt{import\ math} \\
\textbf{ચોક્કસ આઇટમ્સ import કરો} &
\texttt{from\ module\_name\ import\ item1,\ item2} &
\texttt{from\ math\ import\ sqrt,\ sin} \\
\textbf{alias સાથે import કરો} & \texttt{import\ module\_name\ as\ alias}
& \texttt{import\ random\ as\ rnd} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``CODE-LIB'' (Code Libraries for reuse) - ફરીથી
ઉપયોગ માટે કોડ લાઇબ્રેરીઓ

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{એક પાયથન પ્રોગ્રામ લખો જે નિર્ધારિત કરે છે કે આપેલ નંબર `આર્મસ્ટ્રોંગ નંબર' છે
કે વપરાશકર્તા-વ્યાખ્યાયિત કાર્યનો ઉપયોગ કરીને પેલિન્ડ્રોમ છે.}

\begin{solutionbox}

\begin{verbatim}
\# નંબર આર્મસ્ટ્રોંગ છે કે નહીં તે ચેક કરવા માટેનું ફંક્શન
def is\_armstrong(num):
    \# અંકોની સંખ્યા ગણવા માટે નંબરને સ્ટ્રિંગમાં રૂપાંતરિત કરો
    num\_str = str(num)
    n = len(num\_str)
    
    \# દરેક અંકને અંકોની સંખ્યાની ઘાત સુધી ઉગામેલા સરવાળાની ગણતરી
    armstrong\_sum = 0
    for digit in num\_str:
        armstrong\_sum += int(digit) ** n
    
    \# ચેક કરો કે સરવાળો મૂળ નંબર સાથે મેળ ખાય છે
    return armstrong\_sum == num

\# નંબર પેલિન્ડ્રોમ છે કે નહીં તે ચેક કરવા માટેનું ફંક્શન
def is\_palindrome(num):
    \# નંબરને સ્ટ્રિંગમાં રૂપાંતરિત કરો અને ચેક કરો કે તે આગળથી અને પાછળથી એક સરખો વંચાય છે
    num\_str = str(num)
    return num\_str == num\_str[::{-}1]

\# મુખ્ય પ્રોગ્રામ
number = int(input("એક નંબર દાખલ કરો: "))

\# ચેક કરો કે નંબર આર્મસ્ટ્રોંગ છે કે નહીં
if is\_armstrong(number):
    print(f"\{number\} એક આર્મસ્ટ્રોંગ નંબર છે")
else:
    print(f"\{number\} આર્મસ્ટ્રોંગ નંબર નથી")

\# ચેક કરો કે નંબર પેલિન્ડ્રોમ છે કે નહીં
if is\_palindrome(number):
    print(f"\{number\} એક પેલિન્ડ્રોમ છે")
else:
    print(f"\{number\} પેલિન્ડ્રોમ નથી")
\end{verbatim}

\textbf{ટેબલ: ઉદાહરણો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.1951}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3902}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4146}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
નંબર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આર્મસ્ટ્રોંગ ચેક
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
પેલિન્ડ્રોમ ચેક
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
153 & 1^{3} + 5^{3} + 3^{3} = 1 + 125 + 27 = 153 ✓ & 153 \neq 351 ✗ \\
121 & 1^{3} + 2^{3} + 1^{3} = 1 + 8 + 1 = 10 \neq 121 ✗ & 121 = 121 ✓ \\
1634 & 1^{4} + 6^{4} + 3^{4} + 4^{4} = 1 + 1296 + 81 + 256 = 1634 ✓ & 1634 \neq 4361
✗ \\
\end{longtable}
}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Input number]}
    B {-{-} C\{Check Armstrong\}}
    C {-{-} D\{Check Palindrome\}}
    C {-{-} Yes {-}{-} E[Print {-} Is Armstrong]}
    C {-{-} No {-}{-} F[Print {-} Not Armstrong]}
    D {-{-} Yes {-}{-} G[Print {-} Is Palindrome]}
    D {-{-} No {-}{-} H[Print {-} Not Palindrome]}
    E {-{-} D}
    F {-{-} D}
    G {-{-} I[End]}
    H {-{-} I}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SAME SUM'' (SAME આગળ-પાછળ પેલિન્ડ્રોમ માટે, SUM ઘાતના
અંકોનો આર્મસ્ટ્રોંગ માટે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3 ગુણ] - OR
ઓપ્શન}\label{q4a}

\textbf{પાયથોનમાં બિલ્ટ ઇન ફંક્શન સમજાવો.}

\begin{solutionbox}

\textbf{Built-in Functions}: આ ફંક્શન્સ પાયથોનના સ્ટાન્ડર્ડ લાઇબ્રેરીનો ભાગ છે અને
કોઈપણ મોડ્યુલ import કર્યા વિના ઉપલબ્ધ છે.

\textbf{ટેબલ: સામાન્ય પાયથોન Built-in Functions}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ફંક્શન & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{print()} & આઉટપુટ ડિસ્પ્લે & \texttt{print("Hello")} \\
\textbf{input()} & યુઝર ઇનપુટ લે & \texttt{name\ =\ input("Name:\ ")} \\
\textbf{len()} & ઓબ્જેક્ટની લંબાઈ આપે & \texttt{len([1,\ 2,\ 3])} \rightarrow
\texttt{3} \\
\textbf{type()} & ઓબ્જેક્ટનો પ્રકાર આપે & \texttt{type(5)} \rightarrow
\texttt{\textless{}class\ \textquotesingle{}int\textquotesingle{}\textgreater{}} \\
\textbf{int(), float(), str()} & ચોક્કસ પ્રકારમાં રૂપાંતર & \texttt{int("5")}
\rightarrow \texttt{5} \\
\textbf{range()} & સીક્વન્સ જનરેટ કરે & \texttt{list(range(3))} \rightarrow
\texttt{[0,\ 1,\ 2]} \\
\textbf{sum()} & સરવાળો ગણે & \texttt{sum([1,\ 2,\ 3])} \rightarrow
\texttt{6} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``PITS LCR'' (Print, Input, Type, Sum, Len, Convert,
Range)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4 ગુણ] - OR
ઓપ્શન}\label{q4b}

\textbf{એક પાયથોન કોડનું ઉદાહરણ આપીને પાયથોન મેથ મોડ્યુલનું વર્ણન કરો.}

\begin{solutionbox}

\textbf{પાયથોન Math મોડ્યુલ}: math મોડ્યુલ C સ્ટાન્ડર્ડ દ્વારા વ્યાખ્યાયિત ગાણિતિક
ફંક્શન્સની એક્સેસ પ્રદાન કરે છે.

\begin{verbatim}
\# math મોડ્યુલનો ઉપયોગ કરતો ઉદાહરણ
import math

\# મૂળભૂત સ્થિરાંકો
print(f"pi ની કિંમત: \{math.pi\}")
print(f"e ની કિંમત: \{math.e\}")

\# ત્રિકોણમિતિ ફંક્શન્સ (આર્ગ્યુમેન્ટ રેડિયન્સમાં)
angle = math.pi / 3  \# 60 ડિગ્રી
print(f"\{angle:.2f\} રેડિયન્સનો સાઇન: \{math.sin(angle):.4f\}")
print(f"\{angle:.2f\} રેડિયન્સનો કોસાઇન: \{math.cos(angle):.4f\}")
print(f"\{angle:.2f\} રેડિયન્સનો ટેન્જન્ટ: \{math.tan(angle):.4f\}")

\# લોગરિધમિક અને એક્સપોનેન્શિયલ ફંક્શન્સ
x = 10
print(f"\{x\} નો નેચરલ લોગરિધમ: \{math.log(x):.4f\}")
print(f"\{x\} નો લોગરિધમ બેઝ 10: \{math.log10(x):.4f\}")
print(f"e ની \{x\} ઘાત: \{math.exp(x):.4f\}")

\# અન્ય ફંક્શન્સ
print(f"25 નું વર્ગમૂળ: \{math.sqrt(25)\}")
print(f"4.3 નો સીલિંગ: \{math.ceil(4.3)\}")
print(f"4.7 નો ફ્લોર: \{math.floor(4.7)\}")
\end{verbatim}

\textbf{ટેબલ: Math મોડ્યુલ કેટેગરીઝ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
કેટેગરી & ફંક્શન્સ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સ્થિરાંકો} & \texttt{math.pi}, \texttt{math.e} \\
\textbf{ત્રિકોણમિતિ} & \texttt{sin()}, \texttt{cos()}, \texttt{tan()} \\
\textbf{લોગરિધમિક} & \texttt{log()}, \texttt{log10()}, \texttt{exp()} \\
\textbf{ન્યુમેરિક} & \texttt{sqrt()}, \texttt{ceil()}, \texttt{floor()} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``PENT'' (Pi/constants, Exponents, Numbers,
Trigonometry)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7 ગુણ] - OR
ઓપ્શન}\label{q4c}

\textbf{પાયથોનમાં વેરીએબલના અવકાશનો કોન્સેપ્ટ સમજાવો અને પાયથોન પ્રોગ્રામમાં
વૈશ્વિક અને સ્થાનિક વેરીએબલ કોન્સેપ્ટ લાગુ કરો.}

\begin{solutionbox}

\textbf{પાયથોનમાં વેરિએબલનો સ્કોપ}: વેરિએબલનો સ્કોપ નક્કી કરે છે કે પ્રોગ્રામમાં ક્યાં
વેરિએબલ એક્સેસિબલ કે દેખાય છે.

\textbf{ટેબલ: વેરિએબલ સ્કોપના પ્રકારો}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4643}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
સ્કોપ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
એક્સેસ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Local} & ફંક્શનની અંદર વ્યાખ્યાયિત વેરિએબલ્સ & માત્ર ફંક્શનની અંદર \\
\textbf{Global} & ટોપ લેવલ પર વ્યાખ્યાયિત વેરિએબલ્સ & સમગ્ર પ્રોગ્રામમાં \\
\textbf{Enclosing} & નેસ્ટેડ ફંક્શન્સના બાહ્ય ફંક્શનના વેરિએબલ્સ & બાહ્ય અને અંદરના
ફંક્શનમાં \\
\textbf{Built-in} & પાયથોનમાં પહેલેથી વ્યાખ્યાયિત વેરિએબલ્સ & સમગ્ર પ્રોગ્રામમાં \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# વેરિએબલ સ્કોપ ડેમોન્સ્ટ્રેશન

\# Global વેરિએબલ
count = 0

def outer\_function():
    \# Enclosing સ્કોપ વેરિએબલ
    name = "Python"
    
    def inner\_function():
        \# Local વેરિએબલ
        age = 30
        \# Global વેરિએબલ એક્સેસ કરવું
        global count
        count += 1
        \# Enclosing વેરિએબલ એક્સેસ કરવું
        print(f"inner\_function ની અંદર: name is \{name\}")
        print(f"inner\_function ની અંદર: age is \{age\}")
        print(f"inner\_function ની અંદર: count is \{count\}")
    
    \# outer\_function માટે Local વેરિએબલ
    language = "Programming"
    print(f"outer\_function ની અંદર: name is \{name\}")
    print(f"outer\_function ની અંદર: language is \{language\}")
    print(f"outer\_function ની અંદર: count is \{count\}")
    
    \# ઇનર ફંક્શન કોલ કરો
    inner\_function()
    
    \# આ ભૂલ આપશે {- age એ inner\_function માટે Local છે}
    \# print(age)

\# મુખ્ય પ્રોગ્રામ
print(f"Global સ્કોપ: count is \{count\}")
outer\_function()
print(f"ફંક્શન કોલ પછી Global સ્કોપ: count is \{count\}")

\# આ ભૂલ આપશે {- તેઓ ફંક્શન્સ માટે Local છે}
\# print(name)
\# print(language)
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart LR
    A[Global Scope] {-{-} B[count]}
    A {-{-} C[outer\_function]}
    C {-{-} D[Enclosing Scope: name, language]}
    D {-{-} E[inner\_function]}
    E {-{-} F[Local Scope: age]}
    B {{-}.{-} E}
    D {{-}.{-} E}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LEGB'' (Local, Enclosing, Global, Built-in - સ્કોપ
લુકઅપનો ક્રમ)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{આપેલ સૂચિમાં બે ઘટકોને સ્વેપ કરવા માટે પાયથોન પ્રોગ્રામ બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# લિસ્ટમાં બે એલિમેન્ટ્સ સ્વેપ કરવાનો પ્રોગ્રામ

\# એક લિસ્ટ બનાવો
my\_list = [10, 20, 30, 40, 50]
print("મૂળ લિસ્ટ:", my\_list)

\# સ્વેપ કરવા માટેની પોઝિશન મેળવો
pos1 = int(input("પ્રથમ પોઝિશન દાખલ કરો (ઇન્ડેક્સ 0 થી શરૂ થાય છે): "))
pos2 = int(input("બીજી પોઝિશન દાખલ કરો (ઇન્ડેક્સ 0 થી શરૂ થાય છે): "))

\# ટેમ્પરરી વેરિએબલનો ઉપયોગ કરીને એલિમેન્ટ્સ સ્વેપ કરો
if 0 {=} pos1 {} len(my\_list) and 0 {=} pos2 {} len(my\_list):
    \# સ્વેપિંગ
    temp = my\_list[pos1]
    my\_list[pos1] = my\_list[pos2]
    my\_list[pos2] = temp
    
    print(f"પોઝિશન \{pos1\} અને \{pos2\} પર એલિમેન્ટ્સ સ્વેપ કર્યા પછી લિસ્ટ:", my\_list)
else:
    print("અમાન્ય પોઝિશન! પોઝિશન લિસ્ટની રેન્જની અંદર હોવી જોઈએ.")
\end{verbatim}

\textbf{વૈકલ્પિક પદ્ધતિ}:

\begin{verbatim}
\# પાયથોનની tuple અનપેકિંગનો ઉપયોગ કરીને સ્વેપ (વધુ પાયથોનિક)
if 0 {=} pos1 {} len(my\_list) and 0 {=} pos2 {} len(my\_list):
    my\_list[pos1], my\_list[pos2] = my\_list[pos2], my\_list[pos1]
    print(f"પોઝિશન \{pos1\} અને \{pos2\} પર એલિમેન્ટ્સ સ્વેપ કર્યા પછી લિસ્ટ:", my\_list)
\end{verbatim}

\textbf{ટેબલ: સ્વેપિંગ પદ્ધતિઓ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પદ્ધતિ & કોડ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ટેમ્પ વેરિએબલનો ઉપયોગ} &
\texttt{temp\ =\ a;\ a\ =\ b;\ b\ =\ temp} \\
\textbf{પાયથોન ટપલ અનપેકિંગ} & \texttt{a,\ b\ =\ b,\ a} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``TEMP SWAP'' (ટેમ્પરરી વેરિએબલ સલામત સ્વેપિંગમાં મદદ કરે છે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{ઉદાહરણ આપીને નેસ્ટેડ લિસ્ટ સમજાવો}

\begin{solutionbox}

\textbf{Nested List}: Nested list એટલે એવી લિસ્ટ જેના એલિમેન્ટ્સ તરીકે અન્ય લિસ્ટ
હોય, જે મલ્ટી-ડાયમેન્શનલ ડેટા સ્ટ્રક્ચર બનાવે છે.

\begin{verbatim}
\# Nested list બનાવવી (3x3 મેટ્રિક્સ)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

\# એલિમેન્ટ્સ એક્સેસ કરવા
print("સંપૂર્ણ મેટ્રિક્સ:", matrix)
print("પ્રથમ રો:", matrix[0])
print("રો 1, કોલમ 2 પર એલિમેન્ટ:", matrix[0][1])  \# આઉટપુટ: 2

\# એલિમેન્ટ્સ મોડિફાય કરવા
matrix[1][1] = 50
print("મોડિફિકેશન પછી મેટ્રિક્સ:", matrix)

\# Nested list પર પુનરાવર્તન
print("{n}મેટ્રિક્સ પ્રિન્ટ કરી રહ્યા છીએ:")
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()  \# દરેક રો પછી નવી લાઇન
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart TD
    A[matrix] {-{-} B[Row 0]}
    A {-{-} C[Row 1]}
    A {-{-} D[Row 2]}
    B {-{-} B1[1]}
    B {-{-} B2[2]}
    B {-{-} B3[3]}
    C {-{-} C1[4]}
    C {-{-} C2[50]}
    C {-{-} C3[6]}
    D {-{-} D1[7]}
    D {-{-} D2[8]}
    D {-{-} D3[9]}
\end{verbatim}

\textbf{ટેબલ: Nested List ઓપરેશન્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3929}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{એલિમેન્ટ એક્સેસ} & \texttt{list[row][col]} &
\texttt{matrix[0][1]} \\
\textbf{એલિમેન્ટ મોડિફાય} & \texttt{list[row][col]\ =\ new\_value}
& \texttt{matrix[1][1]\ =\ 50} \\
\textbf{નવી રો ઉમેરવી} & \texttt{list.append([...])} &
\texttt{matrix.append([10,\ 11,\ 12])} \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``MARS'' (Matrix Access with Row and column
Structure) - મેટ્રિક્સ એક્સેસ રો અને કોલમ માળખા સાથે

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{ઉદાહરણો સાથે સ્ટ્રિંગ ઓપરેશન્સ સમજાવો}

\begin{solutionbox}

\textbf{ટેબલ: પાયથોનમાં સ્ટ્રિંગ ઓપરેશન્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3939}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{કન્કેટેનેશન} & સ્ટ્રિંગ્સ જોડવી & \texttt{"Hello"\ +\ "\ World"} \rightarrow
\texttt{"Hello\ World"} \\
\textbf{રિપિટિશન} & સ્ટ્રિંગ્સ પુનરાવર્તિત કરવી & \texttt{"Python"\ *\ 3} \rightarrow
\texttt{"PythonPythonPython"} \\
\textbf{સ્લાઇસિંગ} & સબસ્ટ્રિંગ એક્સટ્રેક્ટ & \texttt{"Python"[1:4]} \rightarrow
\texttt{"yth"} \\
\textbf{ઇન્ડેક્સિંગ} & એક્સેસ કેરેક્ટર & \texttt{"Python"[0]} \rightarrow
\texttt{"P"} \\
\textbf{લેન્થ} & કેરેક્ટર્સ ગણો & \texttt{len("Python")} \rightarrow \texttt{6} \\
\textbf{મેમ્બરશિપ} & ચેક કરો કે હાજર છે & \texttt{"P"\ in\ "Python"} \rightarrow
\texttt{True} \\
\textbf{કમ્પેરિઝન} & સ્ટ્રિંગ્સ સરખાવો &
\texttt{"apple"\ \textless{}\ "banana"} \rightarrow \texttt{True} \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# સ્ટ્રિંગ ઓપરેશન્સ ડેમોન્સ્ટ્રેશન
text = "Python Programming"

\# ઇન્ડેક્સિંગ
print("પ્રથમ કેરેક્ટર:", text[0])
print("છેલ્લી કેરેક્ટર:", text[{-}1])

\# સ્લાઇસિંગ
print("પ્રથમ શબ્દ:", text[:6])
print("બીજો શબ્દ:", text[7:])
print("મધ્યના કેરેક્ટર્સ:", text[3:10])
print("રિવર્સ:", text[::{-}1])

\# સ્ટ્રિંગ મેથડ્સ
print("અપરકેસ:", text.upper())
print("લોવરકેસ:", text.lower())
print("{P ને J સાથે બદલો:"}, text.replace("P", "J"))
print("સ્પેસ દ્વારા સ્પ્લિટ:", text.split())
print("{m ની ગણતરી:"}, text.count({m}))
print("{gram શોધો:"}, text.find("gram"))

\# ચેક ઓપરેશન્સ
print("આલ્ફાન્યુમેરિક છે?", text.isalnum())
print("{Py થી શરૂ થાય છે?"}, text.startswith("Py"))
print("{ing થી સમાપ્ત થાય છે?"}, text.endswith("ing"))
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart TD
    A["Python Programming"] {-{-} B["Indexing: P (0), g ({-}1)"]}
    A {-{-} C["Slicing: Python (0:6), Programming (7:)"]}
    A {-{-} D["Methods: PYTHON PROGRAMMING (upper())"]}
    A {-{-} E["Checks: startswith, endswith, isalnum, etc"]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SCREAM'' (Slice, Concat, Replace, Extract, Access,
Methods)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3 ગુણ] - OR
ઓપ્શન}\label{q5a}

\textbf{આપેલ સૂચિમાં તમામ ઘટકોનો સરવાળો શોધવા માટે પાયથોન પ્રોગ્રામ બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\# લિસ્ટમાં બધા એલિમેન્ટ્સનો સરવાળો શોધવાનો પ્રોગ્રામ

\# પદ્ધતિ 1: બિલ્ટ{-ઈન sum() ફંક્શનનો ઉપયોગ}
def sum\_list\_builtin(numbers):
    return sum(numbers)

\# પદ્ધતિ 2: લૂપનો ઉપયોગ
def sum\_list\_loop(numbers):
    total = 0
    for num in numbers:
        total += num
    return total

\# સેમ્પલ લિસ્ટ બનાવો
my\_list = [10, 20, 30, 40, 50]
print("લિસ્ટ:", my\_list)

\# બિલ્ટ{-ઈન ફંક્શનનો ઉપયોગ કરીને સરવાળો ગણો}
print("બિલ્ટ{-ઈન ફંક્શનનો ઉપયોગ કરીને સરવાળો:"}, sum\_list\_builtin(my\_list))

\# લૂપનો ઉપયોગ કરીને સરવાળો ગણો
print("લૂપનો ઉપયોગ કરીને સરવાળો:", sum\_list\_loop(my\_list))
\end{verbatim}

\textbf{ટેબલ: સરવાળા પદ્ધતિઓની તુલના}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
પદ્ધતિ & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બિલ્ટ-ઈન sum()} & સરળ, કાર્યક્ષમ, ઝડપી \\
\textbf{લૂપ અભિગમ} & કસ્ટમ સમિંગ લોજિક માટે કામ કરે છે \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ADD ALL'' (દરેક એલિમેન્ટને ઉમેરો)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4 ગુણ] - OR
ઓપ્શન}\label{q5b}

\textbf{પાયથોન લિસ્ટમાં ઈન્ડેક્સીંગ અને સ્લાઇસિંગ ઓપરેશન્સ સમજાવો}

\begin{solutionbox}

\textbf{ટેબલ: ઇન્ડેક્સિંગ અને સ્લાઇસિંગ ઓપરેશન્સ}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2683}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1951}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3171}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2195}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{પોઝિટિવ ઇન્ડેક્સિંગ} & \texttt{list[i]} & પોઝિશન i પર આઇટમ એક્સેસ
કરો (0-બેઝ્ડ) & \texttt{fruits[0]} \rightarrow પ્રથમ આઇટમ \\
\textbf{નેગેટિવ ઇન્ડેક્સિંગ} & \texttt{list[-i]} & અંતથી આઇટમ એક્સેસ કરો (-1
છેલ્લું છે) & \texttt{fruits[-1]} \rightarrow છેલ્લી આઇટમ \\
\textbf{બેઝિક સ્લાઇસિંગ} & \texttt{list[start:end]} & start થી end-1
સુધીના આઇટમ્સ & \texttt{fruits[1:3]} \rightarrow 1,2 પરના આઇટમ્સ \\
\textbf{સ્ટેપ સાથે સ્લાઇસ} & \texttt{list[start:end:step]} & step ના
અંતરાલ સાથે આઇટમ્સ & \texttt{nums[1:6:2]} \rightarrow 1,3,5 પરના આઇટમ્સ \\
\textbf{ઇન્ડિસીસ છોડવા} & \texttt{list[:end]},
\texttt{list[start:]} & શરૂઆતથી અથવા અંત સુધી & \texttt{fruits[:3]}
\rightarrow પ્રથમ 3 આઇટમ્સ \\
\textbf{નેગેટિવ સ્લાઇસિંગ} & \texttt{list[-start:-end]} & અંતથી સ્લાઇસ &
\texttt{fruits[-3:-1]} \rightarrow 3જી અને 2જી છેલ્લી \\
\textbf{રિવર્સ} & \texttt{list[::-1]} & લિસ્ટ રિવર્સ કરો &
\texttt{fruits[::-1]} \rightarrow લિસ્ટ રિવર્સમાં \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# ઇન્ડેક્સિંગ અને સ્લાઇસિંગ ડેમોન્સ્ટ્રેશન
fruits = ["apple", "banana", "cherry", "date", "elderberry", "fig"]
print("મૂળ લિસ્ટ:", fruits)

\# ઇન્ડેક્સિંગ
print("{n}ઇન્ડેક્સિંગ ઉદાહરણો:")
print("પ્રથમ આઇટમ:", fruits[0])  \# apple
print("છેલ્લી આઇટમ:", fruits[{-}1])  \# fig
print("ત્રીજી આઇટમ:", fruits[2])  \# cherry

\# સ્લાઇસિંગ
print("{n}સ્લાઇસિંગ ઉદાહરણો:")
print("પ્રથમ ત્રણ આઇટમ્સ:", fruits[:3])  \# [{apple, banana, cherry]}
print("છેલ્લી ત્રણ આઇટમ્સ:", fruits[{-}3:])  \# [{date, elderberry, fig]}
print("મધ્યની આઇટમ્સ:", fruits[2:4])  \# [{cherry, date]}
print("દરેક બીજી આઇટમ:", fruits[::2])  \# [{apple, cherry, elderberry]}
print("રિવર્સ લિસ્ટ:", fruits[::{-}1])  \# [{fig, elderberry, date, cherry, banana, apple]}
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart TD
    A["List: fruits"] {-{-} B\{\{"Indexing"\}\}}
    A {-{-} C\{\{"Slicing"\}\}}
    B {-{-} D["Positive: fruits[0], fruits[1], ..."]}
    B {-{-} E["Negative: fruits[{-}1], fruits[{-}2], ..."]}
    C {-{-} F["Basic: fruits[1:3]"]}
    C {-{-} G["With step: fruits[::2]"]}
    C {-{-} H["Reverse: fruits[::{-}1]"]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``START-END-STEP'' (સ્લાઇસિંગ સિન્ટેક્સ:
[start:end:step])

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7 ગુણ] - OR
ઓપ્શન}\label{q5c}

\textbf{જરૂરી ઉદાહરણ સાથે tuple ને ટૂંકમાં સમજાવો.}

\begin{solutionbox}

\textbf{Tuple}: Tuple એ એલિમેન્ટ્સનો ક્રમબદ્ધ, અપરિવર્તનીય સંગ્રહ છે. એકવાર
બનાવ્યા પછી, એલિમેન્ટ્સ બદલી શકાતા નથી.

\textbf{ટેબલ: Tuple vs List}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4091}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3182}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Tuple
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
List
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સિન્ટેક્સ} & \texttt{(item1,\ item2)} &
\texttt{[item1,\ item2]} \\
\textbf{પરિવર્તનશીલતા} & Immutable (બદલી શકાતી નથી) & Mutable (બદલી શકાય
છે) \\
\textbf{પરફોર્મન્સ} & ઝડપી & ધીમું \\
\textbf{ઉપયોગ કેસ} & ફિક્સ્ડ ડેટા, ડિક્શનરી કીઝ & ડેટા જેને મોડિફિકેશનની જરૂર
પડે \\
\textbf{મેથડ્સ} & ઓછી મેથડ્સ & ઘણી મેથડ્સ \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ}:

\begin{verbatim}
\# Tuples બનાવવા
empty\_tuple = ()
single\_item\_tuple = (1,)  \# સિંગલ આઇટમ માટે કોમા જરૂરી છે
mixed\_tuple = (1, "Hello", 3.14, True)
nested\_tuple = (1, 2, (3, 4), 5)

\# Tuple એલિમેન્ટ્સ એક્સેસ કરવા
print("પ્રથમ આઇટમ:", mixed\_tuple[0])  \# 1
print("છેલ્લી આઇટમ:", mixed\_tuple[{-}1])  \# True
print("Nested tuple એલિમેન્ટ:", nested\_tuple[2][0])  \# 3

\# Tuple સ્લાઇસિંગ
print("પ્રથમ બે આઇટમ્સ:", mixed\_tuple[:2])  \# (1, "Hello")

\# Tuple અનપેકિંગ
a, b, c, d = mixed\_tuple
print("અનપેક કરેલી વેલ્યુઝ:", a, b, c, d)

\# Tuple મેથડ્સ
print("1 ની ગણતરી:", mixed\_tuple.count(1))  \# 1
print("{Hello નો ઇન્ડેક્સ:"}, mixed\_tuple.index("Hello"))  \# 1

\# Tuple ઓપરેશન્સ
combined\_tuple = mixed\_tuple + nested\_tuple
repeated\_tuple = mixed\_tuple * 2
print("કોમ્બાઇન્ડ tuple:", combined\_tuple)
print("રિપીટેડ tuple:", repeated\_tuple)

\# આ ભૂલ આપશે કારણ કે tuples immutable છે
\# mixed\_tuple[0] = 100  \# TypeError: {tuple object does not support item assignment}
\end{verbatim}

\textbf{ડાયાગ્રામ}:

\begin{verbatim}
flowchart TD
    A["Tuple (1, {Hello, 3.14, True)"] {-}{-}|"index[0]"| B[1]}
    A {-{-}|"index[1]"| C["Hello"]}
    A {-{-}|"index[2]"| D[3.14]}
    A {-{-}|"index[3]"| E[True]}
    F["Operations"] {-{-} G["Access: tuple[i]"]}
    F {-{-} H["Slice: tuple[i:j]"]}
    F {-{-} I["Concatenate: tuple1 + tuple2"]}
    F {-{-} J["Repeat: tuple * n"]}
    K["Methods"] {-{-} L["count()"]}
    K {-{-} M["index()"]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``IPAC'' (Immutable, Parentheses, Access only,
Cannot modify) - અપરિવર્તનીય, કૌંસ, માત્ર એક્સેસ, મોડિફાય ન કરી શકાય

\end{mnemonicbox}

\end{document}
