\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331105 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{C લેંગ્વેજના કોઈ પણ છ કીવર્ડ લખો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વર્ગ & કીવર્ડ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ડેટા ટાઈપ્સ} & int, float, char \\
\textbf{કંટ્રોલ ફ્લો} & if, for, return \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``I Find Clever Reasons For Results''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{ઓપરેટરની વ્યાખ્યા આપી operand ના આધારે તેના પ્રકાર જણાવો.}

\begin{solutionbox}

\textbf{ઓપરેટર}: એવું ચિહ્ન કે જે ઓપરન્ડ્સ પર કામ કરીને પરિણામ આપે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વિગત & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{યુનરી} & એક ઓપરન્ડ & ++, --, ! \\
\textbf{બાઇનરી} & બે ઓપરન્ડ & +, -, *, /, \% \\
\textbf{ટર્નરી} & ત્રણ ઓપરન્ડ & ?: \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``U-B-T: Use Binary Then Ternary''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{ફ્લોચાર્ટની વ્યાખ્યા લખો. ફ્લોચાર્ટના સિમ્બોલ દોરો. બે પૂર્ણાંક નંબર N1 અને
N2 માંથી નાનો નંબર શોધવા માટેનો ફ્લોચાર્ટ દોરો.}

\begin{solutionbox}

\textbf{ફ્લોચાર્ટ}: અલ્ગોરિધમનું ગ્રાફિકલ નિરૂપણ જેમાં પ્રમાણિત ચિહ્નો દ્વારા ક્રમબદ્ધ
ઓપરેશનો દર્શાવવામાં આવે છે.

\textbf{ફ્લોચાર્ટના સામાન્ય ચિહ્નો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ચિહ્ન & અર્થ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઓવલ} & શરૂઆત/અંત \\
\textbf{પેરાલેલોગ્રામ} & ઇનપુટ/આઉટપુટ \\
\textbf{લંબચોરસ} & પ્રક્રિયા \\
\textbf{ડાયમંડ} & નિર્ણય \\
\textbf{એરો} & ફ્લો દિશા \\
\end{longtable}
}

\textbf{N1 અને N2 માંથી નાનો નંબર શોધવા માટેનો ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input N1, N2/]}
    B {-{-} C\{N1  N2?\}}
    C {-{-}|Yes| D[Min = N1]}
    C {-{-}|No| E[Min = N2]}
    D {-{-} F[/Display Min/]}
    E {-{-} F}
    F {-{-} G([End])}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SPADE: Start-Process-Arrow-Decision-End''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) OR [7
ગુણ]}\label{q1c}

\textbf{અલગોરિધમની વ્યાખ્યા લખો. વર્તુળનું ક્ષેત્રફળ અને પરિઘ શોધવા માટેનો અલગોરિધમ
લખો.}

\begin{solutionbox}

\textbf{અલગોરિધમ}: કોઈ સમસ્યાને ઉકેલવા માટેનું પગલે પગલે પદ્ધતિસરનું કાર્યવાહી, જેમાં
સુનિશ્ચિત સંખ્યામાં સુવ્યાખ્યાયિત સૂચનાઓનો ઉપયોગ થાય છે.

\textbf{વર્તુળનું ક્ષેત્રફળ અને પરિઘ શોધવા માટેનો અલગોરિધમ:}

\begin{enumerate}
\tightlist
\item
  \textbf{શરૂઆત}
\item
  \textbf{ત્રિજ્યા r ઇનપુટ કરો}
\item
  \textbf{PI = 3.14159 સેટ કરો}
\item
  \textbf{ક્ષેત્રફળ = PI \times r \times r ગણો}
\item
  \textbf{પરિઘ = 2 \times PI \times r ગણો}
\item
  \textbf{ક્ષેત્રફળ અને પરિઘ દર્શાવો}
\item
  \textbf{અંત}
\end{enumerate}

\textbf{ઉપયોગિત સૂત્રોનો કોષ્ટક:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
માપન & સૂત્ર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ક્ષેત્રફળ} & π \times r^{2} \\
\textbf{પરિઘ} & 2 \times π \times r \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``RICARD: Radius Input, Calculate Area, Reveal
Dimensions''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{printf() અને scanf() વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & printf() & scanf() \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{હેતુ} & સ્ક્રીન પર ડેટા આઉટપુટ કરે & કીબોર્ડથી ડેટા ઇનપુટ કરે \\
\textbf{દિશા} & આઉટપુટ ફંક્શન & ઇનપુટ ફંક્શન \\
\textbf{ફોર્મેટ સ્પેસિફાયર} & જરૂરી & જરૂરી \\
\textbf{પેરામીટર} & વાસ્તવિક મૂલ્યો & ચલનું સરનામું (\&) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``OIAD: Output-Input, Actual-Destination''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{1 થી n સુધીનો સરવાળો અને સરેરાશ પ્રિન્ટ કરવા માટે પ્રોગ્રામ C લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int n, i, sum = 0;
    float avg;
    
    printf("Enter n: ");
    scanf("\%d", \&n);
    
    for(i = 1; i {=} n; i++) \{
        sum += i;
    \}
    
    avg = (float)sum / n;
    
    printf("Sum = \%d{n}", sum);
    printf("Average = \%.2f{n}", avg);
    
    return 0;
\}
\end{verbatim}

\textbf{મુખ્ય બિંદુઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનિશિયલાઇઝેશન}: sum = 0
\item
  \textbf{પુનરાવર્તન}: 1 થી n સુધી for લૂપ
\item
  \textbf{ટાઇપ કાસ્ટિંગ}: સાચા સરેરાશ માટે (float)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SIAP: Sum Initialize, Add in loop, Print results''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{એરિથમેટિક ઓપરેટર અને રિલેશનલ ઓપરેટરને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{1. એરિથમેટિક ઓપરેટર:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & ઓપરેશન & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{+} & સરવાળો & 5 + 3 & 8 \\
\textbf{-} & બાદબાકી & 5 - 3 & 2 \\
\textbf{*} & ગુણાકાર & 5 * 3 & 15 \\
\textbf{/} & ભાગાકાર & 5 / 2 & 2 (પૂર્ણાંક) \\
\textbf{\%} & મોડ્યુલો (શેષ) & 5 \% 2 & 1 \\
\end{longtable}
}

\textbf{2. રિલેશનલ ઓપરેટર:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & અર્થ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\textless{}} & કરતાં નાનું & 5 \textless{} 3 & 0 (ખોટું) \\
\textbf{\textgreater{}} & કરતાં મોટું & 5 \textgreater{} 3 & 1 (સાચું) \\
\textbf{\textless=} & નાનું અથવા સમાન & 5 \textless= 5 & 1 (સાચું) \\
\textbf{\textgreater=} & મોટું અથવા સમાન & 3 \textgreater= 5 & 0 (ખોટું) \\
\textbf{==} & સમાન & 5 == 5 & 1 (સાચું) \\
\textbf{!=} & અસમાન & 5 != 3 & 1 (સાચું) \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
int

a = 5,

b = 3;

printf("a + b = \%d{n}", a + b);     // આઉટપુટ: 8
printf("a { b is }\%d{n}", a {} b);    // આઉટપુટ: 1 (સાચું)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ASMDR for Arithmetic, LEGENE for Relational''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) OR [3
ગુણ]}\label{q2a}

\textbf{get(S) અને scanf(``\%s'',S) વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & gets(S) & scanf(``\%s'',S) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{વ્હાઇટસ્પેસ હેન્ડલિંગ} & સ્પેસ વાંચે છે & વ્હાઇટસ્પેસ પર બંધ થાય છે \\
\textbf{બફર ઓવરફ્લો} & બાઉન્ડરી ચેક નથી & વિડ્થ લિમિટ સાથે સલામત \\
\textbf{રિટર્ન ટાઇપ} & char* & વાંચેલા આઇટમની સંખ્યા \\
\textbf{ઉપયોગ સુરક્ષા} & ડેપ્રિકેટેડ, અસુરક્ષિત & ફોર્મેટ કંટ્રોલ સાથે સલામત \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``WBRU: Whitespace-Boundary-Return-Usage''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) OR [4
ગુણ]}\label{q2b}

\textbf{બે નંબરોના મૂલ્યની અદલાબદલી (એક્સચેન્જ) કરવા માટે C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int a, b, temp;
    
    printf("Enter two numbers: ");
    scanf("\%d \%d", \&a, \&b);
    
printf("Before swap:

a = \%d,

b = \%d{n}", a, b);

    
    temp = a;
    a = b;
    b = temp;
    
printf("After swap:

a = \%d,

b = \%d{n}", a, b);

    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    subgraph Before
    A1[a = 5] {-{-}{-} B1[b = 10]}
    end
    subgraph Step1
    A2[a = 5] {-{-}{-} T[temp = 5]}
    B2[b = 10]
    end
    subgraph Step2
    A3[a = 10] {-{-}{-} T2[temp = 5]}
    B3[b = 10]
    end
    subgraph After
    A4[a = 10] {-{-}{-} B4[b = 5]}
    end
    Before {-{-} Step1}
    Step1 {-{-} Step2}
    Step2 {-{-} After}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``TAB: Temp-Assign-Backfill''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) OR [7
ગુણ]}\label{q2c}

\textbf{બુલિયન ઓપરેટર અને લોજિકલ ઓપરેટર ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{1. બુલિયન ઓપરેટર:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & ઓપરેશન & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\&} & બિટવાઇઝ AND & 5 \& 3 & 1 \\
\textbf{\textbar{}} & બિટવાઇઝ OR & 5 \textbar{} 3 & 7 \\
\textbf{\^{}} & બિટવાઇઝ XOR & 5 \^{} 3 & 6 \\
\textbf{\textasciitilde{}} & બિટવાઇઝ NOT & \textasciitilde5 & -6 \\
\textbf{\textless\textless{}} & લેફ્ટ શિફ્ટ & 5 \textless\textless{} 1 &
10 \\
\textbf{\textgreater\textgreater{}} & રાઇટ શિફ્ટ & 5
\textgreater\textgreater{} 1 & 2 \\
\end{longtable}
}

\textbf{2. લોજિકલ ઓપરેટર:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & અર્થ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\&\&} & લોજિકલ AND & (5\textgreater3) \&\& (2\textless4) & 1
(સાચું) \\
\textbf{\textbar\textbar{}} & લોજિકલ OR & (5\textless3)
\textbar\textbar{} (2\textless4) & 1 (સાચું) \\
\textbf{!} & લોજિકલ NOT & !(5\textgreater3) & 0 (ખોટું) \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
int

a = 5,

b = 3;

printf("a \& b = \%d{n}", a \& b);           // આઉટપુટ: 1 (બિટવાઇઝ AND)
printf("a { b \&\& b  10 is }\%d{n}", a {} b \&\& b {} 10);  // આઉટપુટ: 1 (સાચું)
\end{verbatim}

\textbf{બિટ રિપ્રેઝન્ટેશન (5 \& 3):}

\begin{verbatim}
5 = 101
3 = 011
& = 001 (1 in decimal)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``BOXNRL for Boolean, AON for Logical''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{Entry controlled અને exit controlled લૂપની ઉદાહરણ સાથે સરખામણી
કરો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & Entry Controlled & Exit Controlled \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{શરત ચકાસણી} & અમલ પહેલા & અમલ પછી \\
\textbf{ન્યૂનતમ પુનરાવર્તન} & શૂન્ય & એક \\
\textbf{ઉદાહરણ} & while, for & do-while \\
\textbf{ઉપયોગ} & પ્રી-ચેક જરૂરી હોય & ઓછામાં ઓછું એક વાર અમલ જરૂરી હોય \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``BCME: Before-Check-Multiple-Examples''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{સ્વીચ કેસનો ઉપયોગ કરીને બે નંબરોના સરવાળા અને બાદબાકી દર્શાવવા માટેનો C
પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int a, b, choice, result;
    
    printf("Enter two numbers: ");
    scanf("\%d \%d", \&a, \&b);
    
    printf("1. Addition{n}2. Subtraction{n}");
    printf("Enter choice (1/2): ");
    scanf("\%d", \&choice);
    
    switch(choice) \{
        case 1:
            result = a + b;
            printf("Addition: \%d{n}", result);
            break;
        case 2:
            result = a {-} b;
            printf("Subtraction: \%d{n}", result);
            break;
        default:
            printf("Invalid choice{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input a, b/]}
    B {-{-} C[/Input choice/]}
    C {-{-} D\{"switch(choice)"\}}
    D {-{-}|case 1| E[result = a + b]}
    D {-{-}|case 2| F[result = a {-} b]}
    D {-{-}|default| G[Display Invalid]}
    E {-{-} H[/Display Addition/]}
    F {-{-} I[/Display Subtraction/]}
    H {-{-} J([End])}
    I {-{-} J}
    G {-{-} J}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CIRCA: Choice-Input-Result-Calculate-Action''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{સિન્ટેક્સ, ફ્લોચાર્ટ અને ઉદાહરણ સાથે multiple if-else સ્ટેટમેન્ટ સમજાવો.}

\begin{solutionbox}

\textbf{multiple if-else સિન્ટેક્સ:}

\begin{verbatim}
if (condition1) \{
    // code block 1
\} 
else if (condition2) \{
    // code block 2
\} 
else if (condition3) \{
    // code block 3
\} 
else \{
    // default code block
\}
\end{verbatim}

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B\{condition1?\}}
    B {-{-}|True| C[Execute block 1]}
    B {-{-}|False| D\{condition2?\}}
    D {-{-}|True| E[Execute block 2]}
    D {-{-}|False| F\{condition3?\}}
    F {-{-}|True| G[Execute block 3]}
    F {-{-}|False| H[Execute default block]}
    C {-{-} I([End])}
    E {-{-} I}
    G {-{-} I}
    H {-{-} I}
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int marks;
    
    printf("Enter marks: ");
    scanf("\%d", \&marks);
    
    if (marks {=} 80) \{
        printf("Grade: A{n}");
    \} 
    else if (marks {=} 70) \{
        printf("Grade: B{n}");
    \} 
    else if (marks {=} 60) \{
        printf("Grade: C{n}");
    \} 
    else \{
        printf("Grade: F{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``TEST: Try Each Statement Then default''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) OR [3
ગુણ]}\label{q3a}

\textbf{break અને continue કીવર્ડનો ઉપયોગ જણાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2105}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3158}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કીવર્ડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
અસર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સામાન્ય ઉપયોગ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{break} & લૂપ/સ્વિચ ટર્મિનેટ કરે & વર્તમાન લૂપ/સ્વિચ છોડી દે & શરત પૂરી થાય
ત્યારે બહાર નીકળવા \\
\textbf{continue} & ઇટરેશન છોડે & આગામી ઇટરેશન પર જાય & ચોક્કસ મૂલ્યો છોડવા \\
\end{longtable}
}

\textbf{ઉદાહરણ કોડ:}

\begin{verbatim}
// break ઉદાહરણ
for(i=1; i{=}10; i++) \{
if(i == 5) break; //

i=5 પર લૂપ છોડે

    printf("\%d ", i);  // 1 2 3 4 પ્રિન્ટ કરે
\}

// continue ઉદાહરણ
for(i=1; i{=}5; i++) \{
if(i == 3) continue; //

i=3 છોડે

    printf("\%d ", i);  // 1 2 4 5 પ્રિન્ટ કરે
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``EXIT-SKIP: EXit IT or SKIP iteration''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) OR [4
ગુણ]}\label{q3b}

\textbf{આપેલ સંખ્યા એકી છે કે બેકી તે ચકાસવા માટે C પ્રોગ્રામનો લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num;
    
    printf("Enter a number: ");
    scanf("\%d", \&num);
    
    if (num \% 2 == 0) \{
        printf("\%d is even.{n}", num);
    \} 
    else \{
        printf("\%d is odd.{n}", num);
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input num/]}
    B {-{-} C\{num \% 2 == 0?\}}
    C {-{-}|Yes| D[/Display "Even"/]}
    C {-{-}|No| E[/Display "Odd"/]}
    D {-{-} F([End])}
    E {-{-} F}
\end{verbatim}

\textbf{મુખ્ય બિંદુઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ચકાસણી}: મોડ્યુલો (\%) ઓપરેટરનો ઉપયોગ
\item
  \textbf{નિર્ણય}: 2 સાથેના શેષ પર આધારિત
\item
  \textbf{આઉટપુટ}: શેષ 0 હોય તો બેકી, અન્યથા એકી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``MODE: MODulo Equals zero for even''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) OR [7
ગુણ]}\label{q3c}

\textbf{સિન્ટેક્સ, ફ્લોચાર્ટ અને ઉદાહરણ સાથે switch-case statement સ્ટેટમેન્ટ
સમજાવો.}

\begin{solutionbox}

\textbf{switch-case સિન્ટેક્સ:}

\begin{verbatim}
switch (expression) \{
    case constant1:
        // code block 1
        break;
    case constant2:
        // code block 2
        break;
    ...
    default:
        // default code block
\}
\end{verbatim}

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[Evaluate expression]}
    B {-{-} C\{matches case 1?\}}
    C {-{-}|Yes| D[Execute block 1]}
    C {-{-}|No| E\{matches case 2?\}}
    E {-{-}|Yes| F[Execute block 2]}
    E {-{-}|No| G\{matches case n?\}}
    G {-{-}|Yes| H[Execute block n]}
    G {-{-}|No| I[Execute default block]}
    D {-{-} J[break?]}
    F {-{-} K[break?]}
    H {-{-} L[break?]}
    J {-{-}|Yes| M([End])}
    K {-{-}|Yes| M}
    L {-{-}|Yes| M}
    I {-{-} M}
    J {-{-}|No| E}
    K {-{-}|No| G}
    L {-{-}|No| M}
\end{verbatim}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    char grade;
    
    printf("Enter grade (A{-D): "});
    scanf(" \%c", \&grade);
    
    switch (grade) \{
        case {A}:
            printf("Excellent!{n}");
            break;
        case {B}:
            printf("Good job!{n}");
            break;
        case {C}:
            printf("Satisfactory{n}");
            break;
        case {D}:
            printf("Needs improvement{n}");
            break;
        default:
            printf("Invalid grade{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CEBID: Compare-Execute-Break-If-Done''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{સ્ટ્રિંગ વ્યાખ્યાયિત કરો. સ્ટ્રિંગ પર કરી શકાય તેવા વિવિધ ઓપરેશન્સની યાદી
આપો.}

\begin{solutionbox}

\textbf{સ્ટ્રિંગ}: કેરેક્ટર્સનો એરે જે NULL કેરેક્ટર `\textbackslash0' થી સમાપ્ત થાય
છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઓપરેશન & વિગત & ફંક્શન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઇનપુટ/આઉટપુટ} & સ્ટ્રિંગ વાંચવી/લખવી & gets(), puts() \\
\textbf{કોપી} & એક સ્ટ્રિંગને બીજી સ્ટ્રિંગમાં કોપી કરવી & strcpy() \\
\textbf{જોડાણ} & બે સ્ટ્રિંગ જોડવી & strcat() \\
\textbf{સરખામણી} & બે સ્ટ્રિંગની સરખામણી & strcmp() \\
\textbf{લંબાઈ} & સ્ટ્રિંગની લંબાઈ શોધવી & strlen() \\
\textbf{શોધ} & સબસ્ટ્રિંગ શોધવી & strstr() \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ICCLS: Input-Copy-Concatenate-Length-Search''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{અપરકેસ આલ્ફાબેટને લોઅરકેસ આલ્ફાબેટમાં કન્વર્ટ કરવા માટે C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    char ch;
    
    printf("Enter an uppercase letter: ");
    scanf(" \%c", \&ch);
    
    if (ch {=} {A} \&\& ch {=} {Z}) \{
        char lowercase = ch + 32;  // ASCII તફાવત 32 છે
        printf("Lowercase: \%c{n}", lowercase);
    \} 
    else \{
        printf("Not an uppercase letter{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{ASCII ટેબલનો અંશ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
કેરેક્ટર & ASCII મૂલ્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{A} & 65 \\
\textbf{a} & 97 \\
\textbf{Z} & 90 \\
\textbf{z} & 122 \\
\textbf{તફાવત} & 32 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``COOL: Character Offset Of Lowercase''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{for લૂપ માટેનો ફ્લોચાર્ટ દોરો અને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{For Loop સિન્ટેક્સ:}

\begin{verbatim}
for (initialization; condition; increment/decrement) \{
    // code block
\}
\end{verbatim}

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[Initialization]}
    B {-{-} C\{Condition?\}}
    C {-{-}|True| D[Execute code block]}
    D {-{-} E[Increment/Decrement]}
    E {-{-} C}
    C {-{-}|False| F([End])}
\end{verbatim}

\textbf{For Loop ઘટકો:}

\begin{enumerate}
\tightlist
\item
  \textbf{ઇનિશિયલાઇઝેશન}: શરૂઆતમાં એક વખત અમલ
\item
  \textbf{શરત}: દરેક પુનરાવર્તન પહેલાં ચકાસાય
\item
  \textbf{વૃદ્ધિ/ઘટાડો}: દરેક પુનરાવર્તન પછી અમલ
\item
  \textbf{બોડી}: શરત સાચી હોય તો અમલ
\end{enumerate}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i;
    
    for (i = 1; i {=} 5; i++) \{
        printf("\%d ", i);
    \}
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}

\textbf{અમલીકરણનો પ્રવાહ:}

\begin{enumerate}
\tightlist
\item
  i = 1 પ્રારંભિક
\item
  શરત ચકાસો (1 \textless= 5) - સાચું
\item
  બોડી અમલ - 1 પ્રિન્ટ
\item
  i ને 2 માં વૃદ્ધિ
\item
  શરત ચકાસો (2 \textless= 5) - સાચું
\item
  અને એ રીતે આગળ i = 6 થાય ત્યાં સુધી
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``ICE-T: Initialize, Check, Execute, Then
increment''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) OR [3
ગુણ]}\label{q4a}

\textbf{એરે વ્યાખ્યાયિત કરો. એરે પર કરી શકાય તેવા વિવિધ ઓપરેશન્સની યાદી આપો.}

\begin{solutionbox}

\textbf{એરે}: સમાન ડેટા પ્રકારના તત્વો જે ક્રમિક મેમરી સ્થાનોમાં સંગ્રહિત થાય છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઓપરેશન & વિગત & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઘોષણા} & એરે બનાવો & int arr[5]; \\
\textbf{ઇનિશિયલાઇઝેશન} & મૂલ્ય આપો & arr[0] = 10; \\
\textbf{ટ્રેવર્સલ} & તમામ તત્વો એક્સેસ કરો & for loop \\
\textbf{ઇન્સર્શન} & નવું તત્વ ઉમેરો & arr[pos] = value; \\
\textbf{ડિલીશન} & તત્વ દૂર કરો & તત્વો શિફ્ટ કરો \\
\textbf{સર્ચિંગ} & તત્વ શોધો & લિનિયર/બાઇનરી શોધ \\
\textbf{સોર્ટિંગ} & તત્વો ગોઠવો & બબલ/સિલેક્શન સોર્ટ \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``DITIDSS:
Declare-Initialize-Traverse-Insert-Delete-Search-Sort''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) OR [4
ગુણ]}\label{q4b}

\textbf{pointer વ્યાખ્યાયિત કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{પોઇન્ટર}: એવું ચલ જે અન્ય ચલના મેમરી સરનામાને સંગ્રહિત કરે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કન્સેપ્ટ & વિગત & સિન્ટેક્સ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઘોષણા} & પોઇન્ટર બનાવો & int *ptr; \\
\textbf{એડ્રેસ ઓપરેટર} & સરનામું મેળવો & \&variable \\
\textbf{ડિરેફરન્સિંગ} & સરનામા પર મૂલ્ય એક્સેસ કરો & *ptr \\
\textbf{એસાઇનમેન્ટ} & પોઇન્ટરમાં સરનામું સંગ્રહો & ptr = \&variable; \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num = 10;
    int *ptr;
    
    ptr = \&num;  // num નું સરનામું ptr માં સંગ્રહો
    
    printf("Value of num: \%d{n}", num);           // 10
    printf("Address of num: \%p{n}", \&num);        // num નું સરનામું
    printf("Value of ptr: \%p{n}", ptr);           // સમાન સરનામું
    printf("Value pointed by ptr: \%d{n}", *ptr);  // 10
    
    *ptr = 20;   // પોઇન્ટર દ્વારા મૂલ્ય બદલો
    printf("New value of num: \%d{n}", num);       // 20
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    subgraph Memory
    direction LR
    A[ptr: 1001] {-{-}|contains| B[1000]}
    C[num: 1000] {-{-}|contains| D[10]}
    end
    B {-.{-}|points to| C}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SAVD: Store Address, Value through Dereferencing''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) OR [7
ગુણ]}\label{q4c}

\textbf{while લૂપ માટેનો ફ્લોચાર્ટ દોરો અને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{While Loop સિન્ટેક્સ:}

\begin{verbatim}
while (condition) \{
    // code block
\}
\end{verbatim}

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B\{Condition?\}}
    B {-{-}|True| C[Execute code block]}
    C {-{-} D[Update control variable]}
    D {-{-} B}
    B {-{-}|False| E([End])}
\end{verbatim}

\textbf{While Loop ઘટકો:}

\begin{enumerate}
\tightlist
\item
  \textbf{ઇનિશિયલાઇઝેશન}: લૂપની પહેલાં
\item
  \textbf{શરત}: દરેક પુનરાવર્તન પહેલાં ચકાસાય
\item
  \textbf{બોડી}: શરત સાચી હોય તો અમલ
\item
  \textbf{અપડેટ}: બોડીની અંદર કરવું જરૂરી
\end{enumerate}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i = 1;
    
    while (i {=} 5) \{
        printf("\%d ", i);
        i++;
    \}
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}

\textbf{અમલીકરણનો પ્રવાહ:}

\begin{enumerate}
\tightlist
\item
  i = 1 પ્રારંભિક (લૂપ પહેલાં)
\item
  શરત ચકાસો (1 \textless= 5) - સાચું
\item
  બોડી અમલ - 1 પ્રિન્ટ
\item
  i ને 2 માં અપડેટ
\item
  શરત ચકાસો (2 \textless= 5) - સાચું
\item
  અને એ રીતે આગળ i = 6 થાય ત્યાં સુધી
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``CHECK-UPDATE: CHECK before entering, UPDATE before
repeating''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{નીચેના functions નો ઉપયોગ જણાવો. (1) strcat() (2) strlen() (3)
strcpy()}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2778}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંક્શન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{strcat()} & સ્ટ્રિંગ્સ જોડે છે & strcat(dest, src) & ``Hello'' +
``World'' -\textgreater{} ``HelloWorld'' \\
\textbf{strlen()} & સ્ટ્રિંગની લંબાઈ આપે છે & strlen(str) & ``Hello''
-\textgreater{} 5 \\
\textbf{strcpy()} & સ્ટ્રિંગ કોપી કરે છે & strcpy(dest, src) & src
-\textgreater{} dest \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {string.h}

char str1[20] = "Hello";
char str2[20] = "World";
char str3[20];

strcat(str1, str2);    // str1 "HelloWorld" બને છે
int len = strlen(str1); // len 10 બને છે
strcpy(str3, str1);    // str3 "HelloWorld" બને છે
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CLS: Concatenate-Length-Source copy''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{પુસ્તકની માહિતી સંગ્રહિત કરવા માટે એક સ્ટ્રક્ચર બનાવો: book\_no,
book\_title, book\_author, book\_price.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}
\#include {string.h}

struct Book \{
    int book\_no;
    char book\_title[50];
    char book\_author[30];
    float book\_price;
\;}

int main() \{
    struct Book book1;
    
    // મૂલ્યો આપો
    book1.book\_no = 101;
    strcpy(book1.book\_title, "Programming in C");
    strcpy(book1.book\_author, "Dennis Ritchie");
    book1.book\_price = 450.75;
    
    // પુસ્તક માહિતી દર્શાવો
    printf("Book No: \%d{n}", book1.book\_no);
    printf("Title: \%s{n}", book1.book\_title);
    printf("Author: \%s{n}", book1.book\_author);
    printf("Price: \%.2f{n}", book1.book\_price);
    
    return 0;
\}
\end{verbatim}

\textbf{સ્ટ્રક્ચર મેમરી લેઆઉટ:}

\begin{verbatim}
flowchart TD
    subgraph "struct Book"
    direction LR
    A[book\_no: 4 bytes] {-{-} B[book\_title: 50 bytes]}
    B {-{-} C[book\_author: 30 bytes]}
    C {-{-} D[book\_price: 4 bytes]}
    end
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``NTAP: Number-Title-Author-Price''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{એરે અને એરે initialization સમજાવો. ઉદાહરણ આપો.}

\begin{solutionbox}

\textbf{એરે}: સમાન ડેટા પ્રકારના તત્વોનો સમૂહ જે ક્રમિક મેમરી સ્થાનોમાં સંગ્રહિત થાય
છે.

\textbf{એરે ઇનિશિયલાઇઝેશન પદ્ધતિઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ્ધતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ઘોષણા સમયે} & datatype array\_name[size] = \{values\}; & int
arr[5] = \{10, 20, 30, 40, 50\}; \\
\textbf{આંશિક} & datatype array\_name[size] = \{values\}; & int
arr[5] = \{10, 20\}; // બાકીના 0 છે \\
\textbf{બધા શૂન્ય} & datatype array\_name[size] = \{0\}; & int
arr[5] = \{0\}; \\
\textbf{તત્વ દર તત્વ} & array\_name[index] = value; & arr[0] = 10;
arr[1] = 20; \\
\textbf{સાઇઝ અનુમાન} & datatype array\_name[] = \{values\}; & int
arr[] = \{10, 20, 30\}; // સાઇઝ 3 \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    // પદ્ધતિ 1: પૂર્ણ ઇનિશિયલાઇઝેશન
    int arr1[5] = \{10, 20, 30, 40, 50\;}
    
    // પદ્ધતિ 2: આંશિક ઇનિશિયલાઇઝેશન (બાકીના તત્વો 0 થાય છે)
    int arr2[5] = \{10, 20\;}  // arr2[2], arr2[3], arr2[4] શૂન્ય થાય છે
    
    // પદ્ધતિ 3: તત્વ દર તત્વ
    int arr3[3];
    arr3[0] = 100;
    arr3[1] = 200;
    arr3[2] = 300;
    
    // પદ્ધતિ 4: સાઇઝ અનુમાન
    int arr4[] = \{1, 2, 3, 4, 5\;}  // સાઇઝ આપોઆપ 5 થાય છે
    
    // તત્વો એક્સેસ
    printf("arr1[2] = \%d{n}", arr1[2]);  // આઉટપુટ: 30
    
    // એરે ટ્રેવર્સલ
    printf("arr4 elements: ");
    for(int i = 0; i {} 5; i++) \{
        printf("\%d ", arr4[i]);  // આઉટપુટ: 1 2 3 4 5
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{મેમરી રિપ્રેઝન્ટેશન:}

\begin{verbatim}
flowchart LR
    subgraph "arr1[5]"
    direction LR
    A["arr1[0]: 10"] {-{-}{-} B["arr1[1]: 20"] {-}{-}{-} C["arr1[2]: 30"] {-}{-}{-} D["arr1[3]: 40"] {-}{-}{-} E["arr1[4]: 50"]}
    end
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CAPES: Complete, Automatic, Partial, Element,
Size-inferred''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) OR [3
ગુણ]}\label{q5a}

\textbf{array અને structure ઉદાહરણ સાથે સરખામણી કરો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લક્ષણ & Array & Structure \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ડેટા ટાઇપ} & સમાન પ્રકારના તત્વો & અલગ પ્રકારના તત્વો \\
\textbf{એક્સેસ} & ઇન્ડેક્સનો ઉપયોગ (arr[i]) & ડોટ ઓપરેટરનો ઉપયોગ
(s.member) \\
\textbf{મેમરી} & ક્રમિક, ફિક્સ સાઇઝ & ક્રમિક, પેડિંગ હોઈ શકે \\
\textbf{એસાઇનમેન્ટ} & તત્વ દર તત્વ & સીધું જ સુસંગત સ્ટ્રક્ચર સાથે \\
\textbf{હેતુ} & સમાન આઇટમોનો સંગ્રહ & સંબંધિત ડેટાનો સમૂહ \\
\end{longtable}
}

\textbf{એરે ઉદાહરણ:}

\begin{verbatim}
int marks[5] = \{85, 90, 78, 92, 88\;}
printf("\%d", marks[2]);  // ઇન્ડેક્સ 2 (78) પર તત્વ એક્સેસ
\end{verbatim}

\textbf{સ્ટ્રક્ચર ઉદાહરણ:}

\begin{verbatim}
struct Student \{
    int roll\_no;
    char name[20];
    float percentage;
\;}

struct Student s1 = \{101, "Raj", 85.5\;}
printf("\%s", s1.name);  // name મેમ્બર ("Raj") એક્સેસ
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``DAMPA: Datatype-Access-Memory-Purpose-Assignment''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) OR [4
ગુણ]}\label{q5b}

\textbf{User Defined Function વ્યાખ્યાયિત કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\textbf{User Defined Function}: પ્રોગ્રામર દ્વારા લખાયેલ કોડનો બ્લોક જે ચોક્કસ
કાર્ય કરે છે અને તેને વારંવાર કોલ કરી શકાય છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & વિગત & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{રિટર્ન ટાઇપ} & પરત થતા ડેટાનો પ્રકાર & int, float, void \\
\textbf{ફંક્શન નેમ} & અનન્ય ઓળખકર્તા & sum, findMax \\
\textbf{પેરામીટર્સ} & ઇનપુટ ડેટા & (int a, int b) \\
\textbf{બોડી} & સ્ટેટમેન્ટ સમૂહ & \{ return a+b; \} \\
\end{longtable}
}

\textbf{ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

// ફંક્શન ઘોષણા
int sum(int a, int b);

int main() \{
    int num1 = 10, num2 = 20, result;
    
    // ફંક્શન કોલ
    result = sum(num1, num2);
    
    printf("Sum = \%d{n}", result);
    
    return 0;
\}

// ફંક્શન વ્યાખ્યા
int sum(int a, int b) \{
    return a + b;
\}
\end{verbatim}

\textbf{ફંક્શન ફ્લો:}

\begin{verbatim}
flowchart LR
    A[main function] {-{-}|"Call sum(10, 20)"| B["sum function"]}
    B {-{-}|Return 30| A}
B {-{-}|a = 10,

b = 20| C[return a + b]}

\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``DPCR: Declaration-Parameters-Call-Return''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) OR [7
ગુણ]}\label{q5c}

\textbf{એરેમાંથી મહત્તમ અને લઘુત્તમ element શોધવા માટે C પ્રોગ્રામનો લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int arr[100], n, i;
    int max, min;
    
    printf("Enter number of elements: ");
    scanf("\%d", \&n);
    
    printf("Enter \%d integers: ", n);
    for(i = 0; i {} n; i++) \{
        scanf("\%d", \&arr[i]);
    \}
    
    // max અને min પ્રથમ તત્વ સાથે પ્રારંભિક કરો
    max = min = arr[0];
    
    // max અને min શોધો
    for(i = 1; i {} n; i++) \{
        if(arr[i] {} max) \{
            max = arr[i];
        \}
        if(arr[i] {} min) \{
            min = arr[i];
        \}
    \}
    
    printf("Maximum element: \%d{n}", max);
    printf("Minimum element: \%d{n}", min);
    
    return 0;
    \}
\end{verbatim}

\textbf{અલ્ગોરિધમ:}

\begin{enumerate}
\tightlist
\item
  એરે સાઇઝ અને તત્વો ઇનપુટ કરો
\item
  max અને min ને પ્રથમ તત્વ સાથે પ્રારંભિક કરો
\item
  દરેક બાકીના તત્વ માટે:

  \begin{itemize}
  \tightlist
  \item
    જો તત્વ \textgreater{} max, max અપડેટ કરો
  \item
    જો તત્વ \textless{} min, min અપડેટ કરો
  \end{itemize}
\item
  max અને min ને દર્શાવો
\end{enumerate}

\textbf{ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input n/]}
    B {-{-} C[/Input array elements/]}
    C {-{-} D["max = min = arr[0]"]}
    D {-{-} E[i = 1]}
    E {-{-} F\{i  n?\}}
    F {-{-}|Yes| G\{"arr[i]  max?"\}}
    G {-{-}|Yes| H["max = arr[i]"]}
    G {-{-}|No| I\{"arr[i]  min?"\}}
    H {-{-} I}
    I {-{-}|Yes| J["min = arr[i]"]}
    I {-{-}|No| K[i++]}
    J {-{-} K}
    K {-{-} F}
    F {-{-}|No| L[/Display max, min/]}
    L {-{-} M([End])}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``FILLS: First Initialize, Loop through, Look for
Small/large''

\end{mnemonicbox}

\end{document}
