\documentclass{article}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/gujarati-boxes.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Programming in C (4331105) - Summer 2023 Solution}
\date{July 26, 2023}

\begin{document}
\maketitle

\questionmarks{1}{a}{3}
\textbf{C લેંગ્વેજના કોઈ પણ છ કીવર્ડ લખો.}

\begin{solutionbox}
    \textbf{કોષ્ટક: C લેંગ્વેજના છ કીવર્ડ}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{કીવર્ડ} & \textbf{ઉપયોગ} \\
        \hline
        \code{int} & પૂર્ણાંક ડેટા પ્રકાર \\
        \hline
        \code{float} & અપૂર્ણાંક ડેટા પ્રકાર \\
        \hline
        \code{if} & શરતી નિવેદન \\
        \hline
        \code{while} & લૂપ સ્ટ્રક્ચર \\
        \hline
        \code{return} & ફંક્શનમાંથી મૂલ્ય પાછું મેળવવા માટે \\
        \hline
        \code{void} & ખાલી રિટર્ન પ્રકાર દર્શાવવા \\
        \hline
    \end{tabulary}

    \begin{mnemonicbox}"I Feel When Running Very Ill" (int, float, while, return, void, if)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{b}{4}
\textbf{વેરિયેબલની વ્યાખ્યા લખો. C પ્રોગ્રામિંગમાં વેરિયેબલના નામ માટેના નિયમો લખો.}

\begin{solutionbox}
    \textbf{વેરિયેબલ}: એક નામાંકિત મેમરી સ્થાન જેનો ઉપયોગ પ્રોગ્રામના અમલ દરમિયાન સુધારી શકાય તેવા ડેટાને સંગ્રહિત કરવા માટે થાય છે.

    \textbf{કોષ્ટક: C માં વેરિયેબલના નામકરણના નિયમો}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{નિયમ} & \textbf{ઉદાહરણ} \\
        \hline
        અક્ષર/અંડરસ્કોરથી શરૂ થવું જોઈએ & \code{name}, \code{\_value} \\
        \hline
        અક્ષરો, અંકો, અંડરસ્કોર સમાવી શકે & \code{user\_1}, \code{count99} \\
        \hline
        ખાલી જગ્યા કે વિશેષ અક્ષરો ન હોવા જોઈએ & \checkmark: \code{total\_sum}, \ding{55}: \code{total-sum} \\
        \hline
        કેસ સેન્સિટિવ છે & \code{Name} $\neq$ \code{name} \\
        \hline
        રિઝર્વ કીવર્ડ્સનો ઉપયોગ ન કરી શકાય & \ding{55}: \code{int}, \code{while} \\
        \hline
        મહત્તમ 31 અક્ષરો (સ્ટાન્ડર્ડ) & \code{studentRegistrationNumber} \\
        \hline
    \end{tabulary}

    \begin{mnemonicbox}"Letters Lead, No Special Keys" (અક્ષરથી શરૂ, વિશેષ અક્ષરો નહીં, કીવર્ડ્સ નહીં)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{c}{7}
\textbf{ફ્લોચાર્ટની વ્યાખ્યા લખો. ફ્લોચાર્ટના સિમ્બોલ દોરો અને સમજાવો. નીચેના સમીકરણનો ઉપયોગ કરીને સિમ્પલ ઇન્ટરેસ્ટની ગણતરી કરવા માટેનો પ્રોગ્રામ લખો. I=PRN/100 જ્યાં P=પ્રિન્સીપલ રકમ, R= વ્યાજનો દર અને N= સમયગાળો.}

\begin{solutionbox}
    \textbf{ફ્લોચાર્ટ}: એક પ્રશ્નનો ઉકેલ કરવા માટે જરૂરી ક્રમિક ઓપરેશન્સને દર્શાવવા માટે પ્રમાણભૂત પ્રતીકોનો ઉપયોગ કરીને અલ્ગોરિધમની ગ્રાફિકલ રજૂઆત.

    \textbf{કોષ્ટક: ફ્લોચાર્ટ સિમ્બોલ}

    \begin{tabulary}{\linewidth}{|C|L|L|}
        \hline
        \textbf{સિમ્બોલ} & \textbf{નામ} & \textbf{ઉપયોગ} \\
        \hline
        \begin{tikzpicture}
            \node[gtu start, minimum width=2cm, minimum height=1cm] {Start/End};
        \end{tikzpicture} & ટર્મિનલ & શરૂઆત/અંત \\
        \hline
        \begin{tikzpicture}
            \node[gtu process, minimum width=2cm, minimum height=1cm] {Process};
        \end{tikzpicture} & પ્રોસેસ & ગણતરી \\
        \hline
        \begin{tikzpicture}
            \node[gtu input, minimum width=2cm, minimum height=1cm] {Input/Output};
        \end{tikzpicture} & ઈનપુટ/આઉટપુટ & ડેટા વાંચવો/દર્શાવવો \\
        \hline
        \begin{tikzpicture}
            \node[gtu decision, minimum width=2cm, minimum height=1.5cm] {};
        \end{tikzpicture} & નિર્ણય & શરતો \\
        \hline
        $\rightarrow$ & ફ્લો લાઈન & ક્રમ બતાવે છે \\
        \hline
    \end{tabulary}

    \textbf{સિમ્પલ ઇન્ટરેસ્ટનું ફ્લોચાર્ટ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input P, R, N};
        \node[gtu process, below=of input] (calc) {Calculate $I = \frac{P \times R \times N}{100}$};
        \node[gtu input, below=of calc] (disp) {Display I};
        \node[gtu start, below=of disp] (end) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (disp);
        \draw[gtu arrow] (disp) -- (end);
    \end{tikzpicture}
    \end{center}

    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    float p, r, n, i;
    
    printf("Enter principal amount: ");
    scanf("%f", &p);
    
    printf("Enter rate of interest: ");
    scanf("%f", &r);
    
    printf("Enter time period in years: ");
    scanf("%f", &n);
    
    i = (p * r * n) / 100;
    
    printf("Simple Interest = %.2f", i);
}
\end{lstlisting}

    \begin{mnemonicbox}"Please Return Nice Interest" (Principal, Rate, Number of years, Interest)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{c}{7}
\textbf{OR અલગોરિધમની વ્યાખ્યા લખો. સિલિન્ડરનું ઘનફળ શોધવા માટેનું અલગોરિધમ લખો. યુઝર પાસેથી સિલિન્ડરની ત્રિજ્યા(R) અને ઊંચાઈ(H) ઈનપુટ લઇ સિલિન્ડરના વોલ્યુમ(V)ની ગણતરી નીચેના સમીકરણનો ઉપયોગ કરીને પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો. V=$\pi$R$^2$H}

\begin{solutionbox}
    \textbf{અલગોરિધમ}: મર્યાદિત સમયમાં કોઈ સમસ્યાનો ઉકેલ કરવા માટેની પગલાવાર પ્રક્રિયા.

    \textbf{સિલિન્ડરના ઘનફળ માટેનું અલગોરિધમ:}

    \begin{enumerate}
        \item શરૂ કરો
        \item ત્રિજ્યા (R) અને ઊંચાઈ (H) ઇનપુટ લો
        \item $V = \pi \times R^2 \times H$ સૂત્રનો ઉપયોગ કરીને ઘનફળની ગણતરી કરો
        \item ઘનફળ પ્રદર્શિત કરો
        \item સમાપ્ત
    \end{enumerate}

    \textbf{ડાયગ્રામ: સિલિન્ડર}

    \begin{center}
    \begin{tikzpicture}
        \draw (0,0) ellipse (1.5 and 0.5);
        \draw (0,3) ellipse (1.5 and 0.5);
        \draw (-1.5,0) -- (-1.5,3);
        \draw (1.5,0) -- (1.5,3);
        
        \draw[<->] (1.7,0) -- (1.7,3) node[midway, right] {H};
        \draw[<->] (0,-0.5) -- (1.5,-0.5) node[midway, below] {R};
    \end{tikzpicture}
    \end{center}

    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    float radius, height, volume;
    float pi = 3.14159;
    
    printf("Enter radius of cylinder: ");
    scanf("%f", &radius);
    
    printf("Enter height of cylinder: ");
    scanf("%f", &height);
    
    volume = pi * radius * radius * height;
    
    printf("Volume of cylinder = %.2f", volume);
}
\end{lstlisting}

    \begin{mnemonicbox}"Round Hat Volume" (Radius, Height, Volume)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{a}{3}
\textbf{C પ્રોગ્રામિંગ ભાષામાં સપોર્ટ કરતા વિવિધ ઓપરેટરોની યાદી બનાવો.}

\begin{solutionbox}
    \textbf{કોષ્ટક: C પ્રોગ્રામિંગમાં ઓપરેટર્સ}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{ઓપરેટર પ્રકાર} & \textbf{ઉદાહરણો} & \textbf{ઉપયોગ} \\
        \hline
        એરિથમેટિક & +, -, *, /, \% & ગાણિતિક ઓપરેશન્સ \\
        \hline
        રિલેશનલ & <, >, ==, !=, <=, >= & મૂલ્યોની સરખામણી \\
        \hline
        લોજીકલ & \&\&, ||, ! & શરતોને જોડવા \\
        \hline
        એસાઇનમેન્ટ & =, +=, -=, *=, /= & મૂલ્યો આપવા \\
        \hline
        ઇનક્રિમેન્ટ/ડિક્રિમેન્ટ & ++, -- & 1 વધારવું/ઘટાડવું \\
        \hline
        બિટવાઇઝ & \&, |, \^{}, \~{}, <<, >> & બિટ મેનિપ્યુલેશન \\
        \hline
        કન્ડિશનલ & ?: & ટૂંકા if-else \\
        \hline
    \end{tabulary}

    \begin{mnemonicbox}"All Relationships Lead Ancestors Incrementally Beyond Conditions" (દરેક પ્રકારનો પ્રથમ અક્ષર)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{b}{4}
\textbf{1 થી 50 નો સરવાળો અને સરેરાશ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int i, sum = 0;
    float avg;
    
    for(i = 1; i <= 50; i++)
    {
        sum = sum + i;
    }
    
    avg = (float)sum / 50;
    
    printf("Sum of numbers from 1 to 50 = %d\n", sum);
    printf("Average of numbers from 1 to 50 = %.2f", avg);
}
\end{lstlisting}

    \textbf{પ્રક્રિયા ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu process, right=of start] (init) {Set sum = 0};
        \node[gtu process, right=of init] (loop) {Loop $i$ from 1 to 50};
        \node[gtu process, below=of loop] (add) {Add $i$ to sum};
        \node[gtu decision, left=of add] (cond) {$i < 50$?};
        \node[gtu process, below=of cond] (calc) {avg = sum/50};
        \node[gtu input, right=of calc] (disp) {Display sum/avg};
        \node[gtu start, right=of disp] (end) {End};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (loop);
        \draw[gtu arrow] (loop) -- (add);
        \draw[gtu arrow] (add) -- (cond);
        \draw[gtu arrow] (cond) |- node[near start, right] {Yes} (loop);
        \draw[gtu arrow] (cond) -- node[left] {No} (calc);
        \draw[gtu arrow] (calc) -- (disp);
        \draw[gtu arrow] (disp) -- (end);
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Summing And Dividing" (Sum, Average, Division)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{c}{7}
\textbf{એરીથમેટીક અને રિલેશનલ ઓપરેટર ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \textbf{એરિથમેટિક ઓપરેટર્સ:}

    \textbf{કોષ્ટક: C માં એરિથમેટિક ઓપરેટર}

    \begin{tabulary}{\linewidth}{|C|L|L|C|}
        \hline
        \textbf{ઓપરેટર} & \textbf{ઓપરેશન} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\
        \hline
        + & સરવાળો & 5 + 3 & 8 \\
        \hline
        - & બાદબાકી & 7 - 2 & 5 \\
        \hline
        * & ગુણાકાર & 4 * 3 & 12 \\
        \hline
        / & ભાગાકાર & 8 / 4 & 2 \\
        \hline
        \% & મોડ્યુલસ (બાકી) & 7 \% 3 & 1 \\
        \hline
    \end{tabulary}

    \textbf{રિલેશનલ ઓપરેટર્સ:}

    \textbf{કોષ્ટક: C માં રિલેશનલ ઓપરેટર}

    \begin{tabulary}{\linewidth}{|C|L|L|C|}
        \hline
        \textbf{ઓપરેટર} & \textbf{અર્થ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\
        \hline
        < & કરતાં ઓછું & 5 < 8 & 1 (સાચું) \\
        \hline
        > & કરતાં વધુ & 9 > 3 & 1 (સાચું) \\
        \hline
        == & બરાબર & 4 == 4 & 1 (સાચું) \\
        \hline
        != & અસમાન & 7 != 3 & 1 (સાચું) \\
        \hline
        <= & કરતાં ઓછું અથવા બરાબર & 4 <= 4 & 1 (સાચું) \\
        \hline
        >= & કરતાં વધુ અથવા બરાબર & 6 >= 9 & 0 (ખોટું) \\
        \hline
    \end{tabulary}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int a = 10, b = 5;
    
    // એરિથમેટિક ઓપરેટર્સ
    printf("a + b = %d\n", a + b);   // 15
    printf("a - b = %d\n", a - b);   // 5
    printf("a * b = %d\n", a * b);   // 50
    printf("a / b = %d\n", a / b);   // 2
    printf("a %% b = %d\n", a % b);  // 0
    
    // રિલેશનલ ઓપરેટર્સ
    printf("a < b: %d\n", a < b);    // 0 (ખોટું)
    printf("a > b: %d\n", a > b);    // 1 (સાચું)
    printf("a == b: %d\n", a == b);  // 0 (ખોટું)
    printf("a != b: %d\n", a != b);  // 1 (સાચું)
}
\end{lstlisting}

    \begin{mnemonicbox}"Add Subtract Multiply Divide Remainder" (એરિથમેટિક), "Less Greater Equal Not" (રિલેશનલ)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{a}{3}
\textbf{OR gets(S) અને scanf("\%s",S) ફંક્શન વચ્ચેનો તફાવત લખો જ્યાં S સ્ટ્રીંગ છે.}

\begin{solutionbox}
    \textbf{કોષ્ટક: gets(S) અને scanf("\%s",S) વચ્ચેનો તફાવત}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લક્ષણ} & \textbf{gets(S)} & \textbf{scanf("\%s",S)} \\
        \hline
        સ્પેસ હેન્ડલિંગ & શબ્દો વચ્ચે સ્પેસ વાંચે છે & સ્પેસ પર વાંચવાનું બંધ કરે છે \\
        \hline
        ઇનપુટ સમાપ્તિ & ન્યૂલાઇન પર સમાપ્ત થાય છે & વ્હાઇટસ્પેસ પર સમાપ્ત થાય છે \\
        \hline
        બફર ઓવરફ્લો & અસુરક્ષિત, લંબાઈ ચકાસણી નથી & વિડ્થ લિમિટ સાથે સુરક્ષિત \\
        \hline
        ઉદાહરણ વર્તન & "Hello World" $\rightarrow$ "Hello World" & "Hello World" $\rightarrow$ "Hello" \\
        \hline
        સુરક્ષા & ઓવરફ્લો જોખમને કારણે અવમૂલ્યિત & વિડ્થ સ્પેસિફાયર સાથે વધુ સારું \\
        \hline
    \end{tabulary}

    \begin{mnemonicbox}"Gets Spaces, Scanf Stops" (gets સ્પેસ વાંચે છે, scanf સ્પેસ પર અટકે છે)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{b}{4}
\textbf{OR બે સંખ્યાની અદલાબદલી કરવાનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int a, b, temp;
    
    printf("Enter value of a: ");
    scanf("%d", &a);
    
    printf("Enter value of b: ");
    scanf("%d", &b);
    
    printf("Before swapping: a = %d, b = %d\n", a, b);
    
    // ટેમ્પ વેરિયેબલનો ઉપયોગ કરીને અદલાબદલી
    temp = a;
    a = b;
    b = temp;
    
    printf("After swapping: a = %d, b = %d", a, b);
}
\end{lstlisting}

    \textbf{અદલાબદલી ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu process] (a) {a = 5};
        \node[gtu process, below=of a] (b) {b = 10};
        \node[gtu process, right=of a, xshift=2cm] (temp) {temp = 5};
        \node[gtu process, below=of temp] (a_new) {a = 10};
        \node[gtu process, below=of a_new] (b_new) {b = 5};

        \draw[gtu arrow] (a) -- node[above] {temp = a} (temp);
        \draw[gtu arrow] (b) -- node[above, sloped] {a = b} (a_new);
        \draw[gtu arrow] (temp) -- node[right] {b = temp} (b_new);
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Temporary Assists Swapping" (ટેમ્પ વેરિયેબલ અદલાબદલી માટે મદદ કરે છે)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{c}{7}
\textbf{OR લોજીકલ ઓપરેટર અને બીટ-વાઈસ ઓપરેટર ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \textbf{લોજીકલ ઓપરેટર્સ:}

    \textbf{કોષ્ટક: C માં લોજીકલ ઓપરેટર}

    \begin{tabulary}{\linewidth}{|C|L|L|C|}
        \hline
        \textbf{ઓપરેટર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\
        \hline
        \&\& & લોજીકલ AND & (5>3) \&\& (8>6) & 1 (બંને સાચાં) \\
        \hline
        || & લોજીકલ OR & (5<3) || (8>6) & 1 (એક સાચું) \\
        \hline
        ! & લોજીકલ NOT & !(5>3) & 0 (સાચાને ખોટામાં ફેરવે) \\
        \hline
    \end{tabulary}

    \textbf{બિટવાઇઝ ઓપરેટર્સ:}

    \textbf{કોષ્ટક: C માં બિટવાઇઝ ઓપરેટર}

    \begin{tabulary}{\linewidth}{|C|L|L|L|}
        \hline
        \textbf{ઓપરેટર} & \textbf{વિગત} & \textbf{ઉદાહરણ} & \textbf{બાઇનરી પરિણામ} \\
        \hline
        \& & બિટવાઇઝ AND & 5 \& 3 & 101 \& 011 = 001 (1) \\
        \hline
        | & બિટવાઇઝ OR & 5 | 3 & 101 | 011 = 111 (7) \\
        \hline
        \^{} & બિટવાઇઝ XOR & 5 \^{} 3 & 101 \^{} 011 = 110 (6) \\
        \hline
        \~{} & બિટવાઇઝ NOT & \~{}5 & \~{}0101 = 1010 (-6) \\
        \hline
        << & લેફ્ટ શિફ્ટ & 5 << 1 & 101 << 1 = 1010 (10) \\
        \hline
        >> & રાઇટ શિફ્ટ & 5 >> 1 & 101 >> 1 = 10 (2) \\
        \hline
    \end{tabulary}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int a = 5, b = 3;
    
    // લોજીકલ ઓપરેટર્સ
    printf("a>3 && b<5: %d\n", (a>3) && (b<5));  // 1 (સાચું)
    printf("a<3 || b>1: %d\n", (a<3) || (b>1));  // 1 (સાચું)
    printf("!(a>b): %d\n", !(a>b));              // 0 (ખોટું)
    
    // બિટવાઇઝ ઓપરેટર્સ
    printf("a & b: %d\n", a & b);   // 1
    printf("a | b: %d\n", a | b);   // 7
    printf("a ^ b: %d\n", a ^ b);   // 6
    printf("~a: %d\n", ~a);         // -6
    printf("a << 1: %d\n", a << 1); // 10
    printf("a >> 1: %d\n", a >> 1); // 2
}
\end{lstlisting}

    \begin{mnemonicbox}"AND OR NOT" (લોજીકલ ઓપરેટર્સ), "AND OR XOR NOT SHIFT" (બિટવાઇઝ ઓપરેટર્સ)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{a}{3}
\textbf{ઉદાહરણ સાથે multiple if-else સ્ટેટમેન્ટ સમજાવો.}

\begin{solutionbox}
    \textbf{Multiple if-else}: શરતોનો ક્રમ અનુસાર ચકાસણી થાય છે જ્યાં સૌથી પહેલી સાચી શરત મળે ત્યાં સુધી.

    \textbf{સ્ટ્રક્ચર:}

\begin{lstlisting}[language=C]
if (condition1)
    statement1;
else if (condition2)
    statement2;
else if (condition3)
    statement3;
else
    default_statement;
\end{lstlisting}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int marks;
    
    printf("Enter marks: ");
    scanf("%d", &marks);
    
    if (marks >= 80)
        printf("Grade: A");
    else if (marks >= 70)
        printf("Grade: B");
    else if (marks >= 60)
        printf("Grade: C");
    else if (marks >= 50)
        printf("Grade: D");
    else
        printf("Grade: F");
}
\end{lstlisting}

    \textbf{ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu decision, alias=d1, below=of start] {marks $\ge$ 80?};
        \node[gtu process, right=of d1] (g1) {Grade A};
        \node[gtu decision, alias=d2, below=of d1] {marks $\ge$ 70?};
        \node[gtu process, right=of d2] (g2) {Grade B};
        \node[gtu decision, alias=d3, below=of d2] {marks $\ge$ 60?};
        \node[gtu process, right=of d3] (g3) {Grade C};
        \node[gtu decision, alias=d4, below=of d3] {marks $\ge$ 50?};
        \node[gtu process, right=of d4] (g4) {Grade D};
        \node[gtu process, below=of d4] (g5) {Grade F};
        
        \draw[gtu arrow] (start) -- (d1);
        \draw[gtu arrow] (d1) -- node[above] {Yes} (g1);
        \draw[gtu arrow] (d1) -- node[left] {No} (d2);
        \draw[gtu arrow] (d2) -- node[above] {Yes} (g2);
        \draw[gtu arrow] (d2) -- node[left] {No} (d3);
        \draw[gtu arrow] (d3) -- node[above] {Yes} (g3);
        \draw[gtu arrow] (d3) -- node[left] {No} (d4);
        \draw[gtu arrow] (d4) -- node[above] {Yes} (g4);
        \draw[gtu arrow] (d4) -- node[left] {No} (g5);
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Check Each Condition in Sequence" (CECS)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{b}{4}
\textbf{While લૂપ અને for લૂપનું વર્કિંગ જણાવો.}

\begin{solutionbox}
    \textbf{કોષ્ટક: While લૂપ vs For લૂપ}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લક્ષણ} & \textbf{While લૂપ} & \textbf{For લૂપ} \\
        \hline
        સિન્ટેક્સ & \code{while(cond) \{ stmt; \}} & \code{for(init; cond; upd) \{ stmt; \}} \\
        \hline
        ક્યારે વાપરવું & જ્યારે પુનરાવર્તનની સંખ્યા અજ્ઞાત હોય & જ્યારે પુનરાવર્તનની સંખ્યા જાણીતી હોય \\
        \hline
        ઇનિશિયલાઇઝેશન & લૂપની બહાર & લૂપના ડિક્લેરેશનમાં \\
        \hline
        અપડેટ & લૂપ બોડીની અંદર કરવું જોઈએ & લૂપ ડિક્લેરેશનમાં આપોઆપ થાય છે \\
        \hline
        એક્ઝિટ કંટ્રોલ & માત્ર શરૂઆતમાં & માત્ર શરૂઆતમાં \\
        \hline
    \end{tabulary}

    \begin{minipage}{0.45\textwidth}
    \textbf{While લૂપ ફ્લો:}
    \begin{center}
    \begin{tikzpicture}[gtu flow, scale=0.7, transform shape]
        \node[gtu start] (start) {Start};
        \node[gtu process, below=of start] (init) {Init};
        \node[gtu decision, below=of init] (cond) {Cond};
        \node[gtu process, right=of cond] (body) {Body};
        \node[gtu start, below=of cond] (end) {End};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (cond);
        \draw[gtu arrow] (cond) -- node[above] {True} (body);
        \draw[gtu arrow] (body) |- (cond);
        \draw[gtu arrow] (cond) -- node[left] {False} (end);
    \end{tikzpicture}
    \end{center}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\textwidth}
    \textbf{For લૂપ ફ્લો:}
    \begin{center}
    \begin{tikzpicture}[gtu flow, scale=0.7, transform shape]
        \node[gtu start] (start) {Start};
        \node[gtu process, below=of start] (init) {Init};
        \node[gtu decision, below=of init] (cond) {Cond};
        \node[gtu process, right=of cond] (body) {Body};
        \node[gtu process, below=of body] (upd) {Update};
        \node[gtu start, below=of cond] (end) {End};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (cond);
        \draw[gtu arrow] (cond) -- node[above] {True} (body);
        \draw[gtu arrow] (body) -- (upd);
        \draw[gtu arrow] (upd) |- (cond);
        \draw[gtu arrow] (cond) -- node[left] {False} (end);
    \end{tikzpicture}
    \end{center}
    \end{minipage}

    \begin{mnemonicbox}"While Checks Then Acts" (WCTA), "For Initializes Tests Updates" (FITU)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{c}{7}
\textbf{આપેલ સંખ્યાના ફેક્ટોરિયલ શોધવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int num, i;
    unsigned long fact = 1;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    if (num < 0)
        printf("Factorial not defined for negative numbers");
    else
    {
        for(i = 1; i <= num; i++)
        {
            fact = fact * i;
        }
        printf("Factorial of %d = %lu", num, fact);
    }
}
\end{lstlisting}

    \textbf{ફેક્ટોરિયલ ગણતરી કોષ્ટક:}
    ઉદાહરણ તરીકે, જો num = 5:

    \begin{tabulary}{\linewidth}{|C|C|L|C|}
        \hline
        \textbf{પુનરાવર્તન} & \textbf{i} & \textbf{fact * i} & \textbf{નવી fact કિંમત} \\
        \hline
        પ્રારંભિક & - & - & 1 \\
        \hline
        1 & 1 & 1 * 1 & 1 \\
        \hline
        2 & 2 & 1 * 2 & 2 \\
        \hline
        3 & 3 & 2 * 3 & 6 \\
        \hline
        4 & 4 & 6 * 4 & 24 \\
        \hline
        5 & 5 & 24 * 5 & 120 \\
        \hline
    \end{tabulary}

    \textbf{ફેક્ટોરિયલ ગણતરી ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (inp) {Input num};
        \node[gtu decision, below=of inp] (chk) {num < 0?};
        \node[gtu process, right=of chk] (err) {Error};
        \node[gtu process, below=of chk] (init) {fact = 1};
        \node[gtu process, below=of init] (loop) {Loop $i=1$ to $num$};
        \node[gtu process, below=of loop] (calc) {fact *= i};
        \node[gtu decision, below=of calc] (lchk) {More $i$?};
        \node[gtu input, below=of lchk] (disp) {Display fact};
        \node[gtu start, below=of disp] (end) {End};

        \draw[gtu arrow] (start) -- (inp);
        \draw[gtu arrow] (inp) -- (chk);
        \draw[gtu arrow] (chk) -- node[above] {Yes} (err);
        \draw[gtu arrow] (chk) -- node[left] {No} (init);
        \draw[gtu arrow] (init) -- (loop);
        \draw[gtu arrow] (loop) -- (calc);
        \draw[gtu arrow] (calc) -- (lchk);
        \draw[gtu arrow] (lchk) -- node[right] {No} (disp);
        \draw[gtu arrow] (lchk.east) -- ++(0.5,0) |- (loop.east);
        \draw[gtu arrow] (disp) -- (end);
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Find And Count The Numbers!" (FACTN! - Factorial)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{a}{3}
\textbf{OR ઉદાહરણ સાથે switch-case સ્ટેટમેન્ટની કામગીરી સમજાવો.}

\begin{solutionbox}
    \textbf{Switch-Case}: એક પસંદગી નિવેદન જે મૂલ્યોની યાદી (કેસ) સામે વેરિયેબલની સમાનતા ચકાસવાની મંજૂરી આપે છે.

    \textbf{સ્ટ્રક્ચર:}

\begin{lstlisting}[language=C]
switch(expression) {
    case value1:
        statements1;
        break;
    case value2:
        statements2;
        break;
    default:
        default_statements;
}
\end{lstlisting}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int day;
    printf("Enter day number (1-7): ");
    scanf("%d", &day);
    
    switch(day) {
        case 1: printf("Monday"); break;
        case 2: printf("Tuesday"); break;
        case 3: printf("Wednesday"); break;
        case 4: printf("Thursday"); break;
        case 5: printf("Friday"); break;
        case 6: printf("Saturday"); break;
        case 7: printf("Sunday"); break;
        default: printf("Invalid day");
    }
}
\end{lstlisting}

    \begin{mnemonicbox}"Select Value, Exit with Break" (SVEB)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{b}{4}
\textbf{OR break અને continue સ્ટેટમેન્ટ ઉપયોગ લખો.}

\begin{solutionbox}
    \textbf{કોષ્ટક: Break vs Continue Keywords}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લક્ષણ} & \textbf{break} & \textbf{continue} \\
        \hline
        ઉદ્દેશ & વર્તમાન લૂપ/સ્વિચમાંથી બહાર નીકળે છે & વર્તમાન પુનરાવર્તન છોડી, આગલા પુનરાવર્તનમાં જાય છે \\
        \hline
        લૂપ પર અસર & લૂપને સમાપ્ત કરે છે & આગલા પુનરાવર્તનમાં આગળ વધે છે \\
        \hline
        ક્યાં વપરાય છે & લૂપ્સ \& સ્વિચ સ્ટેટમેન્ટ્સ & માત્ર લૂપ્સમાં \\
        \hline
        કંટ્રોલ ફ્લો & લૂપ પછીના સ્ટેટમેન્ટ પર જાય છે & લૂપની શરત ચકાસણી પર જાય છે \\
        \hline
    \end{tabulary}

    \textbf{ફ્લો ડાયગ્રામ - break:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu process, right=of start] (loop) {Loop};
        \node[gtu decision, right=of loop] (cond) {Cond?};
        \node[gtu process, below=of cond] (break) {break};
        \node[gtu start, right=of cond] (endloop) {Rest of loop};
        \node[gtu start, below=of break] (end) {End};

        \draw[gtu arrow] (start) -- (loop);
        \draw[gtu arrow] (loop) -- (cond);
        \draw[gtu arrow] (cond) -- node[left] {True} (break);
        \draw[gtu arrow] (cond) -- node[above] {False} (endloop);
        \draw[gtu arrow] (break) -- (end);
        \draw[gtu arrow] (endloop) |- (loop);
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Break Exits, Continue Skips" (BECS)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{c}{7}
\textbf{OR કીબોર્ડ પરથી લીટીઓની સંખ્યા (n) વાંચી અને નીચે દર્શાવેલ ત્રિકોણ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો. ઉદાહરણ તરીકે, n=5}

\begin{solutionbox}
    \textbf{Target Pattern:}
    
\begin{verbatim}
1 2 3 4 5
1 2 3 4
1 2 3
1 2
1
\end{verbatim}

    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int n, i, j;
    
    printf("Enter number of lines: ");
    scanf("%d", &n);
    
    for(i = n; i >= 1; i--)
    {
        for(j = 1; j <= i; j++)
        {
            printf("%d ", j);
        }
        printf("\n");
    }
}
\end{lstlisting}

    \textbf{પેટર્ન લોજિક કોષ્ટક:}
    n = 5 માટે:

    \begin{tabulary}{\linewidth}{|C|C|L|}
        \hline
        \textbf{i} & \textbf{j} & \textbf{આઉટપુટ} \\
        \hline
        5 & j=1 થી 5 & 1 2 3 4 5 \\
        \hline
        4 & j=1 થી 4 & 1 2 3 4 \\
        \hline
        3 & j=1 થી 3 & 1 2 3 \\
        \hline
        2 & j=1 થી 2 & 1 2 \\
        \hline
        1 & j=1 થી 1 & 1 \\
        \hline
    \end{tabulary}

    \begin{mnemonicbox}"Decreasing Rows With Increasing Values" (DRWIV)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{a}{3}
\textbf{નેસ્ટેડ if-else સ્ટેટમેન્ટ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \textbf{નેસ્ટેડ if-else}: બીજા if અથવા else બ્લોકની અંદરનું if-else સ્ટેટમેન્ટ.

    \textbf{સ્ટ્રક્ચર:}

\begin{lstlisting}[language=C]
if (condition1) {
    if (condition2) {
        statements1;
    } else {
        statements2;
    }
} else {
    statements3;
}
\end{lstlisting}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int age, weight;
    
    printf("Enter age: ");
    scanf("%d", &age);
    
    if (age >= 18) {
        printf("Enter weight: ");
        scanf("%d", &weight);
        
        if (weight >= 50) {
            printf("Eligible to donate blood");
        } else {
            printf("Underweight, not eligible");
        }
    } else {
        printf("Age below 18, not eligible");
    }
}
\end{lstlisting}

    \textbf{નેસ્ટેડ if-else ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu decision, alias=d1, below=of start] {age $\ge$ 18?};
        \node[gtu decision, alias=d2, right=of d1, xshift=2cm] {weight $\ge$ 50?};
        \node[gtu process, below=of d1] (not_age) {લાયક નથી: ઉંમર};
        \node[gtu process, right=of d2] (eligible) {લાયક છે};
        \node[gtu process, below=of d2] (not_weight) {લાયક નથી: વજન};
        \node[gtu start, below=of not_weight] (end) {End};

        \draw[gtu arrow] (start) -- (d1);
        \draw[gtu arrow] (d1) -- node[above] {Yes} (d2);
        \draw[gtu arrow] (d1) -- node[left] {No} (not_age);
        \draw[gtu arrow] (d2) -- node[above] {Yes} (eligible);
        \draw[gtu arrow] (d2) -- node[left] {No} (not_weight);
        
        \draw[gtu arrow] (not_age) |- (end);
        \draw[gtu arrow] (not_weight) -- (end);
        \draw[gtu arrow] (eligible) |- (end);
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Check Outside Then Inside" (COTI)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{b}{4}
\textbf{Pointer arguments નો ઉપયોગ કરીને બે પૂર્ણાંક સંખ્યાની અદલાબદલી કરવાનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int a, b, temp;
    int *p1, *p2;
    
    printf("Enter value of a: ");
    scanf("%d", &a);
    
    printf("Enter value of b: ");
    scanf("%d", &b);
    
    p1 = &a;  // p1 a ને પોઇન્ટ કરે છે
    p2 = &b;  // p2 b ને પોઇન્ટ કરે છે
    
    printf("Before swapping: a = %d, b = %d\n", a, b);
    
    // પોઇન્ટર્સનો ઉપયોગ કરીને અદલાબદલી
    temp = *p1;
    *p1 = *p2;
    *p2 = temp;
    
    printf("After swapping: a = %d, b = %d", a, b);
}
\end{lstlisting}

    \textbf{પોઇન્ટર અદલાબદલી ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}
        \node[draw, minimum size=1cm] (a) {5};
        \node[draw, minimum size=1cm, below=of a] (b) {10};
        \node[left=0.2cm of a] {a};
        \node[left=0.2cm of b] {b};
        
        \node[draw, minimum size=1cm, right=2cm of a] (p1) {addr(a)};
        \node[draw, minimum size=1cm, right=2cm of b] (p2) {addr(b)};
        \node[right=0.2cm of p1] {p1};
        \node[right=0.2cm of p2] {p2};
        
        \draw[->, thick, shorten >=2pt] (p1) -- (a);
        \draw[->, thick, shorten >=2pt] (p2) -- (b);
        
        \node[below=1.5cm of b] (text) {પોઇન્ટર્સ દ્વારા અદલાબદલી પછી:};
        
        \node[draw, minimum size=1cm, below=0.5cm of text] (a2) {10};
        \node[draw, minimum size=1cm, below=of a2] (b2) {5};
        \node[left=0.2cm of a2] {a};
        \node[left=0.2cm of b2] {b};
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Pointers Exchange Memory Values" (PEMV)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{c}{7}
\textbf{Array ની વ્યાખ્યા લખો. One dimensional array નું initialization અને declaration સમજાવો.}

\begin{solutionbox}
    \textbf{Array}: એક જ ડેટા પ્રકારના તત્વોનો સમૂહ જે સળંગ મેમરી સ્થાનોમાં સંગ્રહિત થાય છે અને ઇન્ડેક્સ વડે ઍક્સેસ થાય છે.

    \textbf{કોષ્ટક: Array ડિક્લેરેશન \& ઇનિશિયલાઇઝેશન}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{ઓપરેશન} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} \\
        \hline
        ડિક્લેરેશન & \code{type name[size];} & \code{int marks[5];} \\
        \hline
        ડિક્લેરેશન સમયે init & \code{type name[size] = \{vals\};} & \code{int nums[4] = \{10, 20\};} \\
        \hline
        આંશિક init & \code{type name[size] = \{vals\};} & \code{int nums[5] = \{10\};} \\
        \hline
        સાઇઝ વિના & \code{type name[] = \{vals\};} & \code{int nums[] = \{1, 2\};} \\
        \hline
        વ્યક્તિગત તત્વો & \code{name[index] = value;} & \code{marks[0] = 95;} \\
        \hline
    \end{tabulary}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    // ડિક્લેરેશન
    int marks[5];
    
    // ડિક્લેરેશન પછી ઇનિશિયલાઇઝેશન
    marks[0] = 85; marks[1] = 90;
    marks[2] = 78; marks[3] = 92; marks[4] = 88;
    
    // ડિક્લેરેશન સાથે ઇનિશિયલાઇઝેશન
    int scores[] = {95, 89, 76, 82, 91};
    
    printf("marks[2] = %d\n", marks[2]);
}
\end{lstlisting}

    \textbf{મેમરી રજૂઆત:}

    \begin{center}
    \begin{tikzpicture}
        \foreach \x/\val in {0/85, 1/90, 2/78, 3/92, 4/88} {
            \node[draw, minimum width=1.5cm, minimum height=1cm] at (\x*1.5, 0) (box\x) {\val};
            \node[below=0.2cm of box\x] {\footnotesize marks[\x]};
        }
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Declare, Initialize, Access With Index" (DIAWI)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{a}{3}
\textbf{OR do while loop ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \textbf{do-while loop}: એક લૂપ જે શરતની ચકાસણી કરતા પહેલા ઓછામાં ઓછી એકવાર લૂપ બોડી ચલાવે છે.

    \textbf{સ્ટ્રક્ચર:}

\begin{lstlisting}[language=C]
do {
    statements;
} while(condition);
\end{lstlisting}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int num, sum = 0;
    do {
        printf("Enter a number (0 to stop): ");
        scanf("%d", &num);
        sum += num;
    } while(num != 0);
    printf("Sum = %d", sum);
}
\end{lstlisting}

    \textbf{do-while લૂપ ફ્લો:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu process, below=of start] (body) {બોડી સ્ટેટમેન્ટ્સ};
        \node[gtu decision, below=of body] (cond) {શરત?};
        \node[gtu start, below=of cond] (end) {End};

        \draw[gtu arrow] (start) -- (body);
        \draw[gtu arrow] (body) -- (cond);
        \draw[gtu arrow] (cond) -- node[left] {ખોટું} (end);
        \draw[gtu arrow] (cond.east) -- ++(0.5,0) |- node[near start, right] {સાચું} (body.east);
    \end{tikzpicture}
    \end{center}

    \textbf{while લૂપથી મુખ્ય તફાવતો:}
    \begin{itemize}
        \item બોડી ઓછામાં ઓછી એકવાર ચલાવે છે
        \item સ્ટેટમેન્ટ્સ ચલાવ્યા પછી કંડીશન ચેક કરે છે
        \item કંડીશન પછી સેમિકોલોન જરૂરી છે
    \end{itemize}

    \begin{mnemonicbox}"Do First, Check Later" (DFCL)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{b}{4}
\textbf{OR નીચે આપેલ ફંકશન ઉદાહરણ સાથે સમજાવો: (1) gets() (2) puts() (3) strlen() (4) strcpy()}

\begin{solutionbox}
    \textbf{કોષ્ટક: C માં સ્ટ્રિંગ ફંકશન્સ}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{ફંકશન} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\
        \hline
        gets() & સ્પેસ સાથે સ્ટ્રિંગ વાંચે છે & \code{gets(n);} \\
        \hline
        puts() & ન્યૂલાઇન સાથે સ્ટ્રિંગ દર્શાવે છે & \code{puts(n);} \\
        \hline
        strlen() & સ્ટ્રિંગની લંબાઈ આપે છે & \code{l=strlen(s);} \\
        \hline
        strcpy() & સોર્સને ડેસ્ટિનેશનમાં કોપી કરે છે & \code{strcpy(d,s);} \\
        \hline
    \end{tabulary}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>
void main()
{
    char name[50], copy[50];
    int length;
    
    printf("Enter name: ");
    gets(name);           
    puts(name);
    
    length = strlen(name);
    printf("Length: %d\n", length);
    
    strcpy(copy, name);
    printf("Copied: %s", copy);
}
\end{lstlisting}

    \begin{mnemonicbox}"Gets Puts String's Length and Copies" (GPSLC)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{c}{7}
\textbf{OR Recursion ની વ્યાખ્યા આપી ઉદાહરણ સાથે સમજાવો. Recursion નો ઉપયોગ કરીને આપેલા નંબરનો ફેક્ટોરીયલ શોધવાનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{Recursion}: એક પ્રક્રિયા જેમાં ફંક્શન સીધી કે પરોક્ષ રીતે પોતાને જ ચોક્કસ શરત પૂરી થાય ત્યાં સુધી કૉલ કરે છે.

    \textbf{Recursion ના ઘટકો}:
    \begin{enumerate}
        \item બેઝ કેસ: રિકર્ઝન રોકવા માટેની શરત.
        \item રિકર્સિવ કેસ: ફંકશન પોતે જ પોતાને કૉલ કરે છે.
    \end{enumerate}

    \textbf{કોડ ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

unsigned long factorial(int n)
{
    if (n <= 1)
        return 1;
    else
        return n * factorial(n-1);
}

void main()
{
    int num;
    printf("Enter a number: ");
    scanf("%d", &num);
    printf("Factorial of %d = %lu", num, factorial(num));
}
\end{lstlisting}

    \textbf{કોષ્ટક: રિકર્ઝન ટ્રેસ:}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{કૉલ} & \textbf{રિટર્ન} & \textbf{ગણતરી} \\
        \hline
        fact(5) & $5 \times$ fact(4) & $5 \times 24 = 120$ \\
        \hline
        fact(4) & $4 \times$ fact(3) & $4 \times 6 = 24$ \\
        \hline
        fact(3) & $3 \times$ fact(2) & $3 \times 2 = 6$ \\
        \hline
        fact(2) & $2 \times$ fact(1) & $2 \times 1 = 2$ \\
        \hline
        fact(1) & બેઝ કેસ & 1 \\
        \hline
    \end{tabulary}

    \textbf{રિકર્ઝન ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}
        \node[draw] (f5) {fact(5)};
        \node[draw, right=0.5cm of f5] (f4) {fact(4)};
        \node[draw, right=0.5cm of f4] (f3) {fact(3)};
        \node[draw, right=0.5cm of f3] (f2) {fact(2)};
        \node[draw, right=0.5cm of f2] (f1) {fact(1)};

        \draw[->] (f5) -- (f4);
        \draw[->] (f4) -- (f3);
        \draw[->] (f3) -- (f2);
        \draw[->] (f2) -- (f1);
        \draw[->, dashed] (f1) to[bend left] (f2);
        \draw[->, dashed] (f2) to[bend left] (f3);
        \draw[->, dashed] (f3) to[bend left] (f4);
        \draw[->, dashed] (f4) to[bend left] (f5);
        
        \node[above=0.1cm of f1] {Return 1};
        \node[below=0.1cm of f5] {Return 120};
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Function Calling Itself, Bottoming Out" (FCIBO)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{a}{3}
\textbf{array અને structure વચ્ચેનો તફાવત લખો.}

\begin{solutionbox}
    \textbf{કોષ્ટક: Array vs Structure}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લક્ષણ} & \textbf{Array} & \textbf{Structure} \\
        \hline
        ડેટા પ્રકાર & બધા તત્વો માટે એક જ પ્રકાર & વિવિધ ડેટા પ્રકાર \\
        \hline
        ઍક્સેસ & ઇન્ડેક્સ (\code{arr[0]}) & મેમ્બર (\code{s.name}) \\
        \hline
        મેમરી & સળંગ & સળંગ (મિશ્રિત) \\
        \hline
        સાઇઝ & ફિક્સ & બધા મેમ્બર્સનો સરવાળો \\
        \hline
        હેતુ & સમાન વસ્તુઓનો સંગ્રહ & વિવિધ પ્રકારનું ગ્રુપિંગ \\
        \hline
        ડિક્લેરેશન & \code{int a[5];} & \code{struct s \{ int a; \};} \\
        \hline
    \end{tabulary}

    \textbf{ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}
        \node (arr) {Array};
        \foreach \x in {0,1,2} {
            \node[draw, minimum size=0.8cm] at (\x, -1) (a\x) {int};
        }
        
        \node[right=3cm of arr] (str) {Structure};
        \node[draw, minimum width=0.8cm, minimum height=0.8cm] at (5, -1) (s1) {int};
        \node[draw, minimum width=1.5cm, minimum height=0.8cm, right=0cm of s1] (s2) {char[]};
        \node[draw, minimum width=0.8cm, minimum height=0.8cm, right=0cm of s2] (s3) {float};
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Arrays for Same, Structures for Different" (ASSD)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{b}{4}
\textbf{આપેલ 10 કિંમતમાંથી મહત્તમ કિંમત શોધવાનો C પ્રોગ્રામ array નો ઉપયોગ કરીને લખો.}

\begin{solutionbox}
    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    int arr[10], i, max;
    
    printf("Enter 10 values:\n");
    for(i = 0; i < 10; i++) {
        scanf("%d", &arr[i]);
    }
    
    max = arr[0]; 
    for(i = 1; i < 10; i++) {
        if(arr[i] > max)
            max = arr[i];
    }
    
    printf("Maximum value is: %d", max);
}
\end{lstlisting}

    \textbf{અલ્ગોરિધમ ફ્લો:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {10 કિંમતો ઇનપુટ};
        \node[gtu process, below=of input] (init) {max = arr[0]};
        \node[gtu process, right=of init] (loop) {લૂપ $i=1$ થી 9};
        \node[gtu decision, right=of loop] (check) {arr[i] > max?};
        \node[gtu process, below=of check] (update) {max = arr[i]};
        \node[gtu input, below=of init] (disp) {max દર્શાવો};
        \node[gtu start, below=of disp] (end) {End};
        
        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (init);
        \draw[gtu arrow] (init) -- (loop);
        \draw[gtu arrow] (loop) -- (check);
        \draw[gtu arrow] (check) -- node[right] {Yes} (update);
        \draw[gtu arrow] (check) -- node[above] {No} ++(2,0) |- (loop);
        \draw[gtu arrow] (update) -- ++(-1.5,0) |- (loop);
        
        \draw[gtu arrow] (loop) -- node[left] {Done} (disp);
        \draw[gtu arrow] (disp) -- (end);
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Compare And Replace Maximum" (CARM)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{c}{7}
\textbf{Structure ને વ્યાખ્યા લખો. Book નામથી એક structure બનાવો કે જેમાં book વિશેની માહિતી Book title, Name of author, Price and Number of pages સ્ટોર કરી શકાય.}

\begin{solutionbox}
    \textbf{Structure}: વિવિધ ડેટા પ્રકારના સંબંધિત વેરિયેબલ્સને એક જ નામ હેઠળ ગ્રુપ કરતું યુઝર-ડિફાઇન્ડ ડેટા પ્રકાર.

    \textbf{Book Structure કોડ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

struct book {
    char title[50];
    char author[30];
    float price;
    int pages;
};

void main()
{
    struct book b1;
    
    printf("Enter book title: "); gets(b1.title);
    printf("Enter author name: "); gets(b1.author);
    printf("Enter price: "); scanf("%f", &b1.price);
    printf("Enter pages: "); scanf("%d", &b1.pages);
    
    printf("\nBook Details:\n");
    printf("Title: %s\n", b1.title);
    printf("Author: %s\n", b1.author);
    printf("Price: %.2f\n", b1.price);
    printf("Pages: %d", b1.pages);
}
\end{lstlisting}

    \textbf{Structure ડાયગ્રામ:}

    \begin{center}
    \begin{tikzpicture}
        \node[draw, minimum width=4cm, minimum height=0.6cm] (header) {\textbf{struct book}};
        \node[draw, minimum width=4cm, minimum height=0.6cm, below=0cm of header] (f1) {title[50] (char)};
        \node[draw, minimum width=4cm, minimum height=0.6cm, below=0cm of f1] (f2) {author[30] (char)};
        \node[draw, minimum width=4cm, minimum height=0.6cm, below=0cm of f2] (f3) {price (float)};
        \node[draw, minimum width=4cm, minimum height=0.6cm, below=0cm of f3] (f4) {pages (int)};
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Title Author Price Pages" (TAPP)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{a}{3}
\textbf{OR સ્ટ્રીંગ શું છે? સ્ટ્રીંગ ઉપર કયા ઓપરેશન પરફોર્મ થાય છે.}

\begin{solutionbox}
    \textbf{સ્ટ્રીંગ}: NULL કેરેક્ટર '\textbackslash0' દ્વારા સમાપ્ત થતા અક્ષરોની શ્રેણી.

    \textbf{કોષ્ટક: C માં સ્ટ્રીંગ ઓપરેશન્સ}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{ઓપરેશન} & \textbf{ફંક્શન} & \textbf{ઉદાહરણ} \\
        \hline
        ઇનપુટ & gets, scanf & \code{gets(s)} \\
        \hline
        આઉટપુટ & puts, printf & \code{puts(s)} \\
        \hline
        લંબાઈ & strlen & \code{l=strlen(s)} \\
        \hline
        કોપી & strcpy & \code{strcpy(d,s)} \\
        \hline
        જોડાણ & strcat & \code{strcat(s1,s2)} \\
        \hline
        સરખામણી & strcmp & \code{strcmp(s1,s2)} \\
        \hline
        શોધ & strchr & \code{strchr(s,'a')} \\
        \hline
    \end{tabulary}

    \textbf{સ્ટ્રીંગ રજૂઆત:}

    \begin{center}
    \begin{tikzpicture}
        \foreach \x/\vchar in {0/H, 1/e, 2/l, 3/l, 4/o, 5/\textbackslash 0} {
            \node[draw, minimum size=0.8cm] at (\x*0.8, 0) {\vchar};
        }
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Input Output Length Copy Concat Compare Search Convert" (IOLCCSC)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{b}{4}
\textbf{OR A to Z ની ASCII વેલ્યુ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
void main()
{
    char ch;
    
    printf("ASCII values from A to Z:\n");
    printf("Char\tValue\n");
    
    for(ch = 'A'; ch <= 'Z'; ch++)
    {
        printf("%c\t%d\n", ch, ch);
    }
}
\end{lstlisting}

    \textbf{ASCII રજૂઆત:}

    \begin{center}
    \begin{tikzpicture}
        \node[draw] (a) {A (65)};
        \node[draw, right=of a] (b) {B (66)};
        \node[right=of b] (dots) {...};
        \node[draw, right=of dots] (z) {Z (90)};
    \end{tikzpicture}
    \end{center}

    \begin{mnemonicbox}"Alphabets Sequentially Creating Integer Indices" (ASCII)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{c}{7}
\textbf{OR user defined અને library function શું છે? દરેકના બે ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \textbf{Library Functions}: C ભાષા દ્વારા પૂરા પાડવામાં આવતા પહેલેથી વ્યાખ્યાયિત ફંક્શન્સ (e.g., printf, sqrt).
    \textbf{User-Defined Functions}: પ્રોગ્રામર દ્વારા ચોક્કસ કાર્યો કરવા માટે બનાવેલા ફંક્શન્સ.

    \textbf{કોષ્ટક: Library vs User-Defined Functions}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લક્ષણ} & \textbf{Library Functions} & \textbf{User-Defined Functions} \\
        \hline
        વ્યાખ્યા & પહેલેથી વ્યાખ્યાયિત & પ્રોગ્રામર દ્વારા \\
        \hline
        ડિક્લેરેશન & જરૂર નથી & વ્યાખ્યા કરવી જોઈએ \\
        \hline
        હેડર & જરૂરી (stdio.h) & કોઈ હેડર જરૂરી નથી \\
        \hline
        હેતુ & સામાન્ય કાર્યો & કસ્ટમાઇઝ્ડ કાર્યો \\
        \hline
    \end{tabulary}

    \textbf{ઉદાહરણો:}
    
    1. \textbf{Library}: \code{strlen("Hi")} (string.h), \code{sqrt(25)} (math.h)
    
    2. \textbf{User-Defined}:
\begin{lstlisting}[language=C]
float calculateArea(float l, float w) {
    return l * w;
}
int findMax(int a, int b) {
    return (a>b)?a:b;
}
\end{lstlisting}

    \begin{mnemonicbox}"Libraries Provide, Users Create" (LPUC)\end{mnemonicbox}
\end{solutionbox}

\end{document}

