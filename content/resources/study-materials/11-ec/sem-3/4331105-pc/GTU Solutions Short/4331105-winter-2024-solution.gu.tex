\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{પ્રોગ્રામિંગ ઇન સી (4331105) - વિન્ટર 2024 સોલ્યુશન}
\date{May 21, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{C લેંગ્વેજના કોઈ પણ છ કીવર્ડ લખો.}

\begin{solutionbox}
\begin{answertable}{Keywords Categories}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{વર્ગ} & \textbf{કીવર્ડ} \\ \hline
\textbf{ડેટા ટાઈપ્સ} & \code{int}, \code{float}, \code{char} \\ \hline
\textbf{કંટ્રોલ ફ્લો} & \code{if}, \code{for}, \code{return} \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{I Find Clever Reasons For Results}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{ઓપરેટરની વ્યાખ્યા આપી operand ના આધારે તેના પ્રકાર જણાવો.}

\begin{solutionbox}
\textbf{ઓપરેટર}: એવું ચિહ્ન કે જે ઓપરન્ડ્સ પર કામ કરીને પરિણામ આપે છે.

\begin{answertable}{Types of Operators}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પ્રકાર} & \textbf{વિગત} & \textbf{ઉદાહરણ} \\ \hline
\textbf{યુનરી} & એક ઓપરન્ડ & \code{++}, \code{--}, \code{!} \\ \hline
\textbf{બાઇનરી} & બે ઓપરન્ડ & \code{+}, \code{-}, \code{*}, \code{/}, \code{\%} \\ \hline
\textbf{ટર્નરી} & ત્રણ ઓપરન્ડ & \code{?:} \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{U-B-T: Use Binary Then Ternary}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{ફ્લોચાર્ટની વ્યાખ્યા લખો. ફ્લોચાર્ટના સિમ્બોલ દોરો. બે પૂર્ણાંક નંબર N1 અને N2 માંથી નાનો નંબર શોધવા માટેનો ફ્લોચાર્ટ દોરો.}

\begin{solutionbox}
\textbf{ફ્લોચાર્ટ}: અલ્ગોરિધમનું ગ્રાફિકલ નિરૂપણ જેમાં પ્રમાણિત ચિહ્નો દ્વારા ક્રમબદ્ધ ઓપરેશનો દર્શાવવામાં આવે છે.

\textbf{ફ્લોચાર્ટના સામાન્ય ચિહ્નો:}

\begin{answertable}{Flowchart Symbols}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ચિહ્ન} & \textbf{અર્થ} \\ \hline
\textbf{ઓવલ} & શરૂઆત/અંત \\ \hline
\textbf{પેરાલેલોગ્રામ} & ઇનપુટ/આઉટપુટ \\ \hline
\textbf{લંબચોરસ} & પ્રક્રિયા \\ \hline
\textbf{ડાયમંડ} & નિર્ણય \\ \hline
\textbf{એરો} & ફ્લો દિશા \\ \hline
\end{tabulary}
\end{answertable}

\textbf{N1 અને N2 માંથી નાનો નંબર શોધવા માટેનો ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu input, below=of start] (input) {ઇનપુટ N1, N2};
    \node [gtu decision, below=of input] (dec) {N1 < N2?};
    \node [gtu process, below left=of dec] (p1) {Min = N1};
    \node [gtu process, below right=of dec] (p2) {Min = N2};
    \node [gtu output, below=2cm of dec] (out) {Min દર્શાવો};
    \node [gtu state, below=of out] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (dec);
    \path [gtu arrow] (dec) -| node [above] {હા (Yes)} (p1);
    \path [gtu arrow] (dec) -| node [above] {ના (No)} (p2);
    \path [gtu arrow] (p1) |- (out);
    \path [gtu arrow] (p2) |- (out);
    \path [gtu arrow] (out) -- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Minimum of Two Numbers}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SPADE: Start-Process-Arrow-Decision-End}
\end{mnemonicbox}

\orquestionmarks{1(c)}{7}{અલગોરિધમની વ્યાખ્યા લખો. વર્તુળનું ક્ષેત્રફળ અને પરિઘ શોધવા માટેનો અલગોરિધમ લખો.}

\begin{solutionbox}
\textbf{અલગોરિધમ}: કોઈ સમસ્યાને ઉકેલવા માટેનું પગલે પગલે પદ્ધતિસરનું કાર્યવાહી, જેમાં સુનિશ્ચિત સંખ્યામાં સુવ્યાખ્યાયિત સૂચનાઓનો ઉપયોગ થાય છે.

\textbf{વર્તુળનું ક્ષેત્રફળ અને પરિઘ શોધવા માટેનો અલગોરિધમ:}

\begin{enumerate}
    \item \textbf{શરૂઆત}
    \item \textbf{ત્રિજ્યા r ઇનપુટ કરો}
    \item \textbf{PI = 3.14159 સેટ કરો}
    \item \textbf{ક્ષેત્રફળ = PI $\times$ r $\times$ r ગણો}
    \item \textbf{પરિઘ = 2 $\times$ PI $\times$ r ગણો}
    \item \textbf{ક્ષેત્રફળ અને પરિઘ દર્શાવો}
    \item \textbf{અંત}
\end{enumerate}

\begin{answertable}{Table of formulas used}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{માપન} & \textbf{સૂત્ર} \\ \hline
\textbf{ક્ષેત્રફળ} & $\pi \times r^2$ \\ \hline
\textbf{પરિઘ} & $2 \times \pi \times r$ \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RICARD: Radius Input, Calculate Area, Reveal Dimensions}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{printf() અને scanf() વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}
\begin{answertable}{Difference between printf() and scanf()}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{printf()} & \textbf{scanf()} \\ \hline
\textbf{હેતુ} & સ્ક્રીન પર ડેટા આઉટપુટ કરે & કીબોર્ડથી ડેટા ઇનપુટ કરે \\ \hline
\textbf{દિશા} & આઉટપુટ ફંક્શન & ઇનપુટ ફંક્શન \\ \hline
\textbf{ફોર્મેટ સ્પેસિફાયર} & જરૂરી & જરૂરી \\ \hline
\textbf{પેરામીટર} & વાસ્તવિક મૂલ્યો & ચલનું સરનામું (\code{\&}) \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{OIAD: Output-Input, Actual-Destination}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{1 થી n સુધીનો સરવાળો અને સરેરાશ પ્રિન્ટ કરવા માટે પ્રોગ્રામ C લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Sum and Average Program}]
#include <stdio.h>

int main() {
    int n, i, sum = 0;
    float avg;
    
    printf("Enter n: ");
    scanf("%d", &n);
    
    for(i = 1; i <= n; i++) {
        sum += i;
    }
    
    avg = (float)sum / n;
    
    printf("Sum = %d\n", sum);
    printf("Average = %.2f\n", avg);
    
    return 0;
}
\end{lstlisting}

\textbf{મુખ્ય બિંદુઓ:}
\begin{itemize}
    \item \textbf{ઇનિશિયલાઇઝેશન}: \code{sum = 0}
    \item \textbf{પુનરાવર્તન}: 1 થી n સુધી \code{for} લૂપ
    \item \textbf{ટાઇપ કાસ્ટિંગ}: સાચા સરેરાશ માટે \code{(float)}
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SIAP: Sum Initialize, Add in loop, Print results}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{એરિથમેટિક ઓપરેટર અને રિલેશનલ ઓપરેટરને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{1. એરિથમેટિક ઓપરેટર:}

\begin{answertable}{Arithmetic Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ઓપરેટર} & \textbf{ઓપરેશન} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\ \hline
\textbf{+} & સરવાળો & 5 + 3 & 8 \\ \hline
\textbf{-} & બાદબાકી & 5 - 3 & 2 \\ \hline
\textbf{*} & ગુણાકાર & 5 * 3 & 15 \\ \hline
\textbf{/} & ભાગાકાર & 5 / 2 & 2 (પૂર્ણાંક) \\ \hline
\textbf{\%} & મોડ્યુલો (શેષ) & 5 \% 2 & 1 \\ \hline
\end{tabulary}
\end{answertable}

\textbf{2. રિલેશનલ ઓપરેટર:}

\begin{answertable}{Relational Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ઓપરેટર} & \textbf{અર્થ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\ \hline
\textbf{<} & કરતાં નાનું & 5 < 3 & 0 (ખોટું) \\ \hline
\textbf{>} & કરતાં મોટું & 5 > 3 & 1 (સાચું) \\ \hline
\textbf{<=} & નાનું અથવા સમાન & 5 <= 5 & 1 (સાચું) \\ \hline
\textbf{>=} & મોટું અથવા સમાન & 3 >= 5 & 0 (ખોટું) \\ \hline
\textbf{==} & સમાન & 5 == 5 & 1 (સાચું) \\ \hline
\textbf{!=} & અસમાન & 5 != 3 & 1 (સાચું) \\ \hline
\end{tabulary}
\end{answertable}

\textbf{કોડ ઉદાહરણ:}
\begin{lstlisting}[language=C]
int a = 5, b = 3;
printf("a + b = %d\n", a + b);     // Output: 8
printf("a > b is %d\n", a > b);    // Output: 1 (True)
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ASMDR for Arithmetic, LEGENE for Relational}
\end{mnemonicbox}

\orquestionmarks{2(a)}{3}{get(S) અને scanf("\%s",S) વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}
\begin{answertable}{Difference between gets(S) and scanf()}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{gets(S)} & \textbf{scanf("\%s",S)} \\ \hline
\textbf{વ્હાઇટસ્પેસ હેન્ડલિંગ} & સ્પેસ વાંચે છે & વ્હાઇટસ્પેસ પર બંધ થાય છે \\ \hline
\textbf{બફર ઓવરફ્લો} & બાઉન્ડરી ચેક નથી & વિડ્થ લિમિટ સાથે સલામત \\ \hline
\textbf{રિટર્ન ટાઇપ} & \code{char*} & વાંચેલા આઇટમની સંખ્યા \\ \hline
\textbf{ઉપયોગ સુરક્ષા} & ડેપ્રિકેટેડ, અસુરક્ષિત & ફોર્મેટ કંટ્રોલ સાથે સલામત \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{WBRU: Whitespace-Boundary-Return-Usage}
\end{mnemonicbox}

\orquestionmarks{2(b)}{4}{બે નંબરોના મૂલ્યની અદલાબદલી (એક્સચેન્જ) કરવા માટે C પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Swap Two Numbers}]
#include <stdio.h>

int main() {
    int a, b, temp;
    
    printf("Enter two numbers: ");
    scanf("%d %d", &a, &b);
    
    printf("Before swap: a = %d, b = %d\n", a, b);
    
    temp = a;
    a = b;
    b = temp;
    
    printf("After swap: a = %d, b = %d\n", a, b);
    
    return 0;
}
\end{lstlisting}

\textbf{ડાયાગ્રામ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (before) {Before: a=5, b=10};
    \node [gtu process, below=of before] (step1) {temp = a (5)};
    \node [gtu process, below=of step1] (step2) {a = b (10)};
    \node [gtu process, below=of step2] (step3) {b = temp (5)};
    \node [gtu state, below=of step3] (after) {After: a=10, b=5};

    \path [gtu arrow] (before) -- (step1);
    \path [gtu arrow] (step1) -- (step2);
    \path [gtu arrow] (step2) -- (step3);
    \path [gtu arrow] (step3) -- (after);
\end{tikzpicture}
\captionof{figure}{Swapping Logic using Temp Variable}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TAB: Temp-Assign-Backfill}
\end{mnemonicbox}

\orquestionmarks{2(c)}{7}{બુલિયન ઓપરેટર અને લોજિકલ ઓપરેટર ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{1. બુલિયન ઓપરેટર:}

\begin{answertable}{Boolean (Bitwise) Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ઓપરેટર} & \textbf{ઓપરેશન} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\ \hline
\textbf{\&} & બિટવાઇઝ AND & 5 \& 3 & 1 \\ \hline
\textbf{|} & બિટવાઇઝ OR & 5 | 3 & 7 \\ \hline
\textbf{\textasciicircum} & બિટવાઇઝ XOR & 5 \textasciicircum\ 3 & 6 \\ \hline
\textbf{\textasciitilde} & બિટવાઇઝ NOT & \textasciitilde 5 & -6 \\ \hline
\textbf{<<} & લેફ્ટ શિફ્ટ & 5 << 1 & 10 \\ \hline
\textbf{>>} & રાઇટ શિફ્ટ & 5 >> 1 & 2 \\ \hline
\end{tabulary}
\end{answertable}

\textbf{2. લોજિકલ ઓપરેટર:}

\begin{answertable}{Logical Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ઓપરેટર} & \textbf{અર્થ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\ \hline
\textbf{\&\&} & લોજિકલ AND & (5>3) \&\& (2<4) & 1 (સાચું) \\ \hline
\textbf{||} & લોજિકલ OR & (5<3) || (2<4) & 1 (સાચું) \\ \hline
\textbf{!} & લોજિકલ NOT & !(5>3) & 0 (ખોટું) \\ \hline
\end{tabulary}
\end{answertable}

\textbf{ઉદાહરણ:}
\begin{lstlisting}[language=C]
int a = 5, b = 3;
printf("a & b = %d\n", a & b);           // Output: 1 (bitwise AND)
printf("a > b && b < 10 is %d\n", a > b && b < 10);  // Output: 1 (true)
\end{lstlisting}

\textbf{બિટ રિપ્રેઝન્ટેશન (5 \& 3):}
\begin{lstlisting}
5 = 101
3 = 011
& = 001 (1 in decimal)
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BOXNRL for Boolean, AON for Logical}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Entry controlled અને exit controlled લૂપની ઉદાહરણ સાથે સરખામણી કરો.}

\begin{solutionbox}
\begin{answertable}{Entry vs Exit Controlled Loop}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{Entry Controlled} & \textbf{Exit Controlled} \\ \hline
\textbf{શરત ચકાસણી} & અમલ પહેલા & અમલ પછી \\ \hline
\textbf{ન્યૂનતમ પુનરાવર્તન} & શૂન્ય & એક \\ \hline
\textbf{ઉદાહરણ} & \code{while}, \code{for} & \code{do-while} \\ \hline
\textbf{ઉપયોગ} & પ્રી-ચેક જરૂરી હોય & ઓછામાં ઓછું એક વાર અમલ જરૂરી હોય \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BCME: Before-Check-Multiple-Examples}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{સ્વીચ કેસનો ઉપયોગ કરીને બે નંબરોના સરવાળા અને બાદબાકી દર્શાવવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Switch Case Calculator}]
#include <stdio.h>

int main() {
    int a, b, choice, result;
    
    printf("Enter two numbers: ");
    scanf("%d %d", &a, &b);
    
    printf("1. Addition\n2. Subtraction\n");
    printf("Enter choice (1/2): ");
    scanf("%d", &choice);
    
    switch(choice) {
        case 1:
            result = a + b;
            printf("Addition: %d\n", result);
            break;
        case 2:
            result = a - b;
            printf("Subtraction: %d\n", result);
            break;
        default:
            printf("Invalid choice\n");
    }
    
    return 0;
}
\end{lstlisting}

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu input, below=of start] (input) {ઇનપુટ a, b};
    \node [gtu input, below=of input] (choice) {ઇનપુટ choice};
    \node [gtu decision, below=of choice] (sw) {switch(choice)};
    
    \node [gtu process, below left=of sw] (case1) {result = a + b};
    \node [gtu process, below right=of sw] (case2) {result = a - b};
    \node [gtu process, right=2cm of sw] (def) {Display Invalid};
    
    \node [gtu output, below=of case1] (out1) {Display Addition};
    \node [gtu output, below=of case2] (out2) {Display Subtraction};
    \node [gtu state, below=3cm of sw] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (choice);
    \path [gtu arrow] (choice) -- (sw);
    \path [gtu arrow] (sw) -| node [left] {case 1} (case1);
    \path [gtu arrow] (sw) -| node [right] {case 2} (case2);
    \path [gtu arrow] (sw) -- node [above] {default} (def);
    
    \path [gtu arrow] (case1) -- (out1);
    \path [gtu arrow] (case2) -- (out2);
    
    \path [gtu arrow] (out1) -- (end);
    \path [gtu arrow] (out2) -- (end);
    \path [gtu arrow] (def) |- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Switch Case Operation}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CIRCA: Choice-Input-Result-Calculate-Action}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{સિન્ટેક્સ, ફ્લોચાર્ટ અને ઉદાહરણ સાથે multiple if-else સ્ટેટમેન્ટ સમજાવો.}

\begin{solutionbox}
\textbf{multiple if-else સિન્ટેક્સ:}

\begin{lstlisting}[language=C]
if (condition1) {
    // code block 1
} 
else if (condition2) {
    // code block 2
} 
else if (condition3) {
    // code block 3
} 
else {
    // default code block
}
\end{lstlisting}

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu decision, below=of start] (c1) {condition1?};
    \node [gtu process, right=of c1] (b1) {Execute block 1};
    
    \node [gtu decision, below=of c1] (c2) {condition2?};
    \node [gtu process, right=of c2] (b2) {Execute block 2};
    
    \node [gtu decision, below=of c2] (c3) {condition3?};
    \node [gtu process, right=of c3] (b3) {Execute block 3};
    \node [gtu process, below=of c3] (def) {Execute default block};
    
    \node [gtu state, right=of b2, xshift=1cm] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (c1);
    \path [gtu arrow] (c1) -- node [above] {સાચું (True)} (b1);
    \path [gtu arrow] (c1) -- node [right] {ખોટું (False)} (c2);
    
    \path [gtu arrow] (c2) -- node [above] {સાચું (True)} (b2);
    \path [gtu arrow] (c2) -- node [right] {ખોટું (False)} (c3);
    
    \path [gtu arrow] (c3) -- node [above] {સાચું (True)} (b3);
    \path [gtu arrow] (c3) -- node [right] {ખોટું (False)} (def);
    
    \path [gtu arrow] (b1) -| (end);
    \path [gtu arrow] (b2) -- (end);
    \path [gtu arrow] (b3) -| (end);
    \path [gtu arrow] (def) -| (end);
\end{tikzpicture}
\captionof{figure}{Multiple If-Else Flowchart}
\end{center}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int marks;
    
    printf("Enter marks: ");
    scanf("%d", &marks);
    
    if (marks >= 80) {
        printf("Grade: A\n");
    } 
    else if (marks >= 70) {
        printf("Grade: B\n");
    } 
    else if (marks >= 60) {
        printf("Grade: C\n");
    } 
    else {
        printf("Grade: F\n");
    }
    
    return 0;
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TEST: Try Each Statement Then default}
\end{mnemonicbox}

\orquestionmarks{3(a)}{3}{break અને continue કીવર્ડનો ઉપયોગ જણાવો.}

\begin{solutionbox}
\begin{answertable}{Break vs Continue}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{કીવર્ડ} & \textbf{હેતુ} & \textbf{અસર} & \textbf{સામાન્ય ઉપયોગ} \\ \hline
\textbf{break} & લૂપ/સ્વિચ ટર્મિનેટ કરે & વર્તમાન લૂપ/સ્વિચ છોડી દે & શરત પૂરી થાય ત્યારે બહાર નીકળવા \\ \hline
\textbf{continue} & ઇટરેશન છોડે & આગામી ઇટરેશન પર જાય & ચોક્કસ મૂલ્યો છોડવા \\ \hline
\end{tabulary}
\end{answertable}

\textbf{ઉદાહરણ કોડ:}
\begin{lstlisting}[language=C]
// break ઉદાહરણ
for(i=1; i<=10; i++) {
    if(i == 5) break; // i=5 પર લૂપ છોડે
    printf("%d ", i);  // 1 2 3 4 પ્રિન્ટ કરે
}

// continue ઉદાહરણ
for(i=1; i<=5; i++) {
    if(i == 3) continue; // i=3 છોડે
    printf("%d ", i);  // 1 2 4 5 પ્રિન્ટ કરે
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EXIT-SKIP: EXit IT or SKIP iteration}
\end{mnemonicbox}

\orquestionmarks{3(b)}{4}{આપેલ સંખ્યા એકી છે કે બેકી તે ચકાસવા માટે C પ્રોગ્રામનો લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Even Odd Check}]
#include <stdio.h>

int main() {
    int num;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    if (num % 2 == 0) {
        printf("%d is even.\n", num);
    } 
    else {
        printf("%d is odd.\n", num);
    }
    
    return 0;
}
\end{lstlisting}

\textbf{ડાયાગ્રામ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu input, below=of start] (input) {ઇનપુટ num};
    \node [gtu decision, below=of input] (cond) {num \% 2 == 0?};
    \node [gtu output, below left=of cond] (even) {Display "Even"};
    \node [gtu output, below right=of cond] (odd) {Display "Odd"};
    \node [gtu state, below=3cm of cond] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (cond);
    \path [gtu arrow] (cond) -| node [left] {હા (Yes)} (even);
    \path [gtu arrow] (cond) -| node [right] {ના (No)} (odd);
    \path [gtu arrow] (even) |- (end);
    \path [gtu arrow] (odd) |- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Even/Odd Check}
\end{center}

\textbf{મુખ્ય બિંદુઓ:}
\begin{itemize}
    \item \textbf{ચકાસણી}: મોડ્યુલો (\%) ઓપરેટરનો ઉપયોગ
    \item \textbf{નિર્ણય}: 2 સાથેના શેષ પર આધારિત
    \item \textbf{આઉટપુટ}: શેષ 0 હોય તો બેકી, અન્યથા એકી
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MODE: MODulo Equals zero for even}
\end{mnemonicbox}

\orquestionmarks{3(c)}{7}{સિન્ટેક્સ, ફ્લોચાર્ટ અને ઉદાહરણ સાથે switch-case statement સ્ટેટમેન્ટ સમજાવો.}

\begin{solutionbox}
\textbf{switch-case સિન્ટેક્સ:}

\begin{lstlisting}[language=C]
switch (expression) {
    case constant1:
        // code block 1
        break;
    case constant2:
        // code block 2
        break;
    ...
    default:
        // default code block
}
\end{lstlisting}

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu process, below=of start] (eval) {Evaluate expression};
    
    \node [gtu decision, below=of eval] (c1) {matches case 1?};
    \node [gtu process, right=of c1] (b1) {Execute block 1};
    
    \node [gtu decision, below=of c1] (c2) {matches case 2?};
    \node [gtu process, right=of c2] (b2) {Execute block 2};
    
    \node [gtu decision, below=of c2] (cn) {matches case n?};
    \node [gtu process, right=of cn] (bn) {Execute block n};
    \node [gtu process, below=of cn] (def) {Execute default block};
    
    \node [gtu state, right=of b2, xshift=2cm] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (eval);
    \path [gtu arrow] (eval) -- (c1);
    
    \path [gtu arrow] (c1) -- node [above] {હા (Yes)} (b1);
    \path [gtu arrow] (c1) -- node [right] {ના (No)} (c2);
    
    \path [gtu arrow] (c2) -- node [above] {હા (Yes)} (b2);
    \path [gtu arrow] (c2) -- node [right] {ના (No)} (cn);
    
    \path [gtu arrow] (cn) -- node [above] {હા (Yes)} (bn);
    \path [gtu arrow] (cn) -- node [right] {ના (No)} (def);
    
    \path [gtu arrow] (b1) -| (end);
    \path [gtu arrow] (b2) -- (end);
    \path [gtu arrow] (bn) -| (end);
    \path [gtu arrow] (def) -| (end);
\end{tikzpicture}
\captionof{figure}{Switch Case Flowchart}
\end{center}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    char grade;
    
    printf("Enter grade (A-D): ");
    scanf(" %c", &grade);
    
    switch (grade) {
        case 'A':
            printf("Excellent!\n");
            break;
        case 'B':
            printf("Good job!\n");
            break;
        case 'C':
            printf("Satisfactory\n");
            break;
        case 'D':
            printf("Needs improvement\n");
            break;
        default:
            printf("Invalid grade\n");
    }
    
    return 0;
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEBID: Compare-Execute-Break-If-Done}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{સ્ટ્રિંગ વ્યાખ્યાયિત કરો. સ્ટ્રિંગ પર કરી શકાય તેવા વિવિધ ઓપરેશન્સની યાદી આપો.}

\begin{solutionbox}
\textbf{સ્ટ્રિંગ}: કેરેક્ટર્સનો એરે જે NULL કેરેક્ટર '\textbackslash0' થી સમાપ્ત થાય છે.

\begin{answertable}{String Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{વિગત} & \textbf{ફંક્શન} \\ \hline
\textbf{ઇનપુટ/આઉટપુટ} & સ્ટ્રિંગ વાંચવી/લખવી & \code{gets()}, \code{puts()} \\ \hline
\textbf{કોપી} & એક સ્ટ્રિંગને બીજી સ્ટ્રિંગમાં કોપી કરવી & \code{strcpy()} \\ \hline
\textbf{જોડાણ} & બે સ્ટ્રિંગ જોડવી & \code{strcat()} \\ \hline
\textbf{સરખામણી} & બે સ્ટ્રિંગની સરખામણી & \code{strcmp()} \\ \hline
\textbf{લંબાઈ} & સ્ટ્રિંગની લંબાઈ શોધવી & \code{strlen()} \\ \hline
\textbf{શોધ} & સબસ્ટ્રિંગ શોધવી & \code{strstr()} \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ICCLS: Input-Copy-Concatenate-Length-Search}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{અપરકેસ આલ્ફાબેટને લોઅરકેસ આલ્ફાબેટમાં કન્વર્ટ કરવા માટે C પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Uppercase to Lowercase}]
#include <stdio.h>

int main() {
    char ch;
    
    printf("Enter an uppercase letter: ");
    scanf(" %c", &ch);
    
    if (ch >= 'A' && ch <= 'Z') {
        char lowercase = ch + 32;  // ASCII difference is 32
        printf("Lowercase: %c\n", lowercase);
    } 
    else {
        printf("Not an uppercase letter\n");
    }
    
    return 0;
}
\end{lstlisting}

\textbf{ASCII ટેબલનો અંશ:}

\begin{answertable}{ASCII Values}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{કેરેક્ટર} & \textbf{ASCII મૂલ્ય} \\ \hline
\textbf{A} & 65 \\ \hline
\textbf{a} & 97 \\ \hline
\textbf{Z} & 90 \\ \hline
\textbf{z} & 122 \\ \hline
\textbf{તફાવત} & 32 \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{COOL: Character Offset Of Lowercase}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{for લૂપ માટેનો ફ્લોચાર્ટ દોરો અને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{For Loop સિન્ટેક્સ:}

\begin{lstlisting}[language=C]
for (initialization; condition; increment/decrement) {
    // code block
}
\end{lstlisting}

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu process, below=of start] (init) {Initialization};
    \node [gtu decision, below=of init] (cond) {Condition?};
    \node [gtu process, below=of cond] (body) {Execute code block};
    \node [gtu process, right=of cond, xshift=1cm] (inc) {Increment/Decrement};
    \node [gtu state, left=of cond, xshift=-1cm] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (init);
    \path [gtu arrow] (init) -- (cond);
    \path [gtu arrow] (cond) -- node [right] {સાચું (True)} (body);
    \path [gtu arrow] (body) -| (inc);
    \path [gtu arrow] (inc) -- (cond);
    \path [gtu arrow] (cond) -- node [above] {ખોટું (False)} (end);
\end{tikzpicture}
\captionof{figure}{For Loop Flowchart}
\end{center}

\textbf{For Loop ઘટકો:}
\begin{enumerate}
    \item \textbf{ઇનિશિયલાઇઝેશન}: શરૂઆતમાં એક વખત અમલ
    \item \textbf{શરત}: દરેક પુનરાવર્તન પહેલાં ચકાસાય
    \item \textbf{વૃદ્ધિ/ઘટાડો}: દરેક પુનરાવર્તન પછી અમલ
    \item \textbf{બોડી}: શરત સાચી હોય તો અમલ
\end{enumerate}

\textbf{ઉદાહરણ:}
\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i;
    
    for (i = 1; i <= 5; i++) {
        printf("%d ", i);
    }
    // Output: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

\textbf{અમલીકરણનો પ્રવાહ:}
\begin{enumerate}
    \item i = 1 પ્રારંભિક
    \item શરત ચકાસો (1 <= 5) - સાચું
    \item બોડી અમલ - 1 પ્રિન્ટ
    \item i ને 2 માં વૃદ્ધિ
    \item શરત ચકાસો (2 <= 5) - સાચું
    \item અને એ રીતે આગળ i = 6 થાય ત્યાં સુધી
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ICE-T: Initialize, Check, Execute, Then increment}
\end{mnemonicbox}

\orquestionmarks{4(a)}{3}{એરે વ્યાખ્યાયિત કરો. એરે પર કરી શકાય તેવા વિવિધ ઓપરેશન્સની યાદી આપો.}

\begin{solutionbox}
\textbf{એરે}: સમાન ડેટા પ્રકારના તત્વો જે ક્રમિક મેમરી સ્થાનોમાં સંગ્રહિત થાય છે.

\begin{answertable}{Array Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઓપરેશન} & \textbf{વિગત} & \textbf{ઉદાહરણ} \\ \hline
\textbf{ઘોષણા} & એરે બનાવો & \code{int arr[5];} \\ \hline
\textbf{ઇનિશિયલાઇઝેશન} & મૂલ્ય આપો & \code{arr[0] = 10;} \\ \hline
\textbf{ટ્રેવર્સલ} & તમામ તત્વો એક્સેસ કરો & \code{for} loop \\ \hline
\textbf{ઇન્સર્શન} & નવું તત્વ ઉમેરો & \code{arr[pos] = value;} \\ \hline
\textbf{ડિલીશન} & તત્વ દૂર કરો & તત્વો શિફ્ટ કરો \\ \hline
\textbf{સર્ચિંગ} & તત્વ શોધો & લિનિયર/બાઇનરી શોધ \\ \hline
\textbf{સોર્ટિંગ} & તત્વો ગોઠવો & બબલ/સિલેક્શન સોર્ટ \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DITIDSS: Declare-Initialize-Traverse-Insert-Delete-Search-Sort}
\end{mnemonicbox}

\orquestionmarks{4(b)}{4}{pointer વ્યાખ્યાયિત કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{પોઇન્ટર}: એવું ચલ જે અન્ય ચલના મેમરી સરનામાને સંગ્રહિત કરે છે.

\begin{answertable}{Pointer Concepts}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{કન્સેપ્ટ} & \textbf{વિગત} & \textbf{સિન્ટેક્સ} \\ \hline
\textbf{ઘોષણા} & પોઇન્ટર બનાવો & \code{int *ptr;} \\ \hline
\textbf{એડ્રેસ ઓપરેટર} & સરનામું મેળવો & \code{\&variable} \\ \hline
\textbf{ડિરેફરન્સિંગ} & સરનામા પર મૂલ્ય એક્સેસ કરો & \code{*ptr} \\ \hline
\textbf{એસાઇનમેન્ટ} & પોઇન્ટરમાં સરનામું સંગ્રહો & \code{ptr = \&variable;} \\ \hline
\end{tabulary}
\end{answertable}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num = 10;
    int *ptr;
    
    ptr = &num;  // num નું સરનામું ptr માં સંગ્રહો
    
    printf("Value of num: %d\n", num);           // 10
    printf("Address of num: %p\n", &num);        // num નું સરનામું
    printf("Value of ptr: %p\n", ptr);           // સમાન સરનામું
    printf("Value pointed by ptr: %d\n", *ptr);  // 10
    
    *ptr = 20;   // પોઇન્ટર દ્વારા મૂલ્ય બદલો
    printf("New value of num: %d\n", num);       // 20
    
    return 0;
}
\end{lstlisting}

\textbf{ડાયાગ્રામ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [draw, rectangle split, rectangle split parts=2] (mem1) {
        Address: 1000 \nodepart{second} num: 10
    };
    \node [draw, rectangle split, rectangle split parts=2, right=3cm of mem1] (mem2) {
        Address: 2000 \nodepart{second} ptr: 1000
    };
    
    \draw [gtu arrow, dashed, bend right] (mem2.south) to node [below] {points to} (mem1.south);
\end{tikzpicture}
\captionof{figure}{Pointer Memory Layout}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SAVD: Store Address, Value through Dereferencing}
\end{mnemonicbox}

\orquestionmarks{4(c)}{7}{while લૂપ માટેનો ફ્લોચાર્ટ દોરો અને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{While Loop સિન્ટેક્સ:}

\begin{lstlisting}[language=C]
while (condition) {
    // code block
}
\end{lstlisting}

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu decision, below=of start] (cond) {Condition?};
    \node [gtu process, below=of cond] (body) {Execute code block};
    \node [gtu process,  below=of body] (update) {Update control variable};
    \node [gtu state, right=of cond, xshift=1cm] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (cond);
    \path [gtu arrow] (cond) -- node [right] {સાચું (True)} (body);
    \path [gtu arrow] (body) -- (update);
    \path [gtu arrow] (update.west) -- ++(-1,0) |- (cond.west);
    \path [gtu arrow] (cond) -- node [above] {ખોટું (False)} (end);
\end{tikzpicture}
\captionof{figure}{While Loop Flowchart}
\end{center}

\textbf{While Loop ઘટકો:}
\begin{enumerate}
    \item \textbf{ઇનિશિયલાઇઝેશન}: લૂપની પહેલાં
    \item \textbf{શરત}: દરેક પુનરાવર્તન પહેલાં ચકાસાય
    \item \textbf{બોડી}: શરત સાચી હોય તો અમલ
    \item \textbf{અપડેટ}: બોડીની અંદર કરવું જરૂરી
\end{enumerate}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i = 1;
    
    while (i <= 5) {
        printf("%d ", i);
        i++;
    }
    // Output: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

\textbf{અમલીકરણનો પ્રવાહ:}
\begin{enumerate}
    \item i = 1 પ્રારંભિક (લૂપ પહેલાં)
    \item શરત ચકાસો (1 <= 5) - સાચું
    \item બોડી અમલ - 1 પ્રિન્ટ
    \item i ને 2 માં અપડેટ
    \item શરત ચકાસો (2 <= 5) - સાચું
    \item અને એ રીતે આગળ i = 6 થાય ત્યાં સુધી
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CHECK-UPDATE: CHECK before entering, UPDATE before repeating}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{નીચેના functions નો ઉપયોગ જણાવો. (1) strcat() (2) strlen() (3) strcpy()}

\begin{solutionbox}
\begin{answertable}{String Functions}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ફંક્શન} & \textbf{હેતુ} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} \\ \hline
\code{strcat()} & સ્ટ્રિંગ્સ જોડે છે & \code{strcat(dest, src)} & "Hello" + "World" $\rightarrow$ "HelloWorld" \\ \hline
\code{strlen()} & સ્ટ્રિંગની લંબાઈ આપે છે & \code{strlen(str)} & "Hello" $\rightarrow$ 5 \\ \hline
\code{strcpy()} & સ્ટ્રિંગ કોપી કરે છે & \code{strcpy(dest, src)} & src $\rightarrow$ dest \\ \hline
\end{tabulary}
\end{answertable}

\textbf{કોડ ઉદાહરણ:}
\begin{lstlisting}[language=C]
#include <string.h>

char str1[20] = "Hello";
char str2[20] = "World";
char str3[20];

strcat(str1, str2);    // str1 "HelloWorld" બને છે
int len = strlen(str1); // len 10 બને છે
strcpy(str3, str1);    // str3 "HelloWorld" બને છે
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CLS: Concatenate-Length-Source copy}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{પુસ્તકની માહિતી સંગ્રહિત કરવા માટે એક સ્ટ્રક્ચર બનાવો: book\_no, book\_title, book\_author, book\_price.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Book Structure}]
#include <stdio.h>
#include <string.h>

struct Book {
    int book_no;
    char book_title[50];
    char book_author[30];
    float book_price;
};

int main() {
    struct Book book1;
    
    // Assign values
    book1.book_no = 101;
    strcpy(book1.book_title, "Programming in C");
    strcpy(book1.book_author, "Dennis Ritchie");
    book1.book_price = 450.75;
    
    // Display book information
    printf("Book No: %d\n", book1.book_no);
    printf("Title: %s\n", book1.book_title);
    printf("Author: %s\n", book1.book_author);
    printf("Price: %.2f\n", book1.book_price);
    
    return 0;
}
\end{lstlisting}

\textbf{સ્ટ્રક્ચર મેમરી લેઆઉટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [draw, rectangle split, rectangle split parts=4, rectangle split horizontal] (struct) {
        \textbf{book\_no} \nodepart{second} \textbf{book\_title} \nodepart{third} \textbf{book\_author} \nodepart{fourth} \textbf{book\_price}
    };
    \node [below=0.2cm of struct.one] {4 bytes};
    \node [below=0.2cm of struct.two] {50 bytes};
    \node [below=0.2cm of struct.three] {30 bytes};
    \node [below=0.2cm of struct.four] {4 bytes};
\end{tikzpicture}
\captionof{figure}{Structure Memory Representation}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NTAP: Number-Title-Author-Price}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{એરે અને એરે initialization સમજાવો. ઉદાહરણ આપો.}

\begin{solutionbox}
\textbf{એરે}: સમાન ડેટા પ્રકારના તત્વોનો સમૂહ જે ક્રમિક મેમરી સ્થાનોમાં સંગ્રહિત થાય છે.

\textbf{એરે ઇનિશિયલાઇઝેશન પદ્ધતિઓ:}

\begin{answertable}{Initialization Methods}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પદ્ધતિ} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} \\ \hline
\textbf{ઘોષણા સમયે} & \code{type name[size] = \{vals\};} & \code{int arr[5] = \{10, 20, 30, 40, 50\};} \\ \hline
\textbf{આંશિક} & \code{type name[size] = \{vals\};} & \code{int arr[5] = \{10, 20\}; // બાકીના 0} \\ \hline
\textbf{બધા શૂન્ય} & \code{type name[size] = \{0\};} & \code{int arr[5] = \{0\};} \\ \hline
\textbf{તત્વ દર તત્વ} & \code{name[idx] = val;} & \code{arr[0] = 10; arr[1] = 20;} \\ \hline
\textbf{સાઇઝ અનુમાન} & \code{type name[] = \{vals\};} & \code{int arr[] = \{10, 20\}; // સાઇઝ 2} \\ \hline
\end{tabulary}
\end{answertable}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    // Method 1: Complete initialization
    int arr1[5] = {10, 20, 30, 40, 50};
    
    // Method 2: Partial initialization
    int arr2[5] = {10, 20};  // Remaining are 0
    
    // Method 4: Size inference
    int arr4[] = {1, 2, 3, 4, 5};
    
    // Accessing elements
    printf("arr1[2] = %d\n", arr1[2]);  // Output: 30
    
    return 0;
}
\end{lstlisting}

\textbf{મેમરી રિપ્રેઝન્ટેશન:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [draw, rectangle split, rectangle split parts=5, rectangle split horizontal] (arr) {
        10 \nodepart{second} 20 \nodepart{third} 30 \nodepart{fourth} 40 \nodepart{five} 50
    };
    \node [above=0.2cm of arr.one] {arr[0]};
    \node [above=0.2cm of arr.two] {arr[1]};
    \node [above=0.2cm of arr.three] {arr[2]};
    \node [above=0.2cm of arr.four] {arr[3]};
    \node [above=0.2cm of arr.five] {arr[4]};
\end{tikzpicture}
\captionof{figure}{Array Memory Layout}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CAPES: Complete, Automatic, Partial, Element, Size-inferred}
\end{mnemonicbox}

\orquestionmarks{5(a)}{3}{array અને structure ઉદાહરણ સાથે સરખામણી કરો.}

\begin{solutionbox}
\begin{answertable}{Array vs Structure}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{લક્ષણ} & \textbf{Array} & \textbf{Structure} \\ \hline
\textbf{ડેટા ટાઇપ} & સમાન પ્રકારના તત્વો & અલગ પ્રકારના તત્વો \\ \hline
\textbf{એક્સેસ} & ઇન્ડેક્સનો ઉપયોગ (\code{arr[i]}) & ડોટ ઓપરેટરનો ઉપયોગ (\code{s.member}) \\ \hline
\textbf{મેમરી} & ક્રમિક, ફિક્સ સાઇઝ & ક્રમિક, પેડિંગ હોઈ શકે \\ \hline
\textbf{એસાઇનમેન્ટ} & તત્વ દર તત્વ & સીધું જ સુસંગત સ્ટ્રક્ચર સાથે \\ \hline
\textbf{હેતુ} & સમાન આઇટમોનો સંગ્રહ & સંબંધિત ડેટાનો સમૂહ \\ \hline
\end{tabulary}
\end{answertable}

\textbf{ઉદાહરણ:}
\begin{lstlisting}[language=C]
// Array
int marks[5] = {85, 90, 78, 92, 88};
printf("%d", marks[2]);

// Structure
struct Student { int roll; char name[20]; };
struct Student s1 = {101, "Raj"};
printf("%s", s1.name);
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DAMPA: Datatype-Access-Memory-Purpose-Assignment}
\end{mnemonicbox}

\orquestionmarks{5(b)}{4}{User Defined Function વ્યાખ્યાયિત કરો. ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{User Defined Function}: પ્રોગ્રામર દ્વારા લખાયેલ કોડનો બ્લોક જે ચોક્કસ કાર્ય કરે છે અને તેને વારંવાર કોલ કરી શકાય છે.

\begin{answertable}{Function Components}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{ઘટક} & \textbf{વિગત} & \textbf{ઉદાહરણ} \\ \hline
\textbf{રિટર્ન ટાઇપ} & પરત થતા ડેટાનો પ્રકાર & \code{int, float, void} \\ \hline
\textbf{ફંક્શન નેમ} & અનન્ય ઓળખકર્તા & \code{sum, findMax} \\ \hline
\textbf{પેરામીટર્સ} & ઇનપુટ ડેટા & \code{(int a, int b)} \\ \hline
\textbf{બોડી} & સ્ટેટમેન્ટ સમૂહ & \code{\{ return a+b; \}} \\ \hline
\end{tabulary}
\end{answertable}

\textbf{ઉદાહરણ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

// Function declaration
int sum(int a, int b);

int main() {
    int num1 = 10, num2 = 20, result;
    
    // Function call
    result = sum(num1, num2);
    
    printf("Sum = %d\n", result);
    
    return 0;
}

// Function definition
int sum(int a, int b) {
    return a + b;
}
\end{lstlisting}

\textbf{ફંક્શન ફ્લો:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (main) {main function};
    \node [gtu process, right=3cm of main] (func) {sum function};
    
    \draw [gtu arrow, bend left] (main) to node [above] {Call sum(10, 20)} (func);
    \draw [gtu arrow, bend left] (func) to node [below] {Return 30} (main);
\end{tikzpicture}
\captionof{figure}{Function Call Flow}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DPCR: Declaration-Parameters-Call-Return}
\end{mnemonicbox}

\orquestionmarks{5(c)}{7}{એરેમાંથી મહત્તમ અને લઘુત્તમ element શોધવા માટે C પ્રોગ્રામનો લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Min Max Array}]
#include <stdio.h>

int main() {
    int arr[100], n, i;
    int max, min;
    
    printf("Enter number of elements: ");
    scanf("%d", &n);
    
    printf("Enter %d integers: ", n);
    for(i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // Initialize max and min
    max = min = arr[0];
    
    // Find max and min
    for(i = 1; i < n; i++) {
        if(arr[i] > max)
            max = arr[i];
        if(arr[i] < min)
            min = arr[i];
    }
    
    printf("Maximum: %d\n", max);
    printf("Minimum: %d\n", min);
    
    return 0;
}
\end{lstlisting}

\textbf{ફ્લોચાર્ટ:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {શરૂઆત (Start)};
    \node [gtu input, below=of start] (input) {ઇનપુટ n, array};
    \node [gtu process, below=of input] (init) {max = min = arr[0]\\ i = 1};
    \node [gtu decision, below=of init] (cond) {i < n?};
    
    \node [gtu decision, right=of cond, xshift=1cm] (cmax) {arr[i] > max?};
    \node [gtu process, right=of cmax] (umax) {max = arr[i]};
    
    \node [gtu decision, below=of cmax] (cmin) {arr[i] < min?};
    \node [gtu process, right=of cmin] (umin) {min = arr[i]};
    
    \node [gtu process, left=of cmin] (inc) {i++};
    
    \node [gtu output, below left=of cond, yshift=-3cm] (out) {Display max, min};
    \node [gtu state, below=of out] (end) {અંત (End)};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (init);
    \path [gtu arrow] (init) -- (cond);
    
    \path [gtu arrow] (cond) -- node [above] {હા (Yes)} (cmax);
    \path [gtu arrow] (cmax) -- node [above] {હા (Yes)} (umax);
    \path [gtu arrow] (cmax) -- node [right] {ના (No)} (cmin);
    \path [gtu arrow] (umax) -- (cmin);
    
    \path [gtu arrow] (cmin) -- node [above] {હા (Yes)} (umin);
    \path [gtu arrow] (cmin) -| node [below] {ના (No)} (inc);
    \path [gtu arrow] (umin) |- (inc);
    
    \path [gtu arrow] (inc) -| (cond);
    
    \path [gtu arrow] (cond) -- node [left] {ના (No)} (out);
    \path [gtu arrow] (out) -- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Min Max}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FILLS: First Initialize, Loop through, Look for Small/large}
\end{mnemonicbox}

\end{document}
