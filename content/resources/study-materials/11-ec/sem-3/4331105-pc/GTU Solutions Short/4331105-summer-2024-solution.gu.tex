\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{Programming In C (4331105) - Summer 2024 Solution}
\date{June 18, 2024}

\begin{document}
\maketitle

\questionmarks{1}{a}{3}
\textbf{કીવર્ડ વ્યાખ્યાયિત કરો. C ભાષા માટે કોઈપણ ચાર કીવર્ડ્સની યાદી આપો.}

\begin{solutionbox}
    કીવર્ડ એ C માં પૂર્વવ્યાખ્યાયિત, આરક્ષિત શબ્ધ છે જેનો કમ્પાઈલર માટે વિશેષ અર્થ છે અને તેનો ઉપયોગ આઇડેન્ટિફાયર તરીકે કરી શકાતો નથી.

    \textbf{કોષ્ટક: સામાન્ય C કીવર્ડ્સ}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{કીવર્ડ} & \textbf{હેતુ} \\
        \hline
        \code{int} & ઇન્ટીજર ડેટા ટાઈપ \\
        \hline
        \code{float} & ફ્લોટિંગ-પોઈન્ટ ડેટા ટાઈપ \\
        \hline
        \code{char} & કેરેક્ટર ડેટા ટાઈપ \\
        \hline
        \code{if} & શરતી સ્ટેટમેન્ટ \\
        \hline
        \code{for} & લૂપ સ્ટેટમેન્ટ \\
        \hline
        \code{while} & લૂપ સ્ટેટમેન્ટ \\
        \hline
        \code{void} & રિટર્ન ટાઈપ/પેરામીટર \\
        \hline
        \code{return} & ફંક્શનમાંથી કિંમત પરત કરવી \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{આરક્ષિત શબ્દો}: કીવર્ડ્સનો ઉપયોગ વેરિએબલ નામો તરીકે કરી શકાતો નથી
        \item \textbf{પૂર્વ-વ્યાખ્યાયિત}: ભાષામાં તેમનો નિશ્ચિત અર્થ છે
        \item \textbf{કેસ-સેન્સિટિવ}: બધા કીવર્ડ્સ લોઅરકેસમાં હોવા જોઈએ
    \end{itemize}

    \begin{mnemonicbox}"If VoId FoR WhIle" (મહત્વપૂર્ણ કીવર્ડ્સના પ્રથમ અક્ષરો)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{b}{4}
\textbf{વેરિએબલનું નામકરણ કરવા માટેના નિયમો સમજાવો.}

\begin{solutionbox}
    C માં વેરિએબલ્સ માન્ય આઇડેન્ટિફાયર હોવા માટે ચોક્કસ નામકરણ નિયમોનું પાલન કરવું આવશ્યક છે.

    \textbf{કોષ્ટક: C માં વેરિએબલ નામકરણ નિયમો}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{નિયમ} & \textbf{વિવરણ} & \textbf{માન્ય ઉદાહરણ} & \textbf{અમાન્ય ઉદાહરણ} \\
        \hline
        પ્રથમ અક્ષર & અક્ષર અથવા અંડરસ્કોર હોવો જોઈએ & \code{age}, \code{\_count} & \code{1value} \\
        \hline
        પછીના અક્ષરો & અક્ષરો, નંબરો અથવા અંડરસ્કોર & \code{user\_1}, \code{total99} & \code{user@1} \\
        \hline
        કેસ સેન્સિટિવિટી & અપરકેસ અને લોઅરકેસ અલગ છે & \code{Value} $\neq$ \code{value} & - \\
        \hline
        કીવર્ડ્સ & આરક્ષિત કીવર્ડ્સનો ઉપયોગ કરી શકાતો નથી & \code{counter} & \code{int} \\
        \hline
        લંબાઈ & અર્થપૂર્ણ હોવું જોઈએ પણ વધુ લાંબુ નહીં & \code{studentMarks} & \code{sm} \\
        \hline
        વિશેષ અક્ષરો & માન્ય નથી & \code{firstName} & \code{first-name} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{વર્ણનાત્મક નામો}: અર્થપૂર્ણ નામોનો ઉપયોગ કરો જે હેતુ સૂચવે છે
        \item \textbf{સુસંગત શૈલી}: સુસંગત નામકરણ સંમેલનનું પાલન કરો
        \item \textbf{જગ્યા નહીં}: અંડરસ્કોર અથવા camelCase નો ઉપયોગ કરો
    \end{itemize}

    \begin{mnemonicbox}"FLASKS" (First Letter, Letters/digits, Avoid keywords, Sensitive case, Keep meaningful, Skip special chars)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{c}{7}
\textbf{ફ્લોચાર્ટ વ્યાખ્યાયિત કરો. ત્રણ પૂર્ણાંક નંબરો N1, N2 અને N3 માંથી લઘુત્તમ શોધવા માટે ફ્લોચાર્ટ દોરો.}

\begin{solutionbox}
    ફ્લોચાર્ટ એ અલ્ગોરિધમનું એક ગ્રાફિકલ નિરૂપણ છે જે બોક્સ તરીકે પગલાંઓ અને તીર દ્વારા તેમના ક્રમને જોડે છે.

    \textbf{ફ્લોચાર્ટ: ત્રણ નંબરોમાંથી લઘુત્તમ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ N1, N2, N3};
        \node[gtu decision, alias=d1, below=of input] {N1 < N2?};
        
        \node[gtu block, left=of d1, xshift=-1cm, yshift=-1.5cm] (minN1) {min = N1};
        \node[gtu block, right=of d1, xshift=1cm, yshift=-1.5cm] (minN2) {min = N2};
        
        \node[gtu decision, alias=d2, below=of d1, yshift=-3cm] {min < N3?};
        
        \node[gtu block, right=of d2, xshift=2cm] (minN3) {min = N3};
        \node[gtu output, below=of d2, yshift=-1.5cm] (output) {આઉટપુટ min};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (d1);
        \draw[gtu arrow] (d1) -| node[above] {હા} (minN1);
        \draw[gtu arrow] (d1) -| node[above] {ના} (minN2);
        
        \draw[gtu arrow] (minN1) |- (d2);
        \draw[gtu arrow] (minN2) |- (d2);
        
        \draw[gtu arrow] (d2) -- node[left] {હા} (output);
        \draw[gtu arrow] (d2) -- node[above] {ના} (minN3);
        
        \draw[gtu arrow] (minN3) |- (output);
        \draw[gtu arrow] (output) -- (stop);

    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{પ્રતીકો}: અંડાકાર (શરૂઆત/અંત), સમાંતરભુજ (ઇનપુટ/આઉટપુટ), ડાયમંડ (નિર્ણય), લંબચોરસ (પ્રક્રિયા)
        \item \textbf{નિર્ણય બિંદુઓ}: મૂલ્યોની વ્યવસ્થિત સરખામણી
        \item \textbf{તાર્કિક પ્રવાહ}: તીર પ્રક્રિયાઓનો ક્રમ બતાવે છે
    \end{itemize}

    \begin{mnemonicbox}"Start-Input-Compare-Output-End" (SICOE)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{1}{c}{7}
\textbf{અલ્ગોરિધમ વ્યાખ્યાયિત કરો. ત્રણ પૂર્ણાંક નંબરો N1, N2 અને N3 માંથી લઘુત્તમ શોધવા માટે અલ્ગોરિધમ લખો.}

\begin{solutionbox}
    અલ્ગોરિધમ એ કોઈ ચોક્કસ સમસ્યા ઉકેલવા માટેના પગલા-દર-પગલાની પ્રક્રિયા અથવા સારી રીતે વ્યાખ્યાયિત સૂચનાઓનો સમૂહ છે.

    \textbf{અલ્ગોરિધમ: ત્રણ નંબરોમાંથી લઘુત્તમ શોધવું}

    \begin{itemize}
        \item \textbf{પગલું 1}: શરૂઆત
        \item \textbf{પગલું 2}: ત્રણ નંબરો N1, N2, અને N3 ઇનપુટ કરો
        \item \textbf{પગલું 3}: min = N1 સેટ કરો (ધારો કે પ્રથમ નંબર લઘુત્તમ છે)
        \item \textbf{પગલું 4}: જો N2 < min, તો min = N2 સેટ કરો
        \item \textbf{પગલું 5}: જો N3 < min, તો min = N3 સેટ કરો
        \item \textbf{પગલું 6}: લઘુત્તમ નંબર તરીકે min આઉટપુટ કરો
        \item \textbf{પગલું 7}: અંત
    \end{itemize}

    \textbf{કોષ્ટક: અલ્ગોરિધમ લાક્ષણિકતાઓ}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{લાક્ષણિકતા} & \textbf{વિવરણ} \\
        \hline
        સીમિતતા (Finiteness) & અલ્ગોરિધમ નિશ્ચિત પગલાં પછી સમાપ્ત થવું જોઈએ \\
        \hline
        નિશ્ચિતતા (Definiteness) & દરેક પગલું ચોક્કસ રીતે વ્યાખ્યાયિત હોવું જોઈએ \\
        \hline
        ઇનપુટ (Input) & અલ્ગોરિધમ શૂન્ય અથવા વધુ ઇનપુટ લે છે \\
        \hline
        આઉટપુટ (Output) & અલ્ગોરિધમ એક અથવા વધુ આઉટપુટ આપે છે \\
        \hline
        અસરકારકતા (Effectiveness) & પગલાં સરળ અને અમલ યોગ્ય હોવા જોઈએ \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{ક્રમિક પગલાં}: તાર્કિક ક્રમ અનુસરે છે
        \item \textbf{તુલનાત્મક અભિગમ}: વ્યવસ્થિત રીતે લઘુત્તમ શોધે છે
        \item \textbf{સરળતા}: સમજવા અને અમલ કરવા માટે સરળ
    \end{itemize}

    \begin{mnemonicbox}"FIDEO" (Finiteness, Input, Definiteness, Effectiveness, Output)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{a}{3}
\textbf{gets() અને puts() વચ્ચે તફાવત આપો.}

\begin{solutionbox}
    \code{gets()} અને \code{puts()} એ સ્ટ્રિંગ સાથે ઇનપુટ અને આઉટપુટ ઓપરેશન્સ માટે C માં સ્ટાન્ડર્ડ લાઇબ્રેરી ફંક્શન્સ છે.

    \textbf{કોષ્ટક: gets() અને puts() ની સરખામણી}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લાક્ષણિકતા} & \textbf{gets()} & \textbf{puts()} \\
        \hline
        હેતુ & stdin માંથી સ્ટ્રિંગ વાંચે છે & stdout માં સ્ટ્રિંગ લખે છે \\
        \hline
        પ્રોટોટાઇપ & \code{char *gets(char *str)} & \code{int puts(const char *str)} \\
        \hline
        વર્તણૂક & ન્યૂલાઇન સુધી વાંચે છે & સ્વચાલિત રીતે ન્યૂલાઇન ઉમેરે છે \\
        \hline
        રિટર્ન વેલ્યુ & સફળતા પર str, નિષ્ફળતા પર NULL & સફળતા પર નોન-નેગેટિવ, એરર પર EOF \\
        \hline
        સુરક્ષા & અસુરક્ષિત (બફર ઓવરફ્લો જોખમ) & સુરક્ષિત \\
        \hline
        ભલામણ & ના (ડિપ્રિકેટેડ) & હા \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{ઇનપુટ/આઉટપુટ}: ઇનપુટ માટે \code{gets()}, આઉટપુટ માટે \code{puts()}
        \item \textbf{ટર્મિનેશન}: \code{gets()} ન્યૂલાઇન પર અટકે છે, \code{puts()} ન્યૂલાઇન ઉમેરે છે
        \item \textbf{સુરક્ષા}: \code{gets()} માં કોઈ બફર લિમિટ ચેક નથી
    \end{itemize}

    \begin{mnemonicbox}"Gets In, Puts Out" (gets અંદર વાંચે છે, puts બહાર લખે છે)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{b}{4}
\textbf{દાખલ કરેલ નંબર બેકી છે કે એકી તે શોધવા માટે કંડિશનલ ઓપરેટરનો ઉપયોગ કરીને C પ્રોગ્રામ બનાવો.}

\begin{solutionbox}
    આ પ્રોગ્રામ નંબર બેકી છે કે એકી તે તપાસવા માટે કંડિશનલ ઓપરેટરનો ઉપયોગ કરે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    // બેકી અથવા એકી તપાસવા માટે કંડિશનલ ઓપરેટરનો ઉપયોગ
    (num % 2 == 0) ? printf("%d is even\n", num) : printf("%d is odd\n", num);
    
    return 0;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: બેકી (Even) અથવા એકી (Odd)}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ num};
        \node[gtu decision, alias=dec, below=of input] {num \% 2 == 0?};
        \node[gtu output, below left=of dec, xshift=-1cm] (even) {આઉટપુટ "Is Even"};
        \node[gtu output, below right=of dec, xshift=1cm] (odd) {આઉટપુટ "Is Odd"};
        \node[gtu stop, below=of dec, yshift=-3cm] (end) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (dec);
        \draw[gtu arrow] (dec) -| node[above] {સાચું} (even);
        \draw[gtu arrow] (dec) -| node[above] {ખોટું} (odd);
        \draw[gtu arrow] (even) |- (end);
        \draw[gtu arrow] (odd) |- (end);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{કંડિશનલ ઓપરેટર}: \code{? :} એ ટર્નરી ઓપરેટર છે
        \item \textbf{મોડ્યુલસ ઓપરેશન}: \code{\%} ભાગાકાર પછી શેષ આપે છે
        \item \textbf{ટેસ્ટ કન્ડિશન}: \code{num \% 2 == 0} બેકી નંબર માટે તપાસે છે
    \end{itemize}

    \begin{mnemonicbox}"REMinder 0 = Even" (શેષ 0 એટલે બેકી)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{c}{7}
\textbf{લોજીકલ અને રિલેશનલ ઓપરેટરો ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    લોજીકલ અને રિલેશનલ ઓપરેટરોનો ઉપયોગ C પ્રોગ્રામ્સમાં શરતો બનાવવા અને નિર્ણયો લેવા માટે થાય છે.

    \textbf{કોષ્ટક: રિલેશનલ ઓપરેટરો}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{ઓપરેટર} & \textbf{અર્થ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\
        \hline
        \code{==} & સમાન છે & \code{5 == 5} & સાચું (1) \\
        \hline
        \code{!=} & સમાન નથી & \code{5 != 3} & સાચું (1) \\
        \hline
        \code{>} & કરતા મોટું & \code{7 > 3} & સાચું (1) \\
        \hline
        \code{<} & કરતા નાનું & \code{2 < 8} & સાચું (1) \\
        \hline
        \code{>=} & કરતા મોટું કે સમાન & \code{4 >= 4} & સાચું (1) \\
        \hline
        \code{<=} & કરતા નાનું કે સમાન & \code{6 <= 9} & સાચું (1) \\
        \hline
    \end{tabulary}

    \textbf{કોષ્ટક: લોજીકલ ઓપરેટરો}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{ઓપરેટર} & \textbf{અર્થ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\
        \hline
        \code{\&\&} & લોજીકલ AND & \code{(5>3) \&\& (8>5)} & સાચું (1) \\
        \hline
        \code{||} & લોજીકલ OR & \code{(5>7) || (3<6)} & સાચું (1) \\
        \hline
        \code{!} & લોજીકલ NOT & \code{!(5>7)} & સાચું (1) \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
int age = 20;
int score = 75;

// રિલેશનલ અને લોજીકલ બંને ઓપરેટરોનો ઉપયોગ
if ((age >= 18) && (score > 70)) {
    printf("Eligible");
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{સરખામણી}: રિલેશનલ ઓપરેટરો કિંમતોની સરખામણી કરે છે
        \item \textbf{શરતો સંયોજન}: લોજીકલ ઓપરેટરો બહુવિધ શરતોને જોડે છે
        \item \textbf{સત્ય કિંમત}: બધા ઓપરેટરો 1 (સાચું) અથવા 0 (ખોટું) પરત કરે છે
    \end{itemize}

    \begin{mnemonicbox}"CORNL" (Compare with relational, OR/AND/NOT with logical)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2}{a}{3}
\textbf{ઓપરેટરોના પ્રેસીડન્સને ધ્યાનમાં રાખીને, જો 16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) -10 એક્સપ્રેશનને ઉકેલવામાં આવે તો દરેક સ્ટેપ અને અંતિમ જવાબ લખો.}

\begin{solutionbox}
    ચાલો ઓપરેટર પ્રેસીડન્સને અનુસરીને એક્સપ્રેશન \code{16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) - 10} નું મૂલ્યાંકન કરીએ.

    \textbf{કોષ્ટક: સ્ટેપ-બાય-સ્ટેપ મૂલ્યાંકન}

    \begin{tabulary}{\linewidth}{|C|L|L|}
        \hline
        \textbf{સ્ટેપ} & \textbf{ઓપરેશન} & \textbf{આ સ્ટેપ પછીનું એક્સપ્રેશન} \\
        \hline
        1 & \code{(3 + 6)} ગણતરી & \code{16 + ( 216 / ( 9 * 12 ) ) - 10} \\
        \hline
        2 & \code{(9 * 12)} ગણતરી & \code{16 + ( 216 / 108 ) - 10} \\
        \hline
        3 & \code{(216 / 108)} ગણતરી & \code{16 + 2 - 10} \\
        \hline
        4 & \code{16 + 2} ગણતરી & \code{18 - 10} \\
        \hline
        5 & \code{18 - 10} ગણતરી & \code{8} \\
        \hline
    \end{tabulary}

    \textbf{અંતિમ જવાબ: 8}

    \textbf{મૂલ્યાંકન ટ્રી:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu block] (s1) {16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) - 10};
        \node[gtu block, below=of s1] (s2) {16 + ( 216 / ( 9 * 12 ) ) - 10};
        \node[gtu block, below=of s2] (s3) {16 + ( 216 / 108 ) - 10};
        \node[gtu block, below=of s3] (s4) {16 + 2 - 10};
        \node[gtu block, below=of s4] (s5) {18 - 10};
        \node[gtu block, below=of s5, fill=green!20] (s6) {8};

        \draw[gtu arrow] (s1) -- (s2);
        \draw[gtu arrow] (s2) -- (s3);
        \draw[gtu arrow] (s3) -- (s4);
        \draw[gtu arrow] (s4) -- (s5);
        \draw[gtu arrow] (s5) -- (s6);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{કૌંસ પહેલા}: સૌથી અંદરના કૌંસનું પહેલા મૂલ્યાંકન થાય છે
        \item \textbf{ભાગાકાર પહેલા ગુણાકાર}: ડાબી બાજુથી જમણી બાજુ ગણતરી
        \item \textbf{સરવાળો અને બાદબાકી છેલ્લે}: ડાબી બાજુથી જમણી બાજુ
    \end{itemize}

    \begin{mnemonicbox}"PEMDAS" (Parentheses, Exponents, Multiplication/Division, Addition/Subtraction)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{b}{4}
\textbf{વર્તુળનો પરિઘ અને ક્ષેત્રફળ શોધવા માટે C પ્રોગ્રામ લખો.}

\begin{solutionbox}
    આ પ્રોગ્રામ ત્રિજ્યાના આધારે વર્તુળનું ક્ષેત્રફળ અને પરિઘ ગણે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>
#define PI 3.14159

int main() {
    float radius, area, circumference;
    
    printf("Enter the radius of circle: ");
    scanf("%f", &radius);
    
    // ક્ષેત્રફળ અને પરિઘની ગણતરી
    area = PI * radius * radius;
    circumference = 2 * PI * radius;
    
    printf("Area of circle = %.2f square units\n", area);
    printf("Circumference of circle = %.2f units\n", circumference);
    
    return 0;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: ક્ષેત્રફળ અને પરિઘ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ radius};
        \node[gtu process, below=of input] (calc) {area = PI * r * r\\circumference = 2 * PI * r};
        \node[gtu output, below=of calc] (output) {આઉટપુટ area, circ};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ફોર્મ્યુલા}: ક્ષેત્રફળ = $\pi \times r^2$ અને પરિઘ = $2\pi \times r$
        \item \textbf{કોન્સ્ટન્ટ ડેફિનેશન}: PI માટે \code{\#define} નો ઉપયોગ
        \item \textbf{ફ્લોટ વેરિએબલ્સ}: દશાંશ ચોકસાઈ માટે
    \end{itemize}

    \begin{mnemonicbox}"PIR$^2$" ક્ષેત્રફળ માટે, "2PIR" પરિઘ માટે\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{c}{7}
\textbf{એરીથમેટીક અને બીટ-વાઈઝ ઓપરેટરો ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    એરીથમેટીક ઓપરેટરો ગાણિતિક ક્રિયાઓ કરે છે જ્યારે બીટ-વાઈઝ ઓપરેટરો પૂર્ણાંકોના વ્યક્તિગત બીટ્સને મેનિપ્યુલેટ કરે છે.

    \textbf{કોષ્ટક: એરીથમેટીક ઓપરેટરો}

    \begin{tabulary}{\linewidth}{|C|L|L|L|}
        \hline
        \textbf{Op} & \textbf{વિવરણ} & \textbf{ઉદાહરણ} & \textbf{પરિણામ} \\
        \hline
        \code{+\ } & સરવાળો & \code{5 + 3} & 8 \\
        \hline
        \code{-\ } & બાદબાકી & \code{7 - 2} & 5 \\
        \hline
        \code{*\ } & ગુણાકાર & \code{4 * 3} & 12 \\
        \hline
        \code{/\ } & ભાગાકાર & \code{10 / 3} & 3 \\
        \hline
        \code{\%\ } & મોડ્યુલસ & \code{10 \% 3} & 1 \\
        \hline
        \code{++} & ઇન્ક્રીમેન્ટ & \code{a++} & 1 ઉમેરે \\
        \hline
        \code{--} & ડિક્રીમેન્ટ & \code{--b} & 1 બાદ કરે \\
        \hline
    \end{tabulary}

    \textbf{કોષ્ટક: બીટવાઈઝ ઓપરેટરો}

    \begin{tabulary}{\linewidth}{|C|L|L|L|}
        \hline
        \textbf{Op} & \textbf{વિવરણ} & \textbf{Exp (bin)} & \textbf{Res} \\
        \hline
        \code{\&} & બીટવાઈઝ AND & \code{5(101) \& 3(011)} & 1(001) \\
        \hline
        \code{|} & બીટવાઈઝ OR & \code{5(101) | 3(011)} & 7(111) \\
        \hline
        \code{\^} & બીટવાઈઝ XOR & \code{5(101) \^ 3(011)} & 6(110) \\
        \hline
        \code{\~} & બીટવાઈઝ NOT & \code{\~5(101)} & -6 \\
        \hline
        \code{<<} & લેફ્ટ શિફ્ટ & \code{5 << 1} & 10(1010) \\
        \hline
        \code{>>} & રાઈટ શિફ્ટ & \code{5 >> 1} & 2(10) \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
int a = 5, b = 3;
printf("a + b = %d\n", a + b);      // 8
printf("a & b = %d\n", a & b);      // 1
printf("a << 1 = %d\n", a << 1);    // 10
\end{lstlisting}

    \begin{itemize}
        \item \textbf{ગાણિતિક ક્રિયાઓ}: ગણતરી માટે એરીથમેટીક ઓપરેટરો
        \item \textbf{બીટ મેનિપ્યુલેશન}: બીટવાઈઝ ઓપરેટરો બાઈનરી સ્તરે કામ કરે છે
        \item \textbf{કાર્યક્ષમતા}: બીટવાઈઝ ઓપરેશન્સ અમુક કાર્યો માટે ઝડપી છે
    \end{itemize}

    \begin{mnemonicbox}"SAME BARON" (Subtraction Addition Multiplication, Bitwise AND/OR/NOT)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{a}{3}
\textbf{'go to' સ્ટેટમેન્ટનો ઉપયોગ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \code{goto} સ્ટેટમેન્ટનો ઉપયોગ પ્રોગ્રામ કંટ્રોલને લેબલવાળા સ્ટેટમેન્ટમાં બિનશરતી ટ્રાન્સફર કરવા માટે થાય છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num, sum = 0;
    
    printf("Enter a positive number: ");
    scanf("%d", &num);
    
    if (num <= 0) {
        goto error;
    }
    
    sum = num * (num + 1) / 2;
    printf("Sum of first %d numbers = %d\n", num, sum);
    goto end;
    
    error:
        printf("Error: Please enter a positive number!\n");
    
    end:
        return 0;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: goto ઉદાહરણ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ num};
        \node[gtu decision, alias=check, below=of input] {num <= 0?};
        \node[gtu output, right=of check, xshift=1cm] (error) {આઉટપુટ Error};
        \node[gtu process, below=of check] (calc) {ગણતરી sum};
        \node[gtu output, below=of calc] (output) {આઉટપુટ sum};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (check);
        \draw[gtu arrow] (check) -- node[above] {હા} (error);
        \draw[gtu arrow] (check) -- node[right] {ના} (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
        \draw[gtu arrow] (error) |- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{લેબલ ડિક્લેરેશન}: લેબલ્સ કોલોન (:) સાથે સમાપ્ત થાય છે
        \item \textbf{જમ્પ સ્ટેટમેન્ટ}: \code{goto} કંટ્રોલને લેબલ પર ટ્રાન્સફર કરે છે
        \item \textbf{સાવચેતી}: વધુ પડતો ઉપયોગ "સ્પાઘેટ્ટી કોડ" બનાવે છે
    \end{itemize}

    \begin{mnemonicbox}"JUMPing LABEL" (લેબલવાળા સ્ટેટમેન્ટ પર જમ્પ કરો)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{b}{4}
\textbf{કીબોર્ડ દ્વારા ઇનપુટ કરેલા 5 વિષયોમાં વિદ્યાર્થીએ મેળવેલા ગુણના આધારે વિદ્યાર્થીને નીચેના નિયમો મુજબ ગ્રેડ મળે છે: 90 કે તેથી વધુ ટકા - ગ્રેડ A. 80 અને 89 ની વચ્ચે ટકા - ગ્રેડ B. 70 અને 79 ની વચ્ચે ટકા - ગ્રેડ C. 60 અને 69 ની વચ્ચે ટકા - ગ્રેડ D. 50 અને 59 ની વચ્ચે ટકા - ગ્રેડ E. 50 કરતા ઓછા - ગ્રેડ F. વિદ્યાર્થીએ મેળવેલ ગ્રેડ પ્રદર્શિત કરતો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
    આ પ્રોગ્રામ 5 વિષયોના સરેરાશ ગુણના આધારે ગ્રેડની ગણતરી કરે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int marks[5], total = 0, i;
    float percentage;
    char grade;
    
    // 5 વિષયો માટે ગુણ ઇનપુટ
    for (i = 0; i < 5; i++) {
        printf("Enter marks for subject %d (out of 100): ", i+1);
        scanf("%d", &marks[i]);
        total += marks[i];
    }
    
    // ટકાવારીની ગણતરી
    percentage = total / 5.0;
    
    // ગ્રેડ નક્કી કરો
    if (percentage >= 90)
        grade = 'A';
    else if (percentage >= 80)
        grade = 'B';
    else if (percentage >= 70)
        grade = 'C';
    else if (percentage >= 60)
        grade = 'D';
    else if (percentage >= 50)
        grade = 'E';
    else
        grade = 'F';
    
    printf("Percentage: %.2f%%\n", percentage);
    printf("Grade: %c\n", grade);
    
    return 0;
}
\end{lstlisting}

    \textbf{કોષ્ટક: ગ્રેડિંગ માપદંડ}

    \begin{tabulary}{\linewidth}{|C|C|}
        \hline
        \textbf{ટકાવારી શ્રેણી} & \textbf{ગ્રેડ} \\
        \hline
        $\ge$ 90 & A \\
        \hline
        80-89 & B \\
        \hline
        70-79 & C \\
        \hline
        60-69 & D \\
        \hline
        50-59 & E \\
        \hline
        < 50 & F \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{ઇનપુટ એરે}: 5 વિષયોના ગુણ સ્ટોર કરે છે
        \item \textbf{ટકાવારી ગણતરી}: સરવાળાને વિષયોની સંખ્યા વડે ભાગવું
        \item \textbf{ગ્રેડ નિર્ધારણ}: if-else લેડરનો ઉપયોગ કરીને
    \end{itemize}

    \begin{mnemonicbox}"ABCDEF-90-80-70-60-50" (ગ્રેડ્સ અને તેમની ટકાવારી મર્યાદા)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{c}{7}
\textbf{નેસ્ટેડ if-else ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    નેસ્ટેડ if-else એ કંટ્રોલ સ્ટ્રક્ચર છે જ્યાં if અથવા else સ્ટેટમેન્ટની અંદર બીજું if-else સ્ટેટમેન્ટ હોય છે.

    \textbf{ફ્લોચાર્ટ: નેસ્ટેડ if-else}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ age, score};
        \node[gtu decision, alias=d1, below=of input] {age $\ge$ 18?};
        
        \node[gtu decision, alias=d2, below left=of d1, xshift=-1cm, yshift=-1cm] {score $\ge$ 60?};
        \node[gtu process, alias=fail1, below right=of d1, xshift=1cm, yshift=-1cm] {Not eligible: Age};
        
        \node[gtu process, alias=pass, below left=of d2, xshift=-1cm] {Eligible};
        \node[gtu process, alias=fail2, below right=of d2, xshift=1cm] {Not eligible: Score};
        
        \node[gtu stop, below=of d2, yshift=-3cm] (end) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (d1);
        \draw[gtu arrow] (d1) -| node[above] {હા} (d2);
        \draw[gtu arrow] (d1) -| node[above] {ના} (fail1);
        
        \draw[gtu arrow] (d2) -| node[above] {હા} (pass);
        \draw[gtu arrow] (d2) -| node[above] {ના} (fail2);
        
        \draw[gtu arrow] (pass) |- (end);
        \draw[gtu arrow] (fail2) |- (end);
        \draw[gtu arrow] (fail1) |- (end);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int age, score;
    
    printf("Enter age: ");
    scanf("%d", &age);
    printf("Enter score: ");
    scanf("%d", &score);
    
    if (age >= 18) {
        if (score >= 60) {
            printf("Eligible for admission");
        } else {
            printf("Not eligible: Score criteria not met");
        }
    } else {
        printf("Not eligible: Age criteria not met");
    }
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{બહુવિધ શરતો}: ક્રમમાં અનેક શરતો ચકાસે છે
        \item \textbf{હાયરાર્કિકલ નિર્ણય}: અંદરની શરત માત્ર ત્યારે જ મૂલ્યાંકન થાય છે જો બહારની સાચી હોય
        \item \textbf{ઇન્ડેન્ટેશન}: યોગ્ય ઇન્ડેન્ટેશન માળખું સમજવામાં મદદ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"CONE" (Check Outer, Nest Evaluation inside)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{3}{a}{3}
\textbf{continue અને break સ્ટેટમેન્ટનો ઉપયોગ સમજાવો.}

\begin{solutionbox}
    \code{break} અને \code{continue} સ્ટેટમેન્ટ્સ લૂપ્સના પ્રવાહને અલગ અલગ રીતે નિયંત્રિત કરે છે.

    \textbf{કોષ્ટક: break અને continue વચ્ચે સરખામણી}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લાક્ષણિકતા} & \textbf{break} & \textbf{continue} \\
        \hline
        હેતુ & લૂપમાંથી તરત જ બહાર નીકળે છે & વર્તમાન પુનરાવર્તન છોડી દે છે \\
        \hline
        લૂપ પર અસર & સંપૂર્ણપણે સમાપ્ત કરે છે & આગલા પુનરાવર્તન પર આગળ વધે છે \\
        \hline
        ઉપયોગ & \code{switch}, \code{for}, \code{while}, \code{do-while} & \code{for}, \code{while}, \code{do-while} \\
        \hline
        ક્યારે વાપરવું & જ્યારે શરત પૂરી થાય અને વધુ પુનરાવર્તનોની જરૂર ન હોય & જ્યારે વર્તમાન પુનરાવર્તન છોડી દેવું જોઈએ \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
// break સાથે ઉદાહરણ
for (int i = 1; i <= 10; i++) {
    if (i == 5)
        break;    // i 5 હોય ત્યારે લૂપમાંથી બહાર નીકળો
    printf("%d ", i);  // આઉટપુટ: 1 2 3 4
}
\end{lstlisting}

\begin{lstlisting}[language=C]
// continue સાથે ઉદાહરણ
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0)
        continue;  // બેકી નંબરો છોડી દો
    printf("%d ", i);  // આઉટપુટ: 1 3 5 7 9
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{લૂપ કંટ્રોલ}: બંને લૂપ એક્ઝિક્યુશન મેનેજ કરવા માટે વપરાય છે
        \item \textbf{Break એક્ઝિટ}: લૂપને સંપૂર્ણપણે અટકાવે છે
        \item \textbf{Continue સ્કિપ}: માત્ર વર્તમાન પુનરાવર્તન છોડે છે
    \end{itemize}

    \begin{mnemonicbox}"BEC" (Break Exits Completely, Continue only current)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{b}{4}
\textbf{for લૂપનો ઉપયોગ કરીને આ આઉટપુટ પ્રિન્ટ કરવા માટે પ્રોગ્રામ લખો:}
\begin{verbatim}
1
1 2
1 2 3
1 2 3 4
\end{verbatim}

\begin{solutionbox}
    આ પ્રોગ્રામ નંબરોની પેટર્ન પ્રિન્ટ કરવા માટે નેસ્ટેડ for લૂપ્સનો ઉપયોગ કરે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i, j;
    
    // પંક્તિઓ માટે બહારની લૂપ (1 થી 4)
    for (i = 1; i <= 4; i++) {
        // કોલમ માટે અંદરની લૂપ (1 થી i)
        for (j = 1; j <= i; j++) {
            printf("%d ", j);
        }
        printf("\n");  // દરેક પંક્તિ પછી નવી લાઇન પર જાઓ
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: પેટર્ન પ્રિન્ટિંગ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu process, below=of start] (init_i) {i = 1};
        \node[gtu decision, alias=cond_i, below=of init_i] {i <= 4?};
        
        \node[gtu process, alias=init_j, right=of cond_i, xshift=1cm] {j = 1};
        \node[gtu decision, alias=cond_j, below=of init_j] {j <= i?};
        
        \node[gtu output, right=of cond_j, xshift=1cm] (print_j) {Print j};
        \node[gtu process, below=of print_j] (inc_j) {j++};
        
        \node[gtu output, below=of cond_j, yshift=-1.5cm] (newline) {Print newline};
        \node[gtu process, left=of newline, xshift=-1cm] (inc_i) {i++};
        
        \node[gtu stop, below=of cond_i, yshift=-3cm] (stop) {અંત};

        \draw[gtu arrow] (start) -- (init_i);
        \draw[gtu arrow] (init_i) -- (cond_i);
        
        \draw[gtu arrow] (cond_i) -- node[above] {હા} (init_j);
        \draw[gtu arrow] (cond_i) -- node[left] {ના} (stop);
        
        \draw[gtu arrow] (init_j) -- (cond_j);
        \draw[gtu arrow] (cond_j) -- node[above] {હા} (print_j);
        \draw[gtu arrow] (print_j) -- (inc_j);
        \draw[gtu arrow] (inc_j) |- (cond_j);
        
        \draw[gtu arrow] (cond_j) -- node[left] {ના} (newline);
        \draw[gtu arrow] (newline) -- (inc_i);
        \draw[gtu arrow] (inc_i) |- (cond_i);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{નેસ્ટેડ લૂપ્સ}: પંક્તિઓ માટે બહારની લૂપ, કોલમ માટે અંદરની
        \item \textbf{ડાયનેમિક લિમિટ}: અંદરની લૂપ j ને 1 થી વર્તમાન i સુધી ચલાવે છે
        \item \textbf{વધતી પેટર્ન}: દરેક પંક્તિમાં એક વધુ નંબર હોય છે
    \end{itemize}

    \begin{mnemonicbox}"RICI" (Row Increases, Column Increases based on row number)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{c}{7}
\textbf{સ્વિચ સ્ટેટમેન્ટ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \code{switch} સ્ટેટમેન્ટ એ મલ્ટી-વે નિર્ણય લેનાર છે જે વેરિએબલને વિવિધ કેસ મૂલ્યો સામે ચકાસે છે.

    \textbf{ફ્લોચાર્ટ: સ્વિચ સ્ટેટમેન્ટ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ choice};
        \node[gtu decision, alias=switch, below=of input] {Switch(choice)};
        
        \node[gtu process, alias=c1, below left=of switch, xshift=-2cm] {Case 1};
        \node[gtu process, alias=c2, below=of switch] {Case 2};
        \node[gtu process, alias=c3, below right=of switch, xshift=2cm] {Case 3};
        \node[gtu process, alias=def, right=of switch, xshift=2cm] {Default};
        
        \node[gtu stop, below=of c2, yshift=-1cm] (end) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (switch);
        \draw[gtu arrow] (switch) -- (c1);
        \draw[gtu arrow] (switch) -- (c2);
        \draw[gtu arrow] (switch) -- (c3);
        \draw[gtu arrow] (switch) -- (def);
        
        \draw[gtu arrow] (c1) |- (end);
        \draw[gtu arrow] (c2) -- (end);
        \draw[gtu arrow] (c3) |- (end);
        \draw[gtu arrow] (def) |- (end);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int choice;
    
    printf("Menu:\n");
    printf("1. Add\n");
    printf("2. Subtract\n");
    printf("3. Multiply\n");
    printf("Enter your choice (1-3): ");
    scanf("%d", &choice);
    
    switch (choice) {
        case 1:
            printf("Addition selected\n");
            break;
        case 2:
            printf("Subtraction selected\n");
            break;
        case 3:
            printf("Multiplication selected\n");
            break;
        default:
            printf("Invalid choice\n");
    }
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{બહુવિધ કેસો}: એક વેરિએબલને અનેક મૂલ્યો સામે ચકાસે છે
        \item \textbf{બ્રેક સ્ટેટમેન્ટ}: આગલા કેસમાં જવાથી રોકે છે
        \item \textbf{ડિફોલ્ટ કેસ}: કોઈપણ કેસ સાથે મેચ ન થતા મૂલ્યોને હેન્ડલ કરે છે
        \item \textbf{કેસનો ક્રમ}: કોઈપણ ક્રમમાં હોઈ શકે છે, ડિફોલ્ટ સામાન્ય રીતે છેલ્લે હોય છે
    \end{itemize}

    \begin{mnemonicbox}"CASED" (Check All Switch Expression's Destinations)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{a}{3}
\textbf{તાપમાનને સેલ્સિયસમાંથી ફેરનહીટમાં રૂપાંતરિત કરવા માટેનો C પ્રોગ્રામ fahrenheit= ((celsius*9)/5)+32 સૂત્રનો ઉપયોગ કરીને વિકસાવો.}

\begin{solutionbox}
    આ પ્રોગ્રામ સેલ્સિયસમાંથી ફેરનહીટમાં તાપમાન મૂલ્યને રૂપાંતરિત કરે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    float celsius, fahrenheit;
    
    printf("Enter temperature in Celsius: ");
    scanf("%f", &celsius);
    
    // સેલ્સિયસને ફેરનહીટમાં કન્વર્ટ કરો
    fahrenheit = ((celsius * 9) / 5) + 32;
    
    printf("%.2f Celsius = %.2f Fahrenheit\n", celsius, fahrenheit);
    
    return 0;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: સેલ્સિયસ થી ફેરનહીટ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ celsius};
        \node[gtu process, below=of input] (calc) {fahrenheit = ((celsius * 9) / 5) + 32};
        \node[gtu output, below=of calc] (output) {આઉટપુટ celsius, fahrenheit};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ફોર્મ્યુલા}: $F = ((C \times 9) \div 5) + 32$
        \item \textbf{ફ્લોટ વેરિએબલ્સ}: દશાંશ ચોકસાઈ માટે
        \item \textbf{ફોર્મેટેડ આઉટપુટ}: બે દશાંશ સ્થાનો માટે \code{\%.2f} નો ઉપયોગ કરીને
    \end{itemize}

    \begin{mnemonicbox}"C95+32=F" (Celsius x 9 / 5 + 32 = Fahrenheit)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{b}{4}
\textbf{પોઈન્ટર એટલે શું? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    પોઈન્ટર એ એક વેરિએબલ છે જે બીજા વેરિએબલનું મેમરી એડ્રેસ સ્ટોર કરે છે.

    \textbf{મેમરી લેઆઉટ ચિત્રણ}

    \begin{center}
    \begin{tikzpicture}[gtu flow, node distance=1cm]
        \node[draw, rectangle, minimum width=2.5cm, minimum height=1.5cm, align=left] (ptr) {\textbf{ptr} \\ મૂલ્ય: 0x2000 \\ એડ્રેસ: 0x1000};
        \node[draw, rectangle, minimum width=2.5cm, minimum height=1.5cm, align=left, right=of ptr, xshift=2cm] (var) {\textbf{var} \\ મૂલ્ય: 10 \\ એડ્રેસ: 0x2000};
        
        \draw[gtu arrow] (ptr.east) -- node[above] {નિર્દેશ કરે છે} (var.west);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int var = 10;    // સામાન્ય વેરિએબલ
    int *ptr;        // પોઈન્ટર વેરિએબલ
    
    ptr = &var;      // ptr માં var નું એડ્રેસ સ્ટોર કરો
    
    printf("Value of var: %d\n", var);       // આઉટપુટ: 10
    printf("Address of var: %p\n", &var);    // આઉટપુટ: memory address
    printf("Value of ptr: %p\n", ptr);       // આઉટપુટ: same memory address
    printf("Value at address stored in ptr: %d\n", *ptr); // આઉટપુટ: 10
    
    // પોઈન્ટરનો ઉપયોગ કરીને મૂલ્ય બદલો
    *ptr = 20;
    printf("New value of var: %d\n", var);   // આઉટપુટ: 20
    
    return 0;
}
\end{lstlisting}

    \textbf{કોષ્ટક: પોઈન્ટર ઓપરેશન્સ}

    \begin{tabulary}{\linewidth}{|C|C|L|L|}
        \hline
        \textbf{ઓપરેશન} & \textbf{ચિહ્ન} & \textbf{વિવરણ} & \textbf{ઉદાહરણ} \\
        \hline
        એડ્રેસ-ઓફ & \code{\&} & વેરિએબલનું એડ્રેસ મેળવે છે & \code{\&var} \\
        \hline
        ડિરેફરન્સ & \code{*} & એડ્રેસ પરનું મૂલ્ય મેળવે છે & \code{*ptr} \\
        \hline
        ડિક્લેરેશન & \code{*} & પોઈન્ટર વેરિએબલ બનાવે છે & \code{int *ptr;} \\
        \hline
        એસાઇનમેન્ટ & \code{=} & પોઈન્ટરને એડ્રેસ સોંપે છે & \code{ptr = \&var;} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{મેમરી એડ્રેસ}: પોઈન્ટર સ્થાન સ્ટોર કરે છે, મૂલ્ય નહીં
        \item \textbf{ઇનડાયરેક્શન}: એડ્રેસનો ઉપયોગ કરીને પરોક્ષ રીતે મૂલ્ય મેળવે છે
        \item \textbf{મેમરી મેનિપ્યુલેશન}: ડાયનેમિક મેમરી એક્સેસની મંજૂરી આપે છે
    \end{itemize}

    \begin{mnemonicbox}"ADA" (Address Dereferencing Access)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{c}{7}
\textbf{ફ્લોચાર્ટ દોરો અને ઉદાહરણ સાથે ડૂ-વાઇલ લૂપ સમજાવો.}

\begin{solutionbox}
    \code{do-while} લૂપ એ પોસ્ટ-ટેસ્ટ લૂપ છે જે શરત તપાસતા પહેલા ઓછામાં ઓછા એક વખત તેના બોડીને એક્ઝિક્યુટ કરે છે.

    \textbf{ફ્લોચાર્ટ: do-while લૂપ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu process, below=of start] (init) {i = 1 પ્રારંભ કરો};
        \node[gtu process, below=of init] (body) {લૂપ બોડીનો અમલ કરો:\\પ્રિન્ટ i};
        \node[gtu process, below=of body] (inc) {વધારો i: i++};
        \node[gtu decision, alias=cond, below=of inc] {i <= 5?};
        \node[gtu stop, below=of cond, yshift=-1cm] (stop) {અંત};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (body);
        \draw[gtu arrow] (body) -- (inc);
        \draw[gtu arrow] (inc) -- (cond);
        \draw[gtu arrow] (cond) -- node[right] {ના} (stop);
        \draw[gtu arrow] (cond.east) -- ++(1,0) |- node[right, near start] {હા} (body.east);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i = 1;
    
    do {
        printf("%d ", i);
        i++;
    } while (i <= 5);  // પ્રથમ એક્ઝિક્યુશન પછી શરત ચેક થાય છે
    
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

    \textbf{કોષ્ટક: ડૂ-વાઇલ લૂપની લાક્ષણિકતાઓ}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{લાક્ષણિકતા} & \textbf{વિવરણ} \\
        \hline
        એક્ઝિક્યુશન ક્રમ & પહેલા બોડી, પછી શરત \\
        \hline
        ન્યૂનતમ પુનરાવર્તન & ઓછામાં ઓછું એક \\
        \hline
        શરત ચેક & લૂપના અંતે \\
        \hline
        સમાપ્તિ & જ્યારે શરત ખોટી થાય ત્યારે \\
        \hline
        સિન્ટેક્સ & \code{do \{ statements; \} while (condition);} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{પોસ્ટ-ટેસ્ટ લૂપ}: લૂપ બોડી પછી શરત મૂલ્યાંકન
        \item \textbf{ગેરંટેડ એક્ઝિક્યુશન}: લૂપ બોડી હંમેશા ઓછામાં ઓછી એક વખત ચાલે છે
        \item \textbf{સેમિકોલોન}: વાઇલ કન્ડિશન પછી જરૂરી છે
    \end{itemize}

    \begin{mnemonicbox}"DECAT" (Do Execute Check After That)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{4}{a}{3}
\textbf{ત્રિકોણનું ક્ષેત્રફળ (૦.૫ * પાયો * ઉંચાઈ) શોધવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
    આ પ્રોગ્રામ ક્ષેત્રફળ = $0.5 \times base \times height$ સૂત્રનો ઉપયોગ કરીને ત્રિકોણનું ક્ષેત્રફળ ગણે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    float base, height, area;
    
    printf("Enter base of triangle: ");
    scanf("%f", &base);
    printf("Enter height of triangle: ");
    scanf("%f", &height);
    
    // ક્ષેત્રફળ ગણો
    area = 0.5 * base * height;
    
    printf("Area of triangle = %.2f square units\n", area);
    
    return 0;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: ત્રિકોણનું ક્ષેત્રફળ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ base, height};
        \node[gtu process, below=of input] (calc) {area = 0.5 * base * height};
        \node[gtu output, below=of calc] (output) {આઉટપુટ area};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ફોર્મ્યુલા}: ક્ષેત્રફળ = 0.5 * બેઝ * હાઈટ
        \item \textbf{ફ્લોટ વેરિએબલ્સ}: દશાંશ ચોકસાઈ માટે
        \item \textbf{યુઝર ઇનપુટ}: યુઝર પાસેથી પાયો અને ઉંચાઈ મેળવે છે
    \end{itemize}

    \begin{mnemonicbox}"Half-BH" (Half times Base times Height)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{b}{4}
\textbf{પોઈન્ટરનું ડીકલેરેશન અને ઈનીશ્યલાઈઝેશન સમજાવો.}

\begin{solutionbox}
    પોઈન્ટર ડિક્લેરેશન અને ઇનિશિયલાઇઝેશનમાં પોઈન્ટર વેરિએબલ બનાવવાનો અને તેને મેમરી એડ્રેસ સોંપવાનો સમાવેશ થાય છે.

    \textbf{કોષ્ટક: પોઈન્ટર ડિક્લેરેશન અને ઇનિશિયલાઇઝેશન}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{ઓપરેશન} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} & \textbf{સમજૂતી} \\
        \hline
        ડિક્લેરેશન & \code{type *name;} & \code{int *ptr;} & int પોઈન્ટર બનાવે છે \\
        \hline
        ઇનિશિયલાઇઝેશન & \code{name = \&var;} & \code{ptr = \&num;} & num નું એડ્રેસ સોંપે છે \\
        \hline
        સંયુક્ત & \code{type *n = \&v;} & \code{int *p = \&n;} & ડિક્લેર અને ઇનિશિયલાઇઝ \\
        \hline
        નલ પોઈન્ટર & \code{name = NULL;} & \code{ptr = NULL;} & કંઈ નહીં બતાવે \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
int main() {
    // ડિક્લેરેશન
    int *ptr1;
    
    // ડિક્લેરેશન અને ઇનિશિયલાઇઝેશન એકસાથે
    int num = 10;
    int *ptr2 = &num;
    
    // NULL સાથે ઇનિશિયલાઇઝેશન
    int *ptr3 = NULL;
    
    printf("Value at address ptr2: %d\n", *ptr2);  // આઉટપુટ: 10
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{એસ્ટરિસ્ક સિન્ટેક્સ}: \code{*} નો ઉપયોગ ડિક્લેરેશનમાં પોઈન્ટર બનાવવા માટે
        \item \textbf{એડ્રેસ ઓપરેટર}: \code{\&} વેરિએબલનું એડ્રેસ મેળવે છે
        \item \textbf{NULL ઇનિશિયલાઇઝેશન}: વાઈલ્ડ પોઈન્ટર્સ ટાળવા માટે સુરક્ષિત પદ્ધતિ
        \item \textbf{પોઈન્ટર ટાઈપ}: જે ડેટા ટાઈપને પોઈન્ટ કરે છે તેને મેચ કરવું જોઈએ
    \end{itemize}

    \begin{mnemonicbox}"DINA" (Declare, Initialize with NULL or Address)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{c}{7}
\textbf{વાઇલ લૂપ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    વાઇલ લૂપ એક પ્રી-ટેસ્ટ લૂપ છે જે શરત સાચી રહે ત્યાં સુધી તેના બોડીને વારંવાર એક્ઝિક્યુટ કરે છે.

    \textbf{ફ્લોચાર્ટ: while લૂપ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu process, below=of start] (init) {i = 1 પ્રારંભ કરો};
        \node[gtu decision, alias=cond, below=of init] {i <= 5?};
        \node[gtu process, below=of cond] (body) {લૂપ બોડીનો અમલ કરો:\\પ્રિન્ટ i};
        \node[gtu process, below=of body] (inc) {વધારો i: i++};
        \node[gtu stop, right=of cond, xshift=2cm] (stop) {અંત};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (cond);
        \draw[gtu arrow] (cond) -- node[left] {હા} (body);
        \draw[gtu arrow] (body) -- (inc);
        \draw[gtu arrow] (inc.west) -- ++(-1,0) |- (cond.west);
        \draw[gtu arrow] (cond) -- node[above] {ના} (stop);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i = 1;
    
    while (i <= 5) {  // દરેક એક્ઝિક્યુશન પહેલા શરત ચેક થાય છે
        printf("%d ", i);
        i++;
    }
    
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

    \textbf{કોષ્ટક: વાઇલ લૂપની લાક્ષણિકતાઓ}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{લાક્ષણિકતા} & \textbf{વિવરણ} \\
        \hline
        એક્ઝિક્યુશન ક્રમ & પહેલા શરત, પછી બોડી \\
        \hline
        ન્યૂનતમ પુનરાવર્તન & શૂન્ય (જો શરત પ્રારંભમાં ખોટી હોય) \\
        \hline
        શરત ચેક & લૂપની શરૂઆતમાં \\
        \hline
        સમાપ્તિ & જ્યારે શરત ખોટી થાય ત્યારે \\
        \hline
        સિન્ટેક્સ & \code{while (condition) \{ statements; \}} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{પ્રી-ટેસ્ટ લૂપ}: લૂપ બોડી પહેલા શરત મૂલ્યાંકન
        \item \textbf{શૂન્ય પુનરાવર્તન શક્ય}: જો શરત પ્રારંભમાં ખોટી હોય તો બોડી ક્યારેય એક્ઝિક્યુટ ન થઈ શકે
        \item \textbf{લૂપ વેરિએબલ}: લૂપ પહેલા ઇનિશિયલાઇઝ થવું જોઈએ
    \end{itemize}

    \begin{mnemonicbox}"CELT" (Check, Execute, Loop, Terminate)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{a}{3}
\textbf{બુકની આપેલ માહિતી સ્ટોર કરવાનું સ્ટ્રક્ચર બનાવો: book\_no, book\_title, book\_author, book\_price}

\begin{solutionbox}
    આ પ્રોગ્રામ સ્પષ્ટ કરેલા ફિલ્ડ્સ સાથે પુસ્તક માહિતી સંગ્રહ કરવા માટે સ્ટ્રક્ચર બનાવે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>

// પુસ્તક માહિતી માટે સ્ટ્રક્ચર ડેફિનેશન
struct Book {
    int book_no;
    char book_title[50];
    char book_author[30];
    float book_price;
};

int main() {
    // Book સ્ટ્રક્ચરના વેરિએબલની ઘોષણા
    struct Book book1;
    
    // સ્ટ્રક્ચર મેમ્બર્સને મૂલ્યો સોંપો
    book1.book_no = 101;
    strcpy(book1.book_title, "Programming in C");
    strcpy(book1.book_author, "Dennis Ritchie");
    book1.book_price = 450.75;
    
    // પુસ્તક માહિતી પ્રદર્શિત કરો
    printf("Book No: %d\n", book1.book_no);
    printf("Title: %s\n", book1.book_title);
    printf("Author: %s\n", book1.book_author);
    printf("Price: Rs. %.2f\n", book1.book_price);
    
    return 0;
}
\end{lstlisting}

    \textbf{સ્ટ્રક્ચર રજૂઆત:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu class] (book) {
            \textbf{struct Book} \\
            \rule{2cm}{0.4pt} \\
            int book\_no \\
            char book\_title[50] \\
            char book\_author[30] \\
            float book\_price
        };
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{સ્ટ્રક્ચર ડેફિનિશન}: કંપોઝિટ ડેટા પ્રકાર વ્યાખ્યાયિત કરવા \code{struct} કીવર્ડનો ઉપયોગ કરે છે
        \item \textbf{મેમ્બર એક્સેસ}: સભ્યો એક્સેસ કરવા માટે ડોટ (.) ઓપરેટરનો ઉપયોગ કરે છે
        \item \textbf{સ્ટ્રિંગ કોપિંગ}: કેરેક્ટર એરે માટે \code{strcpy()}
    \end{itemize}

    \begin{mnemonicbox}"NTAP" (Number, Title, Author, Price)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{b}{4}
\textbf{(1)sqrt() (2)pow() (3)strlen() (4)strcpy() ફંક્શનો ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    આ ફંક્શન C માં ગણિત ગણતરી અને સ્ટ્રિંગ મેનિપ્યુલેશન માટે વપરાતા સ્ટાન્ડર્ડ લાઇબ્રેરી ફંક્શન્સ છે.

    \textbf{કોષ્ટક: લાઇબ્રેરી ફંક્શન્સ}

    \begin{tabulary}{\linewidth}{|C|C|L|L|}
        \hline
        \textbf{ફંક્શન} & \textbf{હેડર} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\
        \hline
        \code{sqrt()} & math.h & વર્ગમૂળ & \code{sqrt(16) -> 4.0} \\
        \hline
        \code{pow()} & math.h & પાવર & \code{pow(2,3) -> 8.0} \\
        \hline
        \code{strlen()} & string.h & સ્ટ્રિંગ લંબાઈ & \code{strlen("Hi") -> 2} \\
        \hline
        \code{strcpy()} & string.h & સ્ટ્રિંગ કોપી & \code{strcpy(d, "Hi")} \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h>
#include <string.h>

int main() {
    // sqrt() અને pow() ઉદાહરણો
    printf("sqrt(25): %.2f\n", sqrt(25));
    printf("pow(2, 4): %.2f\n", pow(2, 4));
    
    // strlen() ઉદાહરણ
    char str[] = "C Prog";
    printf("Length: %d\n", strlen(str));
    
    // strcpy() ઉદાહરણ
    char dest[10];
    strcpy(dest, "Hello");
    printf("Copied: %s\n", dest);
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{મેથ ફંક્શન્સ}: ગાણિતિક ગણતરી માટે sqrt() અને pow()
        \item \textbf{સ્ટ્રિંગ ફંક્શન્સ}: સ્ટ્રિંગ મેનિપ્યુલેશન માટે strlen() અને strcpy()
        \item \textbf{હેડર ફાઈલ્સ}: આ ફંક્શન્સ વાપરવા જરૂરી છે
    \end{itemize}

    \begin{mnemonicbox}"MPSL" (Math Power and String Length)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{c}{7}
\textbf{એરે અને એરેનું ઈનીશ્યલાઈઝેશન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    એરે એ એક જ ડેટા પ્રકારના એલિમેન્ટ્સનો સમૂહ છે જે લગાતાર મેમરી લોકેશન્સમાં સ્ટોર થયેલા હોય છે.

    \textbf{કોષ્ટક: એરે પ્રકારો અને ઇનિશિયલાઇઝેશન}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{પ્રકાર} & \textbf{ડિક્લેરેશન} & \textbf{ઇનિશિયલાઇઝેશન} \\
        \hline
        ઇન્ટીજર & \code{int a[5];} & \code{int a[5] = \{1,2\};} \\
        \hline
        કેરેક્ટર & \code{char s[10];} & \code{char s[] = "Hi";} \\
        \hline
        ફ્લોટ & \code{float f[3];} & \code{float f[3] = \{1.1\};} \\
        \hline
        સાઇઝ ઇન્ફરન્સ & - & \code{int n[] = \{1,2,3\};} \\
        \hline
    \end{tabulary}

    \textbf{ડાયાગ્રામ: એરે મેમરી લેઆઉટ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \foreach \x/\val in {0/10, 1/20, 2/30, 3/40, 4/50} {
            \node[draw, rectangle, minimum size=1cm] (n\x) at (\x*1.2, 0) {\val};
            \node[below=0.1cm of n\x] {\footnotesize [\x]};
        }
        \node[above=0.2cm of n2] {\textbf{numbers[5]}};
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    
    printf("Array elements: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{ઝીરો-બેઝ્ડ ઇન્ડેક્સિંગ}: પ્રથમ એલિમેન્ટ ઇન્ડેક્સ 0 પર
        \item \textbf{કન્ટિગ્યુઅસ મેમરી}: એલિમેન્ટ્સ લાગલાગટ સ્ટોર થાય છે
        \item \textbf{ફિક્સ્ડ સાઇઝ}: સાઇઝ કમ્પાઇલ ટાઇમે નક્કી થાય છે
    \end{itemize}

    \begin{mnemonicbox}"DICE" (Declaration, Initialization, Contiguous storage, Element access)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5}{a}{3}
\textbf{સ્ટ્રક્ચરનું ડીકલેરેશન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    C માં સ્ટ્રક્ચર ડિક્લેરેશનમાં એક નવો ડેટા પ્રકાર વ્યાખ્યાયિત કરવાનો સમાવેશ થાય છે જે વિવિધ ડેટા પ્રકારોને એક નામ હેઠળ જોડે છે.

    \textbf{કોષ્ટક: સ્ટ્રક્ચર ડિક્લેરેશન પદ્ધતિઓ}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{પદ્ધતિ} & \textbf{ઉદાહરણ} \\
        \hline
        બેઝિક ડિક્લેરેશન & \code{struct Student \{ int id; \};} \\
        \hline
        વેરિએબલ સાથે & \code{struct Point \{ int x; \} p1;} \\
        \hline
        ટેગ વગર & \code{struct \{ float r; \} c1;} \\
        \hline
        ટાઇપડેફ & \code{typedef struct \{ int w; \} Rect;} \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
struct Student {
    int id;
    char name[30];
    float percentage;
};

int main() {
    struct Student s1;
    s1.id = 101;
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{સ્ટ્રક્ચર કીવર્ડ}: નવો ડેટા પ્રકાર વ્યાખ્યાયિત કરવા \code{struct} નો ઉપયોગ
        \item \textbf{મેમ્બર એક્સેસ}: મેમ્બર્સ એક્સેસ કરવા માટે \code{.} (ડોટ) ઓપરેટર
        \item \textbf{વિષમ ડેટા}: વિવિધ ડેટા પ્રકારોને જોડી શકે છે
    \end{itemize}

    \begin{mnemonicbox}"SMUVT" (Structure Mostly Uses Various Types)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{b}{4}
\textbf{યુઝર ડીફાઈન ફંક્શન એટલે શું? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    યુઝર-ડિફાઇન્ડ ફંક્શન એ પ્રોગ્રામર દ્વારા લખાયેલો કોડનો બ્લોક છે જે ચોક્કસ કાર્ય કરે છે અને પ્રોગ્રામના અન્ય ભાગોથી કોલ કરી શકાય છે.

    \textbf{કોષ્ટક: ફંક્શન કોમ્પોનન્ટ્સ}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{કોમ્પોનન્ટ} & \textbf{ઉદાહરણ} \\
        \hline
        રિટર્ન ટાઈપ & \code{int, float, void} \\
        \hline
        ફંક્શન નામ & \code{findMax} \\
        \hline
        પેરામીટર્સ & \code{(int a, int b)} \\
        \hline
        ફંક્શન બોડી & \code{\{ return a + b; \}} \\
        \hline
        ફંક્શન કોલ & \code{result = findMax(5, 3);} \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
#include <stdio.h>

int findMax(int a, int b);

int main() {
    int max = findMax(10, 20);
    printf("Max: %d\n", max);
    return 0;
}

int findMax(int a, int b) {
    if (a > b) return a;
    else return b;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: ફંક્શન કોલ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu process] (main) {main function};
        \node[gtu process, right=of main, xshift=2cm] (func) {findMax function};
        
        \draw[gtu arrow, bend left] (main) to node[above] {સાથે કોલ કરો} (func);
        \draw[gtu arrow, bend left] (func) to node[below] {મૂલ્ય પરત કરે છે} (main);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{મોડ્યુલર કોડ}: મોટા પ્રોગ્રામને નાના ભાગોમાં વિભાજિત કરે છે
        \item \textbf{રીયુઝેબિલિટી}: ફંક્શનને અનેક વખત કોલ કરી શકાય
        \item \textbf{ડિક્લેરેશન vs ડેફિનિશન}: પ્રોટોટાઇપ vs અમલીકરણ
    \end{itemize}

    \begin{mnemonicbox}"CDRP" (Create, Define, Return, Pass)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{c}{7}
\textbf{૧૦ નંબરવાળા એરેના ઘટકોને ચઢતા ક્રમમાં ગોઠવવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
    આ પ્રોગ્રામ બબલ સોર્ટ અલ્ગોરિધમનો ઉપયોગ કરીને 10 ઇન્ટીજરના એરેને ચઢતા ક્રમમાં સોર્ટ કરે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int arr[10], i, j, temp;
    
    // એરે એલિમેન્ટ્સ ઇનપુટ કરો
    printf("Enter 10 integers: \n");
    for (i = 0; i < 10; i++) {
        scanf("%d", &arr[i]);
    }
    
    // ચઢતા ક્રમ માટે બબલ સોર્ટ અલ્ગોરિધમ
    for (i = 0; i < 9; i++) {
        for (j = 0; j < 9 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // સ્વેપ કરો
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    
    // સોર્ટેડ એરે ડિસ્પ્લે કરો
    printf("Array in ascending order: \n");
    for (i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{ફ્લોચાર્ટ: બબલ સોર્ટ}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂઆત};
        \node[gtu input, below=of start] (input) {ઇનપુટ 10 elements};
        \node[gtu process, below=of input] (init_i) {i = 0};
        \node[gtu decision, alias=cond_i, below=of init_i] {i < 9?};
        
        \node[gtu process, alias=init_j, right=of cond_i, xshift=2cm] {j = 0};
        \node[gtu decision, alias=cond_j, below=of init_j] {j < 9-i?};
        
        \node[gtu decision, alias=swap_cond, below=of cond_j] {arr[j] > arr[j+1]?};
        \node[gtu process, alias=swap, right=of swap_cond, xshift=1cm] {સ્વેપ arr[j] અને arr[j+1]};
        \node[gtu process, alias=inc_j, below=of swap_cond] {j++};
        
        \node[gtu process, alias=inc_i, left=of cond_j, xshift=-1cm] {i++};
        \node[gtu output, left=of inc_i, xshift=-1cm] (output) {આઉટપુટ sorted array};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (init_i);
        \draw[gtu arrow] (init_i) -- (cond_i);
        
        \draw[gtu arrow] (cond_i) -- node[above] {હા} (init_j);
        \draw[gtu arrow] (cond_i) -- node[above] {ના} (output);
        
        \draw[gtu arrow] (init_j) -- (cond_j);
        \draw[gtu arrow] (cond_j) -- node[right] {હા} (swap_cond);
        \draw[gtu arrow] (cond_j) -- node[above] {ના} (inc_i);
        
        \draw[gtu arrow] (swap_cond) -- node[above] {હા} (swap);
        \draw[gtu arrow] (swap_cond) -- node[right] {ના} (inc_j);
        
        \draw[gtu arrow] (swap) |- (inc_j);
        \draw[gtu arrow] (inc_j.west) -- ++(-0.5,0) |- (cond_j.west);
        
        \draw[gtu arrow] (inc_i) |- (cond_i);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{બબલ સોર્ટ}: બાજુના એલિમેન્ટની સરખામણી કરે અને જરૂર હોય તો સ્વેપ કરે
        \item \textbf{નેસ્ટેડ લૂપ્સ}: બહારની લૂપ પાસ માટે, અંદરની તુલના માટે
        \item \textbf{ઓપ્ટિમાઇઝેશન}: દરેક પાસ ઓછામાં ઓછા એક એલિમેન્ટને ફિક્સ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"BSCOT" (Bubble Sort Compares and Orders Things)\end{mnemonicbox}
\end{solutionbox}

\end{document}
