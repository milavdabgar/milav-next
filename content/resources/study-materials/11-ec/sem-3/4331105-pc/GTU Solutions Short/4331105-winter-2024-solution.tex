\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/english-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{Programming In C (4331105) - Winter 2024 Solution}
\date{May 21, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{List any six keywords of C language.}

\begin{solutionbox}
\begin{answertable}{Keywords Categories}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Category} & \textbf{Keywords} \\ \hline
\textbf{Data Types} & \code{int}, \code{float}, \code{char} \\ \hline
\textbf{Control Flow} & \code{if}, \code{for}, \code{return} \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{I Find Clever Reasons For Results}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Define Operator. Summarize types of operators based on operands.}

\begin{solutionbox}
\textbf{Operator}: Symbol that performs operations on operands to produce a result.

\begin{answertable}{Types of Operators}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Type} & \textbf{Description} & \textbf{Examples} \\ \hline
\textbf{Unary} & Single operand & \code{++}, \code{--}, \code{!} \\ \hline
\textbf{Binary} & Two operands & \code{+}, \code{-}, \code{*}, \code{/}, \code{\%} \\ \hline
\textbf{Ternary} & Three operands & \code{?:} \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{U-B-T: Use Binary Then Ternary}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{Define flowchart. Draw flowchart symbols. Draw flowchart to find minimum of two integer numbers N1 \& N2.}

\begin{solutionbox}
\textbf{Flowchart}: Graphical representation of algorithm using standardized symbols to show the sequence of operations.

\textbf{Common Flowchart Symbols:}

\begin{answertable}{Flowchart Symbols}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Symbol} & \textbf{Meaning} \\ \hline
\textbf{Oval} & Start/Stop \\ \hline
\textbf{Parallelogram} & Input/Output \\ \hline
\textbf{Rectangle} & Process \\ \hline
\textbf{Diamond} & Decision \\ \hline
\textbf{Arrow} & Flow direction \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Flowchart to find minimum of N1 \& N2:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu input, below=of start] (input) {Input N1, N2};
    \node [gtu decision, below=of input] (dec) {N1 < N2?};
    \node [gtu process, below left=of dec] (p1) {Min = N1};
    \node [gtu process, below right=of dec] (p2) {Min = N2};
    \node [gtu output, below=2cm of dec] (out) {Display Min};
    \node [gtu state, below=of out] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (dec);
    \path [gtu arrow] (dec) -| node [above] {Yes} (p1);
    \path [gtu arrow] (dec) -| node [above] {No} (p2);
    \path [gtu arrow] (p1) |- (out);
    \path [gtu arrow] (p2) |- (out);
    \path [gtu arrow] (out) -- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Minimum of Two Numbers}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SPADE: Start-Process-Arrow-Decision-End}
\end{mnemonicbox}

\orquestionmarks{1(c)}{7}{Define algorithm. Write an algorithm to calculate area and circumference of circle.}

\begin{solutionbox}
\textbf{Algorithm}: Step-by-step procedure to solve a problem using finite number of well-defined instructions.

\textbf{Algorithm to calculate area and circumference of circle:}

\begin{enumerate}
    \item \textbf{Start}
    \item \textbf{Input radius r}
    \item \textbf{Set PI = 3.14159}
    \item \textbf{Calculate area = PI $\times$ r $\times$ r}
    \item \textbf{Calculate circumference = 2 $\times$ PI $\times$ r}
    \item \textbf{Display area and circumference}
    \item \textbf{Stop}
\end{enumerate}

\begin{answertable}{Table of formulas used}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Measurement} & \textbf{Formula} \\ \hline
\textbf{Area} & $\pi \times r^2$ \\ \hline
\textbf{Circumference} & $2 \times \pi \times r$ \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RICARD: Radius Input, Calculate Area, Reveal Dimensions}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{Differentiate printf() and scanf().}

\begin{solutionbox}
\begin{answertable}{Difference between printf() and scanf()}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{printf()} & \textbf{scanf()} \\ \hline
\textbf{Purpose} & Outputs data to screen & Inputs data from keyboard \\ \hline
\textbf{Direction} & Output function & Input function \\ \hline
\textbf{Format specifier} & Required & Required \\ \hline
\textbf{Parameter} & Actual values & Address of variables (\code{\&}) \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{OIAD: Output-Input, Actual-Destination}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Develop a C program to print sum \& average of 1 to n.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Sum and Average Program}]
#include <stdio.h>

int main() {
    int n, i, sum = 0;
    float avg;
    
    printf("Enter n: ");
    scanf("%d", &n);
    
    for(i = 1; i <= n; i++) {
        sum += i;
    }
    
    avg = (float)sum / n;
    
    printf("Sum = %d\n", sum);
    printf("Average = %.2f\n", avg);
    
    return 0;
}
\end{lstlisting}

\textbf{Key Points:}
\begin{itemize}
    \item \textbf{Initialization}: \code{sum = 0}
    \item \textbf{Iteration}: \code{for} loop from 1 to n
    \item \textbf{Type Casting}: \code{(float)} for correct average
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SIAP: Sum Initialize, Add in loop, Print results}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Explain Arithmetic operator and Relational operator with example.}

\begin{solutionbox}
\textbf{1. Arithmetic Operators:}

\begin{answertable}{Arithmetic Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Operator} & \textbf{Operation} & \textbf{Example} & \textbf{Result} \\ \hline
\textbf{+} & Addition & 5 + 3 & 8 \\ \hline
\textbf{-} & Subtraction & 5 - 3 & 2 \\ \hline
\textbf{*} & Multiplication & 5 * 3 & 15 \\ \hline
\textbf{/} & Division & 5 / 2 & 2 (integer) \\ \hline
\textbf{\%} & Modulo (Remainder) & 5 \% 2 & 1 \\ \hline
\end{tabulary}
\end{answertable}

\textbf{2. Relational Operators:}

\begin{answertable}{Relational Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Operator} & \textbf{Meaning} & \textbf{Example} & \textbf{Result} \\ \hline
\textbf{<} & Less than & 5 < 3 & 0 (false) \\ \hline
\textbf{>} & Greater than & 5 > 3 & 1 (true) \\ \hline
\textbf{<=} & Less than or equal & 5 <= 5 & 1 (true) \\ \hline
\textbf{>=} & Greater than or equal & 3 >= 5 & 0 (false) \\ \hline
\textbf{==} & Equal to & 5 == 5 & 1 (true) \\ \hline
\textbf{!=} & Not equal to & 5 != 3 & 1 (true) \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Code Example:}
\begin{lstlisting}[language=C]
int a = 5, b = 3;
printf("a + b = %d\n", a + b);     // Output: 8
printf("a > b is %d\n", a > b);    // Output: 1 (true)
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ASMDR for Arithmetic, LEGENE for Relational}
\end{mnemonicbox}

\orquestionmarks{2(a)}{3}{What is the difference between get(S) and scanf("\%s",S)}

\begin{solutionbox}
\begin{answertable}{Difference between gets(S) and scanf()}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{gets(S)} & \textbf{scanf("\%s",S)} \\ \hline
\textbf{Whitespace handling} & Reads space & Stops at whitespace \\ \hline
\textbf{Buffer overflow} & No boundary check & Safer with width limit \\ \hline
\textbf{Return type} & \code{char*} & Number of items read \\ \hline
\textbf{Usage safety} & Deprecated, unsafe & Safer with format control \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{WBRU: Whitespace-Boundary-Return-Usage}
\end{mnemonicbox}

\orquestionmarks{2(b)}{4}{Develop a C program to swap (exchange) value of two numbers.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Swap Two Numbers}]
#include <stdio.h>

int main() {
    int a, b, temp;
    
    printf("Enter two numbers: ");
    scanf("%d %d", &a, &b);
    
    printf("Before swap: a = %d, b = %d\n", a, b);
    
    temp = a;
    a = b;
    b = temp;
    
    printf("After swap: a = %d, b = %d\n", a, b);
    
    return 0;
}
\end{lstlisting}

\textbf{Diagram:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (before) {Before: a=5, b=10};
    \node [gtu process, below=of before] (step1) {temp = a (5)};
    \node [gtu process, below=of step1] (step2) {a = b (10)};
    \node [gtu process, below=of step2] (step3) {b = temp (5)};
    \node [gtu state, below=of step3] (after) {After: a=10, b=5};

    \path [gtu arrow] (before) -- (step1);
    \path [gtu arrow] (step1) -- (step2);
    \path [gtu arrow] (step2) -- (step3);
    \path [gtu arrow] (step3) -- (after);
\end{tikzpicture}
\captionof{figure}{Swapping Logic using Temp Variable}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TAB: Temp-Assign-Backfill}
\end{mnemonicbox}

\orquestionmarks{2(c)}{7}{Explain Boolean operator and Logical operator with example.}

\begin{solutionbox}
\textbf{1. Boolean Operators:}

\begin{answertable}{Boolean (Bitwise) Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Operator} & \textbf{Operation} & \textbf{Example} & \textbf{Result} \\ \hline
\textbf{\&} & Bitwise AND & 5 \& 3 & 1 \\ \hline
\textbf{|} & Bitwise OR & 5 | 3 & 7 \\ \hline
\textbf{\textasciicircum} & Bitwise XOR & 5 \textasciicircum\ 3 & 6 \\ \hline
\textbf{\textasciitilde} & Bitwise NOT & \textasciitilde 5 & -6 \\ \hline
\textbf{<<} & Left Shift & 5 << 1 & 10 \\ \hline
\textbf{>>} & Right Shift & 5 >> 1 & 2 \\ \hline
\end{tabulary}
\end{answertable}

\textbf{2. Logical Operators:}

\begin{answertable}{Logical Operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Operator} & \textbf{Meaning} & \textbf{Example} & \textbf{Result} \\ \hline
\textbf{\&\&} & Logical AND & (5>3) \&\& (2<4) & 1 (true) \\ \hline
\textbf{||} & Logical OR & (5<3) || (2<4) & 1 (true) \\ \hline
\textbf{!} & Logical NOT & !(5>3) & 0 (false) \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example:}
\begin{lstlisting}[language=C]
int a = 5, b = 3;
printf("a & b = %d\n", a & b);           // Output: 1 (bitwise AND)
printf("a > b && b < 10 is %d\n", a > b && b < 10);  // Output: 1 (true)
\end{lstlisting}

\textbf{Bit Representation (5 \& 3):}
\begin{lstlisting}
5 = 101
3 = 011
& = 001 (1 in decimal)
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BOXNRL for Boolean, AON for Logical}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Compare entry controlled and exit controlled loop with example.}

\begin{solutionbox}
\begin{answertable}{Entry vs Exit Controlled Loop}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{Entry Controlled} & \textbf{Exit Controlled} \\ \hline
\textbf{Condition check} & Before execution & After execution \\ \hline
\textbf{Minimum iterations} & Zero & One \\ \hline
\textbf{Example} & \code{while}, \code{for} & \code{do-while} \\ \hline
\textbf{Usage} & When pre-check needed & When at least one execution needed \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BCME: Before-Check-Multiple-Examples}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Develop a C program to display addition and subtraction of two numbers using switch case.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Switch Case Calculator}]
#include <stdio.h>

int main() {
    int a, b, choice, result;
    
    printf("Enter two numbers: ");
    scanf("%d %d", &a, &b);
    
    printf("1. Addition\n2. Subtraction\n");
    printf("Enter choice (1/2): ");
    scanf("%d", &choice);
    
    switch(choice) {
        case 1:
            result = a + b;
            printf("Addition: %d\n", result);
            break;
        case 2:
            result = a - b;
            printf("Subtraction: %d\n", result);
            break;
        default:
            printf("Invalid choice\n");
    }
    
    return 0;
}
\end{lstlisting}

\textbf{Flowchart:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu input, below=of start] (input) {Input a, b};
    \node [gtu input, below=of input] (choice) {Input choice};
    \node [gtu decision, below=of choice] (sw) {switch(choice)};
    
    \node [gtu process, below left=of sw] (case1) {result = a + b};
    \node [gtu process, below right=of sw] (case2) {result = a - b};
    \node [gtu process, right=2cm of sw] (def) {Display Invalid};
    
    \node [gtu output, below=of case1] (out1) {Display Addition};
    \node [gtu output, below=of case2] (out2) {Display Subtraction};
    \node [gtu state, below=3cm of sw] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (choice);
    \path [gtu arrow] (choice) -- (sw);
    \path [gtu arrow] (sw) -| node [left] {case 1} (case1);
    \path [gtu arrow] (sw) -| node [right] {case 2} (case2);
    \path [gtu arrow] (sw) -- node [above] {default} (def);
    
    \path [gtu arrow] (case1) -- (out1);
    \path [gtu arrow] (case2) -- (out2);
    
    \path [gtu arrow] (out1) -- (end);
    \path [gtu arrow] (out2) -- (end);
    \path [gtu arrow] (def) |- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Switch Case Operation}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CIRCA: Choice-Input-Result-Calculate-Action}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Explain multiple if-else statement with syntax, flowchart and an example.}

\begin{solutionbox}
\textbf{Syntax of multiple if-else:}

\begin{lstlisting}[language=C]
if (condition1) {
    // code block 1
} 
else if (condition2) {
    // code block 2
} 
else if (condition3) {
    // code block 3
} 
else {
    // default code block
}
\end{lstlisting}

\textbf{Flowchart:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu decision, below=of start] (c1) {condition1?};
    \node [gtu process, right=of c1] (b1) {Execute block 1};
    
    \node [gtu decision, below=of c1] (c2) {condition2?};
    \node [gtu process, right=of c2] (b2) {Execute block 2};
    
    \node [gtu decision, below=of c2] (c3) {condition3?};
    \node [gtu process, right=of c3] (b3) {Execute block 3};
    \node [gtu process, below=of c3] (def) {Execute default block};
    
    \node [gtu state, right=of b2, xshift=1cm] (end) {End};

    \path [gtu arrow] (start) -- (c1);
    \path [gtu arrow] (c1) -- node [above] {True} (b1);
    \path [gtu arrow] (c1) -- node [right] {False} (c2);
    
    \path [gtu arrow] (c2) -- node [above] {True} (b2);
    \path [gtu arrow] (c2) -- node [right] {False} (c3);
    
    \path [gtu arrow] (c3) -- node [above] {True} (b3);
    \path [gtu arrow] (c3) -- node [right] {False} (def);
    
    \path [gtu arrow] (b1) -| (end);
    \path [gtu arrow] (b2) -- (end);
    \path [gtu arrow] (b3) -| (end);
    \path [gtu arrow] (def) -| (end);
\end{tikzpicture}
\captionof{figure}{Multiple If-Else Flowchart}
\end{center}

\textbf{Example:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int marks;
    
    printf("Enter marks: ");
    scanf("%d", &marks);
    
    if (marks >= 80) {
        printf("Grade: A\n");
    } 
    else if (marks >= 70) {
        printf("Grade: B\n");
    } 
    else if (marks >= 60) {
        printf("Grade: C\n");
    } 
    else {
        printf("Grade: F\n");
    }
    
    return 0;
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TEST: Try Each Statement Then default}
\end{mnemonicbox}

\orquestionmarks{3(a)}{3}{State the use of break and continue keyword.}

\begin{solutionbox}
\begin{answertable}{Break vs Continue}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Keyword} & \textbf{Purpose} & \textbf{Effect} & \textbf{Common Use} \\ \hline
\textbf{break} & Terminates loop/switch & Exits the current loop/switch & To exit when condition met \\ \hline
\textbf{continue} & Skips iteration & Jumps to next iteration & To skip specific values \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example Code:}
\begin{lstlisting}[language=C]
// break example
for(i=1; i<=10; i++) {
    if(i == 5) break; // exits loop at i=5
    printf("%d ", i);  // prints 1 2 3 4
}

// continue example
for(i=1; i<=5; i++) {
    if(i == 3) continue; // skips i=3
    printf("%d ", i);  // prints 1 2 4 5
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EXIT-SKIP: EXit IT or SKIP iteration}
\end{mnemonicbox}

\orquestionmarks{3(b)}{4}{Develop a C program to check whether the given number is even or odd.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Even Odd Check}]
#include <stdio.h>

int main() {
    int num;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    if (num % 2 == 0) {
        printf("%d is even.\n", num);
    } 
    else {
        printf("%d is odd.\n", num);
    }
    
    return 0;
}
\end{lstlisting}

\textbf{Diagram:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu input, below=of start] (input) {Input num};
    \node [gtu decision, below=of input] (cond) {num \% 2 == 0?};
    \node [gtu output, below left=of cond] (even) {Display "Even"};
    \node [gtu output, below right=of cond] (odd) {Display "Odd"};
    \node [gtu state, below=3cm of cond] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (cond);
    \path [gtu arrow] (cond) -| node [left] {Yes} (even);
    \path [gtu arrow] (cond) -| node [right] {No} (odd);
    \path [gtu arrow] (even) |- (end);
    \path [gtu arrow] (odd) |- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Even/Odd Check}
\end{center}

\textbf{Key Points:}
\begin{itemize}
    \item \textbf{Check}: Using modulo (\%) operator
    \item \textbf{Decision}: Based on remainder with 2
    \item \textbf{Output}: Even for remainder 0, Odd otherwise
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{MODE: MODulo Equals zero for even}
\end{mnemonicbox}

\orquestionmarks{3(c)}{7}{Explain switch-case statement with syntax, flowchart and an example.}

\begin{solutionbox}
\textbf{Syntax of switch-case:}

\begin{lstlisting}[language=C]
switch (expression) {
    case constant1:
        // code block 1
        break;
    case constant2:
        // code block 2
        break;
    ...
    default:
        // default code block
}
\end{lstlisting}

\textbf{Flowchart:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu process, below=of start] (eval) {Evaluate expression};
    
    \node [gtu decision, below=of eval] (c1) {matches case 1?};
    \node [gtu process, right=of c1] (b1) {Execute block 1};
    
    \node [gtu decision, below=of c1] (c2) {matches case 2?};
    \node [gtu process, right=of c2] (b2) {Execute block 2};
    
    \node [gtu decision, below=of c2] (cn) {matches case n?};
    \node [gtu process, right=of cn] (bn) {Execute block n};
    \node [gtu process, below=of cn] (def) {Execute default block};
    
    \node [gtu state, right=of b2, xshift=2cm] (end) {End};

    \path [gtu arrow] (start) -- (eval);
    \path [gtu arrow] (eval) -- (c1);
    
    \path [gtu arrow] (c1) -- node [above] {Yes} (b1);
    \path [gtu arrow] (c1) -- node [right] {No} (c2);
    
    \path [gtu arrow] (c2) -- node [above] {Yes} (b2);
    \path [gtu arrow] (c2) -- node [right] {No} (cn);
    
    \path [gtu arrow] (cn) -- node [above] {Yes} (bn);
    \path [gtu arrow] (cn) -- node [right] {No} (def);
    
    \path [gtu arrow] (b1) -| (end);
    \path [gtu arrow] (b2) -- (end);
    \path [gtu arrow] (bn) -| (end);
    \path [gtu arrow] (def) -| (end);
\end{tikzpicture}
\captionof{figure}{Switch Case Flowchart}
\end{center}

\textbf{Example:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    char grade;
    
    printf("Enter grade (A-D): ");
    scanf(" %c", &grade);
    
    switch (grade) {
        case 'A':
            printf("Excellent!\n");
            break;
        case 'B':
            printf("Good job!\n");
            break;
        case 'C':
            printf("Satisfactory\n");
            break;
        case 'D':
            printf("Needs improvement\n");
            break;
        default:
            printf("Invalid grade\n");
    }
    
    return 0;
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEBID: Compare-Execute-Break-If-Done}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Define string. List out different operations that can be performed on string.}

\begin{solutionbox}
\textbf{String}: Array of characters terminated by null character '\textbackslash0'.

\begin{answertable}{String Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Description} & \textbf{Function} \\ \hline
\textbf{Input/Output} & Read/write strings & \code{gets()}, \code{puts()} \\ \hline
\textbf{Copy} & Copy one string to another & \code{strcpy()} \\ \hline
\textbf{Concatenation} & Join two strings & \code{strcat()} \\ \hline
\textbf{Comparison} & Compare two strings & \code{strcmp()} \\ \hline
\textbf{Length} & Find string length & \code{strlen()} \\ \hline
\textbf{Search} & Find substring & \code{strstr()} \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ICCLS: Input-Copy-Concatenate-Length-Search}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Develop a C program to convert uppercase alphabet to lowercase alphabet.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Uppercase to Lowercase}]
#include <stdio.h>

int main() {
    char ch;
    
    printf("Enter an uppercase letter: ");
    scanf(" %c", &ch);
    
    if (ch >= 'A' && ch <= 'Z') {
        char lowercase = ch + 32;  // ASCII difference is 32
        printf("Lowercase: %c\n", lowercase);
    } 
    else {
        printf("Not an uppercase letter\n");
    }
    
    return 0;
}
\end{lstlisting}

\textbf{ASCII Table Excerpt:}

\begin{answertable}{ASCII Values}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Character} & \textbf{ASCII Value} \\ \hline
\textbf{A} & 65 \\ \hline
\textbf{a} & 97 \\ \hline
\textbf{Z} & 90 \\ \hline
\textbf{z} & 122 \\ \hline
\textbf{Difference} & 32 \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{COOL: Character Offset Of Lowercase}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Draw flowchart of for loop and explain with example.}

\begin{solutionbox}
\textbf{For Loop Syntax:}

\begin{lstlisting}[language=C]
for (initialization; condition; increment/decrement) {
    // code block
}
\end{lstlisting}

\textbf{Flowchart:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu process, below=of start] (init) {Initialization};
    \node [gtu decision, below=of init] (cond) {Condition?};
    \node [gtu process, below=of cond] (body) {Execute code block};
    \node [gtu process, right=of cond, xshift=1cm] (inc) {Increment/Decrement};
    \node [gtu state, left=of cond, xshift=-1cm] (end) {End};

    \path [gtu arrow] (start) -- (init);
    \path [gtu arrow] (init) -- (cond);
    \path [gtu arrow] (cond) -- node [right] {True} (body);
    \path [gtu arrow] (body) -| (inc);
    \path [gtu arrow] (inc) -- (cond);
    \path [gtu arrow] (cond) -- node [above] {False} (end);
\end{tikzpicture}
\captionof{figure}{For Loop Flowchart}
\end{center}

\textbf{For Loop Components:}
\begin{enumerate}
    \item \textbf{Initialization}: Executed once at beginning
    \item \textbf{Condition}: Checked before each iteration
    \item \textbf{Increment/Decrement}: Executed after each iteration
    \item \textbf{Body}: Executed if condition is true
\end{enumerate}

\textbf{Example:}
\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i;
    
    for (i = 1; i <= 5; i++) {
        printf("%d ", i);
    }
    // Output: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

\textbf{Execution Flow:}
\begin{enumerate}
    \item Initialize i = 1
    \item Check condition (1 <= 5) - True
    \item Execute body - Print 1
    \item Increment i to 2
    \item Check condition (2 <= 5) - True
    \item And so on until i becomes 6
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ICE-T: Initialize, Check, Execute, Then increment}
\end{mnemonicbox}

\orquestionmarks{4(a)}{3}{Define array. List out different operations that can be performed on array.}

\begin{solutionbox}
\textbf{Array}: Collection of similar data types stored in contiguous memory locations.

\begin{answertable}{Array Operations}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Operation} & \textbf{Description} & \textbf{Example} \\ \hline
\textbf{Declaration} & Create array & \code{int arr[5];} \\ \hline
\textbf{Initialization} & Assign values & \code{arr[0] = 10;} \\ \hline
\textbf{Traversal} & Access all elements & \code{for} loop \\ \hline
\textbf{Insertion} & Add new element & \code{arr[pos] = value;} \\ \hline
\textbf{Deletion} & Remove element & Shift elements \\ \hline
\textbf{Searching} & Find element & Linear/binary search \\ \hline
\textbf{Sorting} & Arrange elements & Bubble/Selection sort \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DITIDSS: Declare-Initialize-Traverse-Insert-Delete-Search-Sort}
\end{mnemonicbox}

\orquestionmarks{4(b)}{4}{Define pointer. Explain with example.}

\begin{solutionbox}
\textbf{Pointer}: Variable that stores the memory address of another variable.

\begin{answertable}{Pointer Concepts}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Concept} & \textbf{Description} & \textbf{Syntax} \\ \hline
\textbf{Declaration} & Create pointer & \code{int *ptr;} \\ \hline
\textbf{Address operator} & Get address & \code{\&variable} \\ \hline
\textbf{Dereferencing} & Access value at address & \code{*ptr} \\ \hline
\textbf{Assignment} & Store address in pointer & \code{ptr = \&variable;} \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num = 10;
    int *ptr;
    
    ptr = &num;  // Store address of num in ptr
    
    printf("Value of num: %d\n", num);           // 10
    printf("Address of num: %p\n", &num);        // Address of num
    printf("Value of ptr: %p\n", ptr);           // Same address
    printf("Value pointed by ptr: %d\n", *ptr);  // 10
    
    *ptr = 20;   // Change value using pointer
    printf("New value of num: %d\n", num);       // 20
    
    return 0;
}
\end{lstlisting}

\textbf{Diagram:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [draw, rectangle split, rectangle split parts=2] (mem1) {
        Address: 1000 \nodepart{second} num: 10
    };
    \node [draw, rectangle split, rectangle split parts=2, right=3cm of mem1] (mem2) {
        Address: 2000 \nodepart{second} ptr: 1000
    };
    
    \draw [gtu arrow, dashed, bend right] (mem2.south) to node [below] {points to} (mem1.south);
\end{tikzpicture}
\captionof{figure}{Pointer Memory Layout}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SAVD: Store Address, Value through Dereferencing}
\end{mnemonicbox}

\orquestionmarks{4(c)}{7}{Draw flowchart of while loop and explain with example.}

\begin{solutionbox}
\textbf{While Loop Syntax:}

\begin{lstlisting}[language=C]
while (condition) {
    // code block
}
\end{lstlisting}

\textbf{Flowchart:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu decision, below=of start] (cond) {Condition?};
    \node [gtu process, below=of cond] (body) {Execute code block};
    \node [gtu process,  below=of body] (update) {Update control variable};
    \node [gtu state, right=of cond, xshift=1cm] (end) {End};

    \path [gtu arrow] (start) -- (cond);
    \path [gtu arrow] (cond) -- node [right] {True} (body);
    \path [gtu arrow] (body) -- (update);
    \path [gtu arrow] (update.west) -- ++(-1,0) |- (cond.west);
    \path [gtu arrow] (cond) -- node [above] {False} (end);
\end{tikzpicture}
\captionof{figure}{While Loop Flowchart}
\end{center}

\textbf{While Loop Components:}
\begin{enumerate}
    \item \textbf{Initialization}: Before the loop
    \item \textbf{Condition}: Checked before each iteration
    \item \textbf{Body}: Executed if condition is true
    \item \textbf{Update}: Must be done inside the body
\end{enumerate}

\textbf{Example:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i = 1;
    
    while (i <= 5) {
        printf("%d ", i);
        i++;
    }
    // Output: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

\textbf{Execution Flow:}
\begin{enumerate}
    \item Initialize i = 1 (before loop)
    \item Check condition (1 <= 5) - True
    \item Execute body - Print 1
    \item Update i to 2
    \item Check condition (2 <= 5) - True
    \item And so on until i becomes 6
\end{enumerate}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CHECK-UPDATE: CHECK before entering, UPDATE before repeating}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{State the use of following functions. (1) strcat() (2) strlen() (3) strcpy()}

\begin{solutionbox}
\begin{answertable}{String Functions}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Function} & \textbf{Purpose} & \textbf{Syntax} & \textbf{Example} \\ \hline
\code{strcat()} & Concatenates strings & \code{strcat(dest, src)} & "Hello" + "World" $\rightarrow$ "HelloWorld" \\ \hline
\code{strlen()} & Returns string length & \code{strlen(str)} & "Hello" $\rightarrow$ 5 \\ \hline
\code{strcpy()} & Copies string & \code{strcpy(dest, src)} & src $\rightarrow$ dest \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Code Example:}
\begin{lstlisting}[language=C]
#include <string.h>

char str1[20] = "Hello";
char str2[20] = "World";
char str3[20];

strcat(str1, str2);    // str1 becomes "HelloWorld"
int len = strlen(str1); // len becomes 10
strcpy(str3, str1);    // str3 becomes "HelloWorld"
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CLS: Concatenate-Length-Source copy}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Build a structure to store book information: book\_no, book\_title, book\_author, book\_price.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Book Structure}]
#include <stdio.h>
#include <string.h>

struct Book {
    int book_no;
    char book_title[50];
    char book_author[30];
    float book_price;
};

int main() {
    struct Book book1;
    
    // Assign values
    book1.book_no = 101;
    strcpy(book1.book_title, "Programming in C");
    strcpy(book1.book_author, "Dennis Ritchie");
    book1.book_price = 450.75;
    
    // Display book information
    printf("Book No: %d\n", book1.book_no);
    printf("Title: %s\n", book1.book_title);
    printf("Author: %s\n", book1.book_author);
    printf("Price: %.2f\n", book1.book_price);
    
    return 0;
}
\end{lstlisting}

\textbf{Structure Memory Layout:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [draw, rectangle split, rectangle split parts=4, rectangle split horizontal] (struct) {
        \textbf{book\_no} \nodepart{second} \textbf{book\_title} \nodepart{third} \textbf{book\_author} \nodepart{fourth} \textbf{book\_price}
    };
    \node [below=0.2cm of struct.one] {4 bytes};
    \node [below=0.2cm of struct.two] {50 bytes};
    \node [below=0.2cm of struct.three] {30 bytes};
    \node [below=0.2cm of struct.four] {4 bytes};
\end{tikzpicture}
\captionof{figure}{Structure Memory Representation}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NTAP: Number-Title-Author-Price}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Explain array and array initialization. Give example.}

\begin{solutionbox}
\textbf{Array}: Collection of same data type elements stored at contiguous memory locations.

\textbf{Array Initialization Methods:}

\begin{answertable}{Initialization Methods}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Method} & \textbf{Syntax} & \textbf{Example} \\ \hline
\textbf{At declaration} & \code{type name[size] = \{vals\};} & \code{int arr[5] = \{10, 20, 30, 40, 50\};} \\ \hline
\textbf{Partial} & \code{type name[size] = \{vals\};} & \code{int arr[5] = \{10, 20\}; // Rest 0} \\ \hline
\textbf{All zeros} & \code{type name[size] = \{0\};} & \code{int arr[5] = \{0\};} \\ \hline
\textbf{Element wise} & \code{name[idx] = val;} & \code{arr[0] = 10; arr[1] = 20;} \\ \hline
\textbf{Size inference} & \code{type name[] = \{vals\};} & \code{int arr[] = \{10, 20\}; // Size 2} \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example:}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    // Method 1: Complete initialization
    int arr1[5] = {10, 20, 30, 40, 50};
    
    // Method 2: Partial initialization
    int arr2[5] = {10, 20};  // Remaining are 0
    
    // Method 4: Size inference
    int arr4[] = {1, 2, 3, 4, 5};
    
    // Accessing elements
    printf("arr1[2] = %d\n", arr1[2]);  // Output: 30
    
    return 0;
}
\end{lstlisting}

\textbf{Memory Representation:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [draw, rectangle split, rectangle split parts=5, rectangle split horizontal] (arr) {
        10 \nodepart{second} 20 \nodepart{third} 30 \nodepart{fourth} 40 \nodepart{five} 50
    };
    \node [above=0.2cm of arr.one] {arr[0]};
    \node [above=0.2cm of arr.two] {arr[1]};
    \node [above=0.2cm of arr.three] {arr[2]};
    \node [above=0.2cm of arr.four] {arr[3]};
    \node [above=0.2cm of arr.five] {arr[4]};
\end{tikzpicture}
\captionof{figure}{Array Memory Layout}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CAPES: Complete, Automatic, Partial, Element, Size-inferred}
\end{mnemonicbox}

\orquestionmarks{5(a)}{3}{Compare array and structure with example.}

\begin{solutionbox}
\begin{answertable}{Array vs Structure}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Feature} & \textbf{Array} & \textbf{Structure} \\ \hline
\textbf{Data type} & Same type elements & Different type elements \\ \hline
\textbf{Access} & Using index (\code{arr[i]}) & Using dot operator (\code{s.member}) \\ \hline
\textbf{Memory} & Contiguous, fixed size & Contiguous, may have padding \\ \hline
\textbf{Assignment} & Element by element & Direct with compatible structures \\ \hline
\textbf{Purpose} & Collection of similar items & Group of related data \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example:}
\begin{lstlisting}[language=C]
// Array
int marks[5] = {85, 90, 78, 92, 88};
printf("%d", marks[2]);

// Structure
struct Student { int roll; char name[20]; };
struct Student s1 = {101, "Raj"};
printf("%s", s1.name);
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DAMPA: Datatype-Access-Memory-Purpose-Assignment}
\end{mnemonicbox}

\orquestionmarks{5(b)}{4}{Define User Defined Function. Explain with example.}

\begin{solutionbox}
\textbf{User Defined Function}: Block of code written by programmer to perform specific task, which can be called multiple times.

\begin{answertable}{Function Components}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Component} & \textbf{Description} & \textbf{Example} \\ \hline
\textbf{Return type} & Data type returned & \code{int, float, void} \\ \hline
\textbf{Function name} & Unique identifier & \code{sum, findMax} \\ \hline
\textbf{Parameters} & Input data & \code{(int a, int b)} \\ \hline
\textbf{Body} & Set of statements & \code{\{ return a+b; \}} \\ \hline
\end{tabulary}
\end{answertable}

\textbf{Example:}

\begin{lstlisting}[language=C]
#include <stdio.h>

// Function declaration
int sum(int a, int b);

int main() {
    int num1 = 10, num2 = 20, result;
    
    // Function call
    result = sum(num1, num2);
    
    printf("Sum = %d\n", result);
    
    return 0;
}

// Function definition
int sum(int a, int b) {
    return a + b;
}
\end{lstlisting}

\textbf{Function Flow:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (main) {main function};
    \node [gtu process, right=3cm of main] (func) {sum function};
    
    \draw [gtu arrow, bend left] (main) to node [above] {Call sum(10, 20)} (func);
    \draw [gtu arrow, bend left] (func) to node [below] {Return 30} (main);
\end{tikzpicture}
\captionof{figure}{Function Call Flow}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DPCR: Declaration-Parameters-Call-Return}
\end{mnemonicbox}

\orquestionmarks{5(c)}{7}{Develop a C program to find maximum and minimum element of array.}

\begin{solutionbox}
\begin{lstlisting}[language=C, caption={Min Max Array}]
#include <stdio.h>

int main() {
    int arr[100], n, i;
    int max, min;
    
    printf("Enter number of elements: ");
    scanf("%d", &n);
    
    printf("Enter %d integers: ", n);
    for(i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // Initialize max and min
    max = min = arr[0];
    
    // Find max and min
    for(i = 1; i < n; i++) {
        if(arr[i] > max)
            max = arr[i];
        if(arr[i] < min)
            min = arr[i];
    }
    
    printf("Maximum: %d\n", max);
    printf("Minimum: %d\n", min);
    
    return 0;
}
\end{lstlisting}

\textbf{Flowchart:}

\begin{center}
\begin{tikzpicture}[gtu block, auto]
    \node [gtu state] (start) {Start};
    \node [gtu input, below=of start] (input) {Input n, array};
    \node [gtu process, below=of input] (init) {max = min = arr[0]\\ i = 1};
    \node [gtu decision, below=of init] (cond) {i < n?};
    
    \node [gtu decision, right=of cond, xshift=1cm] (cmax) {arr[i] > max?};
    \node [gtu process, right=of cmax] (umax) {max = arr[i]};
    
    \node [gtu decision, below=of cmax] (cmin) {arr[i] < min?};
    \node [gtu process, right=of cmin] (umin) {min = arr[i]};
    
    \node [gtu process, left=of cmin] (inc) {i++};
    
    \node [gtu output, below left=of cond, yshift=-3cm] (out) {Display max, min};
    \node [gtu state, below=of out] (end) {End};

    \path [gtu arrow] (start) -- (input);
    \path [gtu arrow] (input) -- (init);
    \path [gtu arrow] (init) -- (cond);
    
    \path [gtu arrow] (cond) -- node [above] {Yes} (cmax);
    \path [gtu arrow] (cmax) -- node [above] {Yes} (umax);
    \path [gtu arrow] (cmax) -- node [right] {No} (cmin);
    \path [gtu arrow] (umax) -- (cmin);
    
    \path [gtu arrow] (cmin) -- node [above] {Yes} (umin);
    \path [gtu arrow] (cmin) -| node [below] {No} (inc);
    \path [gtu arrow] (umin) |- (inc);
    
    \path [gtu arrow] (inc) -| (cond);
    
    \path [gtu arrow] (cond) -- node [left] {No} (out);
    \path [gtu arrow] (out) -- (end);
\end{tikzpicture}
\captionof{figure}{Flowchart for Min Max}
\end{center}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{FILLS: First Initialize, Loop through, Look for Small/large}
\end{mnemonicbox}

\end{document}
