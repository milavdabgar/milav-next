\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{Programming in C (4331105) - Winter 2023 Solution}
\date{May 21, 2024}

\begin{document}
\maketitle

\questionmarks{1}{a}{3}
\textbf{અલ્ગોરિધમ વ્યાખ્યાયિત કરો અને વર્તુળનું ક્ષેત્રફળ શોધવા માટેનું અલ્ગોરિધમ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    અલ્ગોરિધમ એટલે કોઈ ચોક્કસ સમસ્યાના ઉકેલ માટેની પગલાવાર પ્રક્રિયા અથવા નિયમોનો સમૂહ.

    \textbf{વર્તુળના ક્ષેત્રફળનું અલ્ગોરિધમ:}

    \begin{enumerate}
        \item શરૂ
        \item વર્તુળની ત્રિજ્યા (r) ઇનપુટ લો
        \item ક્ષેત્રફળ = $\pi \times r^2$ ની ગણતરી કરો
        \item ક્ષેત્રફળ દર્શાવો
        \item અંત
    \end{enumerate}

    \begin{mnemonicbox}"શરૂ, વાંચો, ગણતરી, પ્રદર્શન, અંત"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{b}{4}
\textbf{ફ્લોચાર્ટ વ્યાખ્યાયિત કરો અને આપેલ ત્રણ સંખ્યાઓ માંથી ઓછામાં ઓછી સંખ્યા શોધવા માટેનો ફ્લોચાર્ટ દોરો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    ફ્લોચાર્ટ એટલે પ્રમાણિત પ્રતીકો અને આકારોનો ઉપયોગ કરીને એલ્ગોરિધમનું દ્રશ્ય નિરૂપણ, જે પગલાઓના ક્રમને દર્શાવે છે.

    \textbf{ત્રણ સંખ્યાઓમાંથી ન્યૂનતમ શોધવા માટેનો ફ્લોચાર્ટ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂ};
        \node[gtu input, below=of start] (input) {ઇનપુટ A, B, C};
        \node[gtu decision, below=of input] (cond1) {A $<$ B?};
        
        \node[gtu decision, below left=of cond1, xshift=-1cm] (cond2) {A $<$ C?};
        \node[gtu decision, below right=of cond1, xshift=1cm] (cond3) {B $<$ C?};
        
        \node[gtu process, below left=of cond2] (minA) {min = A};
        \node[gtu process, below right=of cond2] (minC1) {min = C};
        
        \node[gtu process, below left=of cond3] (minB) {min = B};
        \node[gtu process, below right=of cond3] (minC2) {min = C};
        
        \node[gtu output, below=of cond2, yshift=-3cm] (print) {min દર્શાવો};
        \node[gtu stop, below=of print] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (cond1);
        \draw[gtu arrow] (cond1) -| node[above] {હા} (cond2);
        \draw[gtu arrow] (cond1) -| node[above] {ના} (cond3);
        
        \draw[gtu arrow] (cond2) -| node[above] {હા} (minA);
        \draw[gtu arrow] (cond2) -| node[above] {ના} (minC1);
        
        \draw[gtu arrow] (cond3) -| node[above] {હા} (minB);
        \draw[gtu arrow] (cond3) -| node[above] {ના} (minC2);
        
        \draw[gtu arrow] (minA) |- (print);
        \draw[gtu arrow] (minC1) |- (print);
        \draw[gtu arrow] (minB) |- (print);
        \draw[gtu arrow] (minC2) |- (print);
        \draw[gtu arrow] (print) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{તુલના વ્યૂહરચના}: પહેલા A અને B ની તુલના કરો, પછી C સાથે તુલના કરો
        \item \textbf{બ્રાન્ચિંગ લોજિક}: સૌથી નાની કિંમત શોધવા માટે if-else સ્ટ્રક્ચરનો ઉપયોગ કરો
    \end{itemize}

    \begin{mnemonicbox}"જોડાઓની તુલના કરો, દુર્લભ નાની કિંમત દરેક જગ્યાએ શોધો"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{c}{7}
\textbf{નીચેના સમીકરણનો ઉપયોગ કરીને સિમ્પલ ઇન્ટરેસ્ટની ગણતરી કરવા માટેનો પ્રોગ્રામ લખો. I=PRN/100 જ્યાં P=પ્રિન્સીપલ રકમ, R=વ્યાજનો દર અને N=સમયગાળો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    float P, R, N, I;
    
    // પ્રિન્સિપલ રકમ, વ્યાજનો દર અને સમયગાળો ઇનપુટ લો
    printf("પ્રિન્સિપલ રકમ દાખલ કરો: ");
    scanf("%f", &P);
    
    printf("વ્યાજનો દર દાખલ કરો: ");
    scanf("%f", &R);
    
    printf("સમયગાળો (વર્ષમાં) દાખલ કરો: ");
    scanf("%f", &N);
    
    // સિમ્પલ ઇન્ટરેસ્ટની ગણતરી કરો
    I = (P * R * N) / 100;
    
    // પરિણામ દર્શાવો
    printf("સિમ્પલ ઇન્ટરેસ્ટ = %.2f\n", I);
    
    return 0;
}
\end{lstlisting}

    \textbf{આકૃતિ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu block] (formula) {Formula: $I = \frac{P \times R \times N}{100}$};
        \node[gtu input, left=of formula, yshift=1cm] (P) {મુદ્દલ (P)};
        \node[gtu input, left=of formula] (R) {દર (R)};
        \node[gtu input, left=of formula, yshift=-1cm] (N) {સમયગાળો (N)};
        \node[gtu output, right=of formula] (I) {વ્યાજ (I)};

        \draw[gtu arrow] (P) -- (formula);
        \draw[gtu arrow] (R) -- (formula);
        \draw[gtu arrow] (N) -- (formula);
        \draw[gtu arrow] (formula) -- (I);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ફ્લોટિંગ-પોઇન્ટ વેરિએબલ્સ}: ચોકસાઈ માટે દશાંશ મૂલ્યો સ્ટોર કરે છે
        \item \textbf{વપરાશકર્તા ઇન્ટરેક્શન}: ઇનપુટ માટે સ્પષ્ટ પ્રોમ્પ્ટ્સ
        \item \textbf{પરિણામ ફોર્મેટિંગ}: \%.2f બે દશાંશ સ્થાન દર્શાવે છે
    \end{itemize}

    \begin{mnemonicbox}"મુદ્દલ, દર અને સંખ્યા, સોથી ભાગીએ તો મળે વ્યાજ"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{1}{c}{7}
\textbf{કીબોર્ડ દ્વારા ત્રિજ્યા(R) અને ઊંચાઈ(H) ઈનપુટ લઇ સિલિન્ડરના વોલ્યુમ(V)ની ગણતરી કરીને પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો V=$\pi$R$^2$H}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    float radius, height, volume;
    const float PI = 3.14159;
    
    // ત્રિજ્યા અને ઊંચાઈ ઇનપુટ લો
    printf("સિલિન્ડરની ત્રિજ્યા દાખલ કરો: ");
    scanf("%f", &radius);
    
    printf("સિલિન્ડરની ઊંચાઈ દાખલ કરો: ");
    scanf("%f", &height);
    
    // સિલિન્ડરના વોલ્યુમની ગણતરી કરો
    volume = PI * radius * radius * height;
    
    // પરિણામ દર્શાવો
    printf("સિલિન્ડરનું વોલ્યુમ = %.2f\n", volume);
    
    return 0;
}
\end{lstlisting}

    \textbf{આકૃતિ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu input] (input) {ત્રિજ્યા, ઊંચાઈ ઇનપુટ લો};
        \node[gtu process, right=of input] (calc) {વોલ્યુમ = $\pi \times r^2 \times h$};
        \node[gtu output, right=of calc] (output) {વોલ્યુમ દર્શાવો};

        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (output);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{કોન્સ્ટન્ટ્સ}: સ્પષ્ટતા માટે PI કોન્સ્ટન્ટ તરીકે વ્યાખ્યાયિત કરવામાં આવ્યું છે
        \item \textbf{ફોર્મ્યુલા}: ત્રિજ્યાને બે વખત ગુણીને R$^2$ નો ઉપયોગ કરો
        \item \textbf{ઇનપુટ વેલિડેશન}: ત્રિજ્યા અને ઊંચાઈ માટે ધનાત્મક મૂલ્યોની ધારણા કરે છે
    \end{itemize}

    \begin{mnemonicbox}"ત્રિજ્યાનો વર્ગ ગુણો ઊંચાઈ ગુણો પાઈ, આપે સિલિન્ડરનું વોલ્યુમ, ન પૂછો શા માટે"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{a}{3}
\textbf{સી પ્રોગ્રામિંગ ભાષામાં સપોર્ટ કરતા વિવિધ ઓપરેટરોની યાદી બનાવો.}

\begin{solutionbox}
    \textbf{જવાબ}:

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{વર્ગ} & \textbf{ઓપરેટર્સ} \\
        \hline
        અંકગણિત & +, -, *, /, \% (સરવાળો, બાદબાકી, ગુણાકાર, ભાગાકાર, મોડ્યુલસ) \\
        \hline
        રિલેશનલ & ==, !=, $>$, $<$, $>=$, $<=$ (સમાન, અસમાન, મોટું, નાનું, મોટું અથવા સમાન, નાનું અથવા સમાન) \\
        \hline
        લોજિકલ & \&\&, $||$, ! (AND, OR, NOT) \\
        \hline
        એસાઇનમેન્ટ & =, +=, -=, *=, /=, \%= (એસાઇન, પ્લસ-એસાઇન, માઇનસ-એસાઇન, વગેરે) \\
        \hline
        ઇન્ક્રિમેન્ટ/ડિક્રિમેન્ટ & ++, -- (ઇન્ક્રિમેન્ટ, ડિક્રિમેન્ટ) \\
        \hline
        બિટવાઇઝ & \&, $|$, \^{}, \~{}, $<<$, $>>$ (AND, OR, XOR, કોમ્પ્લિમેન્ટ, લેફ્ટ શિફ્ટ, રાઇટ શિફ્ટ) \\
        \hline
        કન્ડિશનલ & ? : (ટર્નરી ઓપરેટર) \\
        \hline
        સ્પેશિયલ & sizeof(), \&, *, -$>$, . (સાઇઝ, એડ્રેસ, પોઇન્ટર, સ્ટ્રક્ચર) \\
        \hline
    \end{tabulary}

    \begin{mnemonicbox}"ARABIA CS" (અંકગણિત, રિલેશનલ, એસાઇનમેન્ટ, બિટવાઇઝ, ઇન્ક્રિમેન્ટ, એસાઇનમેન્ટ, કન્ડિશનલ, સ્પેશિયલ)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{b}{4}
\textbf{ઉદાહરણ સાથે રિલેશનલ ઓપરેટર અને ઇન્ક્રીમેન્ટ/ડિક્રીમેન્ટ ઓપરેટર સમજાવો.}

\begin{solutionbox}
    \textbf{જવાબ}:

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{ઓપરેટર પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} & \textbf{આઉટપુટ} \\
        \hline
        રિલેશનલ & બે મૂલ્યોની વચ્ચેના સંબંધની તપાસ કરે છે & \code{int a = 5, b = 10;} \code{printf("\%d", a < b);} & \code{1} (સાચું) \\
        \hline
         & સમાન (==) & \code{printf("\%d", 5 == 5);} & \code{1} (સાચું) \\
        \hline
         & અસમાન (!=) & \code{printf("\%d", 5 != 10);} & \code{1} (સાચું) \\
        \hline
         & મોટું/નાનું & \code{printf("\%d \%d", 5 > 3, 5 < 3);} & \code{1 0} \\
        \hline
        ઇન્ક્રિમેન્ટ & મૂલ્યમાં 1 વધારો કરે છે. પ્રી-ઇન્ક્રિમેન્ટ (++x): પહેલા વધારો પછી ઉપયોગ. પોસ્ટ-ઇન્ક્રિમેન્ટ (x++): પહેલા ઉપયોગ પછી વધારો & \code{int x = 5;} \code{printf("\%d ", ++x);} \code{printf("\%d", x);} & \code{6 6} \\
        \hline
        ડિક્રિમેન્ટ & મૂલ્યમાં 1 ઘટાડો કરે છે. પ્રી-ડિક્રિમેન્ટ (--x): પહેલા ઘટાડો પછી ઉપયોગ. પોસ્ટ-ડિક્રિમેન્ટ (x--): પહેલા ઉપયોગ પછી ઘટાડો & \code{int y = 5;} \code{printf("\%d ", y--);} \code{printf("\%d", y);} & \code{5 4} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{રિલેશનલ ઓપરેટર્સ}: 1 (સાચું) અથવા 0 (ખોટું) પરત કરે છે
        \item \textbf{ઇન્ક્રિમેન્ટ/ડિક્રિમેન્ટ}: વેરિએબલ મૂલ્ય બદલે છે અને મૂલ્ય પરત કરે છે
    \end{itemize}

    \begin{mnemonicbox}"રિલેશનલ કહે સાચું કે ખોટું, ઇન્ક્રિમેન્ટ/ડિક્રિમેન્ટ કરે ચઢાવ કે ઉતાર"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{c}{7}
\textbf{1 થી 100 નો સરવાળો અને એવરેજ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i, sum = 0;
    float average;
    
    // 1 થી 100 સુધીની સંખ્યાઓનો સરવાળો ગણો
    for(i = 1; i <= 100; i++) {
        sum += i;
    }
    
    // એવરેજ ગણો
    average = (float)sum / 100;
    
    // પરિણામો દર્શાવો
    printf("1 થી 100 સુધીની સંખ્યાઓનો સરવાળો = %d\n", sum);
    printf("1 થી 100 સુધીની સંખ્યાઓની સરેરાશ = %.2f\n", average);
    
    return 0;
}
\end{lstlisting}

    \textbf{આકૃતિ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂ};
        \node[gtu process, below=of start] (init) {sum = 0, i = 1};
        \node[gtu decision, below=of init] (cond) {i $\le$ 100?};
        \node[gtu process, below=of cond] (body) {sum += i\\i++};
        \node[gtu process, right=of cond] (avg) {avg = sum / 100};
        \node[gtu output, right=of avg] (output) {sum, avg દર્શાવો};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (cond);
        \draw[gtu arrow] (cond) -- node[left] {હા} (body);
        \draw[gtu arrow] (body.west) -- ++(-0.5,0) |- (cond.west);
        \draw[gtu arrow] (cond) -- node[above] {ના} (avg);
        \draw[gtu arrow] (avg) -- (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{લૂપ કાઉન્ટર}: વેરિએબલ i 1 થી 100 સુધીની સંખ્યાઓ ટ્રેક કરે છે
        \item \textbf{સરવાળાની ગણતરી}: sum વેરિએબલમાં મૂલ્યો એકત્રિત કરે છે
        \item \textbf{ટાઇપ કાસ્ટિંગ}: (float) સરવાળાને ચોક્કસ ભાગાકાર માટે ફ્લોટિંગ-પોઇન્ટમાં કન્વર્ટ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"એક થી સો સરવાળો, પછી ભાગવાથી એવરેજ"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2}{a}{3}
\textbf{gets(S) અને scanf("\%s",S) ફંક્શન વચ્ચેનો તફાવત લખો જ્યાં S સ્ટ્રિંગ છે.}

\begin{solutionbox}
    \textbf{જવાબ}:

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લક્ષણ} & \textbf{gets(S)} & \textbf{scanf("\%s",S)} \\
        \hline
        ઇનપુટ સમાપ્તિ & ન્યૂલાઇન કેરેક્ટર (\textbackslash n) સુધી વાંચે છે & વ્હાઇટસ્પેસ (સ્પેસ, ટેબ, ન્યૂલાઇન) સુધી વાંચે છે \\
        \hline
        વ્હાઇટસ્પેસ હેન્ડલિંગ & સ્પેસ સાથેની સ્ટ્રિંગ વાંચી શકે છે & પ્રથમ વ્હાઇટસ્પેસ પર વાંચવાનું બંધ કરે છે \\
        \hline
        બફર ઓવરફ્લો & બાઉન્ડ્સ ચેકિંગ નથી (અસુરક્ષિત) & બાઉન્ડ્સ ચેકિંગ નથી (અસુરક્ષિત) \\
        \hline
        રિટર્ન વેલ્યુ & સફળતા પર S, ભૂલ પર NULL પરત કરે છે & સફળતાપૂર્વક વાંચેલી આઇટમ્સની સંખ્યા પરત કરે છે \\
        \hline
        રિપ્લેસમેન્ટ & fgets() વધુ સુરક્ષિત વિકલ્પ છે & વિડ્થ લિમિટ સાથે scanf("\%ns",S) વધુ સુરક્ષિત છે \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{સુરક્ષા ચિંતા}: બંને ફંક્શન બફર ઓવરફ્લો કરી શકે છે
        \item \textbf{વ્યવહારિક ઉપયોગ}: gets() પૂર્ણ લાઇન્સ માટે, scanf() એકલ શબ્દો માટે
    \end{itemize}

    \begin{mnemonicbox}"gets મેળવે બધું ન્યૂલાઇન સુધી, scanf અટકે સફેદી જોતાં જ"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2}{b}{4}
\textbf{ઉદાહરણ સાથે લોજિકલ ઓપરેટર અને એસાઈનમેન્ટ ઓપરેટર સમજાવો.}

\begin{solutionbox}
    \textbf{જવાબ}:

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{ઓપરેટર પ્રકાર} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} & \textbf{આઉટપુટ} \\
        \hline
        લોજિકલ & શરતો પર લોજિકલ ઓપરેશન્સ કરે છે & \code{int a = 5, b = 10;} & \\
        \hline
         & લોજિકલ AND (\&\&) & \code{printf("\%d", (a > 0) \&\& (b > 0));} & \code{1} (સાચું) \\
        \hline
         & લોજિકલ OR ($||$) & \code{printf("\%d", (a > 10) || (b > 5));} & \code{1} (સાચું) \\
        \hline
         & લોજિકલ NOT (!) & \code{printf("\%d", !(a == b));} & \code{1} (સાચું) \\
        \hline
        એસાઇનમેન્ટ & વેરિએબલ્સને મૂલ્યો આપે છે & \code{int x = 10;} & \code{x = 10} \\
        \hline
         & સિમ્પલ એસાઇનમેન્ટ (=) & \code{x = 20;} & \code{x = 20} \\
        \hline
         & એડ અને એસાઇન (+=) & \code{x += 5;} & \code{x = 25} \\
        \hline
         & સબટ્રેક્ટ અને એસાઇન (-=) & \code{x -= 10;} & \code{x = 15} \\
        \hline
         & મલ્ટિપ્લાય અને એસાઇન (*=) & \code{x *= 2;} & \code{x = 30} \\
        \hline
         & ડિવાઇડ અને એસાઇન (/=) & \code{x /= 3;} & \code{x = 10} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{લોજિકલ ઓપરેટર્સ}: નિર્ણય લેવામાં ઉપયોગ થાય છે
        \item \textbf{શોર્ટ-સર્કિટ ઇવેલ્યુએશન}: \&\& અને $||$ જરૂરી હોય એટલું જ મૂલ્યાંકન કરે છે
        \item \textbf{કંપાઉન્ડ એસાઇનમેન્ટ}: ઓપરેશન અને એસાઇનમેન્ટ જોડે છે
    \end{itemize}

    \begin{mnemonicbox}"AND માગે બધા સાચા, OR માગે એક; એસાઇનમેન્ટ લે જમણું, ડાબે મૂકે એક"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2}{c}{7}
\textbf{આપેલ બે ફ્લોટિંગ પોઈન્ટ નંબરો વચ્ચેના તમામ પૂર્ણાંકોને પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h>

int main() {
    float num1, num2;
    int start, end, i;
    
    // બે ફ્લોટિંગ પોઇન્ટ નંબર ઇનપુટ લો
    printf("પ્રથમ ફ્લોટિંગ પોઇન્ટ નંબર દાખલ કરો: ");
    scanf("%f", &num1);
    
    printf("બીજો ફ્લોટિંગ પોઇન્ટ નંબર દાખલ કરો: ");
    scanf("%f", &num2);
    
    // નાની સંખ્યાનો સીલિંગ અને મોટી સંખ્યાનો ફ્લોર શોધો
    if(num1 < num2) {
        start = ceil(num1);
        end = floor(num2);
    } else {
        start = ceil(num2);
        end = floor(num1);
    }
    
    // બે સંખ્યાઓ વચ્ચેના તમામ પૂર્ણાંકો પ્રિન્ટ કરો
    printf("%.2f અને %.2f વચ્ચેના પૂર્ણાંકો છે:\n", num1, num2);
    for(i = start; i <= end; i++) {
        printf("%d ", i);
    }
    printf("\n");
    
    return 0;
}
\end{lstlisting}

    \textbf{આકૃતિ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu input] (input) {num1, num2 ઇનપુટ લો};
        \node[gtu decision, below=of input] (cond) {num1 $<$ num2?};
        \node[gtu process, below left=of cond] (case1) {start = ceil(num1)\\end = floor(num2)};
        \node[gtu process, below right=of cond] (case2) {start = ceil(num2)\\end = floor(num1)};
        \node[gtu process, below=of cond, yshift=-3.5cm] (print) {start થી end સુધી પ્રિન્ટ કરો};

        \draw[gtu arrow] (input) -- (cond);
        \draw[gtu arrow] (cond) -| node[above] {હા} (case1);
        \draw[gtu arrow] (cond) -| node[above] {ના} (case2);
        \draw[gtu arrow] (case1) -- (case1 |- print.north);
        \draw[gtu arrow] (case2) -- (case2 |- print.north);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{મેથ ફંક્શન્સ}: ceil() ઉપર રાઉન્ડ કરે છે, floor() નીચે રાઉન્ડ કરે છે
        \item \textbf{રેન્જ નિર્ધારણ}: ઇનપુટ ઓર્ડરથી સ્વતંત્ર કામ કરે છે
        \item \textbf{ઇન્ટીજર એક્સટ્રેક્શન}: ફ્લોટ્સ વચ્ચેના ફક્ત પૂર્ણાંકો પ્રિન્ટ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"નાનાને છત બનાવો, મોટાને ભોંયતળિયું, પછી પ્રિન્ટ કરો વચ્ચેના બધા પૂર્ણાંકો"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{a}{3}
\textbf{ઉદાહરણ સાથે multiple if-else સ્ટેટમેન્ટ સમજાવો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    Multiple if-else સ્ટેટમેન્ટ્સ ક્રમશઃ અનેક શરતોની તપાસ કરવા માટે વપરાય છે, જેમાં દરેક શરત માત્ર ત્યારે જ ચકાસવામાં આવે છે જ્યારે અગાઉની શરતો ખોટી હોય.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int marks;
    
    printf("ગુણ દાખલ કરો (0-100): ");
    scanf("%d", &marks);
    
    if(marks >= 80) {
        printf("ગ્રેડ: A\n");
    } else if(marks >= 70) {
        printf("ગ્રેડ: B\n");
    } else if(marks >= 60) {
        printf("ગ્રેડ: C\n");
    } else if(marks >= 50) {
        printf("ગ્રેડ: D\n");
    } else {
        printf("ગ્રેડ: F\n");
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{આકૃતિ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu input] (input) {ગુણ ઇનપુટ લો};
        \node[gtu decision, below=of input] (cond1) {marks $\ge$ 80?};
        \node[gtu process, right=of cond1] (gradeA) {ગ્રેડ: A};
        \node[gtu decision, below=of cond1] (cond2) {marks $\ge$ 70?};
        \node[gtu process, right=of cond2] (gradeB) {ગ્રેડ: B};
        \node[gtu decision, below=of cond2] (cond3) {marks $\ge$ 60?};
        \node[gtu process, right=of cond3] (gradeC) {ગ્રેડ: C};
        \node[gtu decision, below=of cond3] (cond4) {marks $\ge$ 50?};
        \node[gtu process, right=of cond4] (gradeD) {ગ્રેડ: D};
        \node[gtu process, below=of cond4] (gradeF) {ગ્રેડ: F};
        
        \draw[gtu arrow] (input) -- (cond1);
        \draw[gtu arrow] (cond1) -- node[above] {હા} (gradeA);
        \draw[gtu arrow] (cond1) -- node[right] {ના} (cond2);
        \draw[gtu arrow] (cond2) -- node[above] {હા} (gradeB);
        \draw[gtu arrow] (cond2) -- node[right] {ના} (cond3);
        \draw[gtu arrow] (cond3) -- node[above] {હા} (gradeC);
        \draw[gtu arrow] (cond3) -- node[right] {ના} (cond4);
        \draw[gtu arrow] (cond4) -- node[above] {હા} (gradeD);
        \draw[gtu arrow] (cond4) -- node[right] {ના} (gradeF);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ક્રમિક પરીક્ષણ}: ફક્ત એક બ્લોક જ એક્ઝિક્યુટ થાય છે
        \item \textbf{કાર્યક્ષમતા}: સાચી શરત મળ્યા પછી તપાસ બંધ થઈ જાય છે
    \end{itemize}

    \begin{mnemonicbox}"જો આ તો એ, નહીં તો જો પેલું તો એમ, નહીં તો જો અન્ય તો અલગ"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{b}{4}
\textbf{While લૂપ અને for લૂપની કામગીરી જણાવો.}

\begin{solutionbox}
    \textbf{જવાબ}:

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{લૂપ પ્રકાર} & \textbf{કામગીરી} & \textbf{સિન્ટેક્સ} & \textbf{ઉપયોગ કેસ} \\
        \hline
        while લૂપ & 1. શરત ચકાસો \newline 2. જો સાચી હોય તો બોડી એક્ઝિક્યુટ કરો \newline 3. શરત ખોટી થાય ત્યાં સુધી 1-2 પગલાં પુનરાવર્તિત કરો & \code{while(condition) \{}\newline \code{    // સ્ટેટમેન્ટ્સ}\newline \code{\}} & જ્યારે પુનરાવર્તનની સંખ્યા અગાઉથી ખબર ન હોય \\
        \hline
        for લૂપ & 1. ઇનિશિયલાઇઝેશન એક વખત એક્ઝિક્યુટ કરો \newline 2. શરત ચકાસો \newline 3. જો સાચી હોય તો બોડી એક્ઝિક્યુટ કરો \newline 4. અપડેટ સ્ટેટમેન્ટ એક્ઝિક્યુટ કરો \newline 5. શરત ખોટી થાય ત્યાં સુધી 2-4 પગલાં પુનરાવર્તિત કરો & \code{for(init; cond; update) \{}\newline \code{    // સ્ટેટમેન્ટ્સ}\newline \code{\}} & જ્યારે પુનરાવર્તનની સંખ્યા અગાઉથી ખબર હોય \\
        \hline
    \end{tabulary}

    \textbf{તુલના:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        % While Loop
        \node[gtu start] (w_start) {શરૂ While};
        \node[gtu decision, below=of w_start] (w_cond) {શરત?};
        \node[gtu process, below=of w_cond] (w_body) {બોડી};
        \node[gtu stop, right=of w_cond] (w_end) {અંત};

        \draw[gtu arrow] (w_start) -- (w_cond);
        \draw[gtu arrow] (w_cond) -- node[left] {હા} (w_body);
        \draw[gtu arrow] (w_body.west) -- ++(-0.5,0) |- (w_cond.west);
        \draw[gtu arrow] (w_cond) -- node[above] {ના} (w_end);

        % For Loop - Shifted right
        \node[gtu start, right=of w_end, xshift=1cm] (f_start) {શરૂ For};
        \node[gtu process, below=of f_start] (f_init) {ઇનિશિયલાઇઝેશન};
        \node[gtu decision, below=of f_init] (f_cond) {શરત?};
        \node[gtu process, below=of f_cond] (f_body) {બોડી};
        \node[gtu process, left=of f_body] (f_update) {અપડેટ};
        \node[gtu stop, right=of f_cond] (f_end) {અંત};

        \draw[gtu arrow] (f_start) -- (f_init);
        \draw[gtu arrow] (f_init) -- (f_cond);
        \draw[gtu arrow] (f_cond) -- node[left] {હા} (f_body);
        \draw[gtu arrow] (f_body) -- (f_update);
        \draw[gtu arrow] (f_update) |- (f_cond);
        \draw[gtu arrow] (f_cond) -- node[above] {ના} (f_end);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{એન્ટ્રી કંટ્રોલ}: બંને એક્ઝિક્યુશન પહેલાં શરત ચકાસે છે
        \item \textbf{ઘટકો}: for લૂપ ઇનિશિયલાઇઝેશન, શરત અને અપડેટ જોડે છે
    \end{itemize}

    \begin{mnemonicbox}"WHILE તપાસે પછી કરે, FOR શરૂ કરે તપાસે કરે અપડેટ કરે"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{c}{7}
\textbf{આપેલ સંખ્યાના ફેક્ટોરિયલ શોધવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num, i;
    unsigned long long factorial = 1;
    
    // એક સંખ્યા ઇનપુટ લો
    printf("ધનાત્મક પૂર્ણાંક દાખલ કરો: ");
    scanf("%d", &num);
    
    // તપાસો કે સંખ્યા નકારાત્મક તો નથી
    if(num < 0) {
        printf("ભૂલ: નકારાત્મક સંખ્યાઓનું ફેક્ટોરિયલ વ્યાખ્યાયિત નથી.\n");
    } else {
        // ફેક્ટોરિયલની ગણતરી કરો
        for(i = 1; i <= num; i++) {
            factorial *= i;
        }
        
        printf("%d નું ફેક્ટોરિયલ = %llu\n", num, factorial);
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{આકૃતિ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂ};
        \node[gtu input, below=of start] (input) {સંખ્યા ઇનપુટ લો};
        \node[gtu decision, below=of input] (check) {સંખ્યા $<$ 0?};
        \node[gtu output, right=of check] (error) {ભૂલ દર્શાવો};
        \node[gtu process, below=of check] (init) {fact = 1, i = 1};
        \node[gtu decision, below=of init] (loop) {i $\le$ સંખ્યા?};
        \node[gtu process, right=of loop] (calc) {fact *= i\\i++};
        \node[gtu output, below=of loop] (output) {ફેક્ટોરિયલ દર્શાવો};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (check);
        \draw[gtu arrow] (check) -- node[above] {હા} (error);
        \draw[gtu arrow] (error) |- (stop);
        \draw[gtu arrow] (check) -- node[left] {ના} (init);
        \draw[gtu arrow] (init) -- (loop);
        \draw[gtu arrow] (loop) -- node[above] {હા} (calc);
        \draw[gtu arrow] (calc) |- (init.south east); 
        \draw[gtu arrow] (loop) -- node[left] {ના} (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ડેટા ટાઇપ}: મોટા ફેક્ટોરિયલ માટે unsigned long long
        \item \textbf{ભૂલ હેન્ડલિંગ}: નકારાત્મક ઇનપુટ માટે ચકાસણી
        \item \textbf{લૂપ અમલીકરણ}: ક્રમિક પૂર્ણાંકોનો ગુણાકાર
    \end{itemize}

    \begin{mnemonicbox}"ફેક્ટોરિયલ ફોર્મ્યુલા: એકથી સંખ્યા સુધી ગુણાકાર"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{3}{a}{3}
\textbf{ઉદાહરણ સાથે switch-case સ્ટેટમેન્ટની કામગીરી સમજાવો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    Switch-case સ્ટેટમેન્ટ એ એક મલ્ટી-વે ડિસીઝન મેકર છે જે અભિવ્યક્તિના મૂલ્યને વિવિધ કેસ મૂલ્યો સામે તપાસે છે અને મેચ થતા કેસ બ્લોકને એક્ઝિક્યુટ કરે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int day;
    
    printf("દિવસનો નંબર દાખલ કરો (1-7): ");
    scanf("%d", &day);
    
    switch(day) {
        case 1: printf("સોમવાર\n"); break;
        case 2: printf("મંગળવાર\n"); break;
        case 3: printf("બુધવાર\n"); break;
        case 4: printf("ગુરુવાર\n"); break;
        case 5: printf("શુક્રવાર\n"); break;
        case 6: printf("શનિવાર\n"); break;
        case 7: printf("રવિવાર\n"); break;
        default: printf("અમાન્ય દિવસ નંબર\n");
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{આકૃતિ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu input] (input) {દિવસ ઇનપુટ લો};
        \node[gtu decision, below=of input] (switch) {switch(day)};
        
        \node[gtu process, below left=of switch] (c1) {case 1};
        \node[gtu process, below=of switch] (c2) {case ...};
        \node[gtu process, below right=of switch] (def) {default};
        
        \node[gtu output, below=of c1] (o1) {સોમવાર};
        \node[gtu output, below=of c2] (o2) {...};
        \node[gtu output, below=of def] (odef) {અમાન્ય};
        
        \node[gtu stop, below=of o2] (end) {અંત};

        \draw[gtu arrow] (input) -- (switch);
        \draw[gtu arrow] (switch) -- (c1);
        \draw[gtu arrow] (switch) -- (c2);
        \draw[gtu arrow] (switch) -- (def);
        
        \draw[gtu arrow] (c1) -- (o1);
        \draw[gtu arrow] (c2) -- (o2);
        \draw[gtu arrow] (def) -- (odef);
        
        \draw[gtu arrow] (o1) -- (end);
        \draw[gtu arrow] (o2) -- (end);
        \draw[gtu arrow] (odef) -- (end);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{અભિવ્યક્તિ મૂલ્યાંકન}: ફક્ત ઇન્ટીજર અથવા કેરેક્ટર ટાઈપ્સ
        \item \textbf{કેસ મેચિંગ}: break સુધી મેચીંગ કેસ એક્ઝિક્યુટ કરે છે
        \item \textbf{ડિફોલ્ટ કેસ}: કોઈ કેસ મેચ ન થાય ત્યારે એક્ઝિક્યુટ થાય છે
    \end{itemize}

    \begin{mnemonicbox}"SWITCH મૂલ્ય, CASE મેળ, BREAK બહાર, DEFAULT બચાવ"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{3}{b}{4}
\textbf{break અને continue કીવર્ડ વ્યાખ્યાયિત કરો.}

\begin{solutionbox}
    \textbf{જવાબ}:

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{કીવર્ડ} & \textbf{વ્યાખ્યા} & \textbf{હેતુ} & \textbf{ઉદાહરણ} \\
        \hline
        break & સૌથી અંદરના લૂપ અથવા switch સ્ટેટમેન્ટને તરત જ સમાપ્ત કરે છે & જ્યારે કોઈ ચોક્કસ શરત પૂરી થાય ત્યારે લૂપમાંથી બહાર નીકળવા માટે & \code{for(i=1; i<=10; i++) \{} \newline \code{    if(i == 5) break;} \newline \code{    printf("\%d", i);} \newline \code{\} // 1 2 3 4} \\
        \hline
        continue & લૂપના વર્તમાન પુનરાવર્તનના બાકીના ભાગને છોડીને લૂપના આગલા પુનરાવર્તન પર જાય છે & લૂપને સમાપ્ત કર્યા વિના ચોક્કસ પુનરાવર્તનો છોડવા માટે & \code{for(i=1; i<=10; i++) \{} \newline \code{    if(i == 5) continue;} \newline \code{    printf("\%d", i);} \newline \code{\} // 1 2 3 4 6 7} \\
        \hline
    \end{tabulary}

    \textbf{વર્તન તુલના:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        % Break
        \node[gtu start] (b_check) {શરત};
        \node[gtu decision, below=of b_check] (b_dec) {break?};
        \node[gtu stop, left=of b_dec] (b_exit) {બહાર નીકળો};
        \node[gtu process, right=of b_dec] (b_cont) {ચાલુ રાખો};
        
        \draw[gtu arrow] (b_check) -- (b_dec);
        \draw[gtu arrow] (b_dec) -- node[above] {હા} (b_exit);
        \draw[gtu arrow] (b_dec) -- node[above] {ના} (b_cont);

        % Continue
        \node[gtu start, right=of b_cont, xshift=1cm] (c_check) {શરત};
        \node[gtu decision, below=of c_check] (c_dec) {continue?};
        \node[gtu process, left=of c_dec] (c_skip) {છોડી દો};
        \node[gtu process, right=of c_dec] (c_exec) {એક્ઝિક્યુટ કરો};
        \node[gtu process, below=of c_skip] (c_next) {આગલું પુનરાવર્તન};
        
        \draw[gtu arrow] (c_check) -- (c_dec);
        \draw[gtu arrow] (c_dec) -- node[above] {હા} (c_skip);
        \draw[gtu arrow] (c_dec) -- node[above] {ના} (c_exec);
        \draw[gtu arrow] (c_skip) -- (c_next);
        \draw[gtu arrow] (c_exec) |- (c_next);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{સ્કોપ}: બંને માત્ર સૌથી અંદરના લૂપને અસર કરે છે
        \item \textbf{કંટ્રોલ ટ્રાન્સફર}: break લૂપમાંથી બહાર નીકળે છે, continue આગલા પુનરાવર્તન પર જાય છે
    \end{itemize}

    \begin{mnemonicbox}"BREAK રૂમ છોડે છે, CONTINUE આગલી ડાન્સ મૂવ પર જાય છે"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{3}{c}{7}
\textbf{કીબોર્ડ પરથી લાઈન(n) ની સંખ્યા વાંચી અને નીચે દશાર્વેલ ટ્રાઇંગલ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લાખો.}

\begin{verbatim}
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
\end{verbatim}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int n, i, j;
    
    // લાઈનની સંખ્યા ઇનપુટ લો
    printf("લાઈનની સંખ્યા દાખલ કરો: ");
    scanf("%d", &n);
    
    // ટ્રાયેંગલ પેટર્ન પ્રિન્ટ કરો
    for(i = 1; i <= n; i++) {
        // દરેક રોમાં 1 થી i સુધીની સંખ્યાઓ પ્રિન્ટ કરો
        for(j = 1; j <= i; j++) {
            printf("%d ", j);
        }
        printf("\n");
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{પ્રોગ્રામ પ્રવાહ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu input] (input) {n ઇનપુટ લો};
        \node[gtu process, below=of input] (outer) {i = 1};
        \node[gtu decision, below=of outer] (check_i) {i $\le$ n?};
        
        \node[gtu process, right=of check_i] (inner) {j = 1};
        \node[gtu decision, right=of inner] (check_j) {j $\le$ i?};
        \node[gtu output, below=of check_j] (print_j) {j પ્રિન્ટ કરો};
        \node[gtu process, left=of print_j] (inc_j) {j++};
        
        \node[gtu output, below=of check_i, yshift=-2cm] (newline) {\\n પ્રિન્ટ કરો};
        \node[gtu process, left=of newline] (inc_i) {i++};
        \node[gtu stop, left=of check_i] (stop) {અંત};

        \draw[gtu arrow] (input) -- (outer);
        \draw[gtu arrow] (outer) -- (check_i);
        \draw[gtu arrow] (check_i) -- node[above] {હા} (inner);
        \draw[gtu arrow] (inner) -- (check_j);
        \draw[gtu arrow] (check_j) -- node[right] {હા} (print_j);
        \draw[gtu arrow] (print_j) -- (inc_j);
        \draw[gtu arrow] (inc_j) |- (check_j);
        
        \draw[gtu arrow] (check_j) -- node[right] {ના} (newline); 
        \draw[gtu arrow] (newline) -- (inc_i);
        \draw[gtu arrow] (inc_i) |- (check_i);
        \draw[gtu arrow] (check_i) -- node[above] {ના} (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{નેસ્ટેડ લૂપ્સ}: આઉટર લૂપ રો માટે, ઇનર લૂપ કોલમ માટે
        \item \textbf{પેટર્ન લોજિક}: રો નંબર નક્કી કરે છે કે કેટલી સંખ્યાઓ પ્રિન્ટ કરવી
        \item \textbf{સંખ્યા ક્રમ}: દરેક રો 1 થી રો નંબર સુધી પ્રિન્ટ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"રો નક્કી કરે મર્યાદા, કોલમ પ્રિન્ટ કરે એકથી રો સુધી"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{a}{3}
\textbf{Nested if-else સ્ટેટમેન્ટને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    Nested if-else સ્ટેટમેન્ટ્સ એ if-else કન્સ્ટ્રક્ટ્સ છે જે બીજા if અથવા else બ્લોકની અંદર મૂકવામાં આવે છે, જે વધુ જટિલ શરતી તર્ક અને નિર્ણય લેવાના બહુવિધ સ્તરોની મંજૂરી આપે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int age;
    char hasID;
    
    printf("ઉંમર દાખલ કરો: ");
    scanf("%d", &age);
    
    printf("શું તમારી પાસે ID છે? (Y/N): ");
    scanf(" %c", &hasID);
    
    if(age >= 18) {
        if(hasID == 'Y' || hasID == 'y') {
            printf("તમે મત આપી શકો છો!\n");
        } else {
            printf("મત આપવા માટે ID જરૂરી છે.\n");
        }
    } else {
        printf("મત આપવા માટે તમારી ઉંમર 18 કે તેથી વધુ હોવી જોઈએ.\n");
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{નિર્ણય વૃક્ષ:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu input] (input) {ઉંમર અને hasID ઇનપુટ લો};
        \node[gtu decision, below=of input] (check_age) {age $\ge$ 18?};
        \node[gtu decision, below left=of check_age, xshift=-2cm] (check_id) {hasID == 'Y'\\અથવા 'y'?};
        \node[gtu process, right=of check_age] (too_young) {ઉંમર 18 કે તેથી વધુ હોવી જરૂરી};
        
        \node[gtu process, below left=of check_id] (vote) {તમે મત આપી શકો છો!};
        \node[gtu process, below right=of check_id] (need_id) {મત આપવા માટે ID જરૂરી છે};

        \draw[gtu arrow] (input) -- (check_age);
        \draw[gtu arrow] (check_age) -| node[above] {હા} (check_id);
        \draw[gtu arrow] (check_age) -- node[above] {ના} (too_young);
        
        \draw[gtu arrow] (check_id) -| node[above] {હા} (vote);
        \draw[gtu arrow] (check_id) -| node[above] {ના} (need_id);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{હાયરાર્કિકલ શરતો}: શરતોનું સ્તરમાં મૂલ્યાંકન કરે છે
        \item \textbf{ઇન્ડેન્ટેશન}: નેસ્ટેડ સ્ટ્રક્ચર્સની વાંચનક્ષમતા સુધારે છે
        \item \textbf{મલ્ટી-ફેક્ટર નિર્ણયો}: એકાધિક માપદંડો જોડે છે
    \end{itemize}

    \begin{mnemonicbox}"If ની અંદર if, ઊંડી શરતો ચકાસે"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{b}{4}
\textbf{One-dimensional array ના initialization નું વર્ણન કરો.}

\begin{solutionbox}
    \textbf{જવાબ}:

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{ઇનિશિયલાઇઝેશન પદ્ધતિ} & \textbf{સિન્ટેક્સ} & \textbf{ઉદાહરણ} & \textbf{વર્ણન} \\
        \hline
        સાઇઝ સાથે ડેક્લેરેશન & \code{datatype arrayname[size];} & \code{int marks[5];} & નિર્દિષ્ટ સાઇઝ સાથે એરે બનાવે છે, એલિમેન્ટ્સમાં ગાર્બેજ વેલ્યુ હોય છે \\
        \hline
        ઇનિશિયલાઇઝેશન સાથે ડેક્લેરેશન & \code{datatype arrayname[s] = (v);} & \code{int ages[4] = (21, 19, 25, 32);} & ચોક્કસ મૂલ્યો સાથે એરે બનાવે અને ઇનિશિયલાઇઝ કરે છે \\
        \hline
        આંશિક ઇનિશિયલાઇઝેશન & \code{datatype arrayname[s] = (v);} & \code{int nums[5] = (1, 2);} & પ્રથમ એલિમેન્ટ્સ ઇનિશિયલાઇઝ કરે છે, બાકીના શૂન્ય થાય છે \\
        \hline
        સાઇઝ ઇન્ફરન્સ & \code{datatype arrayname[] = (v);} & \code{int scores[] = (95, 88);} & ઇનિશિયલાઇઝર્સની સંખ્યા દ્વારા સાઇઝ નક્કી થાય છે \\
        \hline
        વ્યક્તિગત એલિમેન્ટ & \code{arrayname[index] = value;} & \code{marks[0] = 85;} & ચોક્કસ એલિમેન્ટને મૂલ્ય આપે છે \\
        \hline
    \end{tabulary}

    \textbf{એરે વિઝ્યુલાઇઝેશન:}

    \begin{center}
    \begin{tikzpicture}
        \node[draw, minimum size=1cm] (a0) at (0,0) {10};
        \node[draw, minimum size=1cm, right=0cm of a0] (a1) {20};
        \node[draw, minimum size=1cm, right=0cm of a1] (a2) {30};
        \node[draw, minimum size=1cm, right=0cm of a2] (a3) {40};
        \node[draw, minimum size=1cm, right=0cm of a3] (a4) {50};
        
        \node[below=0.2cm of a0] {[0]};
        \node[below=0.2cm of a1] {[1]};
        \node[below=0.2cm of a2] {[2]};
        \node[below=0.2cm of a3] {[3]};
        \node[below=0.2cm of a4] {[4]};
        
        \node[left=0.5cm of a0] {Index:};
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ઝીરો-ઇન્ડેક્સિંગ}: પ્રથમ એલિમેન્ટ ઇન્ડેક્સ 0 પર
        \item \textbf{કન્ટિગ્યુઅસ મેમરી}: એલિમેન્ટ્સ ક્રમશઃ સ્ટોર થાય છે
        \item \textbf{સાઇઝ લિમિટેશન}: સાઇઝ કંપાઇલ ટાઇમે જાણીતી હોવી જરૂરી છે
    \end{itemize}

    \begin{mnemonicbox}"પહેલા સાઇઝ જાહેર કરો, પછી મૂલ્યો ભરો અથવા કંપાઇલરને ગણવા દો"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{c}{7}
\textbf{અરેને વ્યાખ્યાયિત કરો અને સ્ટ્રિંગને રિવર્સ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    એરે એ સમાન ડેટા આઇટમ્સનો સંગ્રહ છે જે સળંગ મેમરી સ્થાનો પર સંગ્રહિત થયેલા હોય છે અને એક સામાન્ય નામનો ઉપયોગ કરીને એક્સેસ કરવામાં આવે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>

int main() {
    char str[100], reversed[100];
    int i, j, length;
    
    // સ્ટ્રિંગ ઇનપુટ લો
    printf("એક સ્ટ્રિંગ દાખલ કરો: ");
    gets(str);
    
    // સ્ટ્રિંગની લંબાઈ શોધો
    length = strlen(str);
    
    // સ્ટ્રિંગને રિવર્સ કરો
    for(i = length - 1, j = 0; i >= 0; i--, j++) {
        reversed[j] = str[i];
    }
    
    // NULL ટર્મિનેટર ઉમેરો
    reversed[j] = '\0';
    
    // રિવર્સ કરેલી સ્ટ્રિંગ દર્શાવો
    printf("રિવર્સ કરેલી સ્ટ્રિંગ: %s\n", reversed);
    
    return 0;
}
\end{lstlisting}

    \textbf{એલ્ગોરિધમ વિઝ્યુલાઇઝેશન:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu block] (orig) {ઓરિજિનલ: 'HELLO'};
        \node[gtu block, below=of orig] (h) {H};
        \node[gtu block, right=0.2cm of h] (e) {E};
        \node[gtu block, right=0.2cm of e] (l1) {L};
        \node[gtu block, right=0.2cm of l1] (l2) {L};
        \node[gtu block, right=0.2cm of l2] (o) {O};
        
        \node[gtu block, below=of h] (r0) {reversed[4]};
        \node[gtu block, below=of e] (r1) {reversed[3]};
        \node[gtu block, below=of l1] (r2) {reversed[2]};
        \node[gtu block, below=of l2] (r3) {reversed[1]};
        \node[gtu block, below=of o] (r4) {reversed[0]};
        
        \node[gtu block, below=of r2] (final) {રિવર્સ: 'OLLEH'};
        
        \draw[gtu arrow] (orig) -- (l1);
        \draw[gtu arrow] (h) -- (r0);
        \draw[gtu arrow] (e) -- (r1);
        \draw[gtu arrow] (l1) -- (r2);
        \draw[gtu arrow] (l2) -- (r3);
        \draw[gtu arrow] (o) -- (r4);
        \draw[gtu arrow] (r2) -- (final);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{કેરેક્ટર એરે}: NULL ટર્મિનેટર સાથે સ્ટ્રિંગ સ્ટોર કરે છે
        \item \textbf{ટુ-પોઇન્ટર ટેકનિક}: એક ઓરિજિનલ માટે, એક રિવર્સ માટે
        \item \textbf{ઝીરો-બેઝ્ડ ઇન્ડેક્સિંગ}: એરે ઇન્ડેક્સ 0 થી શરૂ થાય છે
    \end{itemize}

    \begin{mnemonicbox}"અંતથી શરૂ કરો, શરૂઆતમાં મૂકો, શૂન્ય પર અટકો"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{4}{a}{3}
\textbf{do while loop ઉદાહરણ સાથે સમજાવો}

\begin{solutionbox}
    \textbf{જવાબ}:
    do-while લૂપ એ એક એક્ઝિટ-કંટ્રોલ્ડ લૂપ છે જે શરત ચકાસ્યા પહેલાં ઓછામાં ઓછી એક વખત લૂપ બોડી એક્ઝિક્યુટ કરે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num, sum = 0;
    
    do {
        printf("એક સંખ્યા દાખલ કરો (0 રોકવા માટે): ");
        scanf("%d", &num);
        sum += num;
    } while(num != 0);
    
    printf("બધી દાખલ કરેલી સંખ્યાઓનો સરવાળો: %d\n", sum);
    
    return 0;
}
\end{lstlisting}

    \textbf{લૂપ એક્ઝિક્યુશન ફ્લો:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂ};
        \node[gtu process, below=of start] (init) {sum = 0};
        \node[gtu input, below=of init] (input) {num ઇનપુટ લો};
        \node[gtu process, below=of input] (calc) {sum += num};
        \node[gtu decision, below=of calc] (cond) {num != 0?};
        \node[gtu output, right=of cond] (output) {sum દર્શાવો};
        \node[gtu stop, below=of output] (stop) {અંત};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (cond);
        \draw[gtu arrow] (cond.west) -- ++(-0.5,0) |- node[left] {હા} (input.west);
        \draw[gtu arrow] (cond) -- node[above] {ના} (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{એક્ઝિક્યુશન ઓર્ડર}: પહેલા બોડી, પછી શરત ચકાસણી
        \item \textbf{ગેરેન્ટેડ એક્ઝિક્યુશન}: લૂપ બોડી હંમેશા ઓછામાં ઓછી એક વખત એક્ઝિક્યુટ થાય છે
        \item \textbf{ટર્મિનેશન}: શરત લૂપના તળિયે મૂલ્યાંકિત થાય છે
    \end{itemize}

    \begin{mnemonicbox}"પહેલા કરો, પછી પૂછો"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{4}{b}{4}
\textbf{પોઇન્ટરને વ્યાખ્યાયિત કરો અને ઉદાહરણ સાથે પોઇન્ટરનું વર્ણન કરો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    પોઇન્ટર એક એવું વેરિએબલ છે જે અન્ય વેરિએબલનું મેમરી એડ્રેસ સ્ટોર કરે છે.

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{પોઇન્ટર કોન્સેપ્ટ} & \textbf{વર્ણન} & \textbf{ઉદાહરણ} \\
        \hline
        ડેક્લેરેશન & Data\_type *pointer\_name; & \code{int *ptr;} \\
        \hline
        ઇનિશિયલાઇઝેશન & વેરિએબલનું એડ્રેસ એસાઇન કરવું & \code{int n = 10; int *ptr = \&n;} \\
        \hline
        ડીરેફરન્સ & એડ્રેસ પરના મૂલ્યને એક્સેસ કરવું & \code{*ptr} (10 આપે છે) \\
        \hline
        એડ્રેસ ઓપરેટર & વેરિએબલનું એડ્રેસ મેળવે છે & \code{\&n} \\
        \hline
        NULL પોઇન્ટર & કશું પોઇન્ટ ન કરતાં પોઇન્ટર & \code{int *ptr = NULL;} \\
        \hline
    \end{tabulary}

    \textbf{પોઇન્ટર વિઝ્યુલાઇઝેશન:}

    \begin{center}
    \begin{tikzpicture}
        \node[draw, rectangle split, rectangle split parts=2] (mem1) {
            Address: 1000 \nodepart{second} num: 10
        };
        \node[draw, rectangle split, rectangle split parts=2, right=2cm of mem1] (mem2) {
            Address: 2000 \nodepart{second} ptr: 1000
        };
        \draw[->, thick] (mem2.south) .. controls +(0,-1) and +(0,-1) .. (mem1.south) node[midway, below] {Points to};
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ઇનડાયરેક્ટ એક્સેસ}: તેમના એડ્રેસ દ્વારા વેરિએબલ્સ એક્સેસ કરે છે
        \item \textbf{મેમરી મેનિપ્યુલેશન}: કાર્યક્ષમતા માટે ડાયરેક્ટ મેમરી એક્સેસ
        \item \textbf{ડાયનેમિક મેમરી}: રનટાઇમ દરમિયાન એલોકેશન/ડીએલોકેશન સક્ષમ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"પોઇન્ટર્સ એડ્રેસને પોઇન્ટ કરે છે, સ્ટાર્સ મૂલ્યોને ડીરેફરન્સ કરે છે"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{4}{c}{7}
\textbf{પોઇન્ટર વ્યાખ્યાયિત કરો અને પોઇન્ટર આર્ગ્યુમેન્ટનો ઉપયોગ કરીને બે પૂર્ણાંકોની અદલા બદલી કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    પોઇન્ટર એ એક વેરિએબલ છે જે અન્ય વેરિએબલના મેમરી એડ્રેસને ધરાવે છે, જે ડેટાનો પરોક્ષ એક્સેસ અને મેનિપ્યુલેશન કરવાની મંજૂરી આપે છે.

\begin{lstlisting}[language=C]
#include <stdio.h>

// પોઇન્ટર્સનો ઉપયોગ કરીને બે ઇન્ટીજર્સની અદલાબદલી કરવાનું ફંક્શન
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int num1, num2;
    
    // બે પૂર્ણાંક ઇનપુટ લો
    printf("પ્રથમ સંખ્યા દાખલ કરો: ");
    scanf("%d", &num1);
    
    printf("બીજી સંખ્યા દાખલ કરો: ");
    scanf("%d", &num2);
    
    printf("અદલાબદલી પહેલાં: num1 = %d, num2 = %d\n", num1, num2);
    
    // num1 અને num2 ના એડ્રેસ સાથે swap ફંક્શન કૉલ કરો
    swap(&num1, &num2);
    
    printf("અદલાબદલી પછી: num1 = %d, num2 = %d\n", num1, num2);
    
    return 0;
}
\end{lstlisting}

    \textbf{સ્વેપ પ્રોસેસ વિઝ્યુલાઇઝેશન:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu block] (start) {num1, num2};
        \node[gtu process, below=of start] (temp) {temp = *a};
        \node[gtu process, below=of temp] (swap1) {*a = *b};
        \node[gtu process, below=of swap1] (swap2) {*b = temp};
        \node[gtu block, below=of swap2] (end) {Swapped};
        
        \draw[gtu arrow] (start) -- (temp);
        \draw[gtu arrow] (temp) -- (swap1);
        \draw[gtu arrow] (swap1) -- (swap2);
        \draw[gtu arrow] (swap2) -- (end);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{પાસ બાય રેફરન્સ}: પોઇન્ટર્સ ફંક્શન્સને મૂળ વેરિએબલ્સ મોડિફાય કરવાની મંજૂરી આપે છે
        \item \textbf{ટેમ્પરરી વેરિએબલ}: ડેટા નુકસાન વિના સ્વેપ કરવા માટે જરૂરી છે
        \item \textbf{ફંક્શન પેરામીટર}: પોઇન્ટર આર્ગ્યુમેન્ટ્સ એડ્રેસ પાસ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"એડ્રેસથી પકડો, કન્ટેન્ટ બદલો, હાજરી વિના"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{a}{3}
\textbf{50 અને 500 ની વચ્ચે 7 વડે ભાગી શકાય તેવી સંખ્યાઓ શોધવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i, count = 0;
    
    printf("50 અને 500 ની વચ્ચે 7 વડે ભાગી શકાય તેવી સંખ્યાઓ:\n");
    
    // 7 વડે ભાગી શકાય તેવી સંખ્યાઓ શોધો અને પ્રિન્ટ કરો
    for(i = 50; i <= 500; i++) {
        if(i % 7 == 0) {
            printf("%d ", i);
            count++;
            
            // વધુ સારી વાંચનક્ષમતા માટે દર લાઇને 10 સંખ્યાઓ પ્રિન્ટ કરો
            if(count % 10 == 0)
                printf("\n");
        }
    }
    
    printf("\nકુલ સંખ્યા: %d\n", count);
    
    return 0;
}
\end{lstlisting}

    \textbf{એલ્ગોરિધમ વિઝ્યુલાઇઝેશન:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {શરૂ};
        \node[gtu process, below=of start] (init) {i = 50, count = 0};
        \node[gtu decision, below=of init] (cond) {i $\le$ 500?};
        \node[gtu decision, right=of cond, xshift=1cm] (div) {i \% 7 == 0?};
        \node[gtu process, below=of div] (print) {i પ્રિન્ટ કરો\\count++};
        \node[gtu process, right=of div] (inc) {i++};
        \node[gtu output, below=of cond, yshift=-3cm] (total) {કુલ સંખ્યા દર્શાવો};
        \node[gtu stop, below=of total] (stop) {અંત};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (cond);
        \draw[gtu arrow] (cond) -- node[above] {હા} (div);
        \draw[gtu arrow] (div) -- node[right] {હા} (print);
        \draw[gtu arrow] (div) -- node[above] {ના} (inc);
        \draw[gtu arrow] (print) -| (inc);
        \draw[gtu arrow] (inc) |- (cond);
        \draw[gtu arrow] (cond) -- node[right] {ના} (total);
        \draw[gtu arrow] (total) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{મોડ્યુલો ઓપરેટર}: i \% 7 == 0 વિભાજ્યતા ચકાસે છે
        \item \textbf{આઉટપુટ ફોર્મેટિંગ}: વાંચવા માટે લાઇન બ્રેક
        \item \textbf{કાઉન્ટર વેરિએબલ}: કેટલી સંખ્યાઓ મળી તે ટ્રેક કરે છે
    \end{itemize}

    \begin{mnemonicbox}"સાતથી ભાગો, શૂન્ય શેષ જીતે"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{b}{4}
\textbf{કીબોર્ડ પરથી પૂર્ણાંક વાંચી આપેલ સંખ્યા એકી છે કે બેકી છે તે પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int number;
    
    printf("એક પૂર્ણાંક દાખલ કરો: ");
    scanf("%d", &number);
    
    if(number % 2 == 0) {
        printf("%d એક બેકી સંખ્યા છે.\n", number);
    } else {
        printf("%d એક એકી સંખ્યા છે.\n", number);
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{નિર્ણય લોજિક:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu input] (input) {સંખ્યા ઇનપુટ લો};
        \node[gtu decision, below=of input] (check) {number \% 2 == 0?};
        \node[gtu output, below left=of check] (even) {બેકી સંખ્યા};
        \node[gtu output, below right=of check] (odd) {એકી સંખ્યા};
        \node[gtu stop, below=of check, yshift=-2cm] (stop) {અંત};

        \draw[gtu arrow] (input) -- (check);
        \draw[gtu arrow] (check) -| node[above] {હા} (even);
        \draw[gtu arrow] (check) -| node[above] {ના} (odd);
        \draw[gtu arrow] (even) |- (stop);
        \draw[gtu arrow] (odd) |- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{મોડ્યુલો ટેસ્ટ}: બેકી સંખ્યાઓને 2 વડે ભાગતાં શેષ 0 આવે છે
        \item \textbf{બાઇનરી રીપ્રેઝન્ટેશન}: બેકી સંખ્યાનો અંતિમ બિટ 0 હોય છે, એકી સંખ્યાનો 1 હોય છે
        \item \textbf{સિમ્પલ એલ્ગોરિધમ}: નેગેટિવ સંખ્યાઓ સહિત બધા પૂર્ણાંકો માટે કામ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"બેકી અંતે શૂન્ય, એકી અંતે એક"\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{c}{7}
\textbf{સ્ટ્રકચર વ્યાખ્યાયિત કરો? સમજાવો કે તે એરેથી કેવી રીતે અલગ છે? પુસ્તકો વિશે નીચેની માહિતી સાચવવા માટે પુસ્તક નામનું સ્ટ્રકચર વિકસાવો. પુસ્તકનું શીર્ષક, લેખકનું નામ, કિંમત અને પાનાંની સંખ્યા.}

\begin{solutionbox}
    \textbf{જવાબ}:
    સ્ટ્રક્ચર એ વપરાશકર્તા-વ્યાખ્યાયિત ડેટા ટાઇપ છે જે એક જ નામ હેઠળ વિવિધ ડેટા ટાઇપ્સના વેરિએબલ્સના સમૂહને મંજૂરી આપે છે.

    \textbf{સ્ટ્રક્ચર અને એરે વચ્ચેનો તફાવત:}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{લક્ષણ} & \textbf{સ્ટ્રક્ચર} & \textbf{એરે} \\
        \hline
        ડેટા ટાઇપ & વિવિધ ડેટા ટાઇપ્સ સ્ટોર કરી શકે & સમાન ડેટા ટાઇપના એલિમેન્ટ્સ સંગ્રહે છે \\
        \hline
        એક્સેસ & સભ્યો ડોટ (.) ઓપરેટર દ્વારા એક્સેસ થાય છે & એલિમેન્ટ્સ ઇન્ડેક્સ [] દ્વારા એક્સેસ થાય છે \\
        \hline
        ડેક્લેરેશન & struct કીવર્ડનો ઉપયોગ કરે છે & સ્ક્વેર બ્રેકેટ્સ []નો ઉપયોગ કરે છે \\
        \hline
        હેતુ & સંબંધિત વિષમ ડેટાને સંગઠિત કરે છે & સમાન ડેટાને સંગઠિત કરે છે \\
        \hline
    \end{tabulary}

    \textbf{બુક સ્ટ્રક્ચર પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>

struct Book {
    char title[100];
    char author[50];
    float price;
    int pages;
};

int main() {
    struct Book myBook;
    
    strcpy(myBook.title, "C પ્રોગ્રામિંગ");
    strcpy(myBook.author, "ડેનિસ રિચી");
    myBook.price = 350.50;
    myBook.pages = 285;
    
    printf("પુસ્તક વિગતો:\n");
    printf("શીર્ષક: %s\n", myBook.title);
    printf("લેખક: %s\n", myBook.author);
    printf("કિંમત: %.2f\n", myBook.price);
    printf("પાનાં: %d\n", myBook.pages);
    
    return 0;
}
\end{lstlisting}

    \textbf{સ્ટ્રક્ચર વિઝ્યુલાઇઝેશન:}

    \begin{center}
    \begin{tikzpicture}
        \node[draw, rectangle split, rectangle split parts=4] (struct) {
            \textbf{struct Book}
            \nodepart{second} title: "C Programming"
            \nodepart{third} author: "Dennis Ritchie"
            \nodepart{fourth} price: 350.50 \quad pages: 285
        };
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{સ્ટ્રક્ચર વ્યાખ્યા}: ડેટા માટે ટેમ્પ્લેટ બનાવે છે
        \item \textbf{સભ્ય એક્સેસ}: ડોટ ઓપરેટર (structure.member) નો ઉપયોગ કરો
        \item \textbf{સ્ટ્રિંગ હેન્ડલિંગ}: કેરેક્ટર એરે માટે સ્ટ્રિંગ ફંક્શન્સનો ઉપયોગ કરે છે
    \end{itemize}

    \begin{mnemonicbox}"સ્ટ્રક્ચર જુદું એકત્ર કરે, એરે એકસરખું રાખે"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5}{a}{3}
\textbf{કીબોર્ડ પરથી વાસ્તવિક સંખ્યા વાંચી અને તેના કરતા મોટો સૌથી નાનો પૂર્ણાંક પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h>

int main() {
    float number;
    int result;
    
    printf("એક વાસ્તવિક સંખ્યા દાખલ કરો: ");
    scanf("%f", &number);
    
    result = ceil(number);
    
    printf("%.2f કરતાં મોટો સૌથી નાનો પૂર્ણાંક %d છે\n", number, result);
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{મેથ ફંક્શન}: ceil() આગળના પૂર્ણાંક પર રાઉન્ડ કરે છે
        \item \textbf{પરિણામ ટાઇપ}: ઇનપુટથી મોટો નાનામાં નાનો પૂર્ણાંક પરત કરે છે
    \end{itemize}

    \begin{mnemonicbox}"CEILING ફંક્શન, ઉપર જઈએ, આગળનો પૂર્ણાંક બતાવીએ"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5}{b}{4}
\textbf{કીબોર્ડ પરથી અક્ષર વાંચી અને તેની ASCII વેલ્યુ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    char ch;
    
    printf("એક અક્ષર દાખલ કરો: ");
    scanf("%c", &ch);
    
    printf("'%c' ની ASCII વેલ્યુ %d છે\n", ch, ch);
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{કેરેક્ટર સ્ટોરેજ}: કેરેક્ટર્સ મેમરીમાં ઇન્ટીજર તરીકે સંગ્રહ થાય છે
        \item \textbf{ટાઇપ કન્વર્ઝન}: char થી int માં ઓટોમેટિક કન્વર્ઝન
    \end{itemize}

    \begin{mnemonicbox}"અક્ષરો નીચે સંખ્યાઓ છુપાવે, પ્રિન્ટ બંને બાજુ બતાવે"\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5}{c}{7}
\textbf{ફંક્શન ને વ્યાખ્યાયિત કરો? તેનો ફાયદો સમજાવો. આપેલ પૂર્ણાંક સંખ્યાના વર્ગની ગણતરી કરવા માટેનું ફંક્શન લખો.}

\begin{solutionbox}
    \textbf{જવાબ}:
    ફંક્શન એ કોડનો સેલ્ફ-કન્ટેઇન્ડ બ્લોક છે જે ચોક્કસ કાર્ય કરવા માટે ડિઝાઇન કરવામાં આવ્યો છે. તે ઇનપુટ લે છે, તેને પ્રોસેસ કરે છે, અને આઉટપુટ પરત કરે છે.

    \textbf{ફંક્શનના ફાયદાઓ:}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{ફાયદો} & \textbf{વર્ણન} \\
        \hline
        કોડ રીયુઝેબિલિટી & એક વખત લખો, અનેક વખત વાપરો \\
        \hline
        મોડ્યુલારિટી & જટિલ સમસ્યાઓને સંચાલિત ભાગોમાં વિભાજિત કરો \\
        \hline
        મેઇન્ટેનેબિલિટી & ઇસોલેટેડ કોડને ડિબગ અને મોડિફાય કરવું સરળ છે \\
        \hline
        એબ્સ્ટ્રેક્શન & અમલીકરણની વિગતો છુપાવો \\
        \hline
    \end{tabulary}

    \textbf{સ્ક્વેર ફંક્શન સાથે પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <stdio.h>

// પૂર્ણાંકના વર્ગની ગણતરી કરવાનું ફંક્શન
int square(int num) {
    return num * num;
}

int main() {
    int number, result;
    
    printf("એક પૂર્ણાંક દાખલ કરો: ");
    scanf("%d", &number);
    
    result = square(number);
    
    printf("%d નો વર્ગ %d છે\n", number, result);
    
    return 0;
}
\end{lstlisting}

    \textbf{ફંક્શન ફ્લો:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu block] (main) {Main Function};
        \node[gtu process, below=of main] (call) {Call square(number)};
        \node[gtu block, right=2cm of call] (func) {Square Function};
        \node[gtu process, below=of func] (ret) {return num * num};
        
        \draw[gtu arrow, dashed] (call) -- node[above] {pass argument} (func);
        \draw[gtu arrow, dashed] (ret) -- node[below] {return value} (call);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{ફંક્શન પ્રોટોટાઇપ}: ફંક્શન સિગ્નેચર જાહેર કરે છે
        \item \textbf{પેરામીટર્સ}: ફંક્શનમાં પાસ કરેલા ઇનપુટ મૂલ્યો
        \item \textbf{રિટર્ન વેલ્યુ}: ફંક્શનમાંથી આઉટપુટ અથવા પરિણામ
    \end{itemize}
    \begin{mnemonicbox}"ફંક્શન કાર્યોને ENCAPSULATE કરે, INPUTS લે, OUTPUTS આપે"\end{mnemonicbox}
\end{solutionbox}

\end{document}
