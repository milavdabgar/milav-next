\documentclass{article}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/english-boxes.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Programming In C (4331105) - Summer 2024 Solution}
\date{June 18, 2024}

\begin{document}
\maketitle

\questionmarks{1}{a}{3}
\textbf{Define keyword. List any four keywords for C language.}

\begin{solutionbox}
    A keyword is a predefined, reserved word in C that has special meaning to the compiler and cannot be used as an identifier.

    \textbf{Table: Common C Keywords}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{Keyword} & \textbf{Purpose} \\
        \hline
        \code{int} & Integer data type \\
        \hline
        \code{float} & Floating-point data type \\
        \hline
        \code{char} & Character data type \\
        \hline
        \code{if} & Conditional statement \\
        \hline
        \code{for} & Loop statement \\
        \hline
        \code{while} & Loop statement \\
        \hline
        \code{void} & Return type/parameter \\
        \hline
        \code{return} & Return value from function \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Reserved words}: Keywords cannot be used as variable names
        \item \textbf{Pre-defined}: They have fixed meaning in the language
        \item \textbf{Case-sensitive}: All keywords must be in lowercase
    \end{itemize}

    \begin{mnemonicbox}"If VoId FoR WhIle" (first letters of important keywords)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{b}{4}
\textbf{Explain rules for naming a variable.}

\begin{solutionbox}
    Variables in C must follow specific naming rules to be valid identifiers.

    \textbf{Table: Variable Naming Rules in C}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{Rule} & \textbf{Description} & \textbf{Valid Example} & \textbf{Invalid Example} \\
        \hline
        First character & Must be a letter or underscore & \code{age}, \code{\_count} & \code{1value} \\
        \hline
        Subsequent characters & Letters, digits, or underscores & \code{user\_1}, \code{total99} & \code{user@1} \\
        \hline
        Case sensitivity & Uppercase and lowercase are different & \code{Value} $\neq$ \code{value} & - \\
        \hline
        Keywords & Cannot use reserved keywords & \code{counter} & \code{int} \\
        \hline
        Length & Should be meaningful but not too long & \code{studentMarks} & \code{sm} \\
        \hline
        Special characters & Not allowed & \code{firstName} & \code{first-name} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Descriptive names}: Use meaningful names that indicate purpose
        \item \textbf{Consistent style}: Follow a consistent naming convention
        \item \textbf{No spaces}: Use underscores or camelCase instead
    \end{itemize}

    \begin{mnemonicbox}"FLASKS" (First Letter, Letters/digits, Avoid keywords, Sensitive case, Keep meaningful, Skip special chars)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{1}{c}{7}
\textbf{Define flowchart. Draw flowchart to find minimum of three integer numbers N1, N2 and N3.}

\begin{solutionbox}
    A flowchart is a graphical representation of an algorithm showing the steps as boxes and their order by connecting them with arrows.

    \textbf{Flowchart: Minimum of Three Numbers}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input N1, N2, N3};
        \node[gtu decision, alias=d1, below=of input] {N1 < N2?};
        
        \node[gtu block, left=of d1, xshift=-1cm, yshift=-1.5cm] (minN1) {min = N1};
        \node[gtu block, right=of d1, xshift=1cm, yshift=-1.5cm] (minN2) {min = N2};
        
        \node[gtu decision, alias=d2, below=of d1, yshift=-3cm] {min < N3?};
        
        \node[gtu block, right=of d2, xshift=2cm] (minN3) {min = N3};
        \node[gtu output, below=of d2, yshift=-1.5cm] (output) {Output min};
        \node[gtu stop, below=of output] (stop) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (d1);
        \draw[gtu arrow] (d1) -| node[above] {Yes} (minN1);
        \draw[gtu arrow] (d1) -| node[above] {No} (minN2);
        
        \draw[gtu arrow] (minN1) |- (d2);
        \draw[gtu arrow] (minN2) |- (d2);
        
        \draw[gtu arrow] (d2) -- node[left] {Yes} (output);
        \draw[gtu arrow] (d2) -- node[above] {No} (minN3);
        
        \draw[gtu arrow] (minN3) |- (output);
        \draw[gtu arrow] (output) -- (stop);

    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Symbols used}: Oval (start/end), Parallelogram (input/output), Diamond (decision), Rectangle (process)
        \item \textbf{Decision points}: Compare values systematically
        \item \textbf{Logical flow}: Arrows show the sequence of operations
    \end{itemize}

    \begin{mnemonicbox}"Start-Input-Compare-Output-End" (SICOE)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{1}{c}{7}
\textbf{Define algorithm. Write an algorithm to find minimum of three integer numbers N1, N2 and N3.}

\begin{solutionbox}
    An algorithm is a step-by-step procedure or finite set of well-defined instructions to solve a particular problem.

    \textbf{Algorithm: Find Minimum of Three Numbers}

    \begin{itemize}
        \item \textbf{Step 1}: Start
        \item \textbf{Step 2}: Input three numbers N1, N2, and N3
        \item \textbf{Step 3}: Set min = N1 (assume first number is minimum)
        \item \textbf{Step 4}: If N2 < min, then set min = N2
        \item \textbf{Step 5}: If N3 < min, then set min = N3
        \item \textbf{Step 6}: Output min as the minimum number
        \item \textbf{Step 7}: End
    \end{itemize}

    \textbf{Table: Algorithm Characteristics}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{Characteristic} & \textbf{Description} \\
        \hline
        Finiteness & Algorithm must terminate after finite steps \\
        \hline
        Definiteness & Each step must be precisely defined \\
        \hline
        Input & Algorithm takes zero or more inputs \\
        \hline
        Output & Algorithm produces one or more outputs \\
        \hline
        Effectiveness & Steps must be simple and executable \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Sequential steps}: Follows a logical order
        \item \textbf{Comparative approach}: Systematically finds minimum
        \item \textbf{Simplicity}: Easy to understand and implement
    \end{itemize}

    \begin{mnemonicbox}"FIDEO" (Finiteness, Input, Definiteness, Effectiveness, Output)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{a}{3}
\textbf{Differentiate gets() and puts().}

\begin{solutionbox}
    \code{gets()} and \code{puts()} are standard library functions in C for input and output operations with strings.

    \textbf{Table: Comparison of gets() and puts()}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{Feature} & \textbf{gets()} & \textbf{puts()} \\
        \hline
        Purpose & Reads string from stdin & Writes string to stdout \\
        \hline
        Prototype & \code{char *gets(char *str)} & \code{int puts(const char *str)} \\
        \hline
        Behavior & Reads until newline & Adds newline automatically \\
        \hline
        Return value & Returns str on success, NULL on failure & Returns non-negative on success, EOF on error \\
        \hline
        Safety & Unsafe (buffer overflow risk) & Safe \\
        \hline
        Recommended & No (deprecated) & Yes \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Input/Output}: \code{gets()} for input, \code{puts()} for output
        \item \textbf{Termination}: \code{gets()} stops at newline, \code{puts()} adds newline
        \item \textbf{Security}: \code{gets()} has no buffer limit check
    \end{itemize}

    \begin{mnemonicbox}"Gets In, Puts Out" (gets reads in, puts writes out)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{b}{4}
\textbf{Develop a C program to find whether the entered number is even or odd using conditional operator.}

\begin{solutionbox}
    This program uses the conditional operator to check if a number is even or odd.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    // Using conditional operator to check even or odd
    (num % 2 == 0) ? printf("%d is even\n", num) : printf("%d is odd\n", num);
    
    return 0;
}
\end{lstlisting}

    \textbf{Flowchart: Even or Odd}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input num};
        \node[gtu decision, alias=dec, below=of input] {num \% 2 == 0?};
        \node[gtu output, below left=of dec, xshift=-1cm] (even) {Output "Is Even"};
        \node[gtu output, below right=of dec, xshift=1cm] (odd) {Output "Is Odd"};
        \node[gtu stop, below=of dec, yshift=-3cm] (end) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (dec);
        \draw[gtu arrow] (dec) -| node[above] {True} (even);
        \draw[gtu arrow] (dec) -| node[above] {False} (odd);
        \draw[gtu arrow] (even) |- (end);
        \draw[gtu arrow] (odd) |- (end);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Conditional operator}: \code{? :} is a ternary operator
        \item \textbf{Modulus operation}: \code{\%} gives remainder after division
        \item \textbf{Test condition}: \code{num \% 2 == 0} checks for even number
    \end{itemize}

    \begin{mnemonicbox}"REMinder 0 = Even" (Remainder 0 means Even)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{c}{7}
\textbf{Explain logical \& relational operators with examples.}

\begin{solutionbox}
    Logical and relational operators are used to create conditions and make decisions in C programs.

    \textbf{Table: Relational Operators}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{Operator} & \textbf{Meaning} & \textbf{Example} & \textbf{Result} \\
        \hline
        \code{==} & Equal to & \code{5 == 5} & true (1) \\
        \hline
        \code{!=} & Not equal to & \code{5 != 3} & true (1) \\
        \hline
        \code{>} & Greater than & \code{7 > 3} & true (1) \\
        \hline
        \code{<} & Less than & \code{2 < 8} & true (1) \\
        \hline
        \code{>=} & Greater than or equal to & \code{4 >= 4} & true (1) \\
        \hline
        \code{<=} & Less than or equal to & \code{6 <= 9} & true (1) \\
        \hline
    \end{tabulary}

    \textbf{Table: Logical Operators}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{Operator} & \textbf{Meaning} & \textbf{Example} & \textbf{Result} \\
        \hline
        \code{\&\&} & Logical AND & \code{(5>3) \&\& (8>5)} & true (1) \\
        \hline
        \code{||} & Logical OR & \code{(5>7) || (3<6)} & true (1) \\
        \hline
        \code{!} & Logical NOT & \code{!(5>7)} & true (1) \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
int age = 20;
int score = 75;

// Using both relational and logical operators
if ((age >= 18) && (score > 70)) {
    printf("Eligible");
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Comparison}: Relational operators compare values
        \item \textbf{Combining conditions}: Logical operators connect multiple conditions
        \item \textbf{Truth value}: All operators return 1 (true) or 0 (false)
    \end{itemize}

    \begin{mnemonicbox}"CORNL" (Compare with relational, OR/AND/NOT with logical)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{2}{a}{3}
\textbf{Considering precedence of operators, write down each step of evaluation and final answer if expression 16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) -10 is evaluated.}

\begin{solutionbox}
    Let's evaluate the expression \code{16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) - 10} step by step following operator precedence.

    \textbf{Table: Step-by-Step Evaluation}

    \begin{tabulary}{\linewidth}{|C|L|L|}
        \hline
        \textbf{Step} & \textbf{Operation} & \textbf{Expression after this step} \\
        \hline
        1 & Calculate \code{(3 + 6)} & \code{16 + ( 216 / ( 9 * 12 ) ) - 10} \\
        \hline
        2 & Calculate \code{(9 * 12)} & \code{16 + ( 216 / 108 ) - 10} \\
        \hline
        3 & Calculate \code{(216 / 108)} & \code{16 + 2 - 10} \\
        \hline
        4 & Calculate \code{16 + 2} & \code{18 - 10} \\
        \hline
        5 & Calculate \code{18 - 10} & \code{8} \\
        \hline
    \end{tabulary}

    \textbf{Final Answer: 8}

    \textbf{Evaluation Tree:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu block] (s1) {16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) - 10};
        \node[gtu block, below=of s1] (s2) {16 + ( 216 / ( 9 * 12 ) ) - 10};
        \node[gtu block, below=of s2] (s3) {16 + ( 216 / 108 ) - 10};
        \node[gtu block, below=of s3] (s4) {16 + 2 - 10};
        \node[gtu block, below=of s4] (s5) {18 - 10};
        \node[gtu block, below=of s5, fill=green!20] (s6) {8};

        \draw[gtu arrow] (s1) -- (s2);
        \draw[gtu arrow] (s2) -- (s3);
        \draw[gtu arrow] (s3) -- (s4);
        \draw[gtu arrow] (s4) -- (s5);
        \draw[gtu arrow] (s5) -- (s6);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Parentheses first}: Innermost parentheses evaluated first
        \item \textbf{Multiplication before division}: Calculate from left to right
        \item \textbf{Addition and subtraction last}: From left to right
    \end{itemize}

    \begin{mnemonicbox}"PEMDAS" (Parentheses, Exponents, Multiplication/Division, Addition/Subtraction)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{b}{4}
\textbf{Write a C program to find circumference and area of a circle.}

\begin{solutionbox}
    This program calculates the area and circumference of a circle based on its radius.

\begin{lstlisting}[language=C]
#include <stdio.h>
#define PI 3.14159

int main() {
    float radius, area, circumference;
    
    printf("Enter the radius of circle: ");
    scanf("%f", &radius);
    
    // Calculate area and circumference
    area = PI * radius * radius;
    circumference = 2 * PI * radius;
    
    printf("Area of circle = %.2f square units\n", area);
    printf("Circumference of circle = %.2f units\n", circumference);
    
    return 0;
}
\end{lstlisting}

    \textbf{Flowchart: Area and Circumference}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input radius};
        \node[gtu process, below=of input] (calc) {area = PI * r * r\\circumference = 2 * PI * r};
        \node[gtu output, below=of calc] (output) {Output area, circ};
        \node[gtu stop, below=of output] (stop) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Formula}: Area = $\pi \times r^2$ and Circumference = $2\pi \times r$
        \item \textbf{Constant definition}: Using \code{\#define} for PI
        \item \textbf{Float variables}: For decimal precision
    \end{itemize}

    \begin{mnemonicbox}"PIR$^2$" for area, "2PIR" for circumference\end{mnemonicbox}
\end{solutionbox}

\questionmarks{2}{c}{7}
\textbf{Explain arithmetic \& bit-wise operators with examples.}

\begin{solutionbox}
    Arithmetic operators perform mathematical operations while bit-wise operators manipulate individual bits of integers.

    \textbf{Table: Arithmetic Operators}

    \begin{tabulary}{\linewidth}{|C|L|L|L|}
        \hline
        \textbf{Op} & \textbf{Description} & \textbf{Example} & \textbf{Result} \\
        \hline
        \code{+\ } & Addition & \code{5 + 3} & 8 \\
        \hline
        \code{-\ } & Subtraction & \code{7 - 2} & 5 \\
        \hline
        \code{*\ } & Multiplication & \code{4 * 3} & 12 \\
        \hline
        \code{/\ } & Division & \code{10 / 3} & 3 \\
        \hline
        \code{\%\ } & Modulus & \code{10 \% 3} & 1 \\
        \hline
        \code{++} & Increment & \code{a++} & Adds 1 \\
        \hline
        \code{--} & Decrement & \code{--b} & Sub. 1 \\
        \hline
    \end{tabulary}

    \textbf{Table: Bitwise Operators}

    \begin{tabulary}{\linewidth}{|C|L|L|L|}
        \hline
        \textbf{Op} & \textbf{Description} & \textbf{Exp (bin)} & \textbf{Res} \\
        \hline
        \code{\&} & Bitwise AND & \code{5(101) \& 3(011)} & 1(001) \\
        \hline
        \code{|} & Bitwise OR & \code{5(101) | 3(011)} & 7(111) \\
        \hline
        \code{\^} & Bitwise XOR & \code{5(101) \^ 3(011)} & 6(110) \\
        \hline
        \code{\~} & Bitwise NOT & \code{\~5(101)} & -6 \\
        \hline
        \code{<<} & Left Shift & \code{5 << 1} & 10(1010) \\
        \hline
        \code{>>} & Right Shift & \code{5 >> 1} & 2(10) \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
int a = 5, b = 3;
printf("a + b = %d\n", a + b);      // 8
printf("a & b = %d\n", a & b);      // 1
printf("a << 1 = %d\n", a << 1);    // 10
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Mathematical operations}: Arithmetic operators for calculations
        \item \textbf{Bit manipulation}: Bitwise operators work at binary level
        \item \textbf{Efficiency}: Bitwise operations are faster for certain tasks
    \end{itemize}

    \begin{mnemonicbox}"SAME BARON" (Subtraction Addition Multiplication, Bitwise AND/OR/NOT)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{a}{3}
\textbf{Explain the use of 'go to' statement with example.}

\begin{solutionbox}
    The \code{goto} statement is used to transfer program control unconditionally to a labeled statement.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int num, sum = 0;
    
    printf("Enter a positive number: ");
    scanf("%d", &num);
    
    if (num <= 0) {
        goto error;
    }
    
    sum = num * (num + 1) / 2;
    printf("Sum of first %d numbers = %d\n", num, sum);
    goto end;
    
    error:
        printf("Error: Please enter a positive number!\n");
    
    end:
        return 0;
}
\end{lstlisting}

    \textbf{Flowchart: goto Example}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input num};
        \node[gtu decision, alias=check, below=of input] {num <= 0?};
        \node[gtu output, right=of check, xshift=1cm] (error) {Output Error};
        \node[gtu process, below=of check] (calc) {Calculate sum};
        \node[gtu output, below=of calc] (output) {Output sum};
        \node[gtu stop, below=of output] (stop) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (check);
        \draw[gtu arrow] (check) -- node[above] {Yes} (error);
        \draw[gtu arrow] (check) -- node[right] {No} (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
        \draw[gtu arrow] (error) |- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Label declaration}: Labels end with colon (:)
        \item \textbf{Jump statement}: \code{goto} transfers control to label
        \item \textbf{Caution}: Excessive use creates "spaghetti code"
    \end{itemize}

    \begin{mnemonicbox}"JUMPing LABEL" (Jump to a labeled statement)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{b}{4}
\textbf{The marks obtained by the student in 5 different subjects are input through keyboard. The student gets grade as per following rules: Percentage above or equal to 90- Grade A. Percentage between 80 and 89- Grade B. Percentage between 70 and 79-Grade C. Percentage between 60 and 69-Grade D. Percentage between 50 and 59-Grade E. Percentage less than 50- Grade F. Write a C program to display the grade obtained by the student.}

\begin{solutionbox}
    This program calculates the grade based on the average marks in 5 subjects.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int marks[5], total = 0, i;
    float percentage;
    char grade;
    
    // Input marks for 5 subjects
    for (i = 0; i < 5; i++) {
        printf("Enter marks for subject %d (out of 100): ", i+1);
        scanf("%d", &marks[i]);
        total += marks[i];
    }
    
    // Calculate percentage
    percentage = total / 5.0;
    
    // Determine grade
    if (percentage >= 90)
        grade = 'A';
    else if (percentage >= 80)
        grade = 'B';
    else if (percentage >= 70)
        grade = 'C';
    else if (percentage >= 60)
        grade = 'D';
    else if (percentage >= 50)
        grade = 'E';
    else
        grade = 'F';
    
    printf("Percentage: %.2f%%\n", percentage);
    printf("Grade: %c\n", grade);
    
    return 0;
}
\end{lstlisting}

    \textbf{Table: Grading Criteria}

    \begin{tabulary}{\linewidth}{|C|C|}
        \hline
        \textbf{Percentage Range} & \textbf{Grade} \\
        \hline
        $\ge$ 90 & A \\
        \hline
        80-89 & B \\
        \hline
        70-79 & C \\
        \hline
        60-69 & D \\
        \hline
        50-59 & E \\
        \hline
        < 50 & F \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Input array}: Stores marks of 5 subjects
        \item \textbf{Percentage calculation}: Sum divided by number of subjects
        \item \textbf{Grade determination}: Using if-else ladder
    \end{itemize}

    \begin{mnemonicbox}"ABCDEF-90-80-70-60-50" (Grades with their percentage thresholds)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{c}{7}
\textbf{Draw flowchart and explain nested if-else with example.}

\begin{solutionbox}
    Nested if-else is a control structure where an if or else statement contains another if-else statement within it.

    \textbf{Flowchart: Nested if-else}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input age, score};
        \node[gtu decision, alias=d1, below=of input] {age $\ge$ 18?};
        
        \node[gtu decision, alias=d2, below left=of d1, xshift=-1cm, yshift=-1cm] {score $\ge$ 60?};
        \node[gtu process, alias=fail1, below right=of d1, xshift=1cm, yshift=-1cm] {Not eligible: Age};
        
        \node[gtu process, alias=pass, below left=of d2, xshift=-1cm] {Eligible};
        \node[gtu process, alias=fail2, below right=of d2, xshift=1cm] {Not eligible: Score};
        
        \node[gtu stop, below=of d2, yshift=-3cm] (end) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (d1);
        \draw[gtu arrow] (d1) -| node[above] {Yes} (d2);
        \draw[gtu arrow] (d1) -| node[above] {No} (fail1);
        
        \draw[gtu arrow] (d2) -| node[above] {Yes} (pass);
        \draw[gtu arrow] (d2) -| node[above] {No} (fail2);
        
        \draw[gtu arrow] (pass) |- (end);
        \draw[gtu arrow] (fail2) |- (end);
        \draw[gtu arrow] (fail1) |- (end);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int age, score;
    
    printf("Enter age: ");
    scanf("%d", &age);
    printf("Enter score: ");
    scanf("%d", &score);
    
    if (age >= 18) {
        if (score >= 60) {
            printf("Eligible for admission");
        } else {
            printf("Not eligible: Score criteria not met");
        }
    } else {
        printf("Not eligible: Age criteria not met");
    }
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Multiple conditions}: Tests several conditions in sequence
        \item \textbf{Hierarchical decision}: Inner condition only evaluated if outer is true
        \item \textbf{Indentation}: Proper indentation helps in understanding structure
    \end{itemize}

    \begin{mnemonicbox}"CONE" (Check Outer, Nest Evaluation inside)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{3}{a}{3}
\textbf{Explain the use of continue and break statement.}

\begin{solutionbox}
    The \code{break} and \code{continue} statements control the flow of loops in different ways.

    \textbf{Table: Comparison of break and continue}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{Feature} & \textbf{break} & \textbf{continue} \\
        \hline
        Purpose & Exits the loop immediately & Skips current iteration \\
        \hline
        Effect on loop & Terminates completely & Proceeds to next iteration \\
        \hline
        Applicable in & \code{switch}, \code{for}, \code{while}, \code{do-while} & \code{for}, \code{while}, \code{do-while} \\
        \hline
        Usage & When condition met and no more iterations needed & When current iteration should be skipped \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
// Example with break
for (int i = 1; i <= 10; i++) {
    if (i == 5)
        break;    // Exit loop when i equals 5
    printf("%d ", i);  // Outputs: 1 2 3 4
}
\end{lstlisting}

\begin{lstlisting}[language=C]
// Example with continue
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0)
        continue;  // Skip even numbers
    printf("%d ", i);  // Outputs: 1 3 5 7 9
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Loop control}: Both used to manage loop execution
        \item \textbf{Break exits}: Completely stops the loop
        \item \textbf{Continue skips}: Only skips current iteration
    \end{itemize}

    \begin{mnemonicbox}"BEC" (Break Exits Completely, Continue only current)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{b}{4}
\textbf{Write a program using for loop to print this output:}
\begin{verbatim}
1
1 2
1 2 3
1 2 3 4
\end{verbatim}

\begin{solutionbox}
    This program uses nested for loops to print the pattern of numbers.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i, j;
    
    // Outer loop for rows (1 to 4)
    for (i = 1; i <= 4; i++) {
        // Inner loop for columns (1 to i)
        for (j = 1; j <= i; j++) {
            printf("%d ", j);
        }
        printf("\n");  // Move to next line after each row
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{Flowchart: Pattern Printing}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu process, below=of start] (init_i) {i = 1};
        \node[gtu decision, alias=cond_i, below=of init_i] {i <= 4?};
        
        \node[gtu process, alias=init_j, right=of cond_i, xshift=1cm] {j = 1};
        \node[gtu decision, alias=cond_j, below=of init_j] {j <= i?};
        
        \node[gtu output, right=of cond_j, xshift=1cm] (print_j) {Print j};
        \node[gtu process, below=of print_j] (inc_j) {j++};
        
        \node[gtu output, below=of cond_j, yshift=-1.5cm] (newline) {Print newline};
        \node[gtu process, left=of newline, xshift=-1cm] (inc_i) {i++};
        
        \node[gtu stop, below=of cond_i, yshift=-3cm] (stop) {End};

        \draw[gtu arrow] (start) -- (init_i);
        \draw[gtu arrow] (init_i) -- (cond_i);
        
        \draw[gtu arrow] (cond_i) -- node[above] {Yes} (init_j);
        \draw[gtu arrow] (cond_i) -- node[left] {No} (stop);
        
        \draw[gtu arrow] (init_j) -- (cond_j);
        \draw[gtu arrow] (cond_j) -- node[above] {Yes} (print_j);
        \draw[gtu arrow] (print_j) -- (inc_j);
        \draw[gtu arrow] (inc_j) |- (cond_j);
        
        \draw[gtu arrow] (cond_j) -- node[left] {No} (newline);
        \draw[gtu arrow] (newline) -- (inc_i);
        \draw[gtu arrow] (inc_i) |- (cond_i);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Nested loops}: Outer loop for rows, inner for columns
        \item \textbf{Dynamic limit}: Inner loop runs j from 1 to current i
        \item \textbf{Incremental pattern}: Each row has one more number
    \end{itemize}

    \begin{mnemonicbox}"RICI" (Row Increases, Column Increases based on row number)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{3}{c}{7}
\textbf{Draw flowchart and explain switch statement with example.}

\begin{solutionbox}
    The \code{switch} statement is a multi-way decision maker that tests a variable against various case values.

    \textbf{Flowchart: Switch Statement}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input choice};
        \node[gtu decision, alias=switch, below=of input] {Switch(choice)};
        
        \node[gtu process, alias=c1, below left=of switch, xshift=-2cm] {Case 1};
        \node[gtu process, alias=c2, below=of switch] {Case 2};
        \node[gtu process, alias=c3, below right=of switch, xshift=2cm] {Case 3};
        \node[gtu process, alias=def, right=of switch, xshift=2cm] {Default};
        
        \node[gtu stop, below=of c2, yshift=-1cm] (end) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (switch);
        \draw[gtu arrow] (switch) -- (c1);
        \draw[gtu arrow] (switch) -- (c2);
        \draw[gtu arrow] (switch) -- (c3);
        \draw[gtu arrow] (switch) -- (def);
        
        \draw[gtu arrow] (c1) |- (end);
        \draw[gtu arrow] (c2) -- (end);
        \draw[gtu arrow] (c3) |- (end);
        \draw[gtu arrow] (def) |- (end);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int choice;
    
    printf("Menu:\n");
    printf("1. Add\n");
    printf("2. Subtract\n");
    printf("3. Multiply\n");
    printf("Enter your choice (1-3): ");
    scanf("%d", &choice);
    
    switch (choice) {
        case 1:
            printf("Addition selected\n");
            break;
        case 2:
            printf("Subtraction selected\n");
            break;
        case 3:
            printf("Multiplication selected\n");
            break;
        default:
            printf("Invalid choice\n");
    }
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Multiple cases}: Tests one variable against multiple values
        \item \textbf{Break statement}: Prevents fall-through to next case
        \item \textbf{Default case}: Handles values not matching any case
        \item \textbf{Case order}: Can be in any order, default usually last
    \end{itemize}

    \begin{mnemonicbox}"CASED" (Check All Switch Expression's Destinations)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{a}{3}
\textbf{Develop a C program to convert temperature from Celsius to Fahrenheit using formula fahrenheit= ((celsius*9)/5)+32.}

\begin{solutionbox}
    This program converts a temperature value from Celsius to Fahrenheit.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    float celsius, fahrenheit;
    
    printf("Enter temperature in Celsius: ");
    scanf("%f", &celsius);
    
    // Convert Celsius to Fahrenheit
    fahrenheit = ((celsius * 9) / 5) + 32;
    
    printf("%.2f Celsius = %.2f Fahrenheit\n", celsius, fahrenheit);
    
    return 0;
}
\end{lstlisting}

    \textbf{Flowchart: Celsius to Fahrenheit}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input celsius};
        \node[gtu process, below=of input] (calc) {fahrenheit = ((celsius * 9) / 5) + 32};
        \node[gtu output, below=of calc] (output) {Output celsius, fahrenheit};
        \node[gtu stop, below=of output] (stop) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Formula}: $F = ((C \times 9) \div 5) + 32$
        \item \textbf{Float variables}: For decimal precision
        \item \textbf{Formatted output}: Using \code{\%.2f} for two decimal places
    \end{itemize}

    \begin{mnemonicbox}"C95+32=F" (Celsius x 9 / 5 + 32 = Fahrenheit)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{b}{4}
\textbf{What is pointer? Explain with example.}

\begin{solutionbox}
    A pointer is a variable that stores the memory address of another variable.

    \textbf{Memory Layout Illustration}

    \begin{center}
    \begin{tikzpicture}[gtu flow, node distance=1cm]
        \node[draw, rectangle, minimum width=2.5cm, minimum height=1.5cm, align=left] (ptr) {\textbf{ptr} \\ Value: 0x2000 \\ Addr: 0x1000};
        \node[draw, rectangle, minimum width=2.5cm, minimum height=1.5cm, align=left, right=of ptr, xshift=2cm] (var) {\textbf{var} \\ Value: 10 \\ Addr: 0x2000};
        
        \draw[gtu arrow] (ptr.east) -- node[above] {Points to} (var.west);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int var = 10;    // Regular variable
    int *ptr;        // Pointer variable
    
    ptr = &var;      // Store address of var in ptr
    
    printf("Value of var: %d\n", var);       // Output: 10
    printf("Address of var: %p\n", &var);    // Output: memory address
    printf("Value of ptr: %p\n", ptr);       // Output: same memory address
    printf("Value at address stored in ptr: %d\n", *ptr); // Output: 10
    
    // Modify value using pointer
    *ptr = 20;
    printf("New value of var: %d\n", var);   // Output: 20
    
    return 0;
}
\end{lstlisting}

    \textbf{Table: Pointer Operations}

    \begin{tabulary}{\linewidth}{|C|C|L|L|}
        \hline
        \textbf{Operation} & \textbf{Symbol} & \textbf{Description} & \textbf{Example} \\
        \hline
        Address-of & \code{\&} & Gets address of variable & \code{\&var} \\
        \hline
        Dereference & \code{*} & Accesses value at address & \code{*ptr} \\
        \hline
        Declaration & \code{*} & Creates pointer variable & \code{int *ptr;} \\
        \hline
        Assignment & \code{=} & Assigns address to pointer & \code{ptr = \&var;} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Memory address}: Pointer stores location, not value
        \item \textbf{Indirection}: Access value indirectly using address
        \item \textbf{Memory manipulation}: Allows dynamic memory access
    \end{itemize}

    \begin{mnemonicbox}"ADA" (Address Dereferencing Access)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{c}{7}
\textbf{Draw flowchart and explain do-while loop with example.}

\begin{solutionbox}
    The \code{do-while} loop is a post-test loop that executes its body at least once before checking the condition.

    \textbf{Flowchart: do-while Loop}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu process, below=of start] (init) {Initialize counter i = 1};
        \node[gtu process, below=of init] (body) {Execute loop body:\\Print i};
        \node[gtu process, below=of body] (inc) {Increment i: i++};
        \node[gtu decision, alias=cond, below=of inc] {i <= 5?};
        \node[gtu stop, below=of cond, yshift=-1cm] (stop) {End};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (body);
        \draw[gtu arrow] (body) -- (inc);
        \draw[gtu arrow] (inc) -- (cond);
        \draw[gtu arrow] (cond) -- node[right] {No} (stop);
        \draw[gtu arrow] (cond.east) -- ++(1,0) |- node[right, near start] {Yes} (body.east);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i = 1;
    
    do {
        printf("%d ", i);
        i++;
    } while (i <= 5);  // Condition checked after first execution
    
    // Output: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

    \textbf{Table: Characteristics of do-while Loop}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{Characteristic} & \textbf{Description} \\
        \hline
        Execution order & Body first, then condition \\
        \hline
        Minimum iterations & At least one \\
        \hline
        Condition check & At the end of loop \\
        \hline
        Termination & When condition becomes false \\
        \hline
        Syntax & \code{do \{ statements; \} while (condition);} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Post-test loop}: Condition evaluated after loop body
        \item \textbf{Guaranteed execution}: Loop body always runs at least once
        \item \textbf{Semicolon}: Required after while condition
    \end{itemize}

    \begin{mnemonicbox}"DECAT" (Do Execute Check After That)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{4}{a}{3}
\textbf{Develop a C program to find area of a triangle (0.5 * base * height)?}

\begin{solutionbox}
    This program calculates the area of a triangle using the formula $Area = \frac{1}{2} \times base \times height$.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    float base, height, area;
    
    printf("Enter base of triangle: ");
    scanf("%f", &base);
    printf("Enter height of triangle: ");
    scanf("%f", &height);
    
    // Calculate area
    area = 0.5 * base * height;
    
    printf("Area of triangle = %.2f square units\n", area);
    
    return 0;
}
\end{lstlisting}

    \textbf{Flowchart: Area of Triangle}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input base, height};
        \node[gtu process, below=of input] (calc) {area = 0.5 * base * height};
        \node[gtu output, below=of calc] (output) {Output area};
        \node[gtu stop, below=of output] (stop) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (calc);
        \draw[gtu arrow] (calc) -- (output);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Formula}: Area = 0.5 * base * height
        \item \textbf{Float variables}: For decimal precision
        \item \textbf{User input}: Gets base and height from user
    \end{itemize}

    \begin{mnemonicbox}"Half-BH" (Half times Base times Height)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{b}{4}
\textbf{Explain declaration and initialization of pointer.}

\begin{solutionbox}
    Pointer declaration and initialization involve creating a pointer variable and assigning it a memory address.

    \textbf{Table: Pointer Declaration and Initialization}

    \begin{tabulary}{\linewidth}{|L|L|L|L|}
        \hline
        \textbf{Operation} & \textbf{Syntax} & \textbf{Example} & \textbf{Explanation} \\
        \hline
        Declaration & \code{type *name;} & \code{int *ptr;} & Creates pointer to int \\
        \hline
        Initialization & \code{name = \&var;} & \code{ptr = \&num;} & Assigns addr of num \\
        \hline
        Combined & \code{type *n = \&v;} & \code{int *p = \&n;} & Declares \& initializes \\
        \hline
        Null pointer & \code{name = NULL;} & \code{ptr = NULL;} & Points to nothing \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
int main() {
    // Declaration
    int *ptr1;
    
    // Declaration and initialization together
    int num = 10;
    int *ptr2 = &num;
    
    // Initialization with NULL
    int *ptr3 = NULL;
    
    printf("Value at address ptr2: %d\n", *ptr2);  // Output: 10
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Asterisk syntax}: \code{*} used in declaration to create pointer
        \item \textbf{Address operator}: \code{\&} gets address of variable
        \item \textbf{NULL initialization}: Safe practice to avoid wild pointers
        \item \textbf{Pointer type}: Must match the data type it points to
    \end{itemize}

    \begin{mnemonicbox}"DINA" (Declare, Initialize with NULL or Address)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{4}{c}{7}
\textbf{Draw flowchart and explain while loop with example.}

\begin{solutionbox}
    The \code{while} loop is a pre-test loop that executes its body repeatedly as long as the condition remains true.

    \textbf{Flowchart: while Loop}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu process, below=of start] (init) {Initialize counter i = 1};
        \node[gtu decision, alias=cond, below=of init] {i <= 5?};
        \node[gtu process, below=of cond] (body) {Execute loop body:\\Print i};
        \node[gtu process, below=of body] (inc) {Increment i: i++};
        \node[gtu stop, right=of cond, xshift=2cm] (stop) {End};

        \draw[gtu arrow] (start) -- (init);
        \draw[gtu arrow] (init) -- (cond);
        \draw[gtu arrow] (cond) -- node[left] {Yes} (body);
        \draw[gtu arrow] (body) -- (inc);
        \draw[gtu arrow] (inc.west) -- ++(-1,0) |- (cond.west);
        \draw[gtu arrow] (cond) -- node[above] {No} (stop);
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int i = 1;
    
    while (i <= 5) {  // Condition checked before each execution
        printf("%d ", i);
        i++;
    }
    
    // Output: 1 2 3 4 5
    
    return 0;
}
\end{lstlisting}

    \textbf{Table: Characteristics of while Loop}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{Characteristic} & \textbf{Description} \\
        \hline
        Execution order & Condition first, then body \\
        \hline
        Minimum iterations & Zero (if condition initially false) \\
        \hline
        Condition check & At the beginning of loop \\
        \hline
        Termination & When condition becomes false \\
        \hline
        Syntax & \code{while (condition) \{ statements; \}} \\
        \hline
    \end{tabulary}

    \begin{itemize}
        \item \textbf{Pre-test loop}: Condition evaluated before loop body
        \item \textbf{Zero iterations possible}: Body may never execute if condition initially false
        \item \textbf{Loop variable}: Must be initialized before loop
    \end{itemize}

    \begin{mnemonicbox}"CELT" (Check, Execute, Loop, Terminate)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{a}{3}
\textbf{Build a structure to store book information: book\_no, book\_title, book\_author, book\_price}

\begin{solutionbox}
    This program creates a structure to store book information with the specified fields.

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>

// Define structure for book information
struct Book {
    int book_no;
    char book_title[50];
    char book_author[30];
    float book_price;
};

int main() {
    // Declare a variable of Book structure
    struct Book book1;
    
    // Assign values to structure members
    book1.book_no = 101;
    strcpy(book1.book_title, "Programming in C");
    strcpy(book1.book_author, "Dennis Ritchie");
    book1.book_price = 450.75;
    
    // Display book information
    printf("Book No: %d\n", book1.book_no);
    printf("Title: %s\n", book1.book_title);
    printf("Author: %s\n", book1.book_author);
    printf("Price: Rs. %.2f\n", book1.book_price);
    
    return 0;
}
\end{lstlisting}

    \textbf{Structure Representation:}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu class] (book) {
            \textbf{struct Book} \\
            \rule{2cm}{0.4pt} \\
            int book\_no \\
            char book\_title[50] \\
            char book\_author[30] \\
            float book\_price
        };
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Structure definition}: Uses \code{struct} keyword to define composite data type
        \item \textbf{Member access}: Using dot (.) operator to access members
        \item \textbf{String copying}: \code{strcpy()} for character arrays
    \end{itemize}

    \begin{mnemonicbox}"NTAP" (Number, Title, Author, Price)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{b}{4}
\textbf{Explain following functions with example. (1) sqrt() (2) pow() (3) strlen() (4) strcpy()}

\begin{solutionbox}
    These are standard library functions in C, used for mathematical calculations and string manipulations.

    \textbf{Table: Library Functions}

    \begin{tabulary}{\linewidth}{|C|C|L|L|}
        \hline
        \textbf{Function} & \textbf{Header} & \textbf{Purpose} & \textbf{Example} \\
        \hline
        \code{sqrt()} & math.h & Square root & \code{sqrt(16) -> 4.0} \\
        \hline
        \code{pow()} & math.h & Power & \code{pow(2,3) -> 8.0} \\
        \hline
        \code{strlen()} & string.h & String length & \code{strlen("Hi") -> 2} \\
        \hline
        \code{strcpy()} & string.h & String copy & \code{strcpy(d, "Hi")} \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h>
#include <string.h>

int main() {
    // sqrt() and pow() examples
    printf("sqrt(25): %.2f\n", sqrt(25));
    printf("pow(2, 4): %.2f\n", pow(2, 4));
    
    // strlen() example
    char str[] = "C Prog";
    printf("Length: %d\n", strlen(str));
    
    // strcpy() example
    char dest[10];
    strcpy(dest, "Hello");
    printf("Copied: %s\n", dest);
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Math functions}: \code{sqrt()} and \code{pow()} for mathematical calculations
        \item \textbf{String functions}: \code{strlen()} and \code{strcpy()} for string manipulations
        \item \textbf{Header files}: Required to use these functions (\code{math.h}, \code{string.h})
    \end{itemize}

    \begin{mnemonicbox}"MPSL" (Math Power and String Length)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{c}{7}
\textbf{Explain arrays and array initialization. Give example.}

\begin{solutionbox}
    An array is a collection of elements of the same data type stored in contiguous memory locations.

    \textbf{Table: Array Types and Initialization}

    \begin{tabulary}{\linewidth}{|L|L|L|}
        \hline
        \textbf{Type} & \textbf{Declaration} & \textbf{Init (Declaration)} \\
        \hline
        Integer & \code{int a[5];} & \code{int a[5] = \{1,2\};} \\
        \hline
        Char & \code{char s[10];} & \code{char s[] = "Hi";} \\
        \hline
        Float & \code{float f[3];} & \code{float f[3] = \{1.1\};} \\
        \hline
        Size Inference & - & \code{int n[] = \{1,2,3\};} \\
        \hline
    \end{tabulary}

    \textbf{Diagram: Array Memory Layout}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \foreach \x/\val in {0/10, 1/20, 2/30, 3/40, 4/50} {
            \node[draw, rectangle, minimum size=1cm] (n\x) at (\x*1.2, 0) {\val};
            \node[below=0.1cm of n\x] {\footnotesize [\x]};
        }
        \node[above=0.2cm of n2] {\textbf{numbers[5]}};
    \end{tikzpicture}
    \end{center}

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    // Array declaration and initialization
    int numbers[5] = {10, 20, 30, 40, 50};
    
    // Access and display array elements
    printf("Array elements: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numbers[i]);
    }
    
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Zero-based indexing}: First element at index 0
        \item \textbf{Contiguous memory}: Elements stored adjacently
        \item \textbf{Fixed size}: Size defined at compile time
    \end{itemize}

    \begin{mnemonicbox}"DICE" (Declaration, Initialization, Contiguous storage, Element access)\end{mnemonicbox}
\end{solutionbox}

\orquestionmarks{5}{a}{3}
\textbf{Explain declaration of structure with example.}

\begin{solutionbox}
    Structure declaration in C involves defining a new data type that combines different data types under a single name.

    \textbf{Table: Structure Declaration Methods}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{Method} & \textbf{Example} \\
        \hline
        Basic declaration & \code{struct Student \{ int id; \};} \\
        \hline
        With variables & \code{struct Point \{ int x; \} p1;} \\
        \hline
        Without tag & \code{struct \{ float r; \} c1;} \\
        \hline
        Typedef & \code{typedef struct \{ int w; \} Rect;} \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
struct Student {
    int id;
    char name[30];
    float percentage;
};

int main() {
    struct Student s1;
    s1.id = 101;
    return 0;
}
\end{lstlisting}

    \begin{itemize}
        \item \textbf{Structure keyword}: \code{struct} used to define new data type
        \item \textbf{Member access}: \code{.} (dot) operator to access members
        \item \textbf{Heterogeneous data}: Can combine different data types
    \end{itemize}

    \begin{mnemonicbox}"SMUVT" (Structure Mostly Uses Various Types)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{b}{4}
\textbf{What is user defined function? Explain with example.}

\begin{solutionbox}
    A user-defined function is a block of code written by the programmer to perform a specific task, which can be called from other parts of the program.

    \textbf{Table: Function Components}

    \begin{tabulary}{\linewidth}{|L|L|}
        \hline
        \textbf{Component} & \textbf{Example} \\
        \hline
        Return type & \code{int, float, void} \\
        \hline
        Function name & \code{findMax} \\
        \hline
        Parameters & \code{(int a, int b)} \\
        \hline
        Function body & \code{\{ return a + b; \}} \\
        \hline
        Function call & \code{result = findMax(5, 3);} \\
        \hline
    \end{tabulary}

\begin{lstlisting}[language=C]
#include <stdio.h>

// User-defined function declaration
int findMax(int a, int b);

int main() {
    int max = findMax(10, 20);
    printf("Max: %d\n", max);
    return 0;
}

// Function definition
int findMax(int a, int b) {
    if (a > b) return a;
    else return b;
}
\end{lstlisting}

    \textbf{Flowchart: Function Call}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu process] (main) {main function};
        \node[gtu process, right=of main, xshift=2cm] (func) {findMax function};
        
        \draw[gtu arrow, bend left] (main) to node[above] {Call with usage} (func);
        \draw[gtu arrow, bend left] (func) to node[below] {Return value} (main);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Modular code}: Break large program into smaller parts
        \item \textbf{Reusability}: Call function multiple times
        \item \textbf{Declaration vs Definition}: Prototype vs Implementation
    \end{itemize}

    \begin{mnemonicbox}"CDRP" (Create, Define, Return, Pass)\end{mnemonicbox}
\end{solutionbox}

\questionmarks{5}{c}{7}
\textbf{Develop a C program to arrange elements of an array of 10 numbers in ascending order.}

\begin{solutionbox}
    This program sorts an array of 10 integers in ascending order using bubble sort algorithm.

\begin{lstlisting}[language=C]
#include <stdio.h>

int main() {
    int arr[10], i, j, temp;
    
    // Input array elements
    printf("Enter 10 integers: \n");
    for (i = 0; i < 10; i++) {
        scanf("%d", &arr[i]);
    }
    
    // Bubble sort algorithm for ascending order
    for (i = 0; i < 9; i++) {
        for (j = 0; j < 9 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap if current element is greater than next
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    
    // Display sorted array
    printf("Array in ascending order: \n");
    for (i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    
    return 0;
}
\end{lstlisting}

    \textbf{Flowchart: Bubble Sort}

    \begin{center}
    \begin{tikzpicture}[gtu flow]
        \node[gtu start] (start) {Start};
        \node[gtu input, below=of start] (input) {Input 10 elements};
        \node[gtu process, below=of input] (init_i) {i = 0};
        \node[gtu decision, alias=cond_i, below=of init_i] {i < 9?};
        
        \node[gtu process, alias=init_j, right=of cond_i, xshift=2cm] {j = 0};
        \node[gtu decision, alias=cond_j, below=of init_j] {j < 9-i?};
        
        \node[gtu decision, alias=swap_cond, below=of cond_j] {arr[j] > arr[j+1]?};
        \node[gtu process, alias=swap, right=of swap_cond, xshift=1cm] {Swap arr[j] and arr[j+1]};
        \node[gtu process, alias=inc_j, below=of swap_cond] {j++};
        
        \node[gtu process, alias=inc_i, left=of cond_j, xshift=-1cm] {i++};
        \node[gtu output, left=of inc_i, xshift=-1cm] (output) {Output sorted array};
        \node[gtu stop, below=of output] (stop) {End};

        \draw[gtu arrow] (start) -- (input);
        \draw[gtu arrow] (input) -- (init_i);
        \draw[gtu arrow] (init_i) -- (cond_i);
        
        \draw[gtu arrow] (cond_i) -- node[above] {Yes} (init_j);
        \draw[gtu arrow] (cond_i) -- node[above] {No} (output);
        
        \draw[gtu arrow] (init_j) -- (cond_j);
        \draw[gtu arrow] (cond_j) -- node[right] {Yes} (swap_cond);
        \draw[gtu arrow] (cond_j) -- node[above] {No} (inc_i);
        
        \draw[gtu arrow] (swap_cond) -- node[above] {Yes} (swap);
        \draw[gtu arrow] (swap_cond) -- node[right] {No} (inc_j);
        
        \draw[gtu arrow] (swap) |- (inc_j);
        \draw[gtu arrow] (inc_j.west) -- ++(-0.5,0) |- (cond_j.west);
        
        \draw[gtu arrow] (inc_i) |- (cond_i);
        \draw[gtu arrow] (output) -- (stop);
    \end{tikzpicture}
    \end{center}

    \begin{itemize}
        \item \textbf{Bubble sort}: Compare adjacent elements and swap if needed
        \item \textbf{Nested loops}: Outer loop for passes, inner loop for comparisons
        \item \textbf{Optimization}: Each pass fixes at least one element, so inner loop runs fewer times
    \end{itemize}

    \begin{mnemonicbox}"BSCOT" (Bubble Sort Compares and Orders Things)\end{mnemonicbox}
\end{solutionbox}

\end{document}
