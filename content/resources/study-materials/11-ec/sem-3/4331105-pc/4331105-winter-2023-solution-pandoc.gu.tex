\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331105 -- Winter 2023}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(a) [3
ગુણ]}\label{q1a}

\textbf{અલ્ગોરિધમ વ્યાખ્યાયિત કરો અને વર્તુળનું ક્ષેત્રફળ શોધવા માટેનું અલ્ગોરિધમ લખો.}

\begin{solutionbox}
અલ્ગોરિધમ એટલે કોઈ ચોક્કસ સમસ્યાના ઉકેલ માટેની પગલાવાર પ્રક્રિયા
અથવા નિયમોનો સમૂહ.

\textbf{વર્તુળના ક્ષેત્રફળનું અલ્ગોરિધમ:}

\begin{verbatim}
પગલું 1: શરૂ
પગલું 2: વર્તુળની ત્રિજ્યા (r) ઇનપુટ લો
પગલું 3: ક્ષેત્રફળ = π \times r^{2} ની ગણતરી કરો
પગલું 4: ક્ષેત્રફળ દર્શાવો
પગલું 5: અંત
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``શરૂ, વાંચો, ગણતરી, પ્રદર્શન, અંત''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(b) [4
ગુણ]}\label{q1b}

\textbf{ફ્લોચાર્ટ વ્યાખ્યાયિત કરો અને આપેલ ત્રણ સંખ્યાઓ માંથી ઓછામાં ઓછી સંખ્યા શોધવા
માટેનો ફ્લોચાર્ટ દોરો.}

\begin{solutionbox}
ફ્લોચાર્ટ એટલે પ્રમાણિત પ્રતીકો અને આકારોનો ઉપયોગ કરીને
એલ્ગોરિધમનું દ્રશ્ય નિરૂપણ, જે પગલાઓના ક્રમને દર્શાવે છે.

\textbf{ત્રણ સંખ્યાઓમાંથી ન્યૂનતમ શોધવા માટેનો ફ્લોચાર્ટ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input three numbers A, B, C/]}
    B {-{-} C\{Is A  B?\}}
    C {-{-}|Yes| D\{Is A  C?\}}
    C {-{-}|No| E\{Is B  C?\}}
    D {-{-}|Yes| F[min = A]}
    D {-{-}|No| G[min = C]}
    E {-{-}|Yes| H[min = B]}
    E {-{-}|No| I[min = C]}
    F {-{-} J[/Display min/]}
    G {-{-} J}
    H {-{-} J}
    I {-{-} J}
    J {-{-} K([Stop])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{તુલના વ્યૂહરચના}: પહેલા A અને B ની તુલના કરો, પછી C સાથે તુલના કરો
\item
  \textbf{બ્રાન્ચિંગ લોજિક}: સૌથી નાની કિંમત શોધવા માટે if-else સ્ટ્રક્ચરનો
  ઉપયોગ કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``જોડાઓની તુલના કરો, દુર્લભ નાની કિંમત દરેક જગ્યાએ શોધો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c) [7
ગુણ]}\label{q1c}

\textbf{નીચેના સમીકરણનો ઉપયોગ કરીને સિમ્પલ ઇન્ટરેસ્ટની ગણતરી કરવા માટેનો
પ્રોગ્રામ લખો.

I=PRN/100 જ્યાં

P=પ્રિન્સીપલ રકમ,

R=વ્યાજનો દર અને

N=સમયગાળો.}


\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    float P, R, N, I;
    
    // પ્રિન્સિપલ રકમ, વ્યાજનો દર અને સમયગાળો ઇનપુટ લો
    printf("પ્રિન્સિપલ રકમ દાખલ કરો: ");
    scanf("\%f", \&P);
    
    printf("વ્યાજનો દર દાખલ કરો: ");
    scanf("\%f", \&R);
    
    printf("સમયગાળો (વર્ષમાં) દાખલ કરો: ");
    scanf("\%f", \&N);
    
    // સિમ્પલ ઇન્ટરેસ્ટની ગણતરી કરો
    I = (P * R * N) / 100;
    
    // પરિણામ દર્શાવો
    printf("સિમ્પલ ઇન્ટરેસ્ટ = \%.2f{n}", I);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    P["મુદ્દલ (P)"] {-{-} Formula["I = (P  R  N) / 100"]}
    R["દર (R)"] {-{-} Formula}
    N["સમયગાળો (N)"] {-{-} Formula}
    Formula {-{-} Interest["વ્યાજ (I)"]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફ્લોટિંગ-પોઇન્ટ વેરિએબલ્સ}: ચોકસાઈ માટે દશાંશ મૂલ્યો સ્ટોર કરે છે
\item
  \textbf{વપરાશકર્તા ઇન્ટરેક્શન}: ઇનપુટ માટે સ્પષ્ટ પ્રોમ્પ્ટ્સ
\item
  \textbf{પરિણામ ફોર્મેટિંગ}: \%.2f બે દશાંશ સ્થાન દર્શાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``મુદ્દલ, દર અને સંખ્યા, સોથી ભાગીએ તો મળે વ્યાજ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1c-or-7-uxa97uxaa3}

\textbf{કીબોર્ડ દ્વારા ત્રિજ્યા(R) અને ઊંચાઈ(H) ઈનપુટ લઇ સિલિન્ડરના વોલ્યુમ(V)ની
ગણતરી કરીને પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો V=πR^{2}H}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    float radius, height, volume;
    const float PI = 3.14159;
    
    // ત્રિજ્યા અને ઊંચાઈ ઇનપુટ લો
    printf("સિલિન્ડરની ત્રિજ્યા દાખલ કરો: ");
    scanf("\%f", \&radius);
    
    printf("સિલિન્ડરની ઊંચાઈ દાખલ કરો: ");
    scanf("\%f", \&height);
    
    // સિલિન્ડરના વોલ્યુમની ગણતરી કરો
    volume = PI * radius * radius * height;
    
    // પરિણામ દર્શાવો
    printf("સિલિન્ડરનું વોલ્યુમ = \%.2f{n}", volume);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A[/ત્રિજ્યા, ઊંચાઈ ઇનપુટ લો/] {-{-} B["વોલ્યુમની ગણતરી કરો = π  ત્રિજ્યા^{2}  ઊંચાઈ"]}
    B {-{-} C[/વોલ્યુમ દર્શાવો/]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કોન્સ્ટન્ટ્સ}: સ્પષ્ટતા માટે PI કોન્સ્ટન્ટ તરીકે વ્યાખ્યાયિત કરવામાં આવ્યું છે
\item
  \textbf{ફોર્મ્યુલા}: ત્રિજ્યાને બે વખત ગુણીને R^{2} નો ઉપયોગ કરો
\item
  \textbf{ઇનપુટ વેલિડેશન}: ત્રિજ્યા અને ઊંચાઈ માટે ધનાત્મક મૂલ્યોની ધારણા કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ત્રિજ્યાનો વર્ગ ગુણો ઊંચાઈ ગુણો પાઈ, આપે સિલિન્ડરનું વોલ્યુમ,
ન પૂછો શા માટે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a) [3
ગુણ]}\label{q2a}

\textbf{સી પ્રોગ્રામિંગ ભાષામાં સપોર્ટ કરતા વિવિધ ઓપરેટરોની યાદી બનાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4762}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5238}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
વર્ગ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઓપરેટર્સ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
અંકગણિત & +, -, *, /, \% (સરવાળો, બાદબાકી, ગુણાકાર, ભાગાકાર, મોડ્યુલસ) \\
રિલેશનલ & ==, !=, \textgreater, \textless, \textgreater=, \textless=
(સમાન, અસમાન, મોટું, નાનું, મોટું અથવા સમાન, નાનું અથવા સમાન) \\
લોજિકલ & \&\&, \textbar\textbar, ! (AND, OR, NOT) \\
એસાઇનમેન્ટ & =, +=, -=, *=, /=, \%= (એસાઇન, પ્લસ-એસાઇન, માઇનસ-એસાઇન,
વગેરે) \\
ઇન્ક્રિમેન્ટ/ડિક્રિમેન્ટ & ++, -- (ઇન્ક્રિમેન્ટ, ડિક્રિમેન્ટ) \\
બિટવાઇઝ & \&, \textbar, \^{}, \textasciitilde, \textless\textless,
\textgreater\textgreater{} (AND, OR, XOR, કોમ્પ્લિમેન્ટ, લેફ્ટ શિફ્ટ, રાઇટ
શિફ્ટ) \\
કન્ડિશનલ & ? : (ટર્નરી ઓપરેટર) \\
સ્પેશિયલ & sizeof(), \&, *, -\textgreater, . (સાઇઝ, એડ્રેસ, પોઇન્ટર,
સ્ટ્રક્ચર) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ARABIA CS'' (અંકગણિત, રિલેશનલ, એસાઇનમેન્ટ, બિટવાઇઝ,
ઇન્ક્રિમેન્ટ, એસાઇનમેન્ટ, કન્ડિશનલ, સ્પેશિયલ)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b) [4
ગુણ]}\label{q2b}

\textbf{ઉદાહરણ સાથે રિલેશનલ ઓપરેટર અને ઇન્ક્રીમેન્ટ/ડિક્રીમેન્ટ ઓપરેટર સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1778}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેટર પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આઉટપુટ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
રિલેશનલ & બે મૂલ્યોની વચ્ચેના સંબંધની તપાસ કરે છે &
\texttt{int\ a\ =\ 5,\ b\ =\ 10;}\texttt{printf("\%d",\ a\ \textless{}\ b);}
& \texttt{1} (સાચું) \\
& સમાન (==) & \texttt{printf("\%d",\ 5\ ==\ 5);} & \texttt{1} (સાચું) \\
& અસમાન (!=) & \texttt{printf("\%d",\ 5\ !=\ 10);} & \texttt{1} (સાચું) \\
& મોટું/નાનું &
\texttt{printf("\%d\ \%d",\ 5\ \textgreater{}\ 3,\ 5\ \textless{}\ 3);}
& \texttt{1\ 0} \\
ઇન્ક્રિમેન્ટ & મૂલ્યમાં 1 વધારો કરે છેપ્રી-ઇન્ક્રિમેન્ટ (++x): પહેલા વધારો પછી
ઉપયોગપોસ્ટ-ઇન્ક્રિમેન્ટ (x++): પહેલા ઉપયોગ પછી વધારો &
\texttt{int\ x\ =\ 5;}\texttt{printf("\%d\ ",\ ++x);}\texttt{printf("\%d",\ x);}
& \texttt{6\ 6} \\
ડિક્રિમેન્ટ & મૂલ્યમાં 1 ઘટાડો કરે છેપ્રી-ડિક્રિમેન્ટ (--x): પહેલા ઘટાડો પછી
ઉપયોગપોસ્ટ-ડિક્રિમેન્ટ (x--): પહેલા ઉપયોગ પછી ઘટાડો &
\texttt{int\ y\ =\ 5;}\texttt{printf("\%d\ ",\ y-\/-);}\texttt{printf("\%d",\ y);}
& \texttt{5\ 4} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{રિલેશનલ ઓપરેટર્સ}: 1 (સાચું) અથવા 0 (ખોટું) પરત કરે છે
\item
  \textbf{ઇન્ક્રિમેન્ટ/ડિક્રિમેન્ટ}: વેરિએબલ મૂલ્ય બદલે છે અને મૂલ્ય પરત કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``રિલેશનલ કહે સાચું કે ખોટું, ઇન્ક્રિમેન્ટ/ડિક્રિમેન્ટ કરે ચઢાવ કે
ઉતાર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c) [7
ગુણ]}\label{q2c}

\textbf{1 થી 100 નો સરવાળો અને એવરેજ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i, sum = 0;
    float average;
    
    // 1 થી 100 સુધીની સંખ્યાઓનો સરવાળો ગણો
    for(i = 1; i {=} 100; i++) \{
        sum += i;
    \}
    
    // એવરેજ ગણો
    average = (float)sum / 100;
    
    // પરિણામો દર્શાવો
    printf("1 થી 100 સુધીની સંખ્યાઓનો સરવાળો = \%d{n}", sum);
    printf("1 થી 100 સુધીની સંખ્યાઓની સરેરાશ = \%.2f{n}", average);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[sum = 0 સેટ કરો]}
    B {-{-} C[i = 1 સેટ કરો]}
    C {-{-} D\{શું i = 100?\}}
    D {-{-}|હા| E[sum = sum + i]}
    E {-{-} F[i = i + 1]}
    F {-{-} D}
    D {-{-}|ના| G[average = sum / 100 ની ગણતરી કરો]}
    G {-{-} H[sum અને average દર્શાવો]}
    H {-{-} I([Stop])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{લૂપ કાઉન્ટર}: વેરિએબલ i 1 થી 100 સુધીની સંખ્યાઓ ટ્રેક કરે છે
\item
  \textbf{સરવાળાની ગણતરી}: sum વેરિએબલમાં મૂલ્યો એકત્રિત કરે છે
\item
  \textbf{ટાઇપ કાસ્ટિંગ}: (float) સરવાળાને ચોક્કસ ભાગાકાર માટે ફ્લોટિંગ-પોઇન્ટમાં
  કન્વર્ટ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``એક થી સો સરવાળો, પછી ભાગવાથી એવરેજ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2a-or-3-uxa97uxaa3}

\textbf{gets(S) અને scanf(``\%s'',S) ફંક્શન વચ્ચેનો તફાવત લખો જ્યાં S સ્ટ્રિંગ છે.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4545}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લક્ષણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
gets(S)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
scanf(``\%s'',S)
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ઇનપુટ સમાપ્તિ & ન્યૂલાઇન કેરેક્ટર (\n) સુધી વાંચે છે & વ્હાઇટસ્પેસ (સ્પેસ, ટેબ, ન્યૂલાઇન)
સુધી વાંચે છે \\
વ્હાઇટસ્પેસ હેન્ડલિંગ & સ્પેસ સાથેની સ્ટ્રિંગ વાંચી શકે છે & પ્રથમ વ્હાઇટસ્પેસ પર વાંચવાનું બંધ
કરે છે \\
બફર ઓવરફ્લો & બાઉન્ડ્સ ચેકિંગ નથી (અસુરક્ષિત) & બાઉન્ડ્સ ચેકિંગ નથી (અસુરક્ષિત) \\
રિટર્ન વેલ્યુ & સફળતા પર S, ભૂલ પર NULL પરત કરે છે & સફળતાપૂર્વક વાંચેલી આઇટમ્સની
સંખ્યા પરત કરે છે \\
રિપ્લેસમેન્ટ & fgets() વધુ સુરક્ષિત વિકલ્પ છે & વિડ્થ લિમિટ સાથે scanf(``\%ns'',S)
વધુ સુરક્ષિત છે \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{સુરક્ષા ચિંતા}: બંને ફંક્શન બફર ઓવરફ્લો કરી શકે છે
\item
  \textbf{વ્યવહારિક ઉપયોગ}: gets() પૂર્ણ લાઇન્સ માટે, scanf() એકલ શબ્દો માટે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``gets મેળવે બધું ન્યૂલાઇન સુધી, scanf અટકે સફેદી જોતાં જ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2b-or-4-uxa97uxaa3}

\textbf{ઉદાહરણ સાથે લોજિકલ ઓપરેટર અને એસાઈનમેન્ટ ઓપરેટર સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1778}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેટર પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આઉટપુટ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
લોજિકલ & શરતો પર લોજિકલ ઓપરેશન્સ કરે છે & \texttt{int\ a\ =\ 5,\ b\ =\ 10;}
& \\
& લોજિકલ AND (\&\&) &
\texttt{printf("\%d",\ (a\ \textgreater{}\ 0)\ \&\&\ (b\ \textgreater{}\ 0));}
& \texttt{1} (સાચું) \\
& લોજિકલ OR (\textbar\textbar) &
\texttt{printf("\%d",\ (a\ \textgreater{}\ 10)\ \textbackslash{}\textbar{}\textbackslash{}\textbar{}\ (b\ \textgreater{}\ 5));}
& \texttt{1} (સાચું) \\
& લોજિકલ NOT (!) & \texttt{printf("\%d",\ !(a\ ==\ b));} & \texttt{1}
(સાચું) \\
એસાઇનમેન્ટ & વેરિએબલ્સને મૂલ્યો આપે છે & \texttt{int\ x\ =\ 10;} &
\texttt{x\ =\ 10} \\
& સિમ્પલ એસાઇનમેન્ટ (=) & \texttt{x\ =\ 20;} & \texttt{x\ =\ 20} \\
& એડ અને એસાઇન (+=) & \texttt{x\ +=\ 5;} & \texttt{x\ =\ 25} \\
& સબટ્રેક્ટ અને એસાઇન (-=) & \texttt{x\ -=\ 10;} & \texttt{x\ =\ 15} \\
& મલ્ટિપ્લાય અને એસાઇન (*=) & \texttt{x\ *=\ 2;} & \texttt{x\ =\ 30} \\
& ડિવાઇડ અને એસાઇન (/=) & \texttt{x\ /=\ 3;} & \texttt{x\ =\ 10} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{લોજિકલ ઓપરેટર્સ}: નિર્ણય લેવામાં ઉપયોગ થાય છે
\item
  \textbf{શોર્ટ-સર્કિટ ઇવેલ્યુએશન}: \&\& અને \textbar\textbar{} જરૂરી હોય એટલું જ
  મૂલ્યાંકન કરે છે
\item
  \textbf{કંપાઉન્ડ એસાઇનમેન્ટ}: ઓપરેશન અને એસાઇનમેન્ટ જોડે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``AND માગે બધા સાચા, OR માગે એક; એસાઇનમેન્ટ લે જમણું, ડાબે
મૂકે એક''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2c-or-7-uxa97uxaa3}

\textbf{આપેલ બે ફ્લોટિંગ પોઈન્ટ નંબરો વચ્ચેના તમામ પૂર્ણાંકોને પ્રિન્ટ કરવા માટેનો
પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}
\#include {math.h}

int main() \{
    float num1, num2;
    int start, end, i;
    
    // બે ફ્લોટિંગ પોઇન્ટ નંબર ઇનપુટ લો
    printf("પ્રથમ ફ્લોટિંગ પોઇન્ટ નંબર દાખલ કરો: ");
    scanf("\%f", \&num1);
    
    printf("બીજો ફ્લોટિંગ પોઇન્ટ નંબર દાખલ કરો: ");
    scanf("\%f", \&num2);
    
    // નાની સંખ્યાનો સીલિંગ અને મોટી સંખ્યાનો ફ્લોર શોધો
    if(num1 {} num2) \{
        start = ceil(num1);
        end = floor(num2);
    \} else \{
        start = ceil(num2);
        end = floor(num1);
    \}
    
    // બે સંખ્યાઓ વચ્ચેના તમામ પૂર્ણાંકો પ્રિન્ટ કરો
    printf("\%.2f અને \%.2f વચ્ચેના પૂર્ણાંકો છે:{n}", num1, num2);
    for(i = start; i {=} end; i++) \{
        printf("\%d ", i);
    \}
    printf("{n}");
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A[/num1, num2 ઇનપુટ લો/] {-{-} B\{શું num1  num2?\}}
    B {-{-}|હા| C["start = ceil(num1)br /end = floor(num2)"]}
    B {-{-}|ના| D["start = ceil(num2)br /end = floor(num1)"]}
    C {-{-} E[start થી end સુધીના પૂર્ણાંકો પ્રિન્ટ કરો]}
    D {-{-} E}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મેથ ફંક્શન્સ}: ceil() ઉપર રાઉન્ડ કરે છે, floor() નીચે રાઉન્ડ કરે છે
\item
  \textbf{રેન્જ નિર્ધારણ}: ઇનપુટ ઓર્ડરથી સ્વતંત્ર કામ કરે છે
\item
  \textbf{ઇન્ટીજર એક્સટ્રેક્શન}: ફ્લોટ્સ વચ્ચેના ફક્ત પૂર્ણાંકો પ્રિન્ટ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``નાનાને છત બનાવો, મોટાને ભોંયતળિયું, પછી પ્રિન્ટ કરો વચ્ચેના
બધા પૂર્ણાંકો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a) [3
ગુણ]}\label{q3a}

\textbf{ઉદાહરણ સાથે multiple if-else સ્ટેટમેન્ટ સમજાવો.}

\begin{solutionbox}

Multiple if-else સ્ટેટમેન્ટ્સ ક્રમશઃ અનેક શરતોની તપાસ કરવા માટે વપરાય છે, જેમાં દરેક
શરત માત્ર ત્યારે જ ચકાસવામાં આવે છે જ્યારે અગાઉની શરતો ખોટી હોય.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int marks;
    
    printf("ગુણ દાખલ કરો (0{-100): "});
    scanf("\%d", \&marks);
    
    if(marks {=} 80) \{
        printf("ગ્રેડ: A{n}");
    \} else if(marks {=} 70) \{
        printf("ગ્રેડ: B{n}");
    \} else if(marks {=} 60) \{
        printf("ગ્રેડ: C{n}");
    \} else if(marks {=} 50) \{
        printf("ગ્રેડ: D{n}");
    \} else \{
        printf("ગ્રેડ: F{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A[/ગુણ ઇનપુટ લો/] {-{-} B\{marks = 80?\}}
    B {-{-}|હા| C[ગ્રેડ: A]}
    B {-{-}|ના| D\{marks = 70?\}}
    D {-{-}|હા| E[ગ્રેડ: B]}
    D {-{-}|ના| F\{marks = 60?\}}
    F {-{-}|હા| G[ગ્રેડ: C]}
    F {-{-}|ના| H\{marks = 50?\}}
    H {-{-}|હા| I[ગ્રેડ: D]}
    H {-{-}|ના| J[ગ્રેડ: F]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ક્રમિક પરીક્ષણ}: ફક્ત એક બ્લોક જ એક્ઝિક્યુટ થાય છે
\item
  \textbf{કાર્યક્ષમતા}: સાચી શરત મળ્યા પછી તપાસ બંધ થઈ જાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``જો આ તો એ, નહીં તો જો પેલું તો એમ, નહીં તો જો અન્ય તો
અલગ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b) [4
ગુણ]}\label{q3b}

\textbf{While લૂપ અને for લૂપની કામગીરી જણાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2821}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2051}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2821}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લૂપ પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
કામગીરી
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ કેસ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
while લૂપ & 1. શરત ચકાસો2. જો સાચી હોય તો બોડી એક્ઝિક્યુટ કરો3. શરત ખોટી થાય
ત્યાં સુધી 1-2 પગલાં પુનરાવર્તિત કરો &
\texttt{while(condition)\ \{}\texttt{//\ સ્ટેટમેન્ટ્સ}\texttt{\}} & જ્યારે
પુનરાવર્તનની સંખ્યા અગાઉથી ખબર ન હોય \\
for લૂપ & 1. ઇનિશિયલાઇઝેશન એક વખત એક્ઝિક્યુટ કરો2. શરત ચકાસો3. જો સાચી હોય તો
બોડી એક્ઝિક્યુટ કરો4. અપડેટ સ્ટેટમેન્ટ એક્ઝિક્યુટ કરો5. શરત ખોટી થાય ત્યાં સુધી 2-4
પગલાં પુનરાવર્તિત કરો &
\texttt{for(initialization;\ condition;\ update)\ \{}\texttt{//\ સ્ટેટમેન્ટ્સ}\texttt{\}}
& જ્યારે પુનરાવર્તનની સંખ્યા અગાઉથી ખબર હોય \\
\end{longtable}
}

\textbf{તુલના:}

\begin{verbatim}
flowchart TD
    subgraph "while લૂપ"
    A1[શરૂ] {-{-} B1\{શરતbr /સાચી?\}}
    B1 {-{-}|હા| C1[બોડીbr /એક્ઝિક્યુટ કરો]}
    C1 {-{-} B1}
    B1 {-{-}|ના| D1[અંત]}
    end

    subgraph "for લૂપ"
    A2[ઇનિશિયલાઇઝેશન] {-{-} B2\{શરતbr /સાચી?\}}
    B2 {-{-}|હા| C2[બોડીbr /એક્ઝિક્યુટ કરો]}
    C2 {-{-} D2[અપડેટ]}
    D2 {-{-} B2}
    B2 {-{-}|ના| E2[અંત]}
    end
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{એન્ટ્રી કંટ્રોલ}: બંને એક્ઝિક્યુશન પહેલાં શરત ચકાસે છે
\item
  \textbf{ઘટકો}: for લૂપ ઇનિશિયલાઇઝેશન, શરત અને અપડેટ જોડે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``WHILE તપાસે પછી કરે, FOR શરૂ કરે તપાસે કરે અપડેટ કરે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c) [7
ગુણ]}\label{q3c}

\textbf{આપેલ સંખ્યાના ફેક્ટોરિયલ શોધવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num, i;
    unsigned long long factorial = 1;
    
    // એક સંખ્યા ઇનપુટ લો
    printf("ધનાત્મક પૂર્ણાંક દાખલ કરો: ");
    scanf("\%d", \&num);
    
    // તપાસો કે સંખ્યા નકારાત્મક તો નથી
    if(num {} 0) \{
        printf("ભૂલ: નકારાત્મક સંખ્યાઓનું ફેક્ટોરિયલ વ્યાખ્યાયિત નથી.{n}");
    \} else \{
        // ફેક્ટોરિયલની ગણતરી કરો
        for(i = 1; i {=} num; i++) \{
            factorial *= i;
        \}
        
        printf("\%d નું ફેક્ટોરિયલ = \%llu{n}", num, factorial);
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/સંખ્યા ઇનપુટ લો/]}
    B {-{-} C\{શું સંખ્યા  0?\}}
    C {-{-}|હા| D[/ભૂલ સંદેશ દર્શાવો/]}
    C {-{-}|ના| E[factorial = 1 સેટ કરો]}
    E {-{-} F[i = 1 સેટ કરો]}
    F {-{-} G\{શું i = સંખ્યા?\}}
    G {-{-}|હા| H[factorial = factorial * i]}
    H {-{-} I[i = i + 1]}
    I {-{-} G}
    G {-{-}|ના| J[/ફેક્ટોરિયલ દર્શાવો/]}
    D {-{-} K([Stop])}
    J {-{-} K}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ડેટા ટાઇપ}: મોટા ફેક્ટોરિયલ માટે unsigned long long
\item
  \textbf{ભૂલ હેન્ડલિંગ}: નકારાત્મક ઇનપુટ માટે ચકાસણી
\item
  \textbf{લૂપ અમલીકરણ}: ક્રમિક પૂર્ણાંકોનો ગુણાકાર
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ફેક્ટોરિયલ ફોર્મ્યુલા: એકથી સંખ્યા સુધી ગુણાકાર''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3a-or-3-uxa97uxaa3}

\textbf{ઉદાહરણ સાથે switch-case સ્ટેટમેન્ટની કામગીરી સમજાવો.}

\begin{solutionbox}

Switch-case સ્ટેટમેન્ટ એ એક મલ્ટી-વે ડિસીઝન મેકર છે જે અભિવ્યક્તિના મૂલ્યને વિવિધ કેસ
મૂલ્યો સામે તપાસે છે અને મેચ થતા કેસ બ્લોકને એક્ઝિક્યુટ કરે છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int day;
    
    printf("દિવસનો નંબર દાખલ કરો (1{-7): "});
    scanf("\%d", \&day);
    
    switch(day) \{
        case 1:
            printf("સોમવાર{n}");
            break;
        case 2:
            printf("મંગળવાર{n}");
            break;
        case 3:
            printf("બુધવાર{n}");
            break;
        case 4:
            printf("ગુરુવાર{n}");
            break;
        case 5:
            printf("શુક્રવાર{n}");
            break;
        case 6:
            printf("શનિવાર{n}");
            break;
        case 7:
            printf("રવિવાર{n}");
            break;
        default:
            printf("અમાન્ય દિવસ નંબર{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A[/દિવસ ઇનપુટ લો/] {-{-} B\{"switch(day)"\}}
    B {-{-} C1\{case 1\}}
    B {-{-} C2\{case 2\}}
    B {-{-} C3\{...\}}
    B {-{-} C4\{case 7\}}
    B {-{-} C5\{default\}}
    C1 {-{-}|મેચ| D1[Print {-} સોમવાર]}
    C2 {-{-}|મેચ| D2[Print {-} મંગળવાર]}
    C3 {-{-}|મેચ| D3[...]}
    C4 {-{-}|મેચ| D4[Print {-} રવિવાર]}
    C5 {-{-}|કોઈ મેચ નહીં| D5[Print {-} અમાન્ય દિવસ]}
    D1 {-{-} E[break]}
    D2 {-{-} E}
    D3 {-{-} E}
    D4 {-{-} E}
    D5 {-{-} F([End])}
    E {-{-} F}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{અભિવ્યક્તિ મૂલ્યાંકન}: ફક્ત ઇન્ટીજર અથવા કેરેક્ટર ટાઈપ્સ
\item
  \textbf{કેસ મેચિંગ}: break સુધી મેચીંગ કેસ એક્ઝિક્યુટ કરે છે
\item
  \textbf{ડિફોલ્ટ કેસ}: કોઈ કેસ મેચ ન થાય ત્યારે એક્ઝિક્યુટ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SWITCH મૂલ્ય, CASE મેળ, BREAK બહાર, DEFAULT બચાવ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3b-or-4-uxa97uxaa3}

\textbf{break અને continue કીવર્ડ વ્યાખ્યાયિત કરો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3077}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2308}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કીવર્ડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વ્યાખ્યા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
break & સૌથી અંદરના લૂપ અથવા switch સ્ટેટમેન્ટને તરત જ સમાપ્ત કરે છે & જ્યારે કોઈ
ચોક્કસ શરત પૂરી થાય ત્યારે લૂપમાંથી બહાર નીકળવા માટે &
\texttt{c\ for(i=1;\ i\textless{}=10;\ i++)\ \{\ if(i\ ==\ 5)\ break;\ printf("\%d\ ",\ i);\ \}\ //\ આઉટપુટ:\ 1\ 2\ 3\ 4} \\
continue & લૂપના વર્તમાન પુનરાવર્તનના બાકીના ભાગને છોડીને લૂપના આગલા પુનરાવર્તન
પર જાય છે & લૂપને સમાપ્ત કર્યા વિના ચોક્કસ પુનરાવર્તનો છોડવા માટે &
\texttt{c\ for(i=1;\ i\textless{}=10;\ i++)\ \{\ if(i\ ==\ 5)\ continue;\ printf("\%d\ ",\ i);\ \}\ //\ આઉટપુટ:\ 1\ 2\ 3\ 4\ 6\ 7\ 8\ 9\ 10} \\
\end{longtable}
}

\textbf{વર્તન તુલના:}

\begin{verbatim}
flowchart TD
    subgraph "break"
    A1[લૂપમાં પ્રવેશ] {-{-} B1\{break માટેbr /શરત?\}}
    B1 {-{-}|હા| C1[લૂપથી બહાર નીકળો]}
    B1 {-{-}|ના| D1[એક્ઝિક્યુશનbr /ચાલુ રાખો]}
    D1 {-{-} E1[આગલાbr /પુનરાવર્તન]}
    E1 {-{-} B1}
    end

    subgraph "continue"
    A2[લૂપમાં પ્રવેશ] {-{-} B2\{continue માટેbr /શરત?\}}
    B2 {-{-}|હા| C2[લૂપ બોડીનો બાકીનોbr /ભાગ છોડો]}
    B2 {-{-}|ના| D2[એક્ઝિક્યુશનbr /ચાલુ રાખો]}
    C2 {-{-} E2[આગલાbr /પુનરાવર્તન]}
    D2 {-{-} E2}
    E2 {-{-} B2}
    end
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{સ્કોપ}: બંને માત્ર સૌથી અંદરના લૂપને અસર કરે છે
\item
  \textbf{કંટ્રોલ ટ્રાન્સફર}: break લૂપમાંથી બહાર નીકળે છે, continue આગલા
  પુનરાવર્તન પર જાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BREAK રૂમ છોડે છે, CONTINUE આગલી ડાન્સ મૂવ પર જાય છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3c-or-7-uxa97uxaa3}

\textbf{કીબોર્ડ પરથી લાઈન(n) ની સંખ્યા વાંચી અને નીચે દશાર્વેલ ટ્રાઇંગલ પ્રિન્ટ કરવા
માટેનો પ્રોગ્રામ લાખો.}

\textbf{ઉદાહરણ તરીકે, n=5}

\begin{verbatim}
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
\end{verbatim}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int n, i, j;
    
    // લાઈનની સંખ્યા ઇનપુટ લો
    printf("લાઈનની સંખ્યા દાખલ કરો: ");
    scanf("\%d", \&n);
    
    // ટ્રાયેંગલ પેટર્ન પ્રિન્ટ કરો
    for(i = 1; i {=} n; i++) \{
        // દરેક રોમાં 1 થી i સુધીની સંખ્યાઓ પ્રિન્ટ કરો
        for(j = 1; j {=} i; j++) \{
            printf("\%d ", j);
        \}
        printf("{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{પેટર્ન વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
રો 1: 1
રો 2: 1 2
રો 3: 1 2 3
રો 4: 1 2 3 4
રો 5: 1 2 3 4 5
\end{verbatim}

\textbf{પ્રોગ્રામ પ્રવાહ:}

\begin{verbatim}
flowchart LR
    A[/n ઇનપુટ લો/] {-{-} B[i = 1 સેટ કરો]}
    B {-{-} C\{શું i = n?\}}
    C {-{-}|હા| D[j = 1 સેટ કરો]}
    D {-{-} E\{શું j = i?\}}
    E {-{-}|હા| F[/j પ્રિન્ટ કરો/]}
    F {-{-} G[j = j + 1]}
    G {-{-} E}
    E {-{-}|ના| H[/ન્યૂલાઇન પ્રિન્ટ કરો/]}
    H {-{-} I[i = i + 1]}
    I {-{-} C}
    C {-{-}|ના| J([Stop])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{નેસ્ટેડ લૂપ્સ}: આઉટર લૂપ રો માટે, ઇનર લૂપ કોલમ માટે
\item
  \textbf{પેટર્ન લોજિક}: રો નંબર નક્કી કરે છે કે કેટલી સંખ્યાઓ પ્રિન્ટ કરવી
\item
  \textbf{સંખ્યા ક્રમ}: દરેક રો 1 થી રો નંબર સુધી પ્રિન્ટ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``રો નક્કી કરે મર્યાદા, કોલમ પ્રિન્ટ કરે એકથી રો સુધી''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a) [3
ગુણ]}\label{q4a}

\textbf{Nested if-else સ્ટેટમેન્ટને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

Nested if-else સ્ટેટમેન્ટ્સ એ if-else કન્સ્ટ્રક્ટ્સ છે જે બીજા if અથવા else બ્લોકની
અંદર મૂકવામાં આવે છે, જે વધુ જટિલ શરતી તર્ક અને નિર્ણય લેવાના બહુવિધ સ્તરોની મંજૂરી આપે
છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int age;
    char hasID;
    
    printf("ઉંમર દાખલ કરો: ");
    scanf("\%d", \&age);
    
    printf("શું તમારી પાસે ID છે? (Y/N): ");
    scanf(" \%c", \&hasID);
    
    if(age {=} 18) \{
        if(hasID == {Y} || hasID == {y}) \{
            printf("તમે મત આપી શકો છો!{n}");
        \} else \{
            printf("મત આપવા માટે ID જરૂરી છે.{n}");
        \}
    \} else \{
        printf("મત આપવા માટે તમારી ઉંમર 18 કે તેથી વધુ હોવી જોઈએ.{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{નિર્ણય વૃક્ષ:}

\begin{verbatim}
flowchart LR
    A[/ઉંમર અને hasID ઇનપુટ લો/] {-{-} B\{age = 18?\}}
    B {-{-}|હા| C\{hasID == Ybr /અથવા y?\}}
    C {-{-}|હા| D[તમે મત આપી શકો છો!]}
    C {-{-}|ના| E[મત આપવા માટે ID જરૂરી છે]}
    B {-{-}|ના| F[ઉંમર 18 કે તેથી વધુ હોવી જરૂરી]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{હાયરાર્કિકલ શરતો}: શરતોનું સ્તરમાં મૂલ્યાંકન કરે છે
\item
  \textbf{ઇન્ડેન્ટેશન}: નેસ્ટેડ સ્ટ્રક્ચર્સની વાંચનક્ષમતા સુધારે છે
\item
  \textbf{મલ્ટી-ફેક્ટર નિર્ણયો}: એકાધિક માપદંડો જોડે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``If ની અંદર if, ઊંડી શરતો ચકાસે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b) [4
ગુણ]}\label{q4b}

\textbf{One-dimensional array ના initialization નું વર્ણન કરો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.4444}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1481}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1667}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2407}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઇનિશિયલાઇઝેશન પદ્ધતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સાઇઝ સાથે ડેક્લેરેશન & \texttt{data\_type\ array\_name[size];} &
\texttt{int\ marks[5];} & નિર્દિષ્ટ સાઇઝ સાથે એરે બનાવે છે, એલિમેન્ટ્સમાં
ગાર્બેજ વેલ્યુ હોય છે \\
ઇનિશિયલાઇઝેશન સાથે ડેક્લેરેશન &
\texttt{data\_type\ array\_name[size]\ =\ \{values\};} &
\texttt{int\ ages[4]\ =\ \{21,\ 19,\ 25,\ 32\};} & ચોક્કસ મૂલ્યો સાથે એરે
બનાવે અને ઇનિશિયલાઇઝ કરે છે \\
આંશિક ઇનિશિયલાઇઝેશન &
\texttt{data\_type\ array\_name[size]\ =\ \{values\};} &
\texttt{int\ nums[5]\ =\ \{1,\ 2\};} & પ્રથમ એલિમેન્ટ્સ ઇનિશિયલાઇઝ કરે છે,
બાકીના શૂન્ય થાય છે \\
સાઇઝ ઇન્ફરન્સ & \texttt{data\_type\ array\_name[]\ =\ \{values\};} &
\texttt{int\ scores[]\ =\ \{95,\ 88,\ 72,\ 84,\ 91\};} &
ઇનિશિયલાઇઝર્સની સંખ્યા દ્વારા સાઇઝ નક્કી થાય છે \\
વ્યક્તિગત એલિમેન્ટ & \texttt{array\_name[index]\ =\ value;} &
\texttt{marks[0]\ =\ 85;} & ચોક્કસ એલિમેન્ટને મૂલ્ય આપે છે \\
\end{longtable}
}

\textbf{એરે વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
int numbers[5] = {10, 20, 30, 40, 50};
\end{verbatim}

\begin{verbatim}
┌─────┬─────┬─────┬─────┬─────┐
│ 10  │ 20  │ 30  │ 40  │ 50  │
└─────┴─────┴─────┴─────┴─────┘
  [0]   [1]   [2]   [3]   [4]   \leftarrow ઇન્ડેક્સ
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઝીરો-ઇન્ડેક્સિંગ}: પ્રથમ એલિમેન્ટ ઇન્ડેક્સ 0 પર
\item
  \textbf{કન્ટિગ્યુઅસ મેમરી}: એલિમેન્ટ્સ ક્રમશઃ સ્ટોર થાય છે
\item
  \textbf{સાઇઝ લિમિટેશન}: સાઇઝ કંપાઇલ ટાઇમે જાણીતી હોવી જરૂરી છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``પહેલા સાઇઝ જાહેર કરો, પછી મૂલ્યો ભરો અથવા કંપાઇલરને ગણવા
દો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c) [7
ગુણ]}\label{q4c}

\textbf{અરેને વ્યાખ્યાયિત કરો અને સ્ટ્રિંગને રિવર્સ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

એરે એ સમાન ડેટા આઇટમ્સનો સંગ્રહ છે જે સળંગ મેમરી સ્થાનો પર સંગ્રહિત થયેલા હોય છે અને એક
સામાન્ય નામનો ઉપયોગ કરીને એક્સેસ કરવામાં આવે છે.

\begin{verbatim}
\#include {stdio.h}
\#include {string.h}

int main() \{
    char str[100], reversed[100];
    int i, j, length;
    
    // સ્ટ્રિંગ ઇનપુટ લો
    printf("એક સ્ટ્રિંગ દાખલ કરો: ");
    gets(str);
    
    // સ્ટ્રિંગની લંબાઈ શોધો
    length = strlen(str);
    
    // સ્ટ્રિંગને રિવર્સ કરો
for(i = length {-} 1,

j = 0; i {=} 0; i{-{-},} j++) \{

        reversed[j] = str[i];
    \}
    
    // NULL ટર્મિનેટર ઉમેરો
    reversed[j] = {}{0}{};
    
    // રિવર્સ કરેલી સ્ટ્રિંગ દર્શાવો
    printf("રિવર્સ કરેલી સ્ટ્રિંગ: \%s{n}", reversed);
    
    return 0;
\}
\end{verbatim}

\textbf{એલ્ગોરિધમ વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
flowchart LR
    A["ઓરિજિનલ: {HELLO"] {-}{-} B["H"] \& C["E"] \& D["L"] \& E["L"] \& F["O"]}
    F {-{-} G["reversed[0]"]}
    E {-{-} H["reversed[1]"]}
    D {-{-} I["reversed[2]"]}
    C {-{-} J["reversed[3]"]}
    B {-{-} K["reversed[4]"]}
    G \& H \& I \& J \& K {-{-} L["રિવર્સ: OLLEH"]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કેરેક્ટર એરે}: NULL ટર્મિનેટર સાથે સ્ટ્રિંગ સ્ટોર કરે છે
\item
  \textbf{ટુ-પોઇન્ટર ટેકનિક}: એક ઓરિજિનલ માટે, એક રિવર્સ માટે
\item
  \textbf{ઝીરો-બેઝ્ડ ઇન્ડેક્સિંગ}: એરે ઇન્ડેક્સ 0 થી શરૂ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``અંતથી શરૂ કરો, શરૂઆતમાં મૂકો, શૂન્ય પર અટકો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4a-or-3-uxa97uxaa3}

\textbf{do while loop ઉદાહરણ સાથે સમજાવો}

\begin{solutionbox}

do-while લૂપ એ એક એક્ઝિટ-કંટ્રોલ્ડ લૂપ છે જે શરત ચકાસ્યા પહેલાં ઓછામાં ઓછી એક વખત લૂપ
બોડી એક્ઝિક્યુટ કરે છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num, sum = 0;
    
    do \{
        printf("એક સંખ્યા દાખલ કરો (0 રોકવા માટે): ");
        scanf("\%d", \&num);
        sum += num;
    \} while(num != 0);
    
    printf("બધી દાખલ કરેલી સંખ્યાઓનો સરવાળો: \%d{n}", sum);
    
    return 0;
\}
\end{verbatim}

\textbf{લૂપ એક્ઝિક્યુશન ફ્લો:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[sum = 0]}
    B {-{-} C[/num ઇનપુટ લો/]}
    C {-{-} D[sum = sum + num]}
    D {-{-} E\{શું num != 0?\}}
    E {-{-}|હા| C}
    E {-{-}|ના| F[/sum દર્શાવો/]}
    F {-{-} G([Stop])}
\end{verbatim}

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{એક્ઝિક્યુશન ઓર્ડર}: પહેલા બોડી, પછી શરત ચકાસણી
\item
  \textbf{ગેરેન્ટેડ એક્ઝિક્યુશન}: લૂપ બોડી હંમેશા ઓછામાં ઓછી એક વખત એક્ઝિક્યુટ થાય છે
\item
  \textbf{ટર્મિનેશન}: શરત લૂપના તળિયે મૂલ્યાંકિત થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``પહેલા કરો, પછી પૂછો''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4b-or-4-uxa97uxaa3}

\textbf{પોઇન્ટરને વ્યાખ્યાયિત કરો અને ઉદાહરણ સાથે પોઇન્ટરનું વર્ણન કરો.}

\begin{solutionbox}

પોઇન્ટર એક એવું વેરિએબલ છે જે અન્ય વેરિએબલનું મેમરી એડ્રેસ સ્ટોર કરે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4359}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2308}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પોઇન્ટર કોન્સેપ્ટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેક્લેરેશન & Data\_type *pointer\_name; & \texttt{int\ *ptr;} \\
ઇનિશિયલાઇઝેશન & વેરિએબલનું એડ્રેસ એસાઇન કરવું &
\texttt{int\ num\ =\ 10;\ int\ *ptr\ =\ \&num;} \\
ડીરેફરન્સ & એડ્રેસ પરના મૂલ્યને એક્સેસ કરવું & \texttt{printf("\%d",\ *ptr);} // 10
પ્રિન્ટ કરે છે \\
એડ્રેસ ઓપરેટર & વેરિએબલનું એડ્રેસ મેળવે છે & \texttt{printf("\%p",\ \&num);} //
એડ્રેસ પ્રિન્ટ કરે છે \\
NULL પોઇન્ટર & કશું પોઇન્ટ ન કરતાં પોઇન્ટર & \texttt{int\ *ptr\ =\ NULL;} \\
\end{longtable}
}

\textbf{પોઇન્ટર વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
Memory:
┌──────┬───────┐    ┌──────┬───────┐
│ \&num │ 1000  │    │ \&ptr │ 2000  │
├──────┼───────┤    ├──────┼───────┤
│ num  │   10  │    │ ptr  │ 1000  │
└──────┴───────┘    └──────┴───────┘
                      │
                      └──────{ Points to address of num}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનડાયરેક્ટ એક્સેસ}: તેમના એડ્રેસ દ્વારા વેરિએબલ્સ એક્સેસ કરે છે
\item
  \textbf{મેમરી મેનિપ્યુલેશન}: કાર્યક્ષમતા માટે ડાયરેક્ટ મેમરી એક્સેસ
\item
  \textbf{ડાયનેમિક મેમરી}: રનટાઇમ દરમિયાન એલોકેશન/ડીએલોકેશન સક્ષમ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``પોઇન્ટર્સ એડ્રેસને પોઇન્ટ કરે છે, સ્ટાર્સ મૂલ્યોને ડીરેફરન્સ કરે
છે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4c-or-7-uxa97uxaa3}

\textbf{પોઇન્ટર વ્યાખ્યાયિત કરો અને પોઇન્ટર આર્ગ્યુમેન્ટનો ઉપયોગ કરીને બે પૂર્ણાંકોની
અદલા બદલી કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

પોઇન્ટર એ એક વેરિએબલ છે જે અન્ય વેરિએબલના મેમરી એડ્રેસને ધરાવે છે, જે ડેટાનો પરોક્ષ
એક્સેસ અને મેનિપ્યુલેશન કરવાની મંજૂરી આપે છે.

\begin{verbatim}
\#include {stdio.h}

// પોઇન્ટર્સનો ઉપયોગ કરીને બે ઇન્ટીજર્સની અદલાબદલી કરવાનું ફંક્શન
void swap(int *a, int *b) \{
    int temp = *a;
    *a = *b;
    *b = temp;
\}

int main() \{
    int num1, num2;
    
    // બે પૂર્ણાંક ઇનપુટ લો
    printf("પ્રથમ સંખ્યા દાખલ કરો: ");
    scanf("\%d", \&num1);
    
    printf("બીજી સંખ્યા દાખલ કરો: ");
    scanf("\%d", \&num2);
    
    printf("અદલાબદલી પહેલાં: num1 = \%d, num2 = \%d{n}", num1, num2);
    
    // num1 અને num2 ના એડ્રેસ સાથે swap ફંક્શન કૉલ કરો
    swap(\&num1, \&num2);
    
    printf("અદલાબદલી પછી: num1 = \%d, num2 = \%d{n}", num1, num2);
    
    return 0;
\}
\end{verbatim}

\textbf{સ્વેપ પ્રોસેસ વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
flowchart LR
    A[a પોઇન્ટ કરે છે num1ને{br /b પોઇન્ટ કરે છે num2ને] {-}{-} B[temp = *a]}
    B {-{-} C[*a = *b]}
    C {-{-} D[*b = temp]}
    D {-{-} E[મૂલ્યો એક્સચેન્જ થયા]}
\end{verbatim}

\textbf{મેમરી ચેન્જીસ:}

\begin{verbatim}
સ્વેપ પહેલાં:
num1 = 5, num2 = 10
a --> num1, b --> num2

સ્ટેપ 1: temp = *a
temp = 5, num1 = 5, num2 = 10

સ્ટેપ 2: *a = *b
temp = 5, num1 = 10, num2 = 10

સ્ટેપ 3: *b = temp
temp = 5, num1 = 10, num2 = 5

સ્વેપ પછી:
num1 = 10, num2 = 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{પાસ બાય રેફરન્સ}: પોઇન્ટર્સ ફંક્શન્સને મૂળ વેરિએબલ્સ મોડિફાય કરવાની મંજૂરી
  આપે છે
\item
  \textbf{ટેમ્પરરી વેરિએબલ}: ડેટા નુકસાન વિના સ્વેપ કરવા માટે જરૂરી છે
\item
  \textbf{ફંક્શન પેરામીટર}: પોઇન્ટર આર્ગ્યુમેન્ટ્સ એડ્રેસ પાસ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``એડ્રેસથી પકડો, કન્ટેન્ટ બદલો, હાજરી વિના''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a) [3
ગુણ]}\label{q5a}

\textbf{50 અને 500 ની વચ્ચે 7 વડે ભાગી શકાય તેવી સંખ્યાઓ શોધવા માટેનો પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i, count = 0;
    
    printf("50 અને 500 ની વચ્ચે 7 વડે ભાગી શકાય તેવી સંખ્યાઓ:{n}");
    
    // 7 વડે ભાગી શકાય તેવી સંખ્યાઓ શોધો અને પ્રિન્ટ કરો
    for(i = 50; i {=} 500; i++) \{
        if(i \% 7 == 0) \{
            printf("\%d ", i);
            count++;
            
            // વધુ સારી વાંચનક્ષમતા માટે દર લાઇને 10 સંખ્યાઓ પ્રિન્ટ કરો
            if(count \% 10 == 0)
                printf("{n}");
        \}
    \}
    
    printf("{n}કુલ સંખ્યા: \%d{n}", count);
    
    return 0;
\}
\end{verbatim}

\textbf{એલ્ગોરિધમ વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[i = 50, count = 0 સેટ કરો]}
    B {-{-} C\{શું i = 500?\}}
    C {-{-}|હા| D\{શું i \% 7 == 0?\}}
    D {-{-}|હા| E[i પ્રિન્ટ કરોbr /count++]}
    D {-{-}|ના| F[i++]}
    E {-{-} F}
    F {-{-} C}
    C {-{-}|ના| G[કુલ સંખ્યા પ્રિન્ટ કરો]}
    G {-{-} H([Stop])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ્યુલો ઓપરેટર}: i \% 7 == 0 વિભાજ્યતા ચકાસે છે
\item
  \textbf{આઉટપુટ ફોર્મેટિંગ}: વાંચવા માટે લાઇન બ્રેક
\item
  \textbf{કાઉન્ટર વેરિએબલ}: કેટલી સંખ્યાઓ મળી તે ટ્રેક કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``સાતથી ભાગો, શૂન્ય શેષ જીતે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b) [4
ગુણ]}\label{q5b}

\textbf{કીબોર્ડ પરથી પૂર્ણાંક વાંચી આપેલ સંખ્યા એકી છે કે બેકી છે તે પ્રિન્ટ કરવા માટેનો
પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int number;
    
    // પૂર્ણાંક ઇનપુટ લો
    printf("એક પૂર્ણાંક દાખલ કરો: ");
    scanf("\%d", \&number);
    
    // સંખ્યા એકી કે બેકી છે તે ચકાસો
    if(number \% 2 == 0) \{
        printf("\%d એક બેકી સંખ્યા છે.{n}", number);
    \} else \{
        printf("\%d એક એકી સંખ્યા છે.{n}", number);
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{નિર્ણય લોજિક:}

\begin{verbatim}
flowchart LR
    A[/સંખ્યા ઇનપુટ લો/] {-{-} B\{શું number \% 2 == 0?\}}
    B {-{-}|હા| C[/પ્રિન્ટ "સંખ્યા બેકી છે"/]}
    B {-{-}|ના| D[/પ્રિન્ટ "સંખ્યા એકી છે"/]}
    C {-{-} E([End])}
    D {-{-} E}
\end{verbatim}

\textbf{નાની સંખ્યાઓ માટે મોડ્યુલો ડિવિઝન ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
સંખ્યા & Number \% 2 & એકી/બેકી \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & 0 & બેકી \\
1 & 1 & એકી \\
2 & 0 & બેકી \\
3 & 1 & એકી \\
4 & 0 & બેકી \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ્યુલો ટેસ્ટ}: બેકી સંખ્યાઓને 2 વડે ભાગતાં શેષ 0 આવે છે
\item
  \textbf{બાઇનરી રીપ્રેઝન્ટેશન}: બેકી સંખ્યાનો અંતિમ બિટ 0 હોય છે, એકી સંખ્યાનો 1
  હોય છે
\item
  \textbf{સિમ્પલ એલ્ગોરિધમ}: નેગેટિવ સંખ્યાઓ સહિત બધા પૂર્ણાંકો માટે કામ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``બેકી અંતે શૂન્ય, એકી અંતે એક''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c) [7
ગુણ]}\label{q5c}

\textbf{સ્ટ્રકચર વ્યાખ્યાયિત કરો? સમજાવો કે તે એરેથી કેવી રીતે અલગ છે? પુસ્તકો વિશે
નીચેની માહિતી સાચવવા માટે પુસ્તક નામનું સ્ટ્રકચર વિકસાવો. પુસ્તકનું શીર્ષક, લેખકનું નામ,
કિંમત અને પાનાંની સંખ્યા.}

\begin{solutionbox}

સ્ટ્રક્ચર એ વપરાશકર્તા-વ્યાખ્યાયિત ડેટા ટાઇપ છે જે એક જ નામ હેઠળ વિવિધ ડેટા ટાઇપ્સના
વેરિએબલ્સના સમૂહને મંજૂરી આપે છે.

\textbf{સ્ટ્રક્ચર અને એરે વચ્ચેનો તફાવત:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4074}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2593}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લક્ષણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્ટ્રક્ચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
એરે
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેટા ટાઇપ & વિવિધ ડેટા ટાઇપ્સ સ્ટોર કરી શકે & સમાન ડેટા ટાઇપના એલિમેન્ટ્સ સંગ્રહે
છે \\
એક્સેસ & સભ્યો ડોટ (.) ઓપરેટર દ્વારા એક્સેસ થાય છે & એલિમેન્ટ્સ ઇન્ડેક્સ [] દ્વારા
એક્સેસ થાય છે \\
મેમરી એલોકેશન & મેમરી સળંગ ન હોઈ શકે & મેમરી હંમેશા સળંગ હોય છે \\
સાઇઝ & દરેક સભ્ય માટે સાઇઝ અલગ-અલગ હોઈ શકે & બધા એલિમેન્ટ્સ માટે સાઇઝ સમાન હોય
છે \\
ડેક્લેરેશન & struct કીવર્ડનો ઉપયોગ કરે છે & સ્ક્વેર બ્રેકેટ્સ []નો ઉપયોગ કરે છે \\
હેતુ & સંબંધિત વિષમ ડેટાને સંગઠિત કરે છે & સમાન ડેટાને સંગઠિત કરે છે \\
\end{longtable}
}

\textbf{બુક સ્ટ્રક્ચર પ્રોગ્રામ:}

\begin{verbatim}
\#include {stdio.h}
\#include {string.h}

// સ્ટ્રક્ચર વ્યાખ્યાયિત કરો
struct Book \{
    char title[100];
    char author[50];
    float price;
    int pages;
\;}

int main() \{
    // struct Book ટાઇપનું વેરિએબલ ડિક્લેર કરો
    struct Book myBook;
    
    // સ્ટ્રક્ચર સભ્યોને મૂલ્યો આપો
    strcpy(myBook.title, "C પ્રોગ્રામિંગ");
    strcpy(myBook.author, "ડેનિસ રિચી");
    myBook.price = 350.50;
    myBook.pages = 285;
    
    // પુસ્તકની માહિતી દર્શાવો
    printf("પુસ્તક વિગતો:{n}");
    printf("શીર્ષક: \%s{n}", myBook.title);
    printf("લેખક: \%s{n}", myBook.author);
    printf("કિંમત: \%.2f{n}", myBook.price);
    printf("પાનાં: \%d{n}", myBook.pages);
    
    return 0;
\}
\end{verbatim}

\textbf{સ્ટ્રક્ચર વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
struct Book myBook
┌───────────────────┬──────────────────────────────┐
│ Member            │ Value                        │
├───────────────────┼──────────────────────────────┤
│ title             │ "C Programming"              │
├───────────────────┼──────────────────────────────┤
│ author            │ "Dennis Ritchie"             │
├───────────────────┼──────────────────────────────┤
│ price             │ 350.50                       │
├───────────────────┼──────────────────────────────┤
│ pages             │ 285                          │
└───────────────────┴──────────────────────────────┘
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{સ્ટ્રક્ચર વ્યાખ્યા}: ડેટા માટે ટેમ્પ્લેટ બનાવે છે
\item
  \textbf{સભ્ય એક્સેસ}: ડોટ ઓપરેટર (structure.member) નો ઉપયોગ કરો
\item
  \textbf{સ્ટ્રિંગ હેન્ડલિંગ}: કેરેક્ટર એરે માટે સ્ટ્રિંગ ફંક્શન્સનો ઉપયોગ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``સ્ટ્રક્ચર જુદું એકત્ર કરે, એરે એકસરખું રાખે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(a OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5a-or-3-uxa97uxaa3}

\textbf{કીબોર્ડ પરથી વાસ્તવિક સંખ્યા વાંચી અને તેના કરતા મોટો સૌથી નાનો પૂર્ણાંક
પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}
\#include {math.h}

int main() \{
    float number;
    int result;
    
    // વાસ્તવિક સંખ્યા ઇનપુટ લો
    printf("એક વાસ્તવિક સંખ્યા દાખલ કરો: ");
    scanf("\%f", \&number);
    
    // ઇનપુટથી મોટો નાનામાં નાનો પૂર્ણાંક શોધો
    result = ceil(number);
    
    // પરિણામ દર્શાવો
    printf("\%.2f કરતાં મોટો સૌથી નાનો પૂર્ણાંક \%d છે{n}", number, result);
    
    return 0;
\}
\end{verbatim}

\textbf{ફંક્શન વર્તન:}

\begin{verbatim}
flowchart LR
    A[/વાસ્તવિક સંખ્યા ઇનપુટ લો/] {-{-} B[ceil ફંક્શન લાગુ કરો]}
    B {-{-} C[/પરિણામ દર્શાવો/]}
\end{verbatim}

\textbf{ceil() ફંક્શનના ઉદાહરણો:}

\begin{verbatim}
વાસ્તવિક સંખ્યા | ceil() પરિણામ
--------------|-------------
    3.14    |      4
    5.0     |      5
   -2.7     |     -2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મેથ ફંક્શન}: ceil() આગળના પૂર્ણાંક પર રાઉન્ડ કરે છે
\item
  \textbf{પરિણામ ટાઇપ}: ઇનપુટથી મોટો નાનામાં નાનો પૂર્ણાંક પરત કરે છે
\item
  \textbf{એજ કેસ હેન્ડલિંગ}: નકારાત્મક સંખ્યાઓ માટે પણ કામ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CEILING ફંક્શન, ઉપર જઈએ, આગળનો પૂર્ણાંક બતાવીએ''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(b OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5b-or-4-uxa97uxaa3}

\textbf{કીબોર્ડ પરથી અક્ષર વાંચી અને તેની ASCII વેલ્યુ પ્રિન્ટ કરવા માટેનો પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    char ch;
    
    // એક અક્ષર ઇનપુટ લો
    printf("એક અક્ષર દાખલ કરો: ");
    scanf("\%c", \&ch);
    
    // અક્ષરની ASCII વેલ્યુ દર્શાવો
    printf("{}\%c{ ની ASCII વેલ્યુ }\%d છે{n}", ch, ch);
    
    return 0;
\}
\end{verbatim}

\textbf{પ્રોગ્રામ વિઝ્યુલાઇઝેશન:}

\begin{verbatim}
flowchart LR
    A[/અક્ષર ઇનપુટ લો/] {-{-} B[/અક્ષર અને તેની ASCII વેલ્યુ પ્રિન્ટ કરો/]}
\end{verbatim}

\textbf{ASCII ટેબલ સેમ્પલ:}

\begin{verbatim}
અક્ષર | ASCII વેલ્યુ
----------|------------
    'A'    |     65
    'a'    |     97
    '0'    |     48
    ' '    |     32
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કેરેક્ટર સ્ટોરેજ}: કેરેક્ટર્સ મેમરીમાં ઇન્ટીજર તરીકે સંગ્રહ થાય છે
\item
  \textbf{ટાઇપ કન્વર્ઝન}: char થી int માં ઓટોમેટિક કન્વર્ઝન
\item
  \textbf{એક્સટેન્ડેડ ASCII}: 8-બિટ કેરેક્ટર્સ માટે 0 થી 255 સુધીની વેલ્યુ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``અક્ષરો નીચે સંખ્યાઓ છુપાવે, પ્રિન્ટ બંને બાજુ બતાવે''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(c OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5c-or-7-uxa97uxaa3}

\textbf{ફંક્શન ને વ્યાખ્યાયિત કરો? તેનો ફાયદો સમજાવો. આપેલ પૂર્ણાંક સંખ્યાના વર્ગની
ગણતરી કરવા માટેનું ફંક્શન લખો.}

\begin{solutionbox}

ફંક્શન એ કોડનો સેલ્ફ-કન્ટેઇન્ડ બ્લોક છે જે ચોક્કસ કાર્ય કરવા માટે ડિઝાઇન કરવામાં આવ્યો
છે. તે ઇનપુટ લે છે, તેને પ્રોસેસ કરે છે, અને આઉટપુટ પરત કરે છે.

\textbf{ફંક્શનના ફાયદાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ફાયદો & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
કોડ રીયુઝેબિલિટી & એક વખત લખો, અનેક વખત વાપરો \\
મોડ્યુલારિટી & જટિલ સમસ્યાઓને સંચાલિત ભાગોમાં વિભાજિત કરો \\
મેઇન્ટેનેબિલિટી & ઇસોલેટેડ કોડને ડિબગ અને મોડિફાય કરવું સરળ છે \\
એબ્સ્ટ્રેક્શન & અમલીકરણની વિગતો છુપાવો \\
વાંચનક્ષમતા & કોડને વધુ સંગઠિત અને સમજવા યોગ્ય બનાવે છે \\
સ્કોપ કંટ્રોલ & ફંક્શન્સ માટે લોકલ વેરિએબલ્સ નેમિંગ કોન્ફ્લિક્ટ ઘટાડે છે \\
\end{longtable}
}

\textbf{સ્ક્વેર ફંક્શન સાથે પ્રોગ્રામ:}

\begin{verbatim}
\#include {stdio.h}

// પૂર્ણાંકના વર્ગની ગણતરી કરવાનું ફંક્શન
int square(int num) \{
    return num * num;
\}

int main() \{
    int number, result;
    
    // પૂર્ણાંક ઇનપુટ લો
    printf("એક પૂર્ણાંક દાખલ કરો: ");
    scanf("\%d", \&number);
    
    // square ફંક્શન કૉલ કરો
    result = square(number);
    
    // પરિણામ દર્શાવો
    printf("\%d નો વર્ગ \%d છે{n}", number, result);
    
    return 0;
\}
\end{verbatim}

\textbf{ફંક્શન ફ્લો:}

\begin{verbatim}
flowchart LR
    A[main ફંક્શન] {-{-}|number સાથે કૉલ| B[square ફંક્શન]}
    B {-{-}|num * num પરત કરે| C[main ફંક્શન]}
    C {-{-}|પરિણામ દર્શાવે| D[End]}
\end{verbatim}

\textbf{ફંક્શન ઘટકો:}

\begin{verbatim}
Return Type    Function Name    Parameters
    ↓               ↓               ↓
   int           square          (int num)
                    ↓
              Function Body
            {                
             return num * num;   \leftarrow Function Logic
            }
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફંક્શન પ્રોટોટાઇપ}: ફંક્શન સિગ્નેચર જાહેર કરે છે
\item
  \textbf{પેરામીટર્સ}: ફંક્શનમાં પાસ કરેલા ઇનપુટ મૂલ્યો
\item
  \textbf{રિટર્ન વેલ્યુ}: ફંક્શનમાંથી આઉટપુટ અથવા પરિણામ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ફંક્શન કાર્યોને ENCAPSULATE કરે, INPUTS લે, OUTPUTS આપે''

\end{mnemonicbox}

\end{document}
