\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331105 -- Winter 2022}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{C લેંગ્વેજના બેઝીક ડેટા ટાઈપ તેની રેંજ સાથે લખો}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3438}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4375}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2188}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ડેટા ટાઈપ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સાઈઝ (બાઈટ્સ)
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
રેંજ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
char & 1 & -128 થી 127 \\
int & 2 અથવા 4 & -32,768 થી 32,767 (2 બાઈટ્સ) અથવા -2,147,483,648 થી
2,147,483,647 (4 બાઈટ્સ) \\
float & 4 & 3.4E-38 થી 3.4E+38 \\
double & 8 & 1.7E-308 થી 1.7E+308 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``CIFD - Computer Is Fundamentally Digital''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{વેરીએબલના નામ માટેના નિયમો સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
નિયમ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
અક્ષર અથવા અંડરસ્કોરથી શરૂ થવું જોઈએ & માન્ય: \_count, name / અમાન્ય: 1score \\
અક્ષરો, અંકો, અંડરસ્કોર ધરાવી શકે & માન્ય: user\_1 / અમાન્ય: user-1 \\
કીવર્ડ્સનો ઉપયોગ ન થઈ શકે & માન્ય: integer / અમાન્ય: int \\
કેસ સેન્સિટિવ & total અને TOTAL અલગ છે \\
\end{longtable}
}

\textbf{આકૃતિ:}

\begin{verbatim}
┌───────────────────────────────┐
│ Variable Naming Rules         │
├───────────────────────────────┤
│ [A{-Z, a{-}z, \_]  [A{-}Z, a{-}z, 0{-}9, \_]* │}
└───────────────────────────────┘
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``LUCK - Letters Underscore Case Keywords''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{ફ્લોચાર્ટની વ્યાખ્યા લખો. બે પૂર્ણાંક નંબર N1 અને N2 માંથી નાનો નંબર શોધવા
માટેનો ફ્લોચાર્ટ દોરો.}

\begin{solutionbox}

ફ્લોચાર્ટ એ એલ્ગોરિધમનું ગ્રાફિકલ રજૂઆત છે જે પ્રમાણિત સિમ્બોલ્સનો ઉપયોગ કરીને એરો
દ્વારા જોડાયેલા પગલાંઓની ક્રમને દર્શાવે છે.

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input N1, N2/]}
    B {-{-} C\{N1  N2?\}}
    C {-{-}|Yes| D[min = N1]}
    C {-{-}|No| E[min = N2]}
    D {-{-} F[/Output min/]}
    E {-{-} F}
    F {-{-} G([End])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફ્લોચાર્ટ સિમ્બોલ્સ}: તાર્કિક પગલાંઓની દૃશ્ય રજૂઆત
\item
  \textbf{નિર્ણય ડાયમંડ}: શરત તપાસીને વહેણ પથ નક્કી કરે છે
\item
  \textbf{પ્રોસેસ બોક્સેસ}: ગણતરી અથવા ઓપરેશન્સ ધરાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FAST - Flow Analysis Shown Through-charts''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{અલગોરિથમની વ્યાખ્યા લખો. વર્તુળનું ક્ષેત્રફળ અને પરિઘ ગણવા માટેનો અલગોરિથમ
લખો.}

\begin{solutionbox}

અલગોરિધમ એ કોઈ ચોક્કસ સમસ્યાને ઉકેલવા માટેની સ્પષ્ટ રીતે વ્યાખ્યાયિત સૂચનાઓની
પરિમિત ક્રમમાં પગલે-પગલાની પ્રક્રિયા છે.

\textbf{વર્તુળની ગણતરી માટેનો અલગોરિધમ:}

\begin{verbatim}
1. START
2. Input radius r
3. Calculate area = π * r * r
4. Calculate circumference = 2 * π * r
5. Output area, circumference
6. STOP
\end{verbatim}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ઓપરેશન & ફોર્મ્યુલા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & ત્રિજ્યા મેળવો & Input r \\
2 & ક્ષેત્રફળની ગણતરી & A = π \times r^{2} \\
3 & પરિઘની ગણતરી & C = 2 \times π \times r \\
4 & પરિણામ દર્શાવો & Output A, C \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``SICS - Steps In Clear Sequence''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{printf() અને scanf() વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3571}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
printf()
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
scanf()
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ઉદ્દેશ & સ્ક્રીન પર ડેટા આઉટપુટ કરે છે & કીબોર્ડથી ડેટા ઇનપુટ લે છે \\
ફોર્મેટ & printf(``format'', variables) & scanf(``format'',
\&variables) \\
રિટર્ન & છાપેલા અક્ષરોની સંખ્યા & સફળતાપૂર્વક વાંચેલી આઇટમોની સંખ્યા \\
એડ્રેસિંગ & વેરિએબલ્સના નામનો ઉપયોગ કરે છે & વેરિએબલ્સના એડ્રેસનો ઉપયોગ કરે છે
(\&var) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``IO-AR - Input Output-Address Returns''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{કન્ડીશનલ ઓપરેટરનો ઉપયોગ કરીને બે નંબરમાંથી મોટો નંબર શોધવા માટે C
પ્રોગ્રામ બનાવો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num1, num2, max;
    
    printf("Enter two numbers: ");
    scanf("\%d \%d", \&num1, \&num2);
    
    max = (num1 {} num2) ? num1 : num2;
    
    printf("Maximum number is: \%d", max);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
┌─────────────┐     ┌─────────────┐      ┌─────────────┐
│ Input       │────{│ Condition   │─────│ Output      │}
│ num1, num2  │     │ num1 { num2?│      │ max         │}
└─────────────┘     └─────────────┘      └─────────────┘
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CTO - Condition Then Output''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{એરીથમેટીક અને રીલેશનલ ઓપરેટરો ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
પ્રકાર & ઓપરેટર્સ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{એરીથમેટીક ઓપરેટર્સ} & & & \\
સરવાળો & + & 5 + 3 & 8 \\
બાદબાકી & - & 5 - 3 & 2 \\
ગુણાકાર & * & 5 * 3 & 15 \\
ભાગાકાર & / & 5 / 3 & 1 (પૂર્ણાંક ભાગાકાર) \\
મોડ્યુલસ & \% & 5 \% 3 & 2 (શેષ) \\
\textbf{રીલેશનલ ઓપરેટર્સ} & & & \\
સમાન & == & 5 == 3 & 0 (ખોટું) \\
અસમાન & != & 5 != 3 & 1 (સાચું) \\
મોટું & \textgreater{} & 5 \textgreater{} 3 & 1 (સાચું) \\
નાનું & \textless{} & 5 \textless{} 3 & 0 (ખોટું) \\
મોટું અથવા સમાન & \textgreater= & 5 \textgreater= 5 & 1 (સાચું) \\
નાનું અથવા સમાન & \textless= & 5 \textless= 3 & 0 (ખોટું) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ASMDCRO - Add Subtract Multiply Divide Compare
Return Output''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{જો (25/3) * 4 -- 10 \% 3 + 9/2 સમીકરણને ઉકેલવામાં આવે તો ઓપરેટરોની
અગ્રીમતાને ધ્યાને લઇ દરેક સ્ટેપ અને અંતિમ જવાબ લખો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
પગલું & ઓપરેશન & ગણતરી & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & કૌંસ (25/3) & 25/3 = 8 (પૂર્ણાંક ભાગાકાર) & 8 \\
2 & મોડ્યુલસ 10 \% 3 & 10 \% 3 = 1 & 1 \\
3 & ભાગાકાર 9/2 & 9/2 = 4 (પૂર્ણાંક ભાગાકાર) & 4 \\
4 & ગુણાકાર 8 * 4 & 8 * 4 = 32 & 32 \\
5 & બાદબાકી 32 - 1 & 32 - 1 = 31 & 31 \\
6 & સરવાળો 31 + 4 & 31 + 4 = 35 & 35 \\
\end{longtable}
}

અંતિમ જવાબ = 35

\end{solutionbox}
\begin{mnemonicbox}
``PEMDAS - Parentheses, Exponents,
Multiplication/Division, Addition/Subtraction''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{એલ્જેબ્રીક સમીકરણના ઉકેલ માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}
\#include {math.h}

int main() \{
    float a, b, c;
    float discriminant, root1, root2;
    
    printf("Enter coefficients a, b, c: ");
    scanf("\%f \%f \%f", \&a, \&b, \&c);
    
    discriminant = b*b {-} 4*a*c;
    
    if (discriminant {} 0) \{
        root1 = ({-}b + sqrt(discriminant)) / (2*a);
        root2 = ({-}b {-} sqrt(discriminant)) / (2*a);
        printf("Roots: \%.2f and \%.2f", root1, root2);
    \} else if (discriminant == 0) \{
        root1 = {-}b / (2*a);
        printf("Root: \%.2f", root1);
    \} else \{
        printf("No real roots");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A[Input a,b,c] {-{-} B[Calculate d = b^{2}{-}4ac]}
    B {-{-} C\{d  0?\}}
    C {-{-}|Yes| D[Two real roots]}
    C {-{-}|No| E\{d = 0?\}}
    E {-{-}|Yes| F[One real root]}
    E {-{-}|No| G[No real roots]}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``QDR - Quadratic Discriminant Roots''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{લોજીકલ અને બીટ-વાઈસ ઓપરેટરો ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
પ્રકાર & ઓપરેટર્સ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{લોજીકલ ઓપરેટર્સ} & & & \\
લોજીકલ AND & \&\& & (5\textgreater3) \&\& (4\textless7) & 1 (સાચું) \\
લોજીકલ OR & \textbar\textbar{} & (5\textless3) \textbar\textbar{}
(4\textless7) & 1 (સાચું) \\
લોજીકલ NOT & ! & !(5\textgreater3) & 0 (ખોટું) \\
\textbf{બિટવાઈઝ ઓપરેટર્સ} & & & \\
બિટવાઈઝ AND & \& & 5 \& 3 (101 \& 011) & 1 (001) \\
બિટવાઈઝ OR & \textbar{} & 5 \textbar{} 3 (101 \textbar{} 011) & 7
(111) \\
બિટવાઈઝ XOR & \^{} & 5 \^{} 3 (101 \^{} 011) & 6 (110) \\
બિટવાઈઝ NOT & \textasciitilde{} & \textasciitilde5 (\textasciitilde{}
00000101) & -6 (11111010) \\
લેફ્ટ શિફ્ટ & \textless\textless{} & 5 \textless\textless{} 1 (101
\textless\textless{} 1) & 10 (1010) \\
રાઈટ શિફ્ટ & \textgreater\textgreater{} & 5 \textgreater\textgreater{} 1
(101 \textgreater\textgreater{} 1) & 2 (10) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``LAND BORNS - Logical AND OR NOT, Bitwise OR AND
NOT Shift''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{`go to' સ્ટેટમેન્ટનો ઉપયોગ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

\texttt{goto} સ્ટેટમેન્ટ પ્રોગ્રામમાં લેબલ કરેલા સ્ટેટમેન્ટ પર બિનશરતી જમ્પની મંજૂરી આપે
છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i = 0;
    
start:
    printf("\%d ", i);
    i++;
    if (i {} 5)
        goto start;
    
    return 0;
\}
// આઉટપુટ: 0 1 2 3 4
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
     ┌─────────┐
     │ Start   │
     └────┬────┘
          │
          ▼
┌─────────────────┐
│  print(i)       │
│  i++            │
└────────┬────────┘
         │
         ▼
     ┌────────┐    Yes
     │ i { 5? ├───────┐}
     └────┬───┘       │
          │No         │
          ▼           │
     ┌────────┐       │
     │  End   │       │
     └────────┘       │
                      │
     ┌────────────────┘
     │   
     ▼   
  goto start
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``JUMP - Just Unconditionally Move Program-counter''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{લીધેલ નંબર એકી છે કે બેકી તે તપાસવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num;
    
    printf("Enter a number: ");
    scanf("\%d", \&num);
    
    if (num \% 2 == 0)
        printf("\%d is even", num);
    else
        printf("\%d is odd", num);
        
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input num/]}
    B {-{-} C\{num \% 2 == 0?\}}
    C {-{-}|Yes| D[/Print num is even/]}
    C {-{-}|No| E[/Print num is odd/]}
    D {-{-} F([End])}
    E {-{-} F}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``MODE - Modulo Odd-Even Determination''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{else if ladder ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

else-if લેડર કધામ શરતોને ક્રમમાં ચકાસવાની મંજૂરી આપે છે, પ્રથમ સાચી શરત સાથે
જોડાયેલા બ્લોકને એક્ઝીક્યુટ કરે છે.

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input marks/]}
    B {-{-} C\{marks = 90?\}}
    C {-{-}|Yes| D[grade = A]}
    C {-{-}|No| E\{marks = 80?\}}
    E {-{-}|Yes| F[grade = B]}
    E {-{-}|No| G\{marks = 70?\}}
    G {-{-}|Yes| H[grade = C]}
    G {-{-}|No| I\{marks = 60?\}}
    I {-{-}|Yes| J[grade = D]}
    I {-{-}|No| K[grade = F]}
    D \& F \& H \& J \& K {-{-} L[/Output grade/]}
    L {-{-} M([End])}
\end{verbatim}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int marks;
    char grade;
    
    printf("Enter marks: ");
    scanf("\%d", \&marks);
    
    if (marks {=} 90)
        grade = {A};
    else if (marks {=} 80)
        grade = {B};
    else if (marks {=} 70)
        grade = {C};
    else if (marks {=} 60)
        grade = {D};
    else
        grade = {F};
        
    printf("Grade: \%c", grade);
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{એકાધિક શરતો}: ક્રમાનુસાર શરતો તપાસે છે
\item
  \textbf{પ્રથમ મિલાન}: માત્ર પ્રથમ સાચી શરત માટે કોડ એક્ઝિક્યુટ કરે છે
\item
  \textbf{ડિફોલ્ટ કેસ}: છેલ્લો else બાકીના બધા કેસને સંભાળે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CAFE - Condition Assess First Eligible''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{continue અને break સ્ટેટમેન્ટનો ઉપયોગ સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
સ્ટેટમેન્ટ & હેતુ & અસર \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
break & લૂપ અથવા સ્વિચમાંથી બહાર નીકળવું & તરત જ સમગ્ર લૂપ છોડી દે છે \\
continue & વર્તમાન પુનરાવર્તન છોડવું & લૂપના આગલા પુનરાવર્તન પર જાય છે \\
\end{longtable}
}

\begin{verbatim}
// break ઉદાહરણ
for(int

i=1; i{=}10; i++) \{

    if(i == 6)
        break;      // i=6 થાય ત્યારે લૂપમાંથી બહાર નીકળે છે
    printf("\%d ", i); // આઉટપુટ: 1 2 3 4 5
\}

// continue ઉદાહરણ
for(int

i=1; i{=}10; i++) \{

    if(i \% 2 == 0)
        continue;   // બેકી સંખ્યાઓ છોડે છે
    printf("\%d ", i); // આઉટપુટ: 1 3 5 7 9
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
  break                        continue
┌─────────┐                   ┌─────────┐
│ Loop    │                   │ Loop    │
│ ┌─────┐ │                   │ ┌─────┐ │
│ │  1  │ │                   │ │  1  │ │
│ └─────┘ │                   │ └─────┘ │
│ ┌─────┐ │                   │ ┌─────┐ │
│ │  2  │ │◄───┐              │ │  2  │ │◄───┐
│ └─────┘ │    │              │ └─────┘ │    │
│ ┌─────┐ │    │ break        │ ┌─────┐ │    │ continue 
│ │  3  ├─┘    │              │ │  3  ├─┘    │
│ └─────┘      │              │ └─────┘      │
└─────────────┐│              └───────┬──────┘
 Exit Loop    ││               Next   │
              ┘│             Iteration│
               └──────────────────────┘
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``BEST - Break Exits, Skip with conTinue''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxa97uxaa3}

\textbf{૧ થી ૧૦ નંબરનો સરવાળો પ્રિન્ટ કરવા માટેનો C પ્રોગ્રામ ફોર લૂપનો ઉપયોગ
કરીને લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i, sum = 0;
    
    for(i = 1; i {=} 10; i++) \{
        sum += i;
    \}
    
    printf("Sum of numbers from 1 to 10: \%d", sum);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[sum = 0]}
    B {-{-} C[i = 1]}
    C {-{-} D\{i = 10?\}}
    D {-{-}|Yes| E[sum = sum + i]}
    E {-{-} F[i++]}
    F {-{-} D}
    D {-{-}|No| G[/Print sum/]}
    G {-{-} H([End])}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SILA - Sum Increment Loop Add''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{સ્વીચ સ્ટેટમેન્ટ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

સ્વિચ સ્ટેટમેન્ટ વેરિએબલની વેલ્યુના આધારે એકાધિક વિકલ્પોમાંથી એક કોડ બ્લોક પસંદ કરે છે.

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input choice/]}
    B {-{-} C\{switch choice\}}
    C {-{-}|case 1| D[/Print Addition/]}
    C {-{-}|case 2| E[/Print Subtraction/]}
    C {-{-}|case 3| F[/Print Multiplication/]}
    C {-{-}|case 4| G[/Print Division/]}
    C {-{-}|default| H[/Print Invalid/]}
    D \& E \& F \& G \& H {-{-} I([End])}
\end{verbatim}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int choice;
    
    printf("Enter operation (1{-4): "});
    scanf("\%d", \&choice);
    
    switch(choice) \{
        case 1:
            printf("Addition selected");
            break;
        case 2:
            printf("Subtraction selected");
            break;
        case 3:
            printf("Multiplication selected");
            break;
        case 4:
            printf("Division selected");
            break;
        default:
            printf("Invalid choice");
    \}
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{એક્સપ્રેશન}: ઇન્ટિજર અથવા કેરેક્ટર એક્સપ્રેશન લે છે
\item
  \textbf{કેસ લેબલ્સ}: કોન્સ્ટન્ટ એક્સપ્રેશન હોવા જોઈએ
\item
  \textbf{બ્રેક સ્ટેટમેન્ટ}: આગલા કેસમાં પ્રવેશ થતો અટકાવે છે
\item
  \textbf{ડિફોલ્ટ}: કોઈપણ કેસ મેચ ન થાય તો હેન્ડલ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SCBD - Switch Cases Break Default''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{મોટા કેપિટલ મૂળાક્ષરોને નાના મૂળાક્ષરોમાં રૂપાંતર કરવા માટેનો C પ્રોગ્રામ
લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    char upper, lower;
    
    printf("Enter uppercase letter: ");
    scanf("\%c", \&upper);
    
    lower = upper + 32;
    // વૈકલ્પિક: lower = tolower(upper);
    
    printf("Lowercase letter: \%c", lower);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
┌─────────────┐
│ Input {A   │}
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ ASCII code  │
│     65      │
└──────┬──────┘
       │ +32
       ▼
┌─────────────┐
│ ASCII code  │
│     97      │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│ Output {a  │}
└─────────────┘
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ASCII-32 - Add 32 to Shift Characters Into
Lowercase''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{પોઈન્ટર એટલે શું? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

પોઇન્ટર એ એક વેરિએબલ છે જે અન્ય વેરિએબલના મેમરી એડ્રેસને સ્ટોર કરે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કોન્સેપ્ટ & સિન્ટેક્સ & વિગત \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેક્લેરેશન & \texttt{int\ *p;} & ઇન્ટ પ્રકારનો પોઇન્ટર p ડિક્લેર કરે છે \\
ઇનિશિયલાઇઝેશન & \texttt{p\ =\ \&var;} & var નું એડ્રેસ p માં સ્ટોર કરે છે \\
ડિરેફરન્સિંગ & \texttt{*p\ =\ 10;} & પોઇન્ટ થયેલી વેલ્યુને એક્સેસ/મોડિફાય કરે છે \\
પોઇન્ટર એરિથમેટિક & \texttt{p++} & આગલા મેમરી લોકેશન પર જાય છે \\
\end{longtable}
}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num = 10;
    int *ptr;
    
    ptr = \&num;  // num નું એડ્રેસ ptr માં સ્ટોર કરે છે
    
    printf("Value of num: \%d{n}", num);
    printf("Address of num: \%p{n}", \&num);
    printf("Value of ptr: \%p{n}", ptr);
    printf("Value pointed by ptr: \%d{n}", *ptr);
    
    *ptr = 20;  // પોઇન્ટર દ્વારા વેલ્યુ બદલે છે
    printf("New value of num: \%d{n}", num);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
Memory:
┌─────────────┐
│    num      │ 1000  ┌───────────┐
│    (10)     │◄──────┤   *ptr    │ 2000
└─────────────┘       │  (1000)   │
                      └───────────┘
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SAID - Store Address to Indirectly Dereference''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{ફોર લૂપ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

ફોર લૂપનો ઉપયોગ કોડના બ્લોકને નિર્દિષ્ટ સંખ્યામાં વાર રિપીટ કરવા માટે થાય છે.

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[Initialization: i=1]}
    B {-{-} C\{Condition: i=5?\}}
    C {-{-}|True| D[Body: Print i]}
    D {-{-} E[Update: i++]}
    E {-{-} C}
    C {-{-}|False| F([End])}
\end{verbatim}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i;
    
    // સિન્ટેક્સ: for(initialization; condition; update)
    for(i = 1; i {=} 5; i++) \{
        printf("\%d ", i);
    \}
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનિશિયલાઇઝેશન}: લૂપ શરૂ થતાં પહેલાં એક વાર એક્ઝિક્યુટ થાય છે
\item
  \textbf{કન્ડિશન}: દરેક પુનરાવર્તન પહેલાં ચેક થાય છે
\item
  \textbf{અપડેટ}: દરેક પુનરાવર્તન પછી એક્ઝિક્યુટ થાય છે
\item
  \textbf{બોડી}: કોડ બ્લોક જે રિપીટ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ICU-B - Initialize, Check, Update, Body''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{ત્રિકોણનું ક્ષેત્રફળ (૧/૨ * પાયો * ઉંચાઈ) શોધવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    float base, height, area;
    
    printf("Enter base of triangle: ");
    scanf("\%f", \&base);
    
    printf("Enter height of triangle: ");
    scanf("\%f", \&height);
    
    area = 0.5 * base * height;
    
    printf("Area of triangle: \%.2f", area);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input base, height/]}
    B {-{-} C[area = 0.5 * base * height]}
    C {-{-} D[/Output area/]}
    D {-{-} E([End])}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``BHA - Base times Height divided by two equals
Area''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{પોઈન્ટરનું ડીકલેરેશન અને ઈનીશ્યલાઈઝેશન સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2683}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1951}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2195}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3171}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વિગત
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેક્લેરેશન & datatype *pointer\_name; & \texttt{int\ *ptr;} & પોઇન્ટર વેરિએબલ
બનાવે છે \\
ઇનિશિયલાઇઝેશન & pointer\_name = \&variable; & \texttt{ptr\ =\ \&num;} &
પોઇન્ટરને એડ્રેસ સોંપે છે \\
કોમ્બાઇન્ડ & datatype *pointer\_name = \&variable; &
\texttt{int\ *ptr\ =\ \&num;} & ડેક્લેરેશન સાથે ઇનિશિયલાઇઝેશન \\
NULL પોઇન્ટર & pointer\_name = NULL; & \texttt{ptr\ =\ NULL;} & જ્યારે એડ્રેસ
ઉપલબ્ધ ન હોય ત્યારે સુરક્ષિત ઇનિશિયલાઇઝેશન \\
\end{longtable}
}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num = 10;           // સામાન્ય વેરિએબલ
    int *ptr1;              // માત્ર ડેક્લેરેશન
    int *ptr2 = \&num;       // ડેક્લેરેશન સાથે ઇનિશિયલાઇઝેશન
    
    ptr1 = \&num;            // ptr1 નું ઇનિશિયલાઇઝેશન
    
    printf("num value: \%d{n}", num);
    printf("num address: \%p{n}", \&num);
    printf("ptr1 value: \%p{n}", ptr1);
    printf("ptr2 value: \%p{n}", ptr2);
    printf("Value via ptr1: \%d{n}", *ptr1);
    printf("Value via ptr2: \%d{n}", *ptr2);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
Pointer Declaration:
┌───────────┐
│ int *ptr; │
└───────────┘

Pointer Initialization:
┌─────────────┐       ┌──────────┐
│ ptr = \&num; │      │ num (10) │
└─────────────┘       └──────────┘
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``PAIN - Pointer Allocate, Initialize, Navigate''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{વાઇલ લૂપ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

વાઇલ લૂપ એક સ્પષ્ટ કરેલી શરત જ્યાં સુધી સાચી હોય ત્યાં સુધી કોડના બ્લોકને રિપીટ કરે
છે.

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[i = 1]}
    B {-{-} C\{i = 5?\}}
    C {-{-}|True| D[/Print i/]}
    D {-{-} E[i++]}
    E {-{-} C}
    C {-{-}|False| F([End])}
\end{verbatim}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i = 1;
    
    // સિન્ટેક્સ: while(condition) \{ body \}
    while(i {=} 5) \{
        printf("\%d ", i);
        i++;
    \}
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનિશિયલાઇઝેશન}: લૂપ પહેલાં કરવું જરૂરી છે
\item
  \textbf{કન્ડિશન}: દરેક પુનરાવર્તનની શરૂઆતમાં મૂલ્યાંકન થાય છે
\item
  \textbf{બોડી}: માત્ર જો શરત સાચી હોય તો જ એક્ઝિક્યુટ થાય છે
\item
  \textbf{અપડેટ}: લૂપ બોડીની અંદર હોવું જોઈએ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CUBE - Condition check, Update inside Body, Exit
when false''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{બુકની આપેલ માહિતી સ્ટોર કરવાનું સ્ટ્રક્ચર બનાવો: book\_no, book\_title,
book\_author, book\_price}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}
\#include {string.h}

struct Book \{
    int book\_no;
    char book\_title[50];
    char book\_author[50];
    float book\_price;
\;}

int main() \{
    struct Book book1;
    
    book1.book\_no = 101;
    strcpy(book1.book\_title, "Programming in C");
    strcpy(book1.book\_author, "Dennis Ritchie");
    book1.book\_price = 450.50;
    
    printf("Book No: \%d{n}", book1.book\_no);
    printf("Title: \%s{n}", book1.book\_title);
    printf("Author: \%s{n}", book1.book\_author);
    printf("Price: \%.2f", book1.book\_price);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
struct Book
┌───────────────────────────────┐
│ book\_no      (int)            │
├───────────────────────────────┤
│ book\_title   (char[50])       │
├───────────────────────────────┤
│ book\_author  (char[50])       │
├───────────────────────────────┤
│ book\_price   (float)          │
└───────────────────────────────┘
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SNAP - Structure Needs All Properties''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{(1)sqrt() (2)pow() (3)strlen() (4)strcpy() ફંક્શનો ઉદાહરણ સાથે
સમજાવો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2703}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2432}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2432}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2432}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંક્શન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
લાઇબ્રેરી
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
sqrt() & math.h & વર્ગમૂળ ગણે છે & \texttt{sqrt(16)} આઉટપુટ \texttt{4.0} \\
pow() & math.h & પાવર ગણે છે & \texttt{pow(2,\ 3)} આઉટપુટ \texttt{8.0} \\
strlen() & string.h & સ્ટ્રિંગની લંબાઈ શોધે છે & \texttt{strlen("hello")}
આઉટપુટ \texttt{5} \\
strcpy() & string.h & સ્ટ્રિંગની કોપી કરે છે &
\texttt{strcpy(dest,\ "hello")} dest માં ``hello'' કોપી કરે છે \\
\end{longtable}
}

\begin{verbatim}
\#include {stdio.h}
\#include {math.h}
\#include {string.h}

int main() \{
    double sqrtResult = sqrt(25);
    double powResult = pow(2, 4);
    char str[] = "Programming";
    char dest[20];
    int length = strlen(str);
    
    strcpy(dest, str);
    
    printf("sqrt(25) = \%.2f{n}", sqrtResult);
    printf("pow(2, 4) = \%.2f{n}", powResult);
    printf("Length of {}\%s{ = }\%d{n}", str, length);
    printf("Copied string: \%s{n}", dest);
    
    return 0;
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SPSS - Square-root Power String-length
String-copy''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{એરે અને એરેનું ઈનીશ્યલાઈઝેશન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

એરે એ સમાન ડેટા એલિમેન્ટ્સનો સમૂહ છે જે સતત મેમરી લોકેશન પર સ્ટોર થાય છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ્ધતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેક્લેરેશન & \texttt{data\_type\ array\_name[size];} &
\texttt{int\ marks[5];} \\
ડેક્લેરેશન સમયે ઇનિશિયલાઇઝેશન &
\texttt{data\_type\ array\_name[size]\ =\ \{values\};} &
\texttt{int\ marks[5]\ =\ \{95,\ 80,\ 85,\ 75,\ 90\};} \\
વ્યક્તિગત એલિમેન્ટ & \texttt{array\_name[index]\ =\ value;} &
\texttt{marks[0]\ =\ 95;} \\
આંશિક ઇનિશિયલાઇઝેશન & \texttt{int\ arr[5]\ =\ \{1,\ 2\};} & બાકીના
એલિમેન્ટ્સ 0 હોય છે \\
સાઇઝ વગર & \texttt{int\ arr[]\ =\ \{1,\ 2,\ 3\};} & સાઇઝ એલિમેન્ટ્સ
દ્વારા નક્કી થાય છે \\
\end{longtable}
}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    // એરે ડેક્લેરેશન અને ઇનિશિયલાઇઝેશન
    int numbers[5] = \{10, 20, 30, 40, 50\;}
    
    // એરે એલિમેન્ટ્સ એક્સેસ કરવા
    printf("First element: \%d{n}", numbers[0]);
    printf("Third element: \%d{n}", numbers[2]);
    
    // એરે એલિમેન્ટ બદલવી
    numbers[1] = 25;
    
    // બધા એલિમેન્ટ્સ પ્રિન્ટ કરવા
    printf("Array elements: ");
    for(int i = 0; i {} 5; i++) \{
        printf("\%d ", numbers[i]);
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
Array in memory:
┌────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │
└────┴────┴────┴────┴────┘
   0    1    2    3    4   indices
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CASED - Contiguous Arrangement of Similar Elements
with Direct-access''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{એરે અને સ્ટ્રક્ચર નો તફાવત લખો.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2593}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4074}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફીચર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
એરે
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સ્ટ્રક્ચર
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડેટા ટાઈપ્સ & માત્ર એક જ ડેટા ટાઈપ & અલગ અલગ ડેટા ટાઈપ્સ મંજૂર \\
એક્સેસ & ઇન્ડેક્સ દ્વારા: \texttt{arr[0]} & ડોટ ઓપરેટર દ્વારા:
\texttt{emp.id} \\
મેમરી & સતત ફાળવણી & સતત ન પણ હોઈ શકે \\
સાઇઝ & ડેક્લેરેશન સમયે ફિક્સ્ડ & સભ્યોના સાઇઝનો સરવાળો \\
ઇનિશિયલાઇઝેશન & \texttt{int\ arr[3]\ =\ \{1,2,3\};} &
\texttt{struct\ emp\ e\ =\ \{101,"John",5000\};} \\
હેતુ & સમાન આઇટમ્સનો સંગ્રહ & સંબંધિત આઇટમ્સનો સંગ્રહ \\
\end{longtable}
}

\textbf{આકૃતિ:}

\begin{verbatim}
Array:                  Structure:
┌───┬───┬───┐           ┌───────────────┐
│ 1 │ 2 │ 3 │           │ id: 101       │
└───┴───┴───┘           ├───────────────┤
  int  int int          │ name: "John"  │
                        ├───────────────┤
                        │ salary: 5000.0│
                        └───────────────┘
                          int  char[]  float
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``HASDIP - Homogeneous vs.~Assorted, Same
vs.~Different, Index vs.~Point''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{યુઝર ડીફાઈન ફંક્શન એટલે શું? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

યુઝર-ડિફાઇન્ડ ફંક્શન એ એક કોડ બ્લોક છે જે ચોક્કસ કાર્ય કરે છે, પ્રોગ્રામર દ્વારા કોડને
ફરીથી ઉપયોગ કરવા અને વ્યવસ્થિત કરવા માટે બનાવવામાં આવે છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3939}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
કોમ્પોનન્ટ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વિગત
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
રિટર્ન ટાઇપ & ફંક્શન દ્વારા પરત કરવામાં આવતા ડેટાનો પ્રકાર & \texttt{int},
\texttt{void}, વગેરે \\
ફંક્શન નામ & ફંક્શન માટેનું આઇડેન્ટિફાયર & \texttt{sum}, \texttt{findMax} \\
પેરામીટર્સ & કૌંસમાં ઇનપુટ વેલ્યુઝ & \texttt{(int\ a,\ int\ b)} \\
ફંક્શન બોડી & કર્લી બ્રેસિસ અંદરનો કોડ & \texttt{\{\ return\ a+b;\ \}} \\
\end{longtable}
}

\begin{verbatim}
\#include {stdio.h}

// ફંક્શન ડેક્લેરેશન
int sum(int a, int b);

int main() \{
    int num1 = 5, num2 = 10;
    int result;
    
    // ફંક્શન કોલ
    result = sum(num1, num2);
    
    printf("Sum = \%d", result);
    
    return 0;
\}

// ફંક્શન ડેફિનિશન
int sum(int a, int b) \{
    return a + b;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart TD
    A[Main function] {-{-}|Call with arguments| B[User{-}defined function]}
    B {-{-}|Return result| A}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CRPB - Create, Return, Pass, Body''

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{એરેના ઘટકોનો સરવાળો અને સરેરાશ શોધવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int arr[100], n, i;
    int sum = 0;
    float avg;
    
    printf("Enter number of elements: ");
    scanf("\%d", \&n);
    
    printf("Enter \%d elements:{n}", n);
    for(i = 0; i {} n; i++) \{
        scanf("\%d", \&arr[i]);
        sum += arr[i];  // દરેક એલિમેન્ટને સરવાળામાં ઉમેરો
    \}
    
    avg = (float)sum / n;  // સરેરાશની ગણતરી
    
    printf("Sum of array elements: \%d{n}", sum);
    printf("Average of array elements: \%.2f", avg);
    
    return 0;
\}
\end{verbatim}

\textbf{આકૃતિ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input size n/]}
    B {-{-} C[/Input n elements/]}
    C {-{-} D[sum = 0]}
    D {-{-} E[i = 0]}
    E {-{-} F\{i  n?\}}
    F {-{-}|Yes| G["sum += arr[i]"]}
    G {-{-} H[i++]}
    H {-{-} F}
    F {-{-}|No| I[avg = sum / n]}
    I {-{-} J[/Output sum, avg/]}
    J {-{-} K([End])}
\end{verbatim}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ઓપરેશન & ઉદાહરણ (એરે [5,10,15,20] માટે) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & ઇનપુટ એરે & [5,10,15,20] \\
2 & sum = 0 ઇનિશિયલાઇઝ & sum = 0 \\
3 & દરેક એલિમેન્ટ ઉમેરો & sum = 0+5+10+15+20 = 50 \\
4 & સંખ્યા વડે વિભાજીત કરો & avg = 50/4 = 12.5 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``LISA - Loop, Increment, Sum, Average''

\end{mnemonicbox}

\end{document}
