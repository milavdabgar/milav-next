\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4331105 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{કીવર્ડની વ્યાખ્યા લખો. C લેંગ્વેજના કોઈપણ ૪ કીવર્ડ લખો.}

\begin{solutionbox}
કીવર્ડ એ C ભાષામાં પૂર્વનિર્ધારિત, અનામત શબ્દ છે જેનો કમ્પાઇલર
દ્વારા વિશેષ અર્થ હોય છે અને તેનો ઓળખકર્તા તરીકે ઉપયોગ કરી શકાતો નથી.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{સામાન્ય C કીવર્ડ્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
કીવર્ડ & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
int & પૂર્ણાંક ડેટા પ્રકાર \\
float & અપૂર્ણાંક ડેટા પ્રકાર \\
char & અક્ષર ડેટા પ્રકાર \\
if & શરતી નિવેદન \\
for & લૂપ નિવેદન \\
while & લૂપ નિવેદન \\
void & રિટર્ન પ્રકાર/પેરામીટર \\
return & ફંક્શનમાંથી મૂલ્ય પાછું આપવું \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{અનામત શબ્દો}: કીવર્ડનો વેરિએબલ નામ તરીકે ઉપયોગ કરી શકાતો નથી
\item
  \textbf{પૂર્વનિર્ધારિત}: તેમનો ભાષામાં નિશ્ચિત અર્થ છે
\item
  \textbf{કેસ-સેન્સિટિવ}: બધા કીવર્ડ્સ લોઅરકેસમાં હોવા જોઈએ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``If VoId FoR WhIle'' (મહત્વપૂર્ણ કીવર્ડના પ્રથમ અક્ષરો)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(બ) [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{વેરીએબલના નામ માટેના નિયમો સમજાવો.}

\begin{solutionbox}
C માં વેરીએબલ્સ માન્ય ઓળખકર્તા હોવા માટે ચોક્કસ નિયમોનું પાલન કરવું
આવશ્યક છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{C માં વેરીએબલ નામકરણ નિયમો}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
નિયમ & વિવરણ & માન્ય ઉદાહરણ & અમાન્ય ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
પ્રથમ અક્ષર & અક્ષર અથવા અંડરસ્કોર હોવો જોઈએ & age, \_count & 1value \\
પછીના અક્ષરો & અક્ષરો, અંકો અથવા અંડરસ્કોર & user\_1, total99 & user@1 \\
કેસ સંવેદનશીલતા & મોટા અને નાના અક્ષરો અલગ & Value \neq value & - \\
કીવર્ડ્સ & અનામત કીવર્ડ્સનો ઉપયોગ ન કરી શકાય & counter & int \\
લંબાઈ & અર્થપૂર્ણ પરંતુ ખૂબ લાંબી નહીં & studentMarks & sm \\
વિશેષ અક્ષરો & માન્ય નથી & firstName & first-name \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{વર્ણનાત્મક નામો}: હેતુ દર્શાવતા અર્થપૂર્ણ નામોનો ઉપયોગ કરો
\item
  \textbf{સુસંગત શૈલી}: સુસંગત નામકરણ પદ્ધતિનું પાલન કરો
\item
  \textbf{સ્પેસ નહીં}: સ્પેસને બદલે અંડરસ્કોર અથવા camelCase નો ઉપયોગ કરો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FLASKS'' (First Letter, Letters/digits, Avoid
keywords, Sensitive case, Keep meaningful, Skip special chars)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{ફ્લોચાર્ટની વ્યાખ્યા લખો. ત્રણ પૂર્ણાંક નંબર N1, N2 અને N3 માંથી નાનો નંબર
શોધવા માટેનો ફ્લોચાર્ટ દોરો.}

\begin{solutionbox}
ફ્લોચાર્ટ એ એલ્ગોરિધમનું ગ્રાફિકલ નિરૂપણ છે જે પગલાંઓને બોક્સ તરીકે
દર્શાવે છે અને તેમના ક્રમને તીરથી જોડીને દર્શાવે છે.

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input N1, N2, N3/]}
    B {-{-} C\{Is N1  N2?\}}
    C {-{-}|Yes| D[min = N1]}
    C {-{-}|No| E[min = N2]}
    D {-{-} F\{Is min  N3?\}}
    E {-{-} F}
    F {-{-}|Yes| G[min remains same]}
    F {-{-}|No| H[min = N3]}
    G {-{-} I[/Output min/]}
    H {-{-} I}
    I {-{-} J([End])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઉપયોગ કરેલા સિમ્બોલ}: ઓવલ (શરુઆત/અંત), સમાંતર ચતુષ્કોણ (ઇનપુટ/આઉટપુટ),
  હીરા (નિર્ણય), આયત (પ્રક્રિયા)
\item
  \textbf{નિર્ણય બિંદુઓ}: મૂલ્યોની વ્યવસ્થિત સરખામણી
\item
  \textbf{તર્કસંગત પ્રવાહ}: તીર કાર્યોનો ક્રમ દર્શાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Start-Input-Compare-Output-End'' (SICOE)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 1(ક) OR [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{અલગોરિધમની વ્યાખ્યા લખો. ત્રણ પૂર્ણાંક નંબર N1, N2 અને N3 માંથી નાનો નંબર
શોધવા માટેનો અલગોરિધમ લખો.}

\begin{solutionbox}
અલગોરિધમ એ પગલાવાર પ્રક્રિયા અથવા ચોક્કસ સમસ્યાને ઉકેલવા માટેની
સુવ્યાખ્યાયિત સૂચનાઓનો પરિમિત સમૂહ છે.

\textbf{ત્રણ સંખ્યાઓમાંથી ન્યૂનતમ શોધવા માટેનો અલગોરિધમ:}

\begin{verbatim}
પગલું 1: શરૂ કરો
પગલું 2: ત્રણ સંખ્યાઓ N1, N2, અને N3 ઇનપુટ કરો
પગલું 3: min = N1 સેટ કરો (પ્રથમ સંખ્યા લઘુત્તમ માની લો)
પગલું 4: જો N2 < min, તો min = N2 સેટ કરો
પગલું 5: જો N3 < min, તો min = N3 સેટ કરો
પગલું 6: min ને લઘુત્તમ સંખ્યા તરીકે આઉટપુટ કરો
પગલું 7: અંત
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{અલગોરિધમ લક્ષણો}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
લક્ષણ & વિવરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
પરિમિતતા & અલગોરિધમ પરિમિત પગલાં પછી સમાપ્ત થવો જોઈએ \\
સુવ્યાખ્યાયિતતા & દરેક પગલું ચોક્કસપણે વ્યાખ્યાયિત હોવું જોઈએ \\
ઇનપુટ & અલગોરિધમ શૂન્ય અથવા વધુ ઇનપુટ લે છે \\
આઉટપુટ & અલગોરિધમ એક અથવા વધુ આઉટપુટ આપે છે \\
અસરકારકતા & પગલાં સરળ અને ક્રિયાન્વિત થઈ શકે તેવા હોવા જોઈએ \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{અનુક્રમિક પગલાં}: તાર્કિક ક્રમનું પાલન કરે છે
\item
  \textbf{તુલનાત્મક અભિગમ}: વ્યવસ્થિત રીતે લઘુત્તમ શોધે છે
\item
  \textbf{સરળતા}: સમજવા અને અમલમાં મૂકવામાં સરળ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``FIDEO'' (Finiteness, Input, Definiteness,
Effectiveness, Output)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{gets() અને puts() વચ્ચેનો તફાવત સમજાવો.}

\begin{solutionbox}
gets() અને puts() એ C માં સ્ટ્રિંગ્સ સાથે ઇનપુટ અને આઉટપુટ ઓપરેશન્સ
માટેના સ્ટાન્ડર્ડ લાઇબ્રેરી ફંક્શન્સ છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{gets() અને puts() ની તુલના}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3600}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લક્ષણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
gets()
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
puts()
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
હેતુ & stdin માંથી સ્ટ્રિંગ વાંચે છે & stdout પર સ્ટ્રિંગ લખે છે \\
પ્રોટોટાઇપ & char \emph{gets(char }str) & int puts(const char *str) \\
વર્તન & ન્યુલાઇન સુધી વાંચે છે & આપમેળે ન્યુલાઇન ઉમેરે છે \\
રિટર્ન વેલ્યુ & સફળતા પર str, નિષ્ફળતા પર NULL & સફળતા પર નોન-નેગેટિવ, એરર પર
EOF \\
સુરક્ષા & અસુરક્ષિત (બફર ઓવરફ્લો જોખમ) & સુરક્ષિત \\
ભલામણ & ના (અપ્રચલિત) & હા \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનપુટ/આઉટપુટ}: gets() ઇનપુટ માટે, puts() આઉટપુટ માટે
\item
  \textbf{ટર્મિનેશન}: gets() ન્યુલાઇન પર અટકે છે, puts() ન્યુલાઇન ઉમેરે છે
\item
  \textbf{સિક્યોરિટી}: gets() બફર લિમિટ ચેક કરતું નથી
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Gets In, Puts Out'' (gets વાંચે છે, puts લખે છે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{કન્ડીશનલ ઓપરેટરનો ઉપયોગ કરીને લીધેલ નંબર એકી છે કે બેકી તે શોધવા માટે C
પ્રોગ્રામ બનાવો.}

\begin{solutionbox}
આ પ્રોગ્રામ કન્ડિશનલ ઓપરેટરનો ઉપયોગ કરીને નંબર એકી કે બેકી છે તે
તપાસે છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num;
    
    printf("Enter a number: ");
    scanf("\%d", \&num);
    
    // કન્ડિશનલ ઓપરેટરનો ઉપયોગ કરીને એકી{-બેકી તપાસો}
    (num \% 2 == 0) ? printf("\%d is even{n}", num) : printf("\%d is odd{n}", num);
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input num/]}
    B {-{-} C\{"num \% 2 == 0?"\}}
    C {-{-}|True| D[/Output "num is even"/]}
    C {-{-}|False| E[/Output "num is odd"/]}
    D {-{-} F([End])}
    E {-{-} F}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કન્ડિશનલ ઓપરેટર}: ? : એ ટ્રિનેરી ઓપરેટર છે
\item
  \textbf{મોડ્યુલસ ઓપરેશન}: \% ભાગાકાર પછી બાકી આપે છે
\item
  \textbf{ટેસ્ટ કન્ડિશન}: num \% 2 == 0 બેકી સંખ્યા માટે તપાસે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``REMinder 0 = Even'' (બાકી 0 એટલે બેકી)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{લોજીકલ અને રીલેશનલ ઓપરેટરો ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
લોજીકલ અને રીલેશનલ ઓપરેટરો C પ્રોગ્રામમાં શરતો બનાવવા અને નિર્ણયો
લેવા માટે વપરાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{રીલેશનલ ઓપરેટરો}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & અર્થ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
== & બરાબર & 5 == 5 & true (1) \\
!= & બરાબર નથી & 5 != 3 & true (1) \\
\textgreater{} & કરતાં મોટું & 7 \textgreater{} 3 & true (1) \\
\textless{} & કરતાં નાનું & 2 \textless{} 8 & true (1) \\
\textgreater= & કરતાં મોટું અથવા બરાબર & 4 \textgreater= 4 & true (1) \\
\textless= & કરતાં નાનું અથવા બરાબર & 6 \textless= 9 & true (1) \\
\end{longtable}
}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{લોજીકલ ઓપરેટરો}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & અર્થ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\&\& & લોજીકલ AND & (5\textgreater3) \&\& (8\textgreater5) & true (1) \\
\textbar\textbar{} & લોજીકલ OR & (5\textgreater7) \textbar\textbar{}
(3\textless6) & true (1) \\
! & લોજીકલ NOT & !(5\textgreater7) & true (1) \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
int age = 20;
int score = 75;

// રીલેશનલ અને લોજીકલ ઓપરેટરોનો ઉપયોગ
if ((age {=} 18) \&\& (score {} 70)) \{
    printf("Eligible");
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{તુલના}: રીલેશનલ ઓપરેટરો મૂલ્યોની તુલના કરે છે
\item
  \textbf{શરતોનું જોડાણ}: લોજીકલ ઓપરેટરો અનેક શરતોને જોડે છે
\item
  \textbf{સત્ય મૂલ્ય}: બધા ઓપરેટરો 1 (સાચું) અથવા 0 (ખોટું) પાછા આપે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CORNL'' (Compare with relational, OR/AND/NOT with
logical)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(અ) OR [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{જો 16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) -10 સમીકરણને ઉકેલવામાં આવે તો
ઓપરેટરોની અગ્રીમતાને ધ્યાને લઇ દરેક સ્ટેપ અને અંતિમ જવાબ લખો.}

\begin{solutionbox}
ચાલો 16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) - 10 એક્સપ્રેશનને
ઓપરેટર પ્રિસિડન્સને અનુસરીને પગલેવાર મૂલ્યાંકન કરીએ.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{પગલેવાર મૂલ્યાંકન}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ઓપરેશન & આ પગલા પછી એક્સપ્રેશન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & (3 + 6) ની ગણતરી & 16 + ( 216 / ( 9 * 12 ) ) - 10 \\
2 & (9 * 12) ની ગણતરી & 16 + ( 216 / 108 ) - 10 \\
3 & (216 / 108) ની ગણતરી & 16 + 2 - 10 \\
4 & 16 + 2 ની ગણતરી & 18 - 10 \\
5 & 18 - 10 ની ગણતરી & 8 \\
\end{longtable}
}

\textbf{અંતિમ જવાબ: 8}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A["16 + ( 216 / ( ( 3 + 6 ) * 12 ) ) {- 10"] {-}{-} B["16 + ( 216 / ( 9 * 12 ) ) {-} 10"]}
    B {-{-} C["16 + ( 216 / 108 ) {-} 10"]}
    C {-{-} D[16 + 2 {-} 10]}
    D {-{-} E[18 {-} 10]}
    E {-{-} F[8]}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રથમ કૌંસમાં}: સૌથી અંદરના કૌંસનું મૂલ્યાંકન પહેલા કરાય છે
\item
  \textbf{ગુણાકાર પછી ભાગાકાર}: ડાબેથી જમણે ગણતરી કરો
\item
  \textbf{સરવાળો અને બાદબાકી છેલ્લે}: ડાબેથી જમણે ક્રમમાં
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PEMDAS'' (Parentheses, Exponents,
Multiplication/Division, Addition/Subtraction)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(બ) OR [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{વર્તુળનું ક્ષેત્રફળ અને પરિઘ શોધવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
આ પ્રોગ્રામ વર્તુળની ત્રિજ્યાના આધારે વર્તુળનું ક્ષેત્રફળ અને પરિઘ ગણે છે.

\begin{verbatim}
\#include {stdio.h}
\#define PI 3.14159

int main() \{
    float radius, area, circumference;
    
    printf("Enter the radius of circle: ");
    scanf("\%f", \&radius);
    
    // ક્ષેત્રફળ અને પરિઘની ગણતરી કરો
    area = PI * radius * radius;
    circumference = 2 * PI * radius;
    
    printf("Area of circle = \%.2f square units{n}", area);
    printf("Circumference of circle = \%.2f units{n}", circumference);
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input radius/]}
    B {-{-} C[area = PI * radius * radius]}
    C {-{-} D[circumference = 2 * PI * radius]}
    D {-{-} E[/Output area and circumference/]}
    E {-{-} F([End])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફોર્મ્યુલા}: ક્ષેત્રફળ = π \times r^{2} અને પરિઘ = 2π \times r
\item
  \textbf{કોન્સ્ટન્ટ ડેફિનિશન}: PI માટે \#define નો ઉપયોગ
\item
  \textbf{ફ્લોટ વેરિએબલ્સ}: દશાંશ ચોકસાઈ માટે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PIR^{2}'' ક્ષેત્રફળ માટે, ``2PIR'' પરિઘ માટે

\end{mnemonicbox}
\subsection*{પ્રશ્ન 2(ક) OR [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{એરીથમેટીક અને બીટ-વાઈસ ઓપરેટરો ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
એરીથમેટીક ઓપરેટરો ગાણિતિક ઓપરેશન કરે છે જ્યારે બિટ-વાઈસ ઓપરેટરો
ઇન્ટીજરના અલગ બિટ્સ સાથે કામ કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{એરીથમેટીક ઓપરેટરો}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & વિવરણ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
+ & સરવાળો & 5 + 3 & 8 \\
- & બાદબાકી & 7 - 2 & 5 \\
* & ગુણાકાર & 4 * 3 & 12 \\
/ & ભાગાકાર & 10 / 3 & 3 (ઇન્ટીજર ભાગાકાર) \\
\% & મોડ્યુલસ (શેષ) & 10 \% 3 & 1 \\
++ & ઇનક્રિમેન્ટ & a++ & મૂલ્ય વાપર્યા પછી 1 ઉમેરે છે \\
-- & ડિક્રિમેન્ટ & --b & મૂલ્ય વાપરતા પહેલા 1 ઘટાડે છે \\
\end{longtable}
}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{બિટવાઈઝ ઓપરેટરો}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેટર & વિવરણ & ઉદાહરણ (બાઇનરી) & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\& & બિટવાઈઝ AND & 5 (101) \& 3 (011) & 1 (001) \\
\textbar{} & બિટવાઈઝ OR & 5 (101) \textbar{} 3 (011) & 7 (111) \\
\^{} & બિટવાઈઝ XOR & 5 (101) \^{} 3 (011) & 6 (110) \\
\textasciitilde{} & બિટવાઈઝ NOT & \textasciitilde5 (101) & -6 (બિટ્સ પર
આધારિત) \\
\textless\textless{} & લેફ્ટ શિફ્ટ & 5 \textless\textless{} 1 & 10
(1010) \\
\textgreater\textgreater{} & રાઈટ શિફ્ટ & 5 \textgreater\textgreater{} 1
& 2 (10) \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
int

a = 5,

b = 3;

printf("a + b = \%d{n}", a + b);      // 8
printf("a \& b = \%d{n}", a \& b);      // 1
printf("a { 1 = }\%d{n}", a {} 1);    // 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ગાણિતિક ઓપરેશન્સ}: એરીથમેટીક ઓપરેટરો ગણતરી માટે
\item
  \textbf{બિટ મેનિપ્યુલેશન}: બિટવાઈઝ ઓપરેટરો બાઇનરી લેવલ પર કામ કરે છે
\item
  \textbf{કાર્યક્ષમતા}: બિટવાઈઝ ઓપરેશન્સ અમુક કાર્યો માટે વધુ ઝડપી છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SAME BARON'' (Subtraction Addition Multiplication,
Bitwise AND/OR/NOT)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{`go to' સ્ટેટમેન્ટનો ઉપયોગ ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
goto સ્ટેટમેન્ટનો ઉપયોગ પ્રોગ્રામ કંટ્રોલને બિનશરતી રીતે લેબલવાળા
સ્ટેટમેન્ટ પર ટ્રાન્સફર કરવા માટે થાય છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num, sum = 0;
    
    printf("Enter a positive number: ");
    scanf("\%d", \&num);
    
    if (num {=} 0) \{
        goto error;
    \}
    
    sum = num * (num + 1) / 2;
    printf("Sum of first \%d numbers = \%d{n}", num, sum);
    goto end;
    
    error:
        printf("Error: Please enter a positive number!{n}");
    
    end:
        return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input num/]}
    B {-{-} C\{num = 0?\}}
    C {-{-}|Yes| D[/Output error message/]}
    C {-{-}|No| E[Calculate sum]}
    E {-{-} F[/Output sum/]}
    D {-{-} G([End])}
    F {-{-} G}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{લેબલ ડિક્લેરેશન}: લેબલ્સ કોલન (:) સાથે સમાપ્ત થાય
\item
  \textbf{જમ્પ સ્ટેટમેન્ટ}: goto કંટ્રોલને લેબલ પર ટ્રાન્સફર કરે છે
\item
  \textbf{સાવધાની}: વધારે ઉપયોગ ``સ્પેગેટી કોડ'' બનાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``JUMPing LABEL'' (લેબલવાળા સ્ટેટમેન્ટ પર જમ્પ)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{વિદ્યાર્થીએ ૫ અલગ અલગ વિષયોમાં મેળવેલ માર્ક્સને કીબોર્ડથી ઈનપુટમાં લો.
વિધાથીને આ નિયમો પ્રમાણે ગ્રેડ મળે છે: ૯૦ કે તેથી વધુ ટકા માટે- ગ્રેડ A. ૮૦ થી ૮૯
સુધીના ટકા માટે- ગ્રેડ B. ૭૦ થી ૭૯ સુધીના ટકા માટે- ગ્રેડ C. ૬૦ થી ૬૯ સુધીના ટકા
માટે- ગ્રેડ D. ૫૦ થી ૫૯ સુધીના ટકા માટે- ગ્રેડ E. ૫૦ થી ઓછા ટકા માટે- ગ્રેડ F.
વિદ્યાર્થીએ મેળવેલ ગ્રેડને ડિસ્પ્લે કરવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
આ પ્રોગ્રામ 5 વિષયોમાં મેળવેલ માર્ક્સના સરેરાશના આધારે ગ્રેડ ગણે છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int marks[5], total = 0, i;
    float percentage;
    char grade;
    
    // 5 વિષયો માટે માર્ક્સ ઇનપુટ
    for (i = 0; i {} 5; i++) \{
        printf("Enter marks for subject \%d (out of 100): ", i+1);
        scanf("\%d", \&marks[i]);
        total += marks[i];
    \}
    
    // ટકાવારી ગણો
    percentage = total / 5.0;
    
    // ગ્રેડ નક્કી કરો
    if (percentage {=} 90)
        grade = {A};
    else if (percentage {=} 80)
        grade = {B};
    else if (percentage {=} 70)
        grade = {C};
    else if (percentage {=} 60)
        grade = {D};
    else if (percentage {=} 50)
        grade = {E};
    else
        grade = {F};
    
    printf("Percentage: \%.2f\%\%{n}", percentage);
    printf("Grade: \%c{n}", grade);
    
    return 0;
\}
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ગ્રેડિંગ માપદંડ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ટકાવારી રેન્જ & ગ્રેડ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\geq 90 & A \\
80-89 & B \\
70-79 & C \\
60-69 & D \\
50-59 & E \\
\textless{} 50 & F \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનપુટ એરે}: 5 વિષયોના માર્ક્સ સ્ટોર કરે છે
\item
  \textbf{ટકાવારી ગણતરી}: સરવાળો વિષયોની સંખ્યા દ્વારા ભાગીને
\item
  \textbf{ગ્રેડ નિર્ધારણ}: if-else લેડરનો ઉપયોગ કરીને
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ABCDEF-90-80-70-60-50'' (ગ્રેડ્સ તેમની ટકાવારી થ્રેશોલ્ડ
સાથે)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{Nested if-else નો ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
નેસ્ટેડ if-else એ એક કંટ્રોલ સ્ટ્રક્ચર છે જ્યાં if અથવા else
સ્ટેટમેન્ટમાં બીજું if-else સ્ટેટમેન્ટ સમાયેલ હોય છે.

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input age, score/]}
    B {-{-} C\{age = 18?\}}
    C {-{-}|Yes| D\{score = 60?\}}
    C {-{-}|No| E[/Output "Not eligible: Age criteria not met"/]}
    D {-{-}|Yes| F[/Output "Eligible for admission"/]}
    D {-{-}|No| G[/Output "Not eligible: Score criteria not met"/]}
    E {-{-} H([End])}
    F {-{-} H}
    G {-{-} H}
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int age, score;
    
    printf("Enter age: ");
    scanf("\%d", \&age);
    printf("Enter score: ");
    scanf("\%d", \&score);
    
    if (age {=} 18) \{
        if (score {=} 60) \{
            printf("Eligible for admission");
        \} else \{
            printf("Not eligible: Score criteria not met");
        \}
    \} else \{
        printf("Not eligible: Age criteria not met");
    \}
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{બહુવિધ શરતો}: અનુક્રમે કેટલીક શરતોની તપાસ કરે છે
\item
  \textbf{શ્રેણીબદ્ધ નિર્ણય}: અંદરની શરત માત્ર ત્યારે જ મૂલ્યાંકિત થાય છે જો બહારની
  શરત સાચી હોય
\item
  \textbf{ઇન્ડેન્ટેશન}: યોગ્ય ઇન્ડેન્ટેશન સ્ટ્રક્ચર સમજવામાં મદદ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CONE'' (Check Outer, Nest Evaluation inside)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(અ) OR [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{continue અને break સ્ટેટમેન્ટનો ઉપયોગ સમજાવો.}

\begin{solutionbox}
break અને continue સ્ટેટમેન્ટ્સ અલગ અલગ રીતે લૂપના પ્રવાહને નિયંત્રિત
કરે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{break અને continue ની તુલના}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3462}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2692}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3846}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લક્ષણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
break
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
continue
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
હેતુ & લૂપમાંથી તરત જ બહાર નીકળે છે & વર્તમાન પુનરાવર્તન છોડે છે \\
લૂપ પર અસર & સંપૂર્ણપણે સમાપ્ત કરે છે & આગલા પુનરાવર્તન પર આગળ વધે છે \\
લાગુ પડે છે & switch, for, while, do-while & for, while, do-while \\
ઉપયોગ & જ્યારે શરત પૂરી થઈ જાય અને વધુ પુનરાવર્તનની જરૂર ન હોય & જ્યારે વર્તમાન
પુનરાવર્તન છોડવું જોઈએ \\
\end{longtable}
}

\textbf{break સાથે ઉદાહરણ:}

\begin{verbatim}
for (int

i = 1; i {=} 10; i++) \{

    if (i == 5)
        break;    // i 5 થાય ત્યારે લૂપથી બહાર નીકળો
    printf("\%d ", i);  // આઉટપુટ: 1 2 3 4
\}
\end{verbatim}

\textbf{continue સાથે ઉદાહરણ:}

\begin{verbatim}
for (int

i = 1; i {=} 10; i++) \{

    if (i \% 2 == 0)
        continue;  // બેકી સંખ્યાઓ છોડો
    printf("\%d ", i);  // આઉટપુટ: 1 3 5 7 9
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{લૂપ કંટ્રોલ}: બંને લૂપ એક્ઝિક્યુશન મેનેજ કરવા માટે વપરાય છે
\item
  \textbf{Break બહાર નીકળે છે}: સંપૂર્ણપણે લૂપ અટકાવે છે
\item
  \textbf{Continue છોડે છે}: માત્ર વર્તમાન પુનરાવર્તન છોડે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BEC'' (Break Exits Completely, Continue only
current)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(બ) OR [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{નીચે આપેલી પેટર્ન પ્રિન્ટ કરવા માટેનો C પ્રોગ્રામ ફોર લૂપનો ઉપયોગ કરીને
લખો.}

\begin{verbatim}
1
1 2
1 2 3
1 2 3 4
\end{verbatim}

\begin{solutionbox}
આ પ્રોગ્રામ નેસ્ટેડ ફોર લૂપનો ઉપયોગ કરીને નંબર્સની પેટર્ન પ્રિન્ટ કરે
છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i, j;
    
    // બહારની લૂપ રો માટે (1 થી 4)
    for (i = 1; i {=} 4; i++) \{
        // અંદરની લૂપ કોલમ માટે (1 થી i)
        for (j = 1; j {=} i; j++) \{
            printf("\%d ", j);
        \}
        printf("{n}");  // દરેક રો પછી નવી લાઈન
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[i = 1]}
    B {-{-} C\{i = 4?\}}
    C {-{-}|Yes| D[j = 1]}
    D {-{-} E\{j = i?\}}
    E {-{-}|Yes| F[/Print j/]}
    F {-{-} G[j++]}
    G {-{-} E}
    E {-{-}|No| H[/Print newline/]}
    H {-{-} I[i++]}
    I {-{-} C}
    C {-{-}|No| J([End])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{નેસ્ટેડ લૂપ્સ}: બહારની લૂપ રો માટે, અંદરની કોલમ માટે
\item
  \textbf{ડાયનેમિક લિમિટ}: અંદરની લૂપ j=1 થી વર્તમાન i સુધી ચાલે છે
\item
  \textbf{ઇન્ક્રિમેન્ટલ પેટર્ન}: દરેક રોમાં એક વધુ નંબર હોય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``RICI'' (Row Increases, Column Increases based on
row number)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 3(ક) OR [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{સ્વીચ સ્ટેટમેન્ટ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
સ્વિચ સ્ટેટમેન્ટ એક મલ્ટિ-વે ડિસિઝન મેકર છે જે વેરિએબલને વિવિધ કેસ
વેલ્યુઝ સાથે ટેસ્ટ કરે છે.

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input choice/]}
    B {-{-} C\{Switch choice\}}
    C {-{-}|case 1| D[/Output "Option 1 selected"/]}
    C {-{-}|case 2| E[/Output "Option 2 selected"/]}
    C {-{-}|case 3| F[/Output "Option 3 selected"/]}
    C {-{-}|default| G[/Output "Invalid option"/]}
    D {-{-} H([End])}
    E {-{-} H}
    F {-{-} H}
    G {-{-} H}
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int choice;
    
    printf("Menu:{n}");
    printf("1. Add{n}");
    printf("2. Subtract{n}");
    printf("3. Multiply{n}");
    printf("Enter your choice (1{-3): "});
    scanf("\%d", \&choice);
    
    switch (choice) \{
        case 1:
            printf("Addition selected{n}");
            break;
        case 2:
            printf("Subtraction selected{n}");
            break;
        case 3:
            printf("Multiplication selected{n}");
            break;
        default:
            printf("Invalid choice{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મલ્ટિપલ કેસિઝ}: એક વેરિએબલને અનેક વેલ્યુઝ સાથે ટેસ્ટ કરે છે
\item
  \textbf{બ્રેક સ્ટેટમેન્ટ}: આગલા કેસમાં પડતા અટકાવે છે
\item
  \textbf{ડિફોલ્ટ કેસ}: કોઈપણ કેસ સાથે મેચ ન થતા વેલ્યુઝને સંભાળે છે
\item
  \textbf{કેસ ઓર્ડર}: કોઈપણ ક્રમમાં હોઈ શકે, ડિફોલ્ટ સામાન્ય રીતે છેલ્લે હોય
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CASED'' (Check All Switch Expression's
Destinations)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxaaeuxab0uxa95uxab8}

**fahrenheit= ((celsius*9)/5)+32 સમીકરણથી સેલ્સિયસમાં આપેલા તાપમાનને ફેરનહીટમાં
રૂપાંતર કરવા માટેનો C પ્રોગ્રામ લખો.**

\begin{solutionbox}
આ પ્રોગ્રામ તાપમાન મૂલ્યને સેલ્સિયસથી ફેરનહાઇટમાં રૂપાંતરિત કરે છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    float celsius, fahrenheit;
    
    printf("Enter temperature in Celsius: ");
    scanf("\%f", \&celsius);
    
    // સેલ્સિયસને ફેરનહાઇટમાં રૂપાંતરિત કરો
    fahrenheit = ((celsius * 9) / 5) + 32;
    
    printf("\%.2f Celsius = \%.2f Fahrenheit{n}", celsius, fahrenheit);
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input celsius/]}
    B {-{-} C["fahrenheit = ((celsius * 9) / 5) + 32"]}
    C {-{-} D[/Output celsius and fahrenheit/]}
    D {-{-} E([End])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફોર્મ્યુલા}: F = ((C \times 9) \div 5) + 32
\item
  \textbf{ફ્લોટ વેરિએબલ્સ}: દશાંશ ચોકસાઈ માટે
\item
  \textbf{ફોર્મેટેડ આઉટપુટ}: બે દશાંશ સ્થાન માટે \%.2f નો ઉપયોગ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``C95+32=F'' (સેલ્સિયસ \times 9 \div 5 + 32 = ફેરનહાઇટ)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{પોઈન્ટર એટલે શું? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
પોઈન્ટર એ એક વેરિએબલ છે જે અન્ય વેરિએબલના મેમરી એડ્રેસને સ્ટોર કરે છે.

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
મેમરી:
+--------+      +--------+
| ptr    |----->| var    |
| 0x1000 |      | 0x2000 |
+--------+      +--------+
  એડ્રેસ          મૂલ્ય: 10
  0x2000
  ધરાવે છે
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int var = 10;    // સામાન્ય વેરિએબલ
    int *ptr;        // પોઈન્ટર વેરિએબલ
    
    ptr = \&var;      // var નું એડ્રેસ ptr માં સ્ટોર કરો
    
    printf("Value of var: \%d{n}", var);       // આઉટપુટ: 10
    printf("Address of var: \%p{n}", \&var);    // આઉટપુટ: મેમરી એડ્રેસ
    printf("Value of ptr: \%p{n}", ptr);       // આઉટપુટ: એજ મેમરી એડ્રેસ
    printf("Value at address stored in ptr: \%d{n}", *ptr); // આઉટપુટ: 10
    
    // પોઈન્ટરનો ઉપયોગ કરીને મૂલ્ય બદલો
    *ptr = 20;
    printf("New value of var: \%d{n}", var);   // આઉટપુટ: 20
    
    return 0;
\}
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{પોઈન્ટર ઓપરેશન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેશન & સિમ્બોલ & વિવરણ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
એડ્રેસ-ઓફ & \& & વેરિએબલનું એડ્રેસ મેળવે છે & \&var \\
ડિરેફરન્સ & * & એડ્રેસ પર વેલ્યુ એક્સેસ કરે છે & *ptr \\
ડિક્લેરેશન & * & પોઈન્ટર વેરિએબલ બનાવે છે & int *ptr; \\
એસાઈનમેન્ટ & = & પોઈન્ટરને એડ્રેસ સોંપે છે & ptr = \&var; \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{મેમરી એડ્રેસ}: પોઈન્ટર મૂલ્ય નહીં પણ સ્થાન સ્ટોર કરે છે
\item
  \textbf{ઇન્ડાયરેક્શન}: એડ્રેસનો ઉપયોગ કરીને પરોક્ષ રીતે મૂલ્ય એક્સેસ કરે
\item
  \textbf{મેમરી મેનિપ્યુલેશન}: ડાયનેમિક મેમરી એક્સેસની મંજૂરી આપે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ADA'' (Address Dereferencing Access)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{ડૂ-વાઇલ લૂપ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
ડૂ-વાઇલ લૂપ એક પોસ્ટ-ટેસ્ટ લૂપ છે જે શરત તપાસતા પહેલા ઓછામાં ઓછી એક
વખત તેના બોડીને એક્ઝિક્યુટ કરે છે.

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Initialize counter i = 1/]}
    B {-{-} C[/Execute loop body: Print i/]}
    C {-{-} D[/Increment i: i++/]}
    D {-{-} E\{i = 5?\}}
    E {-{-}|Yes| C}
    E {-{-}|No| F([End])}
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i = 1;
    
    do \{
        printf("\%d ", i);
        i++;
    \} while (i {=} 5);  // પ્રથમ એક્ઝિક્યુશન પછી શરત ચેક થાય છે
    
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ડૂ-વાઇલ લૂપની લાક્ષણિકતાઓ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
લાક્ષણિકતા & વિવરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
એક્ઝિક્યુશન ક્રમ & પહેલા બોડી, પછી શરત \\
ન્યૂનતમ પુનરાવર્તન & ઓછામાં ઓછું એક \\
શરત ચેક & લૂપના અંતે \\
સમાપ્તિ & જ્યારે શરત ખોટી થાય ત્યારે \\
સિન્ટેક્સ & do \{ statements; \} while (condition); \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{પોસ્ટ-ટેસ્ટ લૂપ}: લૂપ બોડી પછી શરત મૂલ્યાંકન
\item
  \textbf{ગેરંટેડ એક્ઝિક્યુશન}: લૂપ બોડી હંમેશા ઓછામાં ઓછી એક વખત ચાલે છે
\item
  \textbf{સેમિકોલોન}: વાઇલ કન્ડિશન પછી જરૂરી છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DECAT'' (Do Execute Check After That)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(અ) OR [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{ત્રિકોણનું ક્ષેત્રફળ (૧/૨ * પાયો * ઉંચાઈ) શોધવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
આ પ્રોગ્રામ ક્ષેત્રફળ = ½ \times પાયો \times ઉંચાઈ સૂત્રનો ઉપયોગ કરીને
ત્રિકોણનું ક્ષેત્રફળ ગણે છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    float base, height, area;
    
    printf("Enter base of triangle: ");
    scanf("\%f", \&base);
    printf("Enter height of triangle: ");
    scanf("\%f", \&height);
    
    // ક્ષેત્રફળ ગણો
    area = 0.5 * base * height;
    
    printf("Area of triangle = \%.2f square units{n}", area);
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input base, height/]}
    B {-{-} C[area = 0.5 * base * height]}
    C {-{-} D[/Output area/]}
    D {-{-} E([End])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ફોર્મ્યુલા}: ક્ષેત્રફળ = ½ \times પાયો \times ઉંચાઈ
\item
  \textbf{ફ્લોટ વેરિએબલ્સ}: દશાંશ ચોકસાઈ માટે
\item
  \textbf{યુઝર ઇનપુટ}: યુઝર પાસેથી પાયો અને ઉંચાઈ મેળવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``Half-BH'' (અડધો ગુણા પાયો ગુણા ઉંચાઈ)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(બ) OR [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{પોઈન્ટરનું ડીકલેરેશન અને ઈનીશ્યલાઈઝેશન સમજાવો.}

\begin{solutionbox}
પોઈન્ટર ડિક્લેરેશન અને ઇનિશિયલાઇઝેશનમાં પોઈન્ટર વેરિએબલ બનાવવાનો
અને તેને મેમરી એડ્રેસ સોંપવાનો સમાવેશ થાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{પોઈન્ટર ડિક્લેરેશન અને ઇનિશિયલાઇઝેશન}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2683}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1951}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2195}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3171}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ઓપરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સમજૂતી
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ડિક્લેરેશન & data\_type *pointer\_name; & int *ptr; & int પોઈન્ટર બનાવે છે \\
ઇનિશિયલાઇઝેશન & pointer\_name = \&variable; & ptr = \# & ptr માં num નું
એડ્રેસ સોંપે છે \\
સંયુક્ત & data\_type *pointer\_name = \&variable; & int *ptr = \# & ડિક્લેરેશન
અને ઇનિશિયલાઇઝેશન એકસાથે \\
નલ પોઈન્ટર & pointer\_name = NULL; & ptr = NULL; & કંઈ નહીં બતાવે (સુરક્ષિત
પદ્ધતિ) \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    // ડિક્લેરેશન
    int *ptr1;
    
    // ડિક્લેરેશન અને ઇનિશિયલાઇઝેશન એકસાથે
    int num = 10;
    int *ptr2 = \&num;
    
    // NULL સાથે ઇનિશિયલાઇઝેશન
    int *ptr3 = NULL;
    
    printf("Value at address ptr2: \%d{n}", *ptr2);  // આઉટપુટ: 10
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{એસ્ટરિસ્ક સિન્ટેક્સ}: * નો ઉપયોગ ડિક્લેરેશનમાં પોઈન્ટર બનાવવા માટે
\item
  \textbf{એડ્રેસ ઓપરેટર}: \& વેરિએબલનું એડ્રેસ મેળવે છે
\item
  \textbf{NULL ઇનિશિયલાઇઝેશન}: વાઈલ્ડ પોઈન્ટર્સ ટાળવા માટે સુરક્ષિત પદ્ધતિ
\item
  \textbf{પોઈન્ટર ટાઈપ}: જે ડેટા ટાઈપને પોઈન્ટ કરે છે તેને મેચ કરવું જોઈએ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DINA'' (Declare, Initialize with NULL or Address)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 4(ક) OR [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{વાઇલ લૂપ ફ્લોચાર્ટ દોરી ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
વાઇલ લૂપ એક પ્રી-ટેસ્ટ લૂપ છે જે શરત સાચી રહે ત્યાં સુધી તેના બોડીને
વારંવાર એક્ઝિક્યુટ કરે છે.

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Initialize counter i = 1/]}
    B {-{-} C\{i = 5?\}}
    C {-{-}|Yes| D[/Execute loop body: Print i/]}
    D {-{-} E[/Increment i: i++/]}
    E {-{-} C}
    C {-{-}|No| F([End])}
\end{verbatim}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i = 1;
    
    while (i {=} 5) \{  // દરેક એક્ઝિક્યુશન પહેલા શરત ચેક થાય છે
        printf("\%d ", i);
        i++;
    \}
    
    // આઉટપુટ: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{વાઇલ લૂપની લાક્ષણિકતાઓ}
\vspace{-10pt}
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
લાક્ષણિકતા & વિવરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
એક્ઝિક્યુશન ક્રમ & પહેલા શરત, પછી બોડી \\
ન્યૂનતમ પુનરાવર્તન & શૂન્ય (જો શરત પ્રારંભમાં ખોટી હોય) \\
શરત ચેક & લૂપની શરૂઆતમાં \\
સમાપ્તિ & જ્યારે શરત ખોટી થાય ત્યારે \\
સિન્ટેક્સ & while (condition) \{ statements; \} \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રી-ટેસ્ટ લૂપ}: લૂપ બોડી પહેલા શરત મૂલ્યાંકન
\item
  \textbf{શૂન્ય પુનરાવર્તન શક્ય}: જો શરત પ્રારંભમાં ખોટી હોય તો બોડી ક્યારેય
  એક્ઝિક્યુટ ન થઈ શકે
\item
  \textbf{લૂપ વેરિએબલ}: લૂપ પહેલા ઇનિશિયલાઇઝ થવું જોઈએ
\item
  \textbf{ઇન્ફિનિટ લૂપ}: જો શરત ક્યારેય ખોટી ન થાય તો થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CELT'' (Check, Execute, Loop, Terminate)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxaaeuxab0uxa95uxab8}

\textbf{બુકની આપેલ માહિતી સ્ટોર કરવાનું સ્ટ્રક્ચર બનાવો: book\_no, book\_title,
book\_author, book\_price}

\begin{solutionbox}
આ પ્રોગ્રામ સ્પષ્ટ કરેલા ફિલ્ડ્સ સાથે પુસ્તક માહિતી સંગ્રહ કરવા માટે
સ્ટ્રક્ચર બનાવે છે.

\begin{verbatim}
\#include {stdio.h}
\#include {string.h}

// પુસ્તક માહિતી માટે સ્ટ્રક્ચર ડેફિનેશન
struct Book \{
    int book\_no;
    char book\_title[50];
    char book\_author[30];
    float book\_price;
\;}

int main() \{
    // Book સ્ટ્રક્ચરના વેરિએબલની ઘોષણા
    struct Book book1;
    
    // સ્ટ્રક્ચર મેમ્બર્સને મૂલ્યો સોંપો
    book1.book\_no = 101;
    strcpy(book1.book\_title, "Programming in C");
    strcpy(book1.book\_author, "Dennis Ritchie");
    book1.book\_price = 450.75;
    
    // પુસ્તક માહિતી પ્રદર્શિત કરો
    printf("Book No: \%d{n}", book1.book\_no);
    printf("Title: \%s{n}", book1.book\_title);
    printf("Author: \%s{n}", book1.book\_author);
    printf("Price: Rs. \%.2f{n}", book1.book\_price);
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
+-----------------+
| struct Book     |
+-----------------+
| int book_no     |
| char book_title |
| char book_author|
| float book_price|
+-----------------+
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{સ્ટ્રક્ચર ડેફિનિશન}: કંપોઝિટ ડેટા પ્રકાર વ્યાખ્યાયિત કરવા struct
  કીવર્ડનો ઉપયોગ કરે છે
\item
  \textbf{મેમ્બર એક્સેસ}: સભ્યો એક્સેસ કરવા માટે ડોટ (.) ઓપરેટરનો ઉપયોગ કરે છે
\item
  \textbf{સ્ટ્રિંગ કોપિંગ}: કેરેક્ટર એરે માટે strcpy()
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``NTAP'' (Number, Title, Author, Price)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxaaeuxab0uxa95uxab8}

\textbf{(1)sqrt() (2)pow() (3)strlen() (4)strcpy() ફંક્શનો ઉદાહરણ સાથે
સમજાવો.}

\begin{solutionbox}
આ ફંક્શન C માં ગણિત ગણતરી અને સ્ટ્રિંગ મેનિપ્યુલેશન માટે વપરાતા
સ્ટાન્ડર્ડ લાઇબ્રેરી ફંક્શન્સ છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{લાઇબ્રેરી ફંક્શન્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2041}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.2653}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1837}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1837}}
  >{\raggedright\arraybackslash}p{(\linewidth - 8\tabcolsep) * \real{0.1633}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ફંક્શન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેડર ફાઈલ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
હેતુ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
આઉટપુટ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
sqrt() & math.h & નંબરનો વર્ગમૂળ & sqrt(16) & 4.0 \\
pow() & math.h & નંબરને પાવર કરે & pow(2, 3) & 8.0 \\
strlen() & string.h & સ્ટ્રિંગની લંબાઈ & strlen(``Hello'') & 5 \\
strcpy() & string.h & એક સ્ટ્રિંગથી બીજી સ્ટ્રિંગમાં કોપી & strcpy(dest,
``Hello'') & dest માં ``Hello'' હોય છે \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}
\#include {math.h}
\#include {string.h}

int main() \{
    // sqrt() અને pow() ઉદાહરણો
    printf("Square root of 25: \%.2f{n}", sqrt(25));
    printf("2 raised to power 4: \%.2f{n}", pow(2, 4));
    
    // strlen() ઉદાહરણ
    char str[] = "C Programming";
    printf("Length of string: \%d{n}", strlen(str));
    
    // strcpy() ઉદાહરણ
    char source[] = "Hello";
    char destination[10];
    strcpy(destination, source);
    printf("Copied string: \%s{n}", destination);
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મેથ ફંક્શન્સ}: ગાણિતિક ગણતરી માટે sqrt() અને pow()
\item
  \textbf{સ્ટ્રિંગ ફંક્શન્સ}: સ્ટ્રિંગ મેનિપ્યુલેશન માટે strlen() અને strcpy()
\item
  \textbf{હેડર ફાઈલ્સ}: આ ફંક્શન્સ વાપરવા જરૂરી છે
\item
  \textbf{રિટર્ન ટાઈપ્સ}: sqrt() અને pow() double આપે છે, strlen() size\_t આપે
  છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``MPSL'' (Math Power and String Length)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxaaeuxab0uxa95uxab8}

\textbf{એરે અને એરેનું ઈનીશ્યલાઈઝેશન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
એરે એ એક જ ડેટા પ્રકારના એલિમેન્ટ્સનો સમૂહ છે જે લગાતાર મેમરી
લોકેશન્સમાં સ્ટોર થયેલા હોય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{એરે પ્રકારો અને ઇનિશિયલાઇઝેશન પદ્ધતિઓ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1625}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3875}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
એરે પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ડિક્લેરેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ડિક્લેરેશન સમયે ઇનિશિયલાઇઝેશન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
અલગ ઇનિશિયલાઇઝેશન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ઇન્ટીજર & int arr[5]; & int arr[5] = \{10, 20, 30, 40, 50\}; &
arr[0] = 10; arr[1] = 20; વગેરે \\
કેરેક્ટર & char str[10]; & char str[10] = ``Hello''; & strcpy(str,
``Hello''); \\
ફ્લોટ & float values[3]; & float values[3] = \{1.5, 2.5, 3.5\}; &
values[0] = 1.5; વગેરે \\
આંશિક & int nums[5]; & int nums[5] = \{1, 2\}; & બાકીના 0 પર સેટ
થાય \\
સાઇઝ ઇન્ફરન્સ & - & int nums[] = \{1, 2, 3\}; & ઇનિશિયલાઇઝર દ્વારા સાઇઝ
નક્કી થાય \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    // એરે ડિક્લેરેશન અને ઇનિશિયલાઇઝેશન
    int numbers[5] = \{10, 20, 30, 40, 50\;}
    
    // એરે એલિમેન્ટ્સ એક્સેસ અને ડિસ્પ્લે
    printf("Array elements: ");
    for (int i = 0; i {} 5; i++) \{
        printf("\%d ", numbers[i]);
    \}
    printf("{n}");
    
    // એરે એલિમેન્ટ મોડીફાય કરવું
    numbers[2] = 35;
    printf("Modified element at index 2: \%d{n}", numbers[2]);
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
એરે: numbers[5]
+-----+-----+-----+-----+-----+
| 10  | 20  | 30  | 40  | 50  |
+-----+-----+-----+-----+-----+
  [0]   [1]   [2]   [3]   [4]
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઝીરો-બેઝ્ડ ઇન્ડેક્સિંગ}: પ્રથમ એલિમેન્ટ ઇન્ડેક્સ 0 પર
\item
  \textbf{કન્ટિગ્યુઅસ મેમરી}: એલિમેન્ટ્સ લાગલાગટ સ્ટોર થાય છે
\item
  \textbf{ફિક્સ્ડ સાઇઝ}: સાઇઝ કમ્પાઇલ ટાઇમે નક્કી થાય છે
\item
  \textbf{એલિમેન્ટ એક્સેસ}: સ્ક્વેર બ્રેકેટ્સ સાથે ઇન્ડેક્સનો ઉપયોગ કરીને
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DICE'' (Declaration, Initialization, Contiguous
storage, Element access)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(અ) OR [3
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxaaeuxab0uxa95uxab8}

\textbf{સ્ટ્રક્ચરનું ડીકલેરેશન ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
C માં સ્ટ્રક્ચર ડિક્લેરેશનમાં એક નવો ડેટા પ્રકાર વ્યાખ્યાયિત કરવાનો
સમાવેશ થાય છે જે વિવિધ ડેટા પ્રકારોને એક નામ હેઠળ જોડે છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{સ્ટ્રક્ચર ડિક્લેરેશન પદ્ધતિઓ}
\vspace{-10pt}
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પદ્ધતિ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
સિન્ટેક્સ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
બેઝિક ડિક્લેરેશન & struct tag\_name \{ members; \}; & struct Student \{ int
id; char name[20]; \}; \\
વેરિએબલ સાથે & struct tag\_name \{ members; \} variables; & struct Point
\{ int x, y; \} p1, p2; \\
ટેગ વગર & struct \{ members; \} variables; & struct \{ float real, imag;
\} c1; \\
ટાઇપડેફ & typedef struct \{ members; \} alias; & typedef struct \{ int h,
w; \} Rectangle; \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

// સ્ટ્રક્ચર ડિક્લેરેશન
struct Student \{
    int id;
    char name[30];
    float percentage;
\;}

int main() \{
    // સ્ટ્રક્ચર વેરિએબલ ડિક્લેર
    struct Student s1;
    
    // સ્ટ્રક્ચર મેમ્બર્સને મૂલ્યો સોંપો
    s1.id = 101;
    strcpy(s1.name, "John");
    s1.percentage = 85.5;
    
    // સ્ટ્રક્ચર મેમ્બર્સ ડિસ્પ્લે
    printf("Student ID: \%d{n}", s1.id);
    printf("Name: \%s{n}", s1.name);
    printf("Percentage: \%.2f\%\%{n}", s1.percentage);
    
    return 0;
\}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{સ્ટ્રક્ચર કીવર્ડ}: નવો ડેટા પ્રકાર વ્યાખ્યાયિત કરવા struct નો ઉપયોગ
\item
  \textbf{મેમ્બર એક્સેસ}: મેમ્બર્સ એક્સેસ કરવા માટે . (ડોટ) ઓપરેટર
\item
  \textbf{વિષમ ડેટા}: વિવિધ ડેટા પ્રકારોને જોડી શકે છે
\item
  \textbf{કસ્ટમ ડેટા પ્રકાર}: યુઝર-ડિફાઇન્ડ ડેટા પ્રકાર બનાવે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SMUVT'' (Structure Mostly Uses Various Types)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(બ) OR [4
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxaaeuxab0uxa95uxab8}

\textbf{યુઝર ડીફાઈન ફંક્શન એટલે શું? ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
યુઝર-ડિફાઇન્ડ ફંક્શન એ પ્રોગ્રામર દ્વારા લખાયેલો કોડનો બ્લોક છે જે
ચોક્કસ કાર્ય કરે છે અને પ્રોગ્રામના અન્ય ભાગોથી કોલ કરી શકાય છે.


{\def\LTcaptype{none} % do not increment counter
\vspace{-5pt}
\captionof{table}{ફંક્શન કોમ્પોનન્ટ્સ}
\vspace{-10pt}
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કોમ્પોનન્ટ & વિવરણ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
રિટર્ન ટાઈપ & ફંક્શન દ્વારા પરત કરેલ ડેટા પ્રકાર & int, float, void \\
ફંક્શન નામ & ફંક્શન માટે ઓળખકર્તા & add, findMax \\
પેરામીટર્સ & કૌંસમાં ઇનપુટ મૂલ્યો & (int a, int b) \\
ફંક્શન બોડી & કર્લી બ્રેસિસની અંદર કોડ & \{ return a + b; \} \\
ફંક્શન કોલ & ફંક્શનને બોલાવવું & result = add(5, 3); \\
\end{longtable}
}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\#include {stdio.h}

// યુઝર{-ડિફાઇન્ડ ફંક્શન ડિક્લેરેશન}
int findMax(int a, int b);

int main() \{
    int num1 = 10, num2 = 20, max;
    
    // ફંક્શન કોલ
    max = findMax(num1, num2);
    
    printf("Maximum between \%d and \%d is \%d{n}", num1, num2, max);
    
    return 0;
\}

// ફંક્શન ડેફિનિશન
int findMax(int a, int b) \{
    // ફંક્શન બોડી
    if (a {} b)
        return a;
    else
        return b;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart TD
    A[main function] {-{-}|calls with num1, num2| B[findMax function]}
    B {-{-}|returns maximum value| A}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ્યુલર કોડ}: મોટા પ્રોગ્રામને નાના ભાગોમાં વિભાજિત કરે છે
\item
  \textbf{રીયુઝેબિલિટી}: ફંક્શનને અલગ અલગ જગ્યાએથી અનેક વખત કોલ કરી શકાય
\item
  \textbf{ડિક્લેરેશન vs ડેફિનિશન}: ડિક્લેરેશન કમ્પાઇલરને ફંક્શન વિશે જણાવે છે,
  ડેફિનિશનમાં ખરેખર કોડ હોય છે
\item
  \textbf{પેરામીટર્સ}: ફંક્શન કોલ કરતી વખતે મૂલ્યો પાસ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CDRP'' (Create, Define, Return, Pass)

\end{mnemonicbox}
\subsection*{પ્રશ્ન 5(ક) OR [7
માર્કસ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxaaeuxab0uxa95uxab8}

\textbf{૧૦ નંબરવાળા એરેના ઘટકોને ચઢતા ક્રમમાં ગોઠવવા માટેનો C પ્રોગ્રામ લખો.}

\begin{solutionbox}
આ પ્રોગ્રામ બબલ સોર્ટ અલ્ગોરિધમનો ઉપયોગ કરીને 10 ઇન્ટીજરના એરેને
ચઢતા ક્રમમાં સોર્ટ કરે છે.

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int arr[10], i, j, temp;
    
    // એરે એલિમેન્ટ્સ ઇનપુટ કરો
    printf("Enter 10 integers: {n}");
    for (i = 0; i {} 10; i++) \{
        scanf("\%d", \&arr[i]);
    \}
    
    // ચઢતા ક્રમ માટે બબલ સોર્ટ અલ્ગોરિધમ
    for (i = 0; i {} 9; i++) \{
        for (j = 0; j {} 9 {-} i; j++) \{
            if (arr[j] {} arr[j + 1]) \{
                // જો વર્તમાન એલિમેન્ટ આગળના કરતાં મોટું હોય તો સ્વેપ કરો
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            \}
        \}
    \}
    
    // સોર્ટેડ એરે ડિસ્પ્લે કરો
    printf("Array in ascending order: {n}");
    for (i = 0; i {} 10; i++) \{
        printf("\%d ", arr[i]);
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{ડાયાગ્રામ:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input 10 array elements/]}
    B {-{-} C[i = 0]}
    C {-{-} D\{i  9?\}}
    D {-{-}|Yes| E[j = 0]}
    E {-{-} F\{j  9{-}i?\}}
    F {-{-}|Yes| G\{"arr[j]  arr[j+1]?"\}}
    G {-{-}|Yes| H["Swap arr[j] and arr[j+1]"]}
    G {-{-}|No| I[j++]}
    H {-{-} I}
    I {-{-} F}
    F {-{-}|No| J[i++]}
    J {-{-} D}
    D {-{-}|No| K[/Output sorted array/]}
    K {-{-} L([End])}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{બબલ સોર્ટ}: બાજુના એલિમેન્ટની સરખામણી કરે અને જરૂર હોય તો સ્વેપ કરે
\item
  \textbf{નેસ્ટેડ લૂપ્સ}: બહારની લૂપ પાસ માટે, અંદરની તુલના માટે
\item
  \textbf{ઓપ્ટિમાઇઝેશન}: દરેક પાસ ઓછામાં ઓછા એક એલિમેન્ટને ફિક્સ કરે છે, તેથી અંદરની
  લૂપ ઓછી વખત ચાલે છે
\item
  \textbf{ટેમ્પરરી વેરિએબલ}: એલિમેન્ટ્સ સ્વેપ કરવા માટે ઉપયોગ થાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BSCOT'' (Bubble Sort Compares and Orders Things)

\end{mnemonicbox}

\end{document}
