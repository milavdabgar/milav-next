\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4331105 -- Winter 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{List any six keywords of C language.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Category & Keywords \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Data Types} & int, float, char \\
\textbf{Control Flow} & if, for, return \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``I Find Clever Reasons For Results''

\end{mnemonicbox}
\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Define Operator. Summarize types of operators based on
operands.}

\begin{solutionbox}

\textbf{Operator}: Symbol that performs operations on operands to
produce a result.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Type & Description & Examples \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Unary} & Single operand & ++, --, ! \\
\textbf{Binary} & Two operands & +, -, *, /, \% \\
\textbf{Ternary} & Three operands & ?: \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``U-B-T: Use Binary Then Ternary''

\end{mnemonicbox}
\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{Define flowchart. Draw flowchart symbols. Draw flowchart to find
minimum of two integer numbers N1 \& N2.}

\begin{solutionbox}

\textbf{Flowchart}: Graphical representation of algorithm using
standardized symbols to show the sequence of operations.

\textbf{Common Flowchart Symbols:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Symbol & Meaning \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Oval} & Start/Stop \\
\textbf{Parallelogram} & Input/Output \\
\textbf{Rectangle} & Process \\
\textbf{Diamond} & Decision \\
\textbf{Arrow} & Flow direction \\
\end{longtable}
}

\textbf{Flowchart to find minimum of N1 \& N2:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input N1, N2/]}
    B {-{-} C\{N1  N2?\}}
    C {-{-}|Yes| D[Min = N1]}
    C {-{-}|No| E[Min = N2]}
    D {-{-} F[/Display Min/]}
    E {-{-} F}
    F {-{-} G([End])}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SPADE: Start-Process-Arrow-Decision-End''

\end{mnemonicbox}
\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Define algorithm. Write an algorithm to calculate area and
circumference of circle.}

\begin{solutionbox}

\textbf{Algorithm}: Step-by-step procedure to solve a problem using
finite number of well-defined instructions.

\textbf{Algorithm to calculate area and circumference of circle:}

\begin{enumerate}
\tightlist
\item
  \textbf{Start}
\item
  \textbf{Input radius r}
\item
  \textbf{Set PI = 3.14159}
\item
  \textbf{Calculate area = PI \times r \times r}
\item
  \textbf{Calculate circumference = 2 \times PI \times r}
\item
  \textbf{Display area and circumference}
\item
  \textbf{Stop}
\end{enumerate}

\textbf{Table of formulas used:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Measurement & Formula \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Area} & π \times r^{2} \\
\textbf{Circumference} & 2 \times π \times r \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``RICARD: Radius Input, Calculate Area, Reveal
Dimensions''

\end{mnemonicbox}
\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Differentiate printf() and scanf().}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & printf() & scanf() \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Purpose} & Outputs data to screen & Inputs data from keyboard \\
\textbf{Direction} & Output function & Input function \\
\textbf{Format specifier} & Required & Required \\
\textbf{Parameter} & Actual values & Address of variables (\&) \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``OIAD: Output-Input, Actual-Destination''

\end{mnemonicbox}
\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Develop a C program to print sum \& average of 1 to n.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int n, i, sum = 0;
    float avg;
    
    printf("Enter n: ");
    scanf("\%d", \&n);
    
    for(i = 1; i {=} n; i++) \{
        sum += i;
    \}
    
    avg = (float)sum / n;
    
    printf("Sum = \%d{n}", sum);
    printf("Average = \%.2f{n}", avg);
    
    return 0;
\}
\end{verbatim}

\textbf{Key Points:}

\begin{itemize}
\tightlist
\item
  \textbf{Initialization}: sum = 0
\item
  \textbf{Iteration}: for loop from 1 to n
\item
  \textbf{Type Casting}: (float) for correct average
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SIAP: Sum Initialize, Add in loop, Print results''

\end{mnemonicbox}
\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Explain Arithmetic operator and Relational operator with
example.}

\begin{solutionbox}

\textbf{1. Arithmetic Operators:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Operation & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{+} & Addition & 5 + 3 & 8 \\
\textbf{-} & Subtraction & 5 - 3 & 2 \\
\textbf{*} & Multiplication & 5 * 3 & 15 \\
\textbf{/} & Division & 5 / 2 & 2 (integer) \\
\textbf{\%} & Modulo (Remainder) & 5 \% 2 & 1 \\
\end{longtable}
}

\textbf{2. Relational Operators:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Meaning & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\textless{}} & Less than & 5 \textless{} 3 & 0 (false) \\
\textbf{\textgreater{}} & Greater than & 5 \textgreater{} 3 & 1
(true) \\
\textbf{\textless=} & Less than or equal & 5 \textless= 5 & 1 (true) \\
\textbf{\textgreater=} & Greater than or equal & 3 \textgreater= 5 & 0
(false) \\
\textbf{==} & Equal to & 5 == 5 & 1 (true) \\
\textbf{!=} & Not equal to & 5 != 3 & 1 (true) \\
\end{longtable}
}

\textbf{Code Example:}

\begin{verbatim}
int

a = 5,

b = 3;

printf("a + b = \%d{n}", a + b);     // Output: 8
printf("a { b is }\%d{n}", a {} b);    // Output: 1 (true)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``ASMDR for Arithmetic, LEGENE for Relational''

\end{mnemonicbox}
\subsection*{Question 2(a) OR [3
marks]}\label{q2a}

\textbf{What is the difference between get(S) and scanf(``\%s'',S)}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Feature & gets(S) & scanf(``\%s'',S) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Whitespace handling} & Reads space & Stops at whitespace \\
\textbf{Buffer overflow} & No boundary check & Safer with width limit \\
\textbf{Return type} & char* & Number of items read \\
\textbf{Usage safety} & Deprecated, unsafe & Safer with format
control \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``WBRU: Whitespace-Boundary-Return-Usage''

\end{mnemonicbox}
\subsection*{Question 2(b) OR [4
marks]}\label{q2b}

\textbf{Develop a C program to swap (exchange) value of two numbers.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int a, b, temp;
    
    printf("Enter two numbers: ");
    scanf("\%d \%d", \&a, \&b);
    
printf("Before swap:

a = \%d,

b = \%d{n}", a, b);

    
    temp = a;
    a = b;
    b = temp;
    
printf("After swap:

a = \%d,

b = \%d{n}", a, b);

    
    return 0;
\}
\end{verbatim}

\textbf{Diagram:}

\begin{verbatim}
flowchart LR
    subgraph Before
    A1[a = 5] {-{-}{-} B1[b = 10]}
    end
    subgraph Step1
    A2[a = 5] {-{-}{-} T[temp = 5]}
    B2[b = 10]
    end
    subgraph Step2
    A3[a = 10] {-{-}{-} T2[temp = 5]}
    B3[b = 10]
    end
    subgraph After
    A4[a = 10] {-{-}{-} B4[b = 5]}
    end
    Before {-{-} Step1}
    Step1 {-{-} Step2}
    Step2 {-{-} After}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``TAB: Temp-Assign-Backfill''

\end{mnemonicbox}
\subsection*{Question 2(c) OR [7
marks]}\label{q2c}

\textbf{Explain Boolean operator and Logical operator with example.}

\begin{solutionbox}

\textbf{1. Boolean Operators:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Operation & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\&} & Bitwise AND & 5 \& 3 & 1 \\
\textbf{\textbar{}} & Bitwise OR & 5 \textbar{} 3 & 7 \\
\textbf{\^{}} & Bitwise XOR & 5 \^{} 3 & 6 \\
\textbf{\textasciitilde{}} & Bitwise NOT & \textasciitilde5 & -6 \\
\textbf{\textless\textless{}} & Left Shift & 5 \textless\textless{} 1 &
10 \\
\textbf{\textgreater\textgreater{}} & Right Shift & 5
\textgreater\textgreater{} 1 & 2 \\
\end{longtable}
}

\textbf{2. Logical Operators:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Operator & Meaning & Example & Result \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{\&\&} & Logical AND & (5\textgreater3) \&\& (2\textless4) & 1
(true) \\
\textbf{\textbar\textbar{}} & Logical OR & (5\textless3)
\textbar\textbar{} (2\textless4) & 1 (true) \\
\textbf{!} & Logical NOT & !(5\textgreater3) & 0 (false) \\
\end{longtable}
}

\textbf{Example:}

\begin{verbatim}
int

a = 5,

b = 3;

printf("a \& b = \%d{n}", a \& b);           // Output: 1 (bitwise AND)
printf("a { b \&\& b  10 is }\%d{n}", a {} b \&\& b {} 10);  // Output: 1 (true)
\end{verbatim}

\textbf{Bit Representation (5 \& 3):}

\begin{verbatim}
5 = 101
3 = 011
& = 001 (1 in decimal)
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``BOXNRL for Boolean, AON for Logical''

\end{mnemonicbox}
\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Compare entry controlled and exit controlled loop with example.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2093}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3953}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3953}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Entry Controlled
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Exit Controlled
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Condition check} & Before execution & After execution \\
\textbf{Minimum iterations} & Zero & One \\
\textbf{Example} & while, for & do-while \\
\textbf{Usage} & When pre-check needed & When at least one execution
needed \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``BCME: Before-Check-Multiple-Examples''

\end{mnemonicbox}
\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Develop a C program to display addition and subtraction of two
numbers using switch case.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int a, b, choice, result;
    
    printf("Enter two numbers: ");
    scanf("\%d \%d", \&a, \&b);
    
    printf("1. Addition{n}2. Subtraction{n}");
    printf("Enter choice (1/2): ");
    scanf("\%d", \&choice);
    
    switch(choice) \{
        case 1:
            result = a + b;
            printf("Addition: \%d{n}", result);
            break;
        case 2:
            result = a {-} b;
            printf("Subtraction: \%d{n}", result);
            break;
        default:
            printf("Invalid choice{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{Flowchart:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input a, b/]}
    B {-{-} C[/Input choice/]}
    C {-{-} D\{"switch(choice)"\}}
    D {-{-}|case 1| E[result = a + b]}
    D {-{-}|case 2| F[result = a {-} b]}
    D {-{-}|default| G[Display Invalid]}
    E {-{-} H[/Display Addition/]}
    F {-{-} I[/Display Subtraction/]}
    H {-{-} J([End])}
    I {-{-} J}
    G {-{-} J}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CIRCA: Choice-Input-Result-Calculate-Action''

\end{mnemonicbox}
\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{Explain multiple if-else statement with syntax, flowchart and an
example.}

\begin{solutionbox}

\textbf{Syntax of multiple if-else:}

\begin{verbatim}
if (condition1) \{
    // code block 1
\} 
else if (condition2) \{
    // code block 2
\} 
else if (condition3) \{
    // code block 3
\} 
else \{
    // default code block
\}
\end{verbatim}

\textbf{Flowchart:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B\{condition1?\}}
    B {-{-}|True| C[Execute block 1]}
    B {-{-}|False| D\{condition2?\}}
    D {-{-}|True| E[Execute block 2]}
    D {-{-}|False| F\{condition3?\}}
    F {-{-}|True| G[Execute block 3]}
    F {-{-}|False| H[Execute default block]}
    C {-{-} I([End])}
    E {-{-} I}
    G {-{-} I}
    H {-{-} I}
\end{verbatim}

\textbf{Example:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int marks;
    
    printf("Enter marks: ");
    scanf("\%d", \&marks);
    
    if (marks {=} 80) \{
        printf("Grade: A{n}");
    \} 
    else if (marks {=} 70) \{
        printf("Grade: B{n}");
    \} 
    else if (marks {=} 60) \{
        printf("Grade: C{n}");
    \} 
    else \{
        printf("Grade: F{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``TEST: Try Each Statement Then default''

\end{mnemonicbox}
\subsection*{Question 3(a) OR [3
marks]}\label{q3a}

\textbf{State the use of break and continue keyword.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2368}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2105}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.3158}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Keyword
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Effect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Common Use
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{break} & Terminates loop/switch & Exits the current loop/switch
& To exit when condition met \\
\textbf{continue} & Skips iteration & Jumps to next iteration & To skip
specific values \\
\end{longtable}
}

\textbf{Example Code:}

\begin{verbatim}
// break example
for(i=1; i{=}10; i++) \{
if(i == 5) break; // exits loop at

i=5

    printf("\%d ", i);  // prints 1 2 3 4
\}

// continue example
for(i=1; i{=}5; i++) \{
if(i == 3) continue; // skips

i=3

    printf("\%d ", i);  // prints 1 2 4 5
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``EXIT-SKIP: EXit IT or SKIP iteration''

\end{mnemonicbox}
\subsection*{Question 3(b) OR [4
marks]}\label{q3b}

\textbf{Develop a C program to check whether the given number is even or
odd.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num;
    
    printf("Enter a number: ");
    scanf("\%d", \&num);
    
    if (num \% 2 == 0) \{
        printf("\%d is even.{n}", num);
    \} 
    else \{
        printf("\%d is odd.{n}", num);
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{Diagram:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input num/]}
    B {-{-} C\{num \% 2 == 0?\}}
    C {-{-}|Yes| D[/Display "Even"/]}
    C {-{-}|No| E[/Display "Odd"/]}
    D {-{-} F([End])}
    E {-{-} F}
\end{verbatim}

\textbf{Key Points:}

\begin{itemize}
\tightlist
\item
  \textbf{Check}: Using modulo (\%) operator
\item
  \textbf{Decision}: Based on remainder with 2
\item
  \textbf{Output}: Even for remainder 0, Odd otherwise
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``MODE: MODulo Equals zero for even''

\end{mnemonicbox}
\subsection*{Question 3(c) OR [7
marks]}\label{q3c}

\textbf{Explain switch-case statement with syntax, flowchart and an
example.}

\begin{solutionbox}

\textbf{Syntax of switch-case:}

\begin{verbatim}
switch (expression) \{
    case constant1:
        // code block 1
        break;
    case constant2:
        // code block 2
        break;
    ...
    default:
        // default code block
\}
\end{verbatim}

\textbf{Flowchart:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[Evaluate expression]}
    B {-{-} C\{matches case 1?\}}
    C {-{-}|Yes| D[Execute block 1]}
    C {-{-}|No| E\{matches case 2?\}}
    E {-{-}|Yes| F[Execute block 2]}
    E {-{-}|No| G\{matches case n?\}}
    G {-{-}|Yes| H[Execute block n]}
    G {-{-}|No| I[Execute default block]}
    D {-{-} J[break?]}
    F {-{-} K[break?]}
    H {-{-} L[break?]}
    J {-{-}|Yes| M([End])}
    K {-{-}|Yes| M}
    L {-{-}|Yes| M}
    I {-{-} M}
    J {-{-}|No| E}
    K {-{-}|No| G}
    L {-{-}|No| M}
\end{verbatim}

\textbf{Example:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    char grade;
    
    printf("Enter grade (A{-D): "});
    scanf(" \%c", \&grade);
    
    switch (grade) \{
        case {A}:
            printf("Excellent!{n}");
            break;
        case {B}:
            printf("Good job!{n}");
            break;
        case {C}:
            printf("Satisfactory{n}");
            break;
        case {D}:
            printf("Needs improvement{n}");
            break;
        default:
            printf("Invalid grade{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CEBID: Compare-Execute-Break-If-Done''

\end{mnemonicbox}
\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Define string. List out different operations that can be
performed on string.}

\begin{solutionbox}

\textbf{String}: Array of characters terminated by null character
`\textbackslash0'.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Description & Function \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Input/Output} & Read/write strings & gets(), puts() \\
\textbf{Copy} & Copy one string to another & strcpy() \\
\textbf{Concatenation} & Join two strings & strcat() \\
\textbf{Comparison} & Compare two strings & strcmp() \\
\textbf{Length} & Find string length & strlen() \\
\textbf{Search} & Find substring & strstr() \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``ICCLS: Input-Copy-Concatenate-Length-Search''

\end{mnemonicbox}
\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Develop a C program to convert uppercase alphabet to lowercase
alphabet.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    char ch;
    
    printf("Enter an uppercase letter: ");
    scanf(" \%c", \&ch);
    
    if (ch {=} {A} \&\& ch {=} {Z}) \{
        char lowercase = ch + 32;  // ASCII difference is 32
        printf("Lowercase: \%c{n}", lowercase);
    \} 
    else \{
        printf("Not an uppercase letter{n}");
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{ASCII Table Excerpt:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Character & ASCII Value \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{A} & 65 \\
\textbf{a} & 97 \\
\textbf{Z} & 90 \\
\textbf{z} & 122 \\
\textbf{Difference} & 32 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``COOL: Character Offset Of Lowercase''

\end{mnemonicbox}
\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Draw flowchart of for loop and explain with example.}

\begin{solutionbox}

\textbf{For Loop Syntax:}

\begin{verbatim}
for (initialization; condition; increment/decrement) \{
    // code block
\}
\end{verbatim}

\textbf{Flowchart:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[Initialization]}
    B {-{-} C\{Condition?\}}
    C {-{-}|True| D[Execute code block]}
    D {-{-} E[Increment/Decrement]}
    E {-{-} C}
    C {-{-}|False| F([End])}
\end{verbatim}

\textbf{For Loop Components:}

\begin{enumerate}
\tightlist
\item
  \textbf{Initialization}: Executed once at beginning
\item
  \textbf{Condition}: Checked before each iteration
\item
  \textbf{Increment/Decrement}: Executed after each iteration
\item
  \textbf{Body}: Executed if condition is true
\end{enumerate}

\textbf{Example:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i;
    
    for (i = 1; i {=} 5; i++) \{
        printf("\%d ", i);
    \}
    // Output: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}

\textbf{Execution Flow:}

\begin{enumerate}
\tightlist
\item
  Initialize i = 1
\item
  Check condition (1 \textless= 5) - True
\item
  Execute body - Print 1
\item
  Increment i to 2
\item
  Check condition (2 \textless= 5) - True
\item
  And so on until i becomes 6
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``ICE-T: Initialize, Check, Execute, Then increment''

\end{mnemonicbox}
\subsection*{Question 4(a) OR [3
marks]}\label{q4a}

\textbf{Define array. List out different operations that can be
performed on array.}

\begin{solutionbox}

\textbf{Array}: Collection of similar data types stored in contiguous
memory locations.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Operation & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Declaration} & Create array & int arr[5]; \\
\textbf{Initialization} & Assign values & arr[0] = 10; \\
\textbf{Traversal} & Access all elements & for loop \\
\textbf{Insertion} & Add new element & arr[pos] = value; \\
\textbf{Deletion} & Remove element & Shift elements \\
\textbf{Searching} & Find element & Linear/binary search \\
\textbf{Sorting} & Arrange elements & Bubble/Selection sort \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``DITIDSS:
Declare-Initialize-Traverse-Insert-Delete-Search-Sort''

\end{mnemonicbox}
\subsection*{Question 4(b) OR [4
marks]}\label{q4b}

\textbf{Define pointer. Explain with example.}

\begin{solutionbox}

\textbf{Pointer}: Variable that stores the memory address of another
variable.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Concept & Description & Syntax \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Declaration} & Create pointer & int *ptr; \\
\textbf{Address operator} & Get address & \&variable \\
\textbf{Dereferencing} & Access value at address & *ptr \\
\textbf{Assignment} & Store address in pointer & ptr = \&variable; \\
\end{longtable}
}

\textbf{Example:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int num = 10;
    int *ptr;
    
    ptr = \&num;  // Store address of num in ptr
    
    printf("Value of num: \%d{n}", num);           // 10
    printf("Address of num: \%p{n}", \&num);        // Address of num
    printf("Value of ptr: \%p{n}", ptr);           // Same address
    printf("Value pointed by ptr: \%d{n}", *ptr);  // 10
    
    *ptr = 20;   // Change value using pointer
    printf("New value of num: \%d{n}", num);       // 20
    
    return 0;
\}
\end{verbatim}

\textbf{Diagram:}

\begin{verbatim}
flowchart LR
    subgraph Memory
    direction LR
    A[ptr: 1001] {-{-}|contains| B[1000]}
    C[num: 1000] {-{-}|contains| D[10]}
    end
    B {-.{-}|points to| C}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``SAVD: Store Address, Value through Dereferencing''

\end{mnemonicbox}
\subsection*{Question 4(c) OR [7
marks]}\label{q4c}

\textbf{Draw flowchart of while loop and explain with example.}

\begin{solutionbox}

\textbf{While Loop Syntax:}

\begin{verbatim}
while (condition) \{
    // code block
\}
\end{verbatim}

\textbf{Flowchart:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B\{Condition?\}}
    B {-{-}|True| C[Execute code block]}
    C {-{-} D[Update control variable]}
    D {-{-} B}
    B {-{-}|False| E([End])}
\end{verbatim}

\textbf{While Loop Components:}

\begin{enumerate}
\tightlist
\item
  \textbf{Initialization}: Before the loop
\item
  \textbf{Condition}: Checked before each iteration
\item
  \textbf{Body}: Executed if condition is true
\item
  \textbf{Update}: Must be done inside the body
\end{enumerate}

\textbf{Example:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int i = 1;
    
    while (i {=} 5) \{
        printf("\%d ", i);
        i++;
    \}
    // Output: 1 2 3 4 5
    
    return 0;
\}
\end{verbatim}

\textbf{Execution Flow:}

\begin{enumerate}
\tightlist
\item
  Initialize i = 1 (before loop)
\item
  Check condition (1 \textless= 5) - True
\item
  Execute body - Print 1
\item
  Update i to 2
\item
  Check condition (2 \textless= 5) - True
\item
  And so on until i becomes 6
\end{enumerate}

\end{solutionbox}
\begin{mnemonicbox}
``CHECK-UPDATE: CHECK before entering, UPDATE before
repeating''

\end{mnemonicbox}
\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{State the use of following functions. (1) strcat() (2) strlen()
(3) strcpy()}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2778}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2222}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Function
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{strcat()} & Concatenates strings & strcat(dest, src) & ``Hello''
+ ``World'' -\textgreater{} ``HelloWorld'' \\
\textbf{strlen()} & Returns string length & strlen(str) & ``Hello''
-\textgreater{} 5 \\
\textbf{strcpy()} & Copies string & strcpy(dest, src) & src
-\textgreater{} dest \\
\end{longtable}
}

\textbf{Code Example:}

\begin{verbatim}
\#include {string.h}

char str1[20] = "Hello";
char str2[20] = "World";
char str3[20];

strcat(str1, str2);    // str1 becomes "HelloWorld"
int len = strlen(str1); // len becomes 10
strcpy(str3, str1);    // str3 becomes "HelloWorld"
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CLS: Concatenate-Length-Source copy''

\end{mnemonicbox}
\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Build a structure to store book information: book\_no,
book\_title, book\_author, book\_price.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}
\#include {string.h}

struct Book \{
    int book\_no;
    char book\_title[50];
    char book\_author[30];
    float book\_price;
\;}

int main() \{
    struct Book book1;
    
    // Assign values
    book1.book\_no = 101;
    strcpy(book1.book\_title, "Programming in C");
    strcpy(book1.book\_author, "Dennis Ritchie");
    book1.book\_price = 450.75;
    
    // Display book information
    printf("Book No: \%d{n}", book1.book\_no);
    printf("Title: \%s{n}", book1.book\_title);
    printf("Author: \%s{n}", book1.book\_author);
    printf("Price: \%.2f{n}", book1.book\_price);
    
    return 0;
\}
\end{verbatim}

\textbf{Structure Memory Layout:}

\begin{verbatim}
flowchart TD
    subgraph "struct Book"
    direction LR
    A[book\_no: 4 bytes] {-{-} B[book\_title: 50 bytes]}
    B {-{-} C[book\_author: 30 bytes]}
    C {-{-} D[book\_price: 4 bytes]}
    end
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``NTAP: Number-Title-Author-Price''

\end{mnemonicbox}
\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Explain array and array initialization. Give example.}

\begin{solutionbox}

\textbf{Array}: Collection of same data type elements stored at
contiguous memory locations.

\textbf{Array Initialization Methods:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3200}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3600}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Method
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Example
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{At declaration} & datatype array\_name[size] = \{values\}; &
int arr[5] = \{10, 20, 30, 40, 50\}; \\
\textbf{Partial} & datatype array\_name[size] = \{values\}; & int
arr[5] = \{10, 20\}; // Rest are 0 \\
\textbf{All zeros} & datatype array\_name[size] = \{0\}; & int
arr[5] = \{0\}; \\
\textbf{Element by element} & array\_name[index] = value; &
arr[0] = 10; arr[1] = 20; \\
\textbf{Size inference} & datatype array\_name[] = \{values\}; & int
arr[] = \{10, 20, 30\}; // Size 3 \\
\end{longtable}
}

\textbf{Example:}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    // Method 1: Complete initialization
    int arr1[5] = \{10, 20, 30, 40, 50\;}
    
    // Method 2: Partial initialization (remaining elements set to 0)
    int arr2[5] = \{10, 20\;}  // arr2[2], arr2[3], arr2[4] become 0
    
    // Method 3: Element by element
    int arr3[3];
    arr3[0] = 100;
    arr3[1] = 200;
    arr3[2] = 300;
    
    // Method 4: Size inference
    int arr4[] = \{1, 2, 3, 4, 5\;}  // Size automatically set to 5
    
    // Accessing elements
    printf("arr1[2] = \%d{n}", arr1[2]);  // Output: 30
    
    // Array traversal
    printf("arr4 elements: ");
    for(int i = 0; i {} 5; i++) \{
        printf("\%d ", arr4[i]);  // Output: 1 2 3 4 5
    \}
    
    return 0;
\}
\end{verbatim}

\textbf{Memory Representation:}

\begin{verbatim}
flowchart LR
    subgraph "arr1[5]"
    direction LR
    A["arr1[0]: 10"] {-{-}{-} B["arr1[1]: 20"] {-}{-}{-} C["arr1[2]: 30"] {-}{-}{-} D["arr1[3]: 40"] {-}{-}{-} E["arr1[4]: 50"]}
    end
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``CAPES: Complete, Automatic, Partial, Element,
Size-inferred''

\end{mnemonicbox}
\subsection*{Question 5(a) OR [3
marks]}\label{q5a}

\textbf{Compare array and structure with example.}

\begin{solutionbox}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2593}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4074}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Array
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Structure
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Data type} & Same type elements & Different type elements \\
\textbf{Access} & Using index (arr[i]) & Using dot operator
(s.member) \\
\textbf{Memory} & Contiguous, fixed size & Contiguous, may have
padding \\
\textbf{Assignment} & Element by element & Direct with compatible
structures \\
\textbf{Purpose} & Collection of similar items & Group of related
data \\
\end{longtable}
}

\textbf{Array Example:}

\begin{verbatim}
int marks[5] = \{85, 90, 78, 92, 88\;}
printf("\%d", marks[2]);  // Access element at index 2 (78)
\end{verbatim}

\textbf{Structure Example:}

\begin{verbatim}
struct Student \{
    int roll\_no;
    char name[20];
    float percentage;
\;}

struct Student s1 = \{101, "Raj", 85.5\;}
printf("\%s", s1.name);  // Access name member ("Raj")
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``DAMPA: Datatype-Access-Memory-Purpose-Assignment''

\end{mnemonicbox}
\subsection*{Question 5(b) OR [4
marks]}\label{q5b}

\textbf{Define User Defined Function. Explain with example.}

\begin{solutionbox}

\textbf{User Defined Function}: Block of code written by programmer to
perform specific task, which can be called multiple times.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Component & Description & Example \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Return type} & Data type returned & int, float, void \\
\textbf{Function name} & Unique identifier & sum, findMax \\
\textbf{Parameters} & Input data & (int a, int b) \\
\textbf{Body} & Set of statements & \{ return a+b; \} \\
\end{longtable}
}

\textbf{Example:}

\begin{verbatim}
\#include {stdio.h}

// Function declaration
int sum(int a, int b);

int main() \{
    int num1 = 10, num2 = 20, result;
    
    // Function call
    result = sum(num1, num2);
    
    printf("Sum = \%d{n}", result);
    
    return 0;
\}

// Function definition
int sum(int a, int b) \{
    return a + b;
\}
\end{verbatim}

\textbf{Function Flow:}

\begin{verbatim}
flowchart LR
    A[main function] {-{-}|"Call sum(10, 20)"| B["sum function"]}
    B {-{-}|Return 30| A}
B {-{-}|a = 10,

b = 20| C[return a + b]}

\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``DPCR: Declaration-Parameters-Call-Return''

\end{mnemonicbox}
\subsection*{Question 5(c) OR [7
marks]}\label{q5c}

\textbf{Develop a C program to find maximum and minimum element of
array.}

\begin{solutionbox}

\begin{verbatim}
\#include {stdio.h}

int main() \{
    int arr[100], n, i;
    int max, min;
    
    printf("Enter number of elements: ");
    scanf("\%d", \&n);
    
    printf("Enter \%d integers: ", n);
    for(i = 0; i {} n; i++) \{
        scanf("\%d", \&arr[i]);
    \}
    
    // Initialize max and min with first element
    max = min = arr[0];
    
    // Find max and min
    for(i = 1; i {} n; i++) \{
        if(arr[i] {} max) \{
            max = arr[i];
        \}
        if(arr[i] {} min) \{
            min = arr[i];
        \}
    \}
    
    printf("Maximum element: \%d{n}", max);
    printf("Minimum element: \%d{n}", min);
    
    return 0;
\}
\end{verbatim}

\textbf{Algorithm:}

\begin{enumerate}
\tightlist
\item
  Input array size and elements
\item
  Initialize max and min with first element
\item
  For each remaining element:

  \begin{itemize}
  \tightlist
  \item
    If element \textgreater{} max, update max
  \item
    If element \textless{} min, update min
  \end{itemize}
\item
  Display max and min
\end{enumerate}

\textbf{Flowchart:}

\begin{verbatim}
flowchart LR
    A([Start]) {-{-} B[/Input n/]}
    B {-{-} C[/Input array elements/]}
    C {-{-} D["max = min = arr[0]"]}
    D {-{-} E[i = 1]}
    E {-{-} F\{i  n?\}}
    F {-{-}|Yes| G\{"arr[i]  max?"\}}
    G {-{-}|Yes| H["max = arr[i]"]}
    G {-{-}|No| I\{"arr[i]  min?"\}}
    H {-{-} I}
    I {-{-}|Yes| J["min = arr[i]"]}
    I {-{-}|No| K[i++]}
    J {-{-} K}
    K {-{-} F}
    F {-{-}|No| L[/Display max, min/]}
    L {-{-} M([End])}
\end{verbatim}

\end{solutionbox}
\begin{mnemonicbox}
``FILLS: First Initialize, Loop through, Look for
Small/large''

\end{mnemonicbox}

\end{document}
