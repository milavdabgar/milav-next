\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4351108 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{Python માં for loop નું કાર્ય સમજાવો.}

\begin{solutionbox}

For loop એ list, tuple અથવા string જેવા sequence ના દરેક item માટે code
block ને repeat કરે છે.

\textbf{સિન્ટેક્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & Syntax & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
મૂળભૂત & \texttt{for\ variable\ in\ sequence:} &
\texttt{for\ i\ in\ [1,2,3]:} \\
Range & \texttt{for\ i\ in\ range(n):} &
\texttt{for\ i\ in\ range(5):} \\
String & \texttt{for\ char\ in\ string:} &
\texttt{for\ c\ in\ "hello":} \\
\end{longtable}
}

\textbf{આકૃતિ:}

\begin{verbatim}
Start {-{-} Check if items left in sequence}
         |
         v
    Execute loop body
         |
         v
    Move to next item {-{-} Check if items left}
         |                      |
         v                      v
    Items left? {-{-}{-}{-}No{-}{-}{-}{-} End}
         |
        Yes
         |
         v
    Back to Execute loop body
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{પુનરાવર્તન}: Loop variable ને sequence માંથી દરેક value એક પછી એક
  મળે છે
\item
  \textbf{આપમેળે}: Python આપમેળે next item પર જવાનું handle કરે છે\\
\item
  \textbf{લવચીક}: Lists, strings, tuples, ranges સાથે કામ કરે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``દરેક Item માટે, Block Execute કરો''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{Python માં if-elif-else નું કાર્ય સમજાવો.}

\begin{solutionbox}

બહુ-માર્ગીય નિર્ણય માળખું જે sequence માં અનેક conditions ને ચકાસે છે.

\textbf{માળખાકીય ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Statement & હેતુ & Syntax \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
if & પ્રથમ શરત & \texttt{if\ condition1:} \\
elif & વૈકલ્પિક શરતો & \texttt{elif\ condition2:} \\
else & મૂળભૂત કેસ & \texttt{else:} \\
\end{longtable}
}

\textbf{પ્રવાહ આકૃતિ:}

\begin{verbatim}
    Start
      |
      v
 Check if condition
      |
   True/ {False}
     /    {}
    v      v
Execute   Check elif
if block   condition
    |         |
    v      True/ {False}
   End       /    {}
            v      v
       Execute   Check next elif
       elif      or else
       block        |
          |         v
          v      Execute
         End     else block
                    |
                    v
                   End
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ક્રમબદ્ધ}: ઉપરથી નીચે conditions ને ચકાસે છે
\item
  \textbf{વિશિષ્ટ}: માત્ર એક જ block execute થાય છે
\item
  \textbf{વૈકલ્પિક}: elif અને else વૈકલ્પિક છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``જો આ, અથવા જો તે, અથવા Default''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{Python પ્રોગ્રામનું માળખું સમજાવો.}

\begin{solutionbox}

Python પ્રોગ્રામમાં તાર્કિક ક્રમમાં વિશિષ્ટ ઘટકો સાથે વ્યવસ્થિત માળખું હોય છે.

\textbf{પ્રોગ્રામ માળખું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Comments & દસ્તાવેજીકરણ & \texttt{\#\ This\ is\ comment} \\
Import & બાહ્ય modules & \texttt{import\ math} \\
Constants & નિશ્ચિત વેલ્યુઝ & \texttt{PI\ =\ 3.14} \\
Functions & પુનઃઉપયોગી કોડ & \texttt{def\ function\_name():} \\
Classes & Objects નો blueprint & \texttt{class\ ClassName:} \\
Main code & પ્રોગ્રામ execution &
\texttt{if\ \_\_name\_\_\ ==\ "\_\_main\_\_":} \\
\end{longtable}
}

\textbf{પ્રોગ્રામ આર્કિટેક્ચર:}

\begin{verbatim}
    ┌─────────────────────┐
    │     Comments        │
    │   \# Documentation   │
    └─────────────────────┘
              │
              v
    ┌─────────────────────┐
    │    Import Section   │
    │   import modules    │
    └─────────────────────┘
              │
              v
    ┌─────────────────────┐
    │    Constants \&      │
    │     Variables       │
    └─────────────────────┘
              │
              v
    ┌─────────────────────┐
    │   Function          │
    │   Definitions       │
    └─────────────────────┘
              │
              v
    ┌─────────────────────┐
    │   Class             │
    │   Definitions       │
    └─────────────────────┘
              │
              v
    ┌─────────────────────┐
    │   Main Program      │
    │     Execution       │
    └─────────────────────┘
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ્યુલર}: દરેક વિભાગનો વિશિષ્ટ હેતુ હોય છે
\item
  \textbf{વાંચવા યોગ્ય}: સ્પષ્ટ સંગઠન સમજવામાં મદદ કરે છે
\item
  \textbf{જાળવણી યોગ્ય}: ફેરફાર અને debug કરવું સરળ
\item
  \textbf{માનક}: Python conventions ને અનુસરે છે
\end{itemize}

\textbf{સરળ ઉદાહરણ:}

\begin{verbatim}
\# Program to calculate area
import math

PI = 3.14159

def calculate\_area(radius):
    return PI * radius * radius

\# Main execution
radius = float(input("Enter radius: "))
area = calculate\_area(radius)
print(f"Area = \{area\}")
\end{verbatim}

\textbf{યાદી કૌશલ્ય:} ``Comment, Import, Constant, Function, Class,
Main''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-or-7-uxa97uxaa3}

\textbf{Python પ્રોગ્રામિંગ લેંગવેજની વિશેષતાઓ સમજાવો.}

\begin{solutionbox}

Python ની અનન્ય લાક્ષણિકતાઓ છે જે તેને beginners અને professionals માટે લોકપ્રિય
બનાવે છે.

\textbf{Python વિશેષતાઓ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન & લાભ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સરળ & સરળ syntax & ઝડપી શીખવા \\
Interpreted & કોઈ compilation નહીં & ઝડપી development \\
Object-Oriented & Classes અને objects & કોડની પુનઃઉપયોગીતા \\
Open Source & ઉપયોગ માટે મફત & કોઈ licensing ખર્ચ નહીં \\
Cross-Platform & દરેક જગ્યાએ run થાય છે & ઉચ્ચ portability \\
\end{longtable}
}

\textbf{વિશેષતા કેટેગરીઝ:}

\begin{verbatim}
         Python Features
              │
    ┌─────────┼─────────┐
    │         │         │
    v         v         v
Language   Technical  Community
Features   Features   Features
    │         │         │
    v         v         v
{- Simple   {-} Interpreted {-} Open Source}
{- Readable {-} Portable    {-} Large Library}
{- Dynamic  {-} Extensible  {-} Active Support}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{શિખાઉ-મિત્ર}: અંગ્રેજી ભાષા જેવું સરળ syntax
\item
  \textbf{બહુમુખી}: web, AI, data science, automation માટે ઉપયોગ
\item
  \textbf{સમૃદ્ધ લાયબ્રેરીઝ}: પ્રી-બિલ્ટ modules નો વિશાળ સંગ્રહ
\item
  \textbf{ડાયનેમિક ટાઇપિંગ}: variable types declare કરવાની જરૂર નથી
\item
  \textbf{ઇન્ટરેક્ટિવ}: interpreter માં લાઇન બાય લાઇન કોડ ટેસ્ટ કરી શકાય
\item
  \textbf{હાઇ-લેવલ}: memory management આપમેળે handle કરે છે
\end{itemize}

\textbf{કોડ ઉદાહરણ:}

\begin{verbatim}
\# Simple Python syntax
name = "Python"
print(f"Hello, \{name\}!")
\end{verbatim}

\textbf{યાદી કૌશલ્ય:} ``સરળ, Interpreted, Object-Oriented, Open,
Cross-platform''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{સ્ટ્રિંગ પર થતાં કોઈ 3 ઓપરેશન સમજાવો.}

\begin{solutionbox}

String operations વિવિધ રીતે text data ને manipulate અને process કરે છે.

\textbf{સ્ટ્રિંગ ઓપરેશન્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ઓપરેશન & Method & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
જોડવું & \texttt{+} & \texttt{"Hello"\ +\ "World"} &
\texttt{"HelloWorld"} \\
લંબાઈ & \texttt{len()} & \texttt{len("Python")} & \texttt{6} \\
મોટા અક્ષર & \texttt{.upper()} & \texttt{"hello".upper()} &
\texttt{"HELLO"} \\
\end{longtable}
}

\textbf{ઓપરેશન ઉદાહરણો:}

\begin{verbatim}
text = "Python"
\# 1. જોડવું
result1 = text + " Programming"
\# 2. લંબાઈ શોધવી
result2 = len(text)
\# 3. મોટા અક્ષરમાં કન્વર્ટ કરવું
result3 = text.upper()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{જોડવું}: બે અથવા વધુ strings ને સાથે જોડે છે
\item
  \textbf{લંબાઈ}: string માં કુલ characters ગણે છે
\item
  \textbf{કેસ કન્વર્ઝન}: અક્ષરોના કેસ બદલે છે (upper/lower)
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``જોડો, ગણો, કન્વર્ટ કરો''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{તાપમાનને ફેરનહાઇટથી સેલ્સિયસ એકમમાં (C=(F-32)/1.8 સમીકરણથી) પરિવર્તિત
કરવા માટેનો Python પ્રોગ્રામ વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ user input સાથે ગાણિતિક formula વાપરીને temperature convert કરે છે.

\textbf{એલ્ગોરિધમ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & કોડ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Input લો & \texttt{fahrenheit\ =\ float(input())} \\
2 & Formula લાગુ કરો &
\texttt{celsius\ =\ (fahrenheit\ -\ 32)\ /\ 1.8} \\
3 & પરિણામ દર્શાવો & \texttt{print(f"Celsius:\ \{celsius\}")} \\
\end{longtable}
}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Temperature conversion program
fahrenheit = float(input("Enter temperature in Fahrenheit: "))
celsius = (fahrenheit {-} 32) / 1.8
print(f"Temperature in Celsius: \{celsius:.2f\}")
\end{verbatim}

\textbf{ટેસ્ટ કેસેસ:}

\begin{itemize}
\item
  Input: 32^\circF \rightarrow Output: 0.00^\circC
\item
  Input: 100^\circF \rightarrow Output: 37.78^\circC
\item
  \textbf{યુઝર ઇનપુટ}: યુઝર પાસેથી Fahrenheit temperature લે છે
\item
  \textbf{ફોર્મ્યુલા એપ્લિકેશન}: આપેલ conversion equation વાપરે છે
\item
  \textbf{ફોર્મેટેડ આઉટપુટ}: decimal places સાથે પરિણામ બતાવે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Input, Calculate, Output''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{Python માં list ડેટા ટાઇપ વિસ્તૃત રીતે સમજાવો.}

\begin{solutionbox}

List એ ordered, mutable collection છે જે single variable માં multiple items
store કરે છે.

\textbf{લિસ્ટ લાક્ષણિકતાઓ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રોપર્ટી & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
ક્રમબદ્ધ & Items નો position હોય છે & \texttt{[1,\ 2,\ 3]} \\
પરિવર્તનશીલ & બદલાઈ શકાય છે & \texttt{list[0]\ =\ 10} \\
ઇન્ડેક્સ્ડ & Position દ્વારા access & \texttt{list[0]} \\
મિશ્ર પ્રકારો & વિવિધ data types & \texttt{[1,\ "hello",\ 3.14]} \\
\end{longtable}
}

\textbf{લિસ્ટ ઓપરેશન્સ આકૃતિ:}

\begin{verbatim}
    List: [10, 20, 30, 40]
           |   |   |   |
    Index: 0   1   2   3
        
    Operations:
    ┌─────────────┐  ┌─────────────┐
    │   Access    │  │   Modify    │
    │  list[0]    │  │ list[0]=50  │
    └─────────────┘  └─────────────┘
           │                │
           v                v
         "10"          [50, 20, 30, 40]
\end{verbatim}

\textbf{સામાન્ય લિસ્ટ મેથડ્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
append() & અંતે item ઉમેરો & \texttt{list.append(5)} \\
insert() & position પર ઉમેરો & \texttt{list.insert(1,\ 15)} \\
remove() & item ડિલીટ કરો & \texttt{list.remove(20)} \\
pop() & છેલ્લું item દૂર કરો & \texttt{list.pop()} \\
len() & લંબાઈ મેળવો & \texttt{len(list)} \\
\end{longtable}
}

\textbf{ઉદાહરણ કોડ:}

\begin{verbatim}
\# Creating and using lists
numbers = [1, 2, 3, 4, 5]
numbers.append(6)        \# અંતે 6 ઉમેરો
numbers.insert(0, 0)     \# શરૂઆતમાં 0 ઉમેરો
print(numbers[2])        \# 3જું element access કરો
numbers.remove(3)        \# value 3 દૂર કરો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ડાયનેમિક સાઇઝ}: execution દરમ્યાન વધી અથવા ઘટી શકે છે
\item
  \textbf{ઝીરો ઇન્ડેક્સિંગ}: પ્રથમ element index 0 પર
\item
  \textbf{સ્લાઇસિંગ}: [start:end] વાપરીને ભાગો extract કરી શકાય
\item
  \textbf{નેસ્ટેડ લિસ્ટ્સ}: અન્ય lists સમાવી શકે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``ક્રમબદ્ધ, પરિવર્તનશીલ, ઇન્ડેક્સ્ડ, મિશ્ર''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-or-3-uxa97uxaa3}

\textbf{Python માં સ્ટ્રિંગ ફોર્મેટિંગ સમજાવો.}

\begin{solutionbox}

String formatting એ templates માં values insert કરીને formatted strings
બનાવે છે.

\textbf{ફોર્મેટિંગ મેથડ્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & Syntax & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
f-strings & \texttt{f"text\ \{variable\}"} &
\texttt{f"Hello\ \{name\}"} \\
format() & \texttt{"text\ \{\}".format(value)} &
\texttt{"Age:\ \{\}".format(25)} \\
\% operator & \texttt{"text\ \%s"\ \%\ value} &
\texttt{"Name:\ \%s"\ \%\ "John"} \\
\end{longtable}
}

\textbf{ઉપયોગ ઉદાહરણ:}

\begin{verbatim}
name = "Alice"
age = 25
\# f{-string formatting}
message = f"Hello \{name\}, you are \{age\} years old"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{પ્લેસહોલ્ડર}: \{\} માર્ક કરે છે કે values ક્યાં જાય છે
\item
  \textbf{ડાયનેમિક}: Runtime પર values insert થાય છે
\item
  \textbf{વાંચવા યોગ્ય}: Concatenation કરતાં કોડ સાફ બનાવે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Format, Insert, Display''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-or-4-uxa97uxaa3}

\textbf{સ્કેન કરેલ નંબર એકી સંખ્યા છે કે બેકી સંખ્યા છે તે ઓળખી અને યોગ્ય મેસેજ પ્રિન્ટ
કરતો Python પ્રોગ્રામ વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ number 2 થી divisible છે કે નહીં તે ચકાસીને even અથવા odd નક્કી કરે છે.

\textbf{લૉજિક ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
શરત & પરિણામ & મેસેજ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
number \% 2 == 0 & Even & ``Number is even'' \\
number \% 2 != 0 & Odd & ``Number is odd'' \\
\end{longtable}
}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Even/Odd checker program
number = int(input("Enter a number: "))
if number \% 2 == 0:
    print(f"\{number\} is even")
else:
    print(f"\{number\} is odd")
\end{verbatim}

\textbf{ટેસ્ટ કેસેસ:}

\begin{itemize}
\item
  Input: 4 \rightarrow Output: ``4 is even''
\item
  Input: 7 \rightarrow Output: ``7 is odd''
\item
  \textbf{મોડ્યુલો ઓપરેટર}: \% division પછીનો remainder આપે છે
\item
  \textbf{કંડિશનલ લૉજિક}: if-else પરિણામ નક્કી કરે છે
\item
  \textbf{યુઝર ફીડબેક}: પરિણામ વિશે સ્પષ્ટ મેસેજ
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Input, Check Remainder, Display Result''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-or-7-uxa97uxaa3}

\textbf{Python માં Set ડેટા ટાઇપ વિસ્તૃત રીતે સમજાવો.}

\begin{solutionbox}

Set એ unordered collection છે જેમાં unique items હોય છે અને duplicate values
નહીં.

\textbf{સેટ લાક્ષણિકતાઓ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રોપર્ટી & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
અક્રમ & કોઈ નિશ્ચિત position નથી & \texttt{\{1,\ 3,\ 2\}} \\
અનન્ય & કોઈ duplicates નથી & \texttt{\{1,\ 2,\ 3\}} \\
પરિવર્તનશીલ & ફેરફાર કરી શકાય & \texttt{set.add(4)} \\
પુનરાવર્તન યોગ્ય & Loop કરી શકાય & \texttt{for\ item\ in\ set:} \\
\end{longtable}
}

\textbf{સેટ ઓપરેશન્સ આકૃતિ:}

\begin{verbatim}
    Set A: \{1, 2, 3\    Set B: \{3, 4, 5\}}
         {                    /}
          {                  /}
           v                v
    ┌─────────────────────────────┐
    │     Set Operations          │
    ├─────────────────────────────┤
    │ Union: \{1, 2, 3, 4, 5\  b   │}
    │ Intersection: \{3\           │}
    │ Difference: \{1, 2\          │}
    │ Symmetric Diff: \{1,2,4,5\   │}
    └─────────────────────────────┘
\end{verbatim}

\textbf{સેટ મેથડ્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Method & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
add() & single item ઉમેરો & \texttt{set.add(6)} \\
update() & multiple items ઉમેરો & \texttt{set.update([7,\ 8])} \\
remove() & item ડિલીટ કરો & \texttt{set.remove(3)} \\
union() & sets જોડો & \texttt{set1.union(set2)} \\
intersection() & સામાન્ય items & \texttt{set1.intersection(set2)} \\
\end{longtable}
}

\textbf{ઉદાહરણ કોડ:}

\begin{verbatim}
\# Creating and using sets
fruits = \{"apple", "banana", "orange"\}
fruits.add("mango")              \# single item ઉમેરો
fruits.update(["grape", "kiwi"]) \# multiple ઉમેરો
fruits.remove("banana")          \# item દૂર કરો
print(len(fruits))               \# items ગણો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{આપમેળે ડુપ્લિકેશન હટાવવું}: Duplicate values આપમેળે દૂર કરે છે
\item
  \textbf{ઝડપી મેમ્બરશિપ}: Item exists છે કે નહીં ઝડપથી ચકાસી શકાય
\item
  \textbf{ગાણિતિક ઓપરેશન્સ}: Union, intersection, difference
\item
  \textbf{કોઈ ઇન્ડેક્સિંગ નહીં}: Position દ્વારા items access કરી શકાતાં નથી
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``અનન્ય, અક્રમ, પરિવર્તનશીલ, ગાણિતિક''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{math મૉડ્યુલની કોઈ પણ 3 મેથડ સમજાવો.}

\begin{solutionbox}

Math module જટિલ ગણતરીઓ માટે ગાણિતિક functions પ્રદાન કરે છે.

\textbf{મેથ મેથડ્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Method & હેતુ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
math.sqrt() & વર્ગમૂળ & \texttt{math.sqrt(16)} & \texttt{4.0} \\
math.pow() & પાવર ગણતરી & \texttt{math.pow(2,\ 3)} & \texttt{8.0} \\
math.ceil() & ઉપર રાઉન્ડ & \texttt{math.ceil(4.3)} & \texttt{5} \\
\end{longtable}
}

\textbf{ઉપયોગ ઉદાહરણ:}

\begin{verbatim}
import math
number = 16
result1 = math.sqrt(number)  \# વર્ગમૂળ
result2 = math.pow(2, 4)     \# 2 ની પાવર 4
result3 = math.ceil(7.2)     \# 8 સુધી રાઉન્ડ અપ
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ચોકસાઈ}: Basic operators કરતાં વધુ accurate
\item
  \textbf{ઇમ્પોર્ટ જરૂરી}: પહેલા math module import કરવું પડે
\item
  \textbf{રિટર્ન વેલ્યુઝ}: સામાન્ય રીતે float numbers return કરે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``વર્ગમૂળ, પાવર, સીલિંગ''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{for loop નો ઉપયોગ કરીને લિસ્ટમાં આવેલ તમામ ઘટકોનો સરવાળો શોધવા માટેનો
Python પ્રોગ્રામ વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ list દ્વારા iterate કરે છે અને બધા elements નો sum accumulate કરે છે.

\textbf{એલ્ગોરિધમ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & કોડ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Sum initialize કરો & \texttt{total\ =\ 0} \\
2 & List માં loop કરો & \texttt{for\ element\ in\ list:} \\
3 & Sum માં ઉમેરો & \texttt{total\ +=\ element} \\
4 & પરિણામ દર્શાવો & \texttt{print(total)} \\
\end{longtable}
}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Sum of list elements
numbers = [10, 20, 30, 40, 50]
total = 0
for element in numbers:
    total += element
print(f"Sum of all elements: \{total\}")
\end{verbatim}

\textbf{ટેસ્ટ કેસ:}

\begin{itemize}
\item
  Input: [1, 2, 3, 4, 5] \rightarrow Output: 15
\item
  \textbf{એક્યુમ્યુલેટર}: Variable running total store કરે છે
\item
  \textbf{પુનરાવર્તન}: Loop દરેક element ની એકવાર મુલાકાત લે છે
\item
  \textbf{ઉમેરો}: દરેક element ને running sum માં ઉમેરે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Initialize, Loop, Add, Display''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{બે list ની લંબાઈ સમાન છે કે નહીં તે ચકાસવા, અને જો હોય તો તેમને ભેગા કરીને
તેમાંથી એક dictionary બનાવવાનો Python પ્રોગ્રામ વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ list lengths ની સરખામણી કરે છે અને જો તે match કરે તો dictionary બનાવે
છે.

\textbf{લૉજિક ફ્લો ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & શરત & ક્રિયા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & લંબાઈ ચકાસો & \texttt{len(list1)\ ==\ len(list2)} \\
2 & જો સમાન & Merge અને dictionary બનાવો \\
3 & જો અસમાન & Error message દર્શાવો \\
\end{longtable}
}

\textbf{પ્રક્રિયા આકૃતિ:}

\begin{verbatim}
    List1: [a, b, c]     List2: [1, 2, 3]
       |                     |
       v                     v
     len(List1) == len(List2) ?
             |
        Yes / { No}
           /   {}
          v     v
    Create Dict  Error
    \{a:1, b:2,   Message
     c:3\}
\end{verbatim}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Merge lists into dictionary
list1 = [{name}, {age}, {city}]
list2 = [{John}, 25, {Mumbai}]

if len(list1) == len(list2):
    \# Create dictionary using zip
    result\_dict = dict(zip(list1, list2))
    print("Dictionary created:", result\_dict)
else:
    print("Lists have different lengths, cannot merge")
\end{verbatim}

\textbf{અપેક્ષિત આઉટપુટ:}

\begin{verbatim}
Dictionary created: {'name': 'John', 'age': 25, 'city': 'Mumbai'}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{લંબાઈ સરખામણી}: લિસ્ટ્સ યોગ્ય રીતે pair કરી શકાય છે તેની ખાતરી કરે છે
\item
  \textbf{zip() ફંક્શન}: બંને lists ના elements ને pair કરે છે
\item
  \textbf{dict() કન્સ્ટ્રક્ટર}: Paired elements માંથી dictionary બનાવે છે
\item
  \textbf{એરર હેન્ડલિંગ}: ખોટા pairing ને અટકાવે છે
\end{itemize}

\textbf{વૈકલ્પિક મેથડ:}

\begin{verbatim}
\# Manual dictionary creation
result\_dict = \{\}
for i in range(len(list1)):
    result\_dict[list1[i]] = list2[i]
\end{verbatim}

\textbf{યાદી કૌશલ્ય:} ``લંબાઈ ચકાસો, Zip કરો, Dictionary બનાવો''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-or-3-uxa97uxaa3}

\textbf{statistics મૉડ્યુલની કોઈ પણ 3 મેથડ સમજાવો.}

\begin{solutionbox}

Statistics module numeric data પર statistical calculations માટે functions
પ્રદાન કરે છે.

\textbf{સ્ટેટિસ્ટિક્સ મેથડ્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Method & હેતુ & ઉદાહરણ & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
statistics.mean() & સરેરાશ value & \texttt{mean([1,2,3,4,5])} &
\texttt{3.0} \\
statistics.median() & મધ્ય value & \texttt{median([1,2,3,4,5])} &
\texttt{3} \\
statistics.mode() & સૌથી વધુ વારંવાર & \texttt{mode([1,1,2,3])} &
\texttt{1} \\
\end{longtable}
}

\textbf{ઉપયોગ ઉદાહરણ:}

\begin{verbatim}
import statistics
data = [10, 20, 30, 40, 50]
avg = statistics.mean(data)      \# સરેરાશ કેલ્ક્યુલેટ કરો
mid = statistics.median(data)    \# મધ્ય value શોધો
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ડેટા એનાલિસિસ}: ડેટા patterns સમજવામાં મદદ કરે છે
\item
  \textbf{બિલ્ટ-ઇન ફંક્શન્સ}: જટિલ formulas લખવાની જરૂર નથી
\item
  \textbf{ચોક્કસ પરિણામો}: Edge cases ને યોગ્ય રીતે handle કરે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Mean, Median, Mode''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-or-7-uxa97uxaa3}

\textbf{આપેલ સ્ટ્રિંગમાં કોઈ અક્ષર કેટલી વાર આવે છે તે ગણવા માટેની dictionary
બનાવવાનો Python પ્રોગ્રામ વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ dictionary બનાવે છે જ્યાં keys અક્ષરો છે અને values તેમની counts છે.

\textbf{અક્ષર ગણતરી એલ્ગોરિધમ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3889}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2778}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પગલું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ક્રિયા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
કોડ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Dictionary initialize કરો & \texttt{char\_count\ =\ \{\}} \\
2 & String માં loop કરો & \texttt{for\ char\ in\ string:} \\
3 & Occurrences ગણો &
\texttt{char\_count[char]\ =\ char\_count.get(char,\ 0)\ +\ 1} \\
4 & પરિણામો દર્શાવો & \texttt{print(char\_count)} \\
\end{longtable}
}

\textbf{ગણતરી પ્રક્રિયા:}

\begin{verbatim}
    String: "hello"
         |
         v
    Loop through each character
         |
    ┌────┴────┬────┬────┬────┬────┐
    │    h    │ e  │ l  │ l  │ o  │
    └────┬────┴────┴────┴────┴────┘
         v
    Dictionary: \{{h:1, e:1, l:2, o:1\}}
\end{verbatim}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Character frequency counter
text = input("Enter a string: ")
char\_count = \{\}

for char in text:
    if char in char\_count:
        char\_count[char] += 1
    else:
        char\_count[char] = 1

print("Character frequencies:")
for char, count in char\_count.items():
    print(f"{}\{char\}{: }\{count\}")
\end{verbatim}

\textbf{વૈકલ્પિક મેથડ (વધુ Pythonic):}

\begin{verbatim}
\# Using get() method
text = "programming"
char\_count = \{\}

for char in text:
    char\_count[char] = char\_count.get(char, 0) + 1

print(char\_count)
\end{verbatim}

\textbf{ઉદાહરણ આઉટપુટ:}

\begin{verbatim}
Input: "hello"
Output: {'h': 1, 'e': 1, 'l': 2, 'o': 1}
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ડિક્શનરી કીઝ}: દરેક અનન્ય અક્ષર key બને છે
\item
  \textbf{ડિક્શનરી વેલ્યુઝ}: અક્ષરની occurrences ની count
\item
  \textbf{get() મેથડ}: Key exist નથી તો 0 return કરે છે, errors ટાળે છે
\item
  \textbf{પુનરાવર્તન}: String ના દરેક અક્ષરને એકવાર process કરે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Loop, Check, Count, Store''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{Python ક્લાસ અને ઓબ્જેક્ટ્સનું કાર્ય ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}

Class એ objects બનાવવા માટેનો blueprint છે. Objects એ classes ના instances
છે.

\textbf{ક્લાસ-ઓબ્જેક્ટ સંબંધ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કન્સેપ્ટ & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Class & Template/Blueprint & \texttt{class\ Car:} \\
Object & Class નો instance & \texttt{my\_car\ =\ Car()} \\
Attributes & Class માં ડેટા & \texttt{self.color\ =\ "red"} \\
Methods & Class માં functions & \texttt{def\ start(self):} \\
\end{longtable}
}

\textbf{ક્લાસ માળખું:}

\begin{verbatim}
         Class: Car
    ┌─────────────────────┐
    │   Attributes:       │
    │   {- color           │}
    │   {- model           │}
    │                     │
    │   Methods:          │
    │   {- start()         │}
    │   {- stop()          │}
    └─────────────────────┘
              │
              │ inherits
              v
    Object: my\_car = Car()
\end{verbatim}

\textbf{ઉદાહરણ કોડ:}

\begin{verbatim}
class Student:
    def \_\_init\_\_(self, name, age):
        self.name = name  \# Attribute
        self.age = age    \# Attribute
    
    def display(self):    \# Method
        print(f"Name: \{self.name\}, Age: \{self.age\}")

\# Creating objects
student1 = Student("Alice", 20)
student1.display()
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{એન્કેપ્સુલેશન}: સંબંધિત data અને functions ને સાથે group કરે છે
\item
  \textbf{પુનઃઉપયોગીતા}: એક class અનેક objects બનાવી શકે છે
\item
  \textbf{સંગઠન}: બહેતર code structure અને maintenance
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``ક્લાસ Blueprint, ઓબ્જેક્ટ Instance''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{લિસ્ટમાં આવેલી તમામ એકી સંખ્યાઓ પ્રિન્ટ કરવા માટેનો Python પ્રોગ્રામ
વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ list elements ને filter કરે છે અને માત્ર odd numbers દર્શાવે છે.

\textbf{એકી સંખ્યા ચકાસણી ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
સંખ્યા & number \% 2 & પરિણામ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & 1 & એકી \\
2 & 0 & બેકી \\
3 & 1 & એકી \\
4 & 0 & બેકી \\
\end{longtable}
}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Print odd numbers from list
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print("Odd numbers in the list:")
for number in numbers:
    if number \% 2 != 0:
        print(number, end=" ")
\end{verbatim}

\textbf{વૈકલ્પિક મેથડ્સ:}

\begin{verbatim}
\# Method 2: List comprehension
odd\_numbers = [num for num in numbers if num \% 2 != 0]
print(odd\_numbers)

\# Method 3: Using filter
odd\_numbers = list(filter(lambda x: x \% 2 != 0, numbers))
print(odd\_numbers)
\end{verbatim}

\textbf{અપેક્ષિત આઉટપુટ:}

\begin{verbatim}
Odd numbers in the list:
1 3 5 7 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ્યુલો ઓપરેશન}: \% operator remainder શોધે છે
\item
  \textbf{કંડિશન ચેક}: જો remainder 0 નથી તો number odd છે
\item
  \textbf{લૂપ પુનરાવર્તન}: List ની દરેક number ચકાસે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Loop, Check Remainder, Print Odd''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{Python માં યુઝર ડિફાઇન્ડ ફંક્શન્સનું કાર્ય સમજાવો.}

\begin{solutionbox}

User-defined functions એ programmers દ્વારા બનાવેલા custom functions છે જે
વિશિષ્ટ કાર્યો કરે છે.

\textbf{ફંક્શન ઘટકો ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & હેતુ & Syntax \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
def કીવર્ડ & Function declaration & \texttt{def\ function\_name():} \\
Parameters & Input values & \texttt{def\ func(param1,\ param2):} \\
Body & Function code & Indented statements \\
return & Output value & \texttt{return\ value} \\
\end{longtable}
}

\textbf{ફંક્શન માળખું:}

\begin{verbatim}
    def function\_name(parameters):
         │        │        │
         │        │        └─ Input values
         │        └─ Function identifier
         └─ Keyword to define function
         
    Function Body (indented)
         │
         v
    ┌─────────────────────┐
    │  Local variables    │
    │  Processing logic   │
    │  Calculations       │
    └─────────────────────┘
         │
         v
    return result (optional)
\end{verbatim}

\textbf{ફંક્શન પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પ્રકાર & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
કોઈ parameters નહીં & કોઈ input લેતું નથી & \texttt{def\ greet():} \\
Parameters સાથે & Input લે છે & \texttt{def\ add(a,\ b):} \\
Return value & Output આપે છે & \texttt{return\ a\ +\ b} \\
કોઈ return નહીં & Action કરે છે & \texttt{print("Hello")} \\
\end{longtable}
}

\textbf{ઉદાહરણ ફંક્શન્સ:}

\begin{verbatim}
\# Function with no parameters
def greet():
    print("Hello, World!")

\# Function with parameters and return value
def calculate\_area(length, width):
    area = length * width
    return area

\# Function with default parameters
def introduce(name, age=18):
    print(f"My name is \{name\} and I am \{age\} years old")

\# Using functions
greet()
result = calculate\_area(5, 3)
print(f"Area: \{result\}")
introduce("Alice", 25)
introduce("Bob")  \# Uses default age
\end{verbatim}

\textbf{ફંક્શન લાભો:}

\begin{itemize}
\tightlist
\item
  \textbf{પુનઃઉપયોગીતા}: એકવાર લખો, અનેકવાર વાપરો
\item
  \textbf{મોડ્યુલરિટી}: જટિલ સમસ્યાઓને નાના ભાગોમાં તોડો
\item
  \textbf{જાળવણીયોગ્યતા}: Update અને debug કરવું સરળ
\item
  \textbf{વાંચવાયોગ્યતા}: કોડને વધુ organized અને સમજવાયોગ્ય બનાવે છે
\item
  \textbf{ટેસ્ટિંગ}: અલગ અલગ functions ને અલગથી test કરી શકાય
\end{itemize}

\textbf{વેરિયેબલ સ્કોપ:}

\begin{itemize}
\tightlist
\item
  \textbf{લોકલ વેરિયેબલ્સ}: માત્ર function અંદર exist કરે છે
\item
  \textbf{ગ્લોબલ વેરિયેબલ્સ}: આખા program માં accessible
\item
  \textbf{પેરામીટર્સ}: Local variables તરીકે કામ કરે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Define, Parameters, Body, Return''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-or-3-uxa97uxaa3}

\textbf{Python માં કન્સ્ટ્રક્ટરનું કાર્ય સમજાવો.}

\begin{solutionbox}

Constructor એ special method છે જે objects બનાવવામાં આવે ત્યારે તેમને initialize
કરે છે.

\textbf{કન્સ્ટ્રક્ટર વિગતો ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પાસું & વર્ણન & Syntax \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Method name & હંમેશા \texttt{\_\_init\_\_} &
\texttt{def\ \_\_init\_\_(self):} \\
હેતુ & Object initialize કરવું & Initial values set કરવા \\
આપમેળે કૉલ & Object creation દરમ્યાન કૉલ થાય & \texttt{obj\ =\ Class()} \\
Parameters & Arguments લઈ શકે છે &
\texttt{def\ \_\_init\_\_(self,\ param):} \\
\end{longtable}
}

\textbf{કન્સ્ટ્રક્ટર ઉદાહરણ:}

\begin{verbatim}
class Student:
    def \_\_init\_\_(self, name, age):
        self.name = name
        self.age = age
        print("Student object created")

\# Object creation automatically calls constructor
student1 = Student("Alice", 20)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{આપમેળે એક્ઝિક્યુશન}: Object બનાવાતી વખતે તરત જ run થાય છે
\item
  \textbf{ઇનિશિયલાઇઝેશન}: Object ની શરૂઆતી state set કરે છે
\item
  \textbf{self પેરામીટર}: હાલનો object જે બનાવાઈ રહ્યો છે તેનો reference
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Initialize, Automatic, Self''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-or-4-uxa97uxaa3}

\textbf{min ફંક્શનનો ઉપયોગ કર્યા વિના લિસ્ટમાંથી સૌથી નાનો નંબર શોધવા માટેનો
Python પ્રોગ્રામ વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ manually બધા elements ની સરખામણી કરીને સૌથી નાની value શોધે છે.

\textbf{મિનિમમ શોધવાનો એલ્ગોરિધમ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પગલું & ક્રિયા & કોડ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & પહેલું smallest માનો & \texttt{smallest\ =\ list[0]} \\
2 & બીજાઓ સાથે સરખાવો & \texttt{for\ num\ in\ list[1:]:} \\
3 & નાનું મળે તો અપડેટ કરો & \texttt{if\ num\ \textless{}\ smallest:} \\
4 & પરિણામ દર્શાવો & \texttt{print(smallest)} \\
\end{longtable}
}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Find smallest number without min()
numbers = [45, 23, 67, 12, 89, 5, 34]

smallest = numbers[0]  \# પ્રથમને smallest માનો

for i in range(1, len(numbers)):
    if numbers[i] {} smallest:
        smallest = numbers[i]

print(f"Smallest number: \{smallest\}")
\end{verbatim}

\textbf{વૈકલ્પિક મેથડ:}

\begin{verbatim}
\# Using for loop with list elements
numbers = [45, 23, 67, 12, 89, 5, 34]
smallest = numbers[0]

for num in numbers[1:]:
    if num {} smallest:
        smallest = num

print(f"Smallest number: \{smallest\}")
\end{verbatim}

\textbf{અપેક્ષિત આઉટપુટ:}

\begin{verbatim}
Smallest number: 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કમ્પેરિઝન લૉજિક}: દરેક element ને current smallest સાથે compare કરો
\item
  \textbf{અપડેટ સ્ટ્રેટેજી}: નાનો number મળે ત્યારે smallest replace કરો
\item
  \textbf{લિનિયર સર્ચ}: બધા elements ને એકવાર ચકાસો
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``માનો, સરખાવો, અપડેટ કરો, દર્શાવો''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-or-7-uxa97uxaa3}

\textbf{Python માં યુઝર ડિફાઇન્ડ મોડ્યુલ્સનું કાર્ય સમજાવો.}

\begin{solutionbox}

User-defined modules એ custom Python files છે જેમાં functions, classes અને
variables હોય છે જે અન્ય programs માં import અને use કરી શકાય છે.

\textbf{મોડ્યુલ ઘટકો ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & હેતુ & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Functions & પુનઃઉપયોગી કોડ blocks & \texttt{def\ calculate\_area():} \\
Classes & Object blueprints & \texttt{class\ Shape:} \\
Variables & સ્પેર્ડ ડેટા & \texttt{PI\ =\ 3.14159} \\
Constants & નિશ્ચિત વેલ્યુઝ & \texttt{MAX\_SIZE\ =\ 100} \\
\end{longtable}
}

\textbf{મોડ્યુલ બનાવવાની પ્રક્રિયા:}

\begin{verbatim}
    Step 1: .py file બનાવો
         |
         v
    Step 2: Functions/classes લખો
         |
         v
    Step 3: File save કરો
         |
         v
    Step 4: અન્ય programs માં import કરો
         |
         v
    Step 5: Module functions વાપરો
\end{verbatim}

\textbf{ઉદાહરણ મોડ્યુલ બનાવવું:}

\textbf{ફાઇલ: math\_operations.py}

\begin{verbatim}
\# User{-defined module}
PI = 3.14159

def calculate\_circle\_area(radius):
    return PI * radius * radius

def calculate\_rectangle\_area(length, width):
    return length * width

class Calculator:
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a {-} b
\end{verbatim}

\textbf{મોડ્યુલ વાપરવું:}

\textbf{ઇમ્પોર્ટ મેથડ્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2857}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3810}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
મેથડ
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Syntax
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉપયોગ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સંપૂર્ણ module import & \texttt{import\ math\_operations} &
\texttt{math\_operations.calculate\_circle\_area(5)} \\
વિશિષ્ટ function import &
\texttt{from\ math\_operations\ import\ calculate\_circle\_area} &
\texttt{calculate\_circle\_area(5)} \\
Alias સાથે import & \texttt{import\ math\_operations\ as\ math\_ops} &
\texttt{math\_ops.PI} \\
બધું import & \texttt{from\ math\_operations\ import\ *} &
\texttt{calculate\_circle\_area(5)} \\
\end{longtable}
}

\textbf{મુખ્ય પ્રોગ્રામ:}

\begin{verbatim}
\# main.py {- Module વાપરવું}
import math\_operations

\# Module functions વાપરવા
radius = 5
area = math\_operations.calculate\_circle\_area(radius)
print(f"Circle area: \{area\}")

\# Module variables વાપરવા
print(f"PI value: \{math\_operations.PI\}")

\# Module classes વાપરવા
calc = math\_operations.Calculator()
result = calc.add(10, 20)
print(f"Addition result: \{result\}")
\end{verbatim}

\textbf{મોડ્યુલ લાભો:}

\begin{itemize}
\tightlist
\item
  \textbf{કોડ પુનઃઉપયોગીતા}: એકવાર લખો, અનેક programs માં વાપરો
\item
  \textbf{સંગઠન}: સંબંધિત functions એકસાથે રાખો
\item
  \textbf{નેમસ્પેસ}: Naming conflicts ટાળો
\item
  \textbf{જાળવણીયોગ્યતા}: Update અને debug કરવું સરળ
\item
  \textbf{સહયોગ}: અન્ય developers સાથે modules share કરો
\end{itemize}

\textbf{મોડ્યુલ સર્ચ પાથ:}

\begin{enumerate}
\tightlist
\item
  વર્તમાન directory
\item
  PYTHONPATH environment variable
\item
  Standard library directories
\item
  Site-packages directory
\end{enumerate}

\textbf{બેસ્ટ પ્રેક્ટિસિસ:}

\begin{itemize}
\tightlist
\item
  વર્ણનાત્મક module names વાપરો
\item
  Documentation માટે docstrings include કરો
\item
  સંબંધિત functionality એકસાથે રાખો
\item
  Circular imports ટાળો
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``ફાઇલ બનાવો, ફંક્શન્સ ડિફાઇન કરો, ઇમ્પોર્ટ કરો, વાપરો''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{ઉદાહરણ સાથે Python માં સિંગલ ઇન્હેરિટન્સ સમજાવો.}

\begin{solutionbox}

Single inheritance એ જ્યારે એક class બરાબર એક parent class પાસેથી
properties અને methods inherit કરે છે.

\textbf{ઇન્હેરિટન્સ માળખું ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
ઘટક & ભૂમિકા & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Parent Class & Base/Super class & \texttt{class\ Animal:} \\
Child Class & Derived/Sub class & \texttt{class\ Dog(Animal):} \\
Inheritance & \texttt{class\ Child(Parent):} &
\texttt{class\ Dog(Animal):} \\
\end{longtable}
}

\textbf{ઇન્હેરિટન્સ આકૃતિ:}

\begin{verbatim}
    Parent Class: Animal
    ┌─────────────────────┐
    │   Attributes:       │
    │   {- name            │}
    │   {- age             │}
    │                     │
    │   Methods:          │
    │   {- eat()           │}
    │   {- sleep()         │}
    └─────────────────────┘
              │
              │ inherits
              v
    Child Class: Dog
    ┌─────────────────────┐
    │ Inherited:          │
    │   {- name, age       │}
    │   {- eat(), sleep()  │}
    │                     │
    │ Own Methods:        │
    │   {- bark()          │}
    └─────────────────────┘
\end{verbatim}

\textbf{ઉદાહરણ કોડ:}

\begin{verbatim}
\# Parent class
class Animal:
    def \_\_init\_\_(self, name):
        self.name = name
    
    def eat(self):
        print(f"\{self.name\} is eating")

\# Child class inheriting from Animal
class Dog(Animal):
    def bark(self):
        print(f"\{self.name\} is barking")

\# Using inheritance
my\_dog = Dog("Buddy")
my\_dog.eat()    \# Inherited method
my\_dog.bark()   \# Own method
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{કોડ પુનઃઉપયોગ}: Child class ને parent ની functionality આપમેળે મળે છે
\item
  \textbf{વિસ્તરણ}: Child નવા methods અને attributes ઉમેરી શકે છે
\item
  \textbf{Is-a સંબંધ}: Dog is-a Animal
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``એક Parent, એક Child''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{Python માં એબ્સ્ટ્રેક્શનની વિભાવના અને તેના લાભો સમજાવો.}

\begin{solutionbox}

Abstraction જટિલ implementation details છુપાવે છે અને user ને માત્ર આવશ્યક
features બતાવે છે.

\textbf{એબ્સ્ટ્રેક્શન કન્સેપ્ટ્સ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
કન્સેપ્ટ & વર્ણન & ઉદાહરણ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Abstract Class & Instantiate કરી શકાતું નથી &
\texttt{class\ Shape(ABC):} \\
Abstract Method & Implement કરવું જ પડે & \texttt{@abstractmethod} \\
Interface & Method structure define કરે & \texttt{def\ area(self):} \\
\end{longtable}
}

\textbf{એબ્સ્ટ્રેક્શન Implementation:}

\begin{verbatim}
from abc import ABC, abstractmethod

\# Abstract class
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
    
    @abstractmethod
    def perimeter(self):
        pass

\# Concrete class
class Rectangle(Shape):
    def \_\_init\_\_(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width
    
    def perimeter(self):
        return 2 * (self.length + self.width)
\end{verbatim}

\textbf{લાભો ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લાભ & વર્ણન & ફાયદો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સરળતા & જટિલ details છુપાવે & વાપરવામાં સરળ \\
સુરક્ષા & આંતરિક implementation છુપાવે & ડેટા સુરક્ષા \\
જાળવણીયોગ્યતા & Implementation બદલી શકાય & લવચીક અપડેટ્સ \\
કોડ સંગઠન & સ્પષ્ટ માળખું & બહેતર ડિઝાઇન \\
\end{longtable}
}

\begin{itemize}
\tightlist
\item
  \textbf{જટિલતા છુપાવવી}: Users ને આંતરિક workings જાણવાની જરૂર નથી
\item
  \textbf{સુસંગત Interface}: બધા child classes એક જ structure અનુસરે છે
\item
  \textbf{Implementation ફરજિયાત}: Abstract methods child classes માં
  define કરવા જ પડે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``વિગતો છુપાવો, Interface બતાવો''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{મલ્ટિપલ અને મલ્ટિ-લેવલ ઇન્હેરિટન્સનું કાર્ય દર્શાવતો Python પ્રોગ્રામ
વિકસાવો.}

\begin{solutionbox}

પ્રોગ્રામ બંને inheritance types દર્શાવે છે: multiple (અનેક parents) અને
multi-level (inheritance ની chain).

\textbf{ઇન્હેરિટન્સ પ્રકારો સરખામણી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3182}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4091}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પ્રકાર
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
માળખું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Multiple & Child અનેક parents પાસેથી inherit કરે &
\texttt{class\ C(A,\ B):} \\
Multi-level & Grandparent \rightarrow Parent \rightarrow Child & \texttt{class\ C(B):} જ્યાં
\texttt{class\ B(A):} \\
\end{longtable}
}

\textbf{ઇન્હેરિટન્સ પદાનુક્રમ:}

\begin{verbatim}
Multiple Inheritance:
    Father    Mother
      {       /}
       {     /}
        Child

Multi{-level Inheritance:}
    Animal
      |
      v
    Mammal
      |
      v
     Dog
\end{verbatim}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Multi{-level Inheritance Demo}
print("=== Multi{-level Inheritance ==="})

class Animal:
    def \_\_init\_\_(self, name):
        self.name = name
    
    def eat(self):
        print(f"\{self.name\} can eat")

class Mammal(Animal):  \# Animal પાસેથી inherit કરે છે
    def breathe(self):
        print(f"\{self.name\} breathes air")

class Dog(Mammal):     \# Mammal પાસેથી inherit કરે છે (જે Animal પાસેથી inherit કરે છે)
    def bark(self):
        print(f"\{self.name\} can bark")

\# Multi{-level inheritance નો ઉપયોગ}
my\_dog = Dog("Buddy")
my\_dog.eat()     \# Animal પાસેથી (grandparent)
my\_dog.breathe() \# Mammal પાસેથી (parent)
my\_dog.bark()    \# પોતાની method

print("{n}=== Multiple Inheritance ===")

class Father:
    def father\_method(self):
        print("Method from Father class")

class Mother:
    def mother\_method(self):
        print("Method from Mother class")

class Child(Father, Mother):  \# Father અને Mother બંને પાસેથી inherit કરે છે
    def child\_method(self):
        print("Method from Child class")

\# Multiple inheritance નો ઉપયોગ
child = Child()
child.father\_method()  \# Father પાસેથી
child.mother\_method()  \# Mother પાસેથી
child.child\_method()   \# પોતાની method

\# Inheritance ચકાસવી
print(f"{n}Child inherits from Father: \{issubclass(Child, Father)\}")
print(f"Child inherits from Mother: \{issubclass(Child, Mother)\}")
\end{verbatim}

\textbf{અપેક્ષિત આઉટપુટ:}

\begin{verbatim}
=== Multi-level Inheritance ===
Buddy can eat
Buddy breathes air
Buddy can bark

=== Multiple Inheritance ===
Method from Father class
Method from Mother class
Method from Child class

Child inherits from Father: True
Child inherits from Mother: True
\end{verbatim}

\textbf{મુખ્ય તફાવતો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પાસું & Multiple & Multi-level \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Parents & 2 અથવા વધુ direct parents & Single parent chain \\
Syntax & \texttt{class\ C(A,\ B):} & \texttt{class\ C(B):} જ્યાં
\texttt{B(A):} \\
Inheritance & આડી & ઊભી \\
જટિલતા & વધુ (diamond problem) & ઓછી \\
\end{longtable}
}

\textbf{મેથડ રિઝોલ્યુશન ઓર્ડર (MRO):}

\begin{itemize}
\tightlist
\item
  \textbf{Multiple}: Python ડાબેથી-જમણે order અનુસરે છે
\item
  \textbf{Multi-level}: Inheritance chain ઉપર જાય છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``અનેક Parents, મલ્ટિ-લેવલ Chain''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(અ OR) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-or-3-uxa97uxaa3}

\textbf{Python માં આવતી 3 પ્રકારની મેથડ્સનું કાર્ય સમજાવો.}

\begin{solutionbox}

Python classes માં ત્રણ પ્રકારની methods છે જે class data ને કેવી રીતે access કરે
છે તેના આધારે.

\textbf{મેથડ પ્રકારો ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
મેથડ પ્રકાર & ડેકોરેટર & પ્રથમ Parameter & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Instance Method & કોઈ નહીં & \texttt{self} & Instance data access \\
Class Method & \texttt{@classmethod} & \texttt{cls} & Class data
access \\
Static Method & \texttt{@staticmethod} & કોઈ નહીં & Utility functions \\
\end{longtable}
}

\textbf{ઉદાહરણ કોડ:}

\begin{verbatim}
class Student:
    school\_name = "ABC School"  \# Class variable
    
    def \_\_init\_\_(self, name):
        self.name = name        \# Instance variable
    
    \# Instance method
    def display\_info(self):
        print(f"Student: \{self.name\}")
    
    \# Class method
    @classmethod
    def get\_school(cls):
        return cls.school\_name
    
    \# Static method
    @staticmethod
    def is\_adult(age):
        return age {=} 18

\# ઉપયોગ
student = Student("Alice")
student.display\_info()           \# Instance method
print(Student.get\_school())      \# Class method
print(Student.is\_adult(20))      \# Static method
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{ઇન્સ્ટન્સ મેથડ્સ}: \texttt{self} વાપરીને object-specific data સાથે
  કામ કરે છે
\item
  \textbf{ક્લાસ મેથડ્સ}: \texttt{cls} વાપરીને class-wide data સાથે કામ કરે છે
\item
  \textbf{સ્ટેટિક મેથડ્સ}: સ્વતંત્ર utility functions
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``Instance Self, Class Cls, Static કોઈ નહીં''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(બ OR) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-or-4-uxa97uxaa3}

\textbf{Python માં ઇન્હેરિટન્સ દ્વારા પોલીમોર્ફિઝમ સમજાવો.}

\begin{solutionbox}

Polymorphism વિવિધ classes ના objects ને સામાન્ય base class ના objects
તરીકે treat કરવાની મંજૂરી આપે છે, દરેક પોતાની રીતે methods implement કરે છે.

\textbf{પોલીમોર્ફિઝમ કન્સેપ્ટ ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2727}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3182}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4091}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
ઉદાહરણ
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
સમાન Interface & સામાન્ય method names & \texttt{area()} method \\
અલગ Implementation & દરેક class નું પોતાનું version & Rectangle vs Circle
area \\
Runtime Decision & Execution દરમ્યાન method પસંદ & Dynamic binding \\
\end{longtable}
}

\textbf{પોલીમોર્ફિઝમ ઉદાહરણ:}

\begin{verbatim}
\# Base class
class Shape:
    def area(self):
        pass

\# અલગ implementations
class Rectangle(Shape):
    def \_\_init\_\_(self, length, width):
        self.length = length
        self.width = width
    
    def area(self):
        return self.length * self.width

class Circle(Shape):
    def \_\_init\_\_(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius * self.radius

\# Polymorphic behavior
shapes = [Rectangle(5, 3), Circle(4)]

for shape in shapes:
    print(f"Area: \{shape.area()\}")  \# સમાન method, અલગ પરિણામો
\end{verbatim}

\textbf{લાભો:}

\begin{itemize}
\tightlist
\item
  \textbf{લવચીકતા}: સમાન કોડ વિવિધ object types સાથે કામ કરે છે
\item
  \textbf{વિસ્તરણશીલતા}: વર્તમાન કોડ બદલ્યા વિના નવા classes ઉમેરવા સરળ
\item
  \textbf{જાળવણીયોગ્યતા}: એક class માં ફેરફાર અન્યને અસર કરતો નથી
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``સમાન નામ, અલગ વર્તન''

\end{solutionbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(ક OR) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-or-7-uxa97uxaa3}

\textbf{હાઇબ્રિડ ઇન્હેરિટન્સનું કાર્ય દર્શાવતો Python પ્રોગ્રામ વિકસાવો.}

\begin{solutionbox}

Hybrid inheritance એ single program structure માં multiple અને multi-level
inheritance ને combine કરે છે.

\textbf{હાઇબ્રિડ ઇન્હેરિટન્સ માળખું:}

\begin{verbatim}
        Animal (Base)
          |
          v
        Mammal
       /      {}
      v        v
     Dog      Cat
       {      /}
        {    /}
         v  v
      Hybrid Pet
\end{verbatim}

\textbf{હાઇબ્રિડ માં ઇન્હેરિટન્સ પ્રકારો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
લેવલ & પ્રકાર & Classes \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Single & Animal \rightarrow Mammal \\
2 & Multiple & Mammal \rightarrow Dog, Cat \\
3 & Multiple & Dog, Cat \rightarrow Pet \\
\end{longtable}
}

\textbf{સંપૂર્ણ પ્રોગ્રામ:}

\begin{verbatim}
\# Hybrid Inheritance Demonstration

print("=== Hybrid Inheritance Demo ===")

\# Base class (Level 1)
class Animal:
    def \_\_init\_\_(self, name):
        self.name = name
    
    def eat(self):
        print(f"\{self.name\} can eat")
    
    def sleep(self):
        print(f"\{self.name\} can sleep")

\# Single inheritance (Level 2)
class Mammal(Animal):
    def breathe(self):
        print(f"\{self.name\} breathes air")
    
    def give\_birth(self):
        print(f"\{self.name\} gives birth to babies")

\# Multiple inheritance branches (Level 3)
class Dog(Mammal):
    def bark(self):
        print(f"\{self.name\} barks: Woof!")
    
    def loyalty(self):
        print(f"\{self.name\} is loyal to owner")

class Cat(Mammal):
    def meow(self):
        print(f"\{self.name\} meows: Meow!")
    
    def independence(self):
        print(f"\{self.name\} is independent")

\# Hybrid class {- Multiple inheritance (Level 4)}
class HybridPet(Dog, Cat):
    def \_\_init\_\_(self, name, breed):
        super().\_\_init\_\_(name)
        self.breed = breed
    
    def play(self):
        print(f"\{self.name\} loves to play")
    
    def show\_info(self):
        print(f"Name: \{self.name\}, Breed: \{self.breed\}")

\# Creating and using hybrid inheritance
print("{n}{-{-}{-} Creating Hybrid Pet {-}{-}{-}"})
pet = HybridPet("Buddy", "Labrador{-Persian Mix"})

print("{n}{-{-}{-} Methods from Animal (Great{-}grandparent) {-}{-}{-}"})
pet.eat()
pet.sleep()

print("{n}{-{-}{-} Methods from Mammal (Grandparent) {-}{-}{-}"})
pet.breathe()
pet.give\_birth()

print("{n}{-{-}{-} Methods from Dog (Parent 1) {-}{-}{-}"})
pet.bark()
pet.loyalty()

print("{n}{-{-}{-} Methods from Cat (Parent 2) {-}{-}{-}"})
pet.meow()
pet.independence()

print("{n}{-{-}{-} Own Methods {-}{-}{-}"})
pet.play()
pet.show\_info()

print("{n}{-{-}{-} Inheritance Chain {-}{-}{-}"})
print(f"MRO (Method Resolution Order): \{HybridPet.\_\_mro\_\_\}")

\# Checking inheritance relationships
print(f"{n}Is HybridPet subclass of Animal? \{issubclass(HybridPet, Animal)\}")
print(f"Is HybridPet subclass of Dog? \{issubclass(HybridPet, Dog)\}")
print(f"Is HybridPet subclass of Cat? \{issubclass(HybridPet, Cat)\}")
\end{verbatim}

\textbf{અપેક્ષિત આઉટપુટ:}

\begin{verbatim}
=== Hybrid Inheritance Demo ===

--- Creating Hybrid Pet ---

--- Methods from Animal (Great-grandparent) ---
Buddy can eat
Buddy can sleep

--- Methods from Mammal (Grandparent) ---
Buddy breathes air
Buddy gives birth to babies

--- Methods from Dog (Parent 1) ---
Buddy barks: Woof!
Buddy is loyal to owner

--- Methods from Cat (Parent 2) ---
Buddy meows: Meow!
Buddy is independent

--- Own Methods ---
Buddy loves to play
Name: Buddy, Breed: Labrador-Persian Mix

--- Inheritance Chain ---
MRO (Method Resolution Order): (<class '__main__.HybridPet'>, <class '__main__.Dog'>, <class '__main__.Cat'>, <class '__main__.Mammal'>, <class '__main__.Animal'>, <class 'object'>)

Is HybridPet subclass of Animal? True
Is HybridPet subclass of Dog? True
Is HybridPet subclass of Cat? True
\end{verbatim}

\textbf{હાઇબ્રિડ ઇન્હેરિટન્સની મુખ્ય વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{જટિલ માળખું}: વિવિધ inheritance types ને combine કરે છે
\item
  \textbf{મેથડ રિઝોલ્યુશન ઓર્ડર}: Python method lookup માટે વિશિષ્ટ order અનુસરે
  છે
\item
  \textbf{ડાયમંડ પ્રોબ્લેમ}: Python ના MRO દ્વારા આપમેળે handle થાય છે
\item
  \textbf{લવચીકતા}: અનેક parent classes પાસેથી methods ને access
\end{itemize}

\textbf{લાભો:}

\begin{itemize}
\tightlist
\item
  \textbf{સમૃદ્ધ Functionality}: અનેક sources પાસેથી inherit કરે છે
\item
  \textbf{કોડ પુનઃઉપયોગ}: વર્તમાન કોડનો મહત્તમ ઉપયોગ
\item
  \textbf{સંબંધ મોડેલિંગ}: જટિલ વાસ્તવિક સંબંધો દર્શાવે છે
\end{itemize}

\textbf{પડકારો:}

\begin{itemize}
\tightlist
\item
  \textbf{જટિલતા}: સમજવું અને maintain કરવું કઠિન
\item
  \textbf{નામ સંઘર્ષ}: અનેક parents પાસે સમાન method names હોઈ શકે
\item
  \textbf{મેમોરી ઉપયોગ}: Objects વધુ overhead carry કરે છે
\end{itemize}

\textbf{યાદી કૌશલ્ય:} ``હાઇબ્રિડ બધા પ્રકારો Combine કરે છે''

\end{solutionbox}

\end{document}
