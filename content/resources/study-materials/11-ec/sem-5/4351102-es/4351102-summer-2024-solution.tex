\documentclass{article}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/preamble.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/english-boxes.tex}
\input{/Users/milav/Code/milav-next/latex-templates/gtu-solutions/commands.tex}

\title{Embedded System \& Microcontroller Application (4351102) - Summer 2024 Solution}
\date{May 16, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{What is the definition of an embedded system? Provide an example of an embedded system.}

\begin{solutionbox}
An \keyword{embedded system} is a specialized computer system designed to perform specific tasks with dedicated functions. It combines hardware and software components that are integrated into a larger system.

\keyword{Key Features:}
\begin{itemize}
    \item \keyword{Real-time operation}: Responds to inputs within specified time limits
    \item \keyword{Dedicated function}: Designed for specific applications
    \item \keyword{Resource constraints}: Limited memory, power, and processing capabilities
\end{itemize}

\keyword{Example}: Washing machine controller that manages wash cycles, water temperature, and timing automatically.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SMART Embedded: Specialized, Microprocessor-based, Application-specific, Real-time, Task-oriented}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{Define a Real-Time Operating System (RTOS) and list three characteristics of RTOS.}

\begin{solutionbox}
\keyword{RTOS} is an operating system designed to handle real-time applications where timing constraints are critical for system operation.

\begin{answertable}{RTOS Characteristics}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Characteristic} & \textbf{Description} \\ \hline
\keyword{Deterministic Response} & Guaranteed response time for critical tasks \\ \hline
\keyword{Priority-based Scheduling} & High-priority tasks execute before low-priority tasks \\ \hline
\keyword{Multitasking Support} & Multiple tasks can run concurrently \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Additional Features:}
\begin{itemize}
    \item \keyword{Task management}: Efficiently handles multiple concurrent processes
    \item \keyword{Interrupt handling}: Quick response to external events
    \item \keyword{Memory management}: Optimized for embedded applications
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DPM RTOS: Deterministic, Priority-based, Multitasking}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{a) Draw the general block diagram of Embedded System\\b) Explain the criteria for choosing a microcontroller for an embedded system.}

\begin{solutionbox}
\textbf{a) General Block Diagram:}

\begin{answerdiagram}{General Block Diagram of Embedded System}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block] (cpu) {Microcontroller/\\Processor};
    \node [gtu block, left=of cpu] (input) {Input Devices};
    \node [gtu block, right=of cpu] (output) {Output Devices};
    \node [gtu block, above=of cpu] (mem) {Memory System};
    \node [gtu block, below=of cpu] (comm) {Communication\\Interface};
    \node [gtu block, below left=1.5cm of cpu] (power) {Power Supply};
    \node [gtu block, below right=1.5cm of cpu] (clock) {Clock/Timer};

    \path [gtu arrow] (input) -- (cpu);
    \path [gtu arrow] (cpu) -- (output);
    \path [gtu arrow] (cpu) edge[bend right] (mem);
    \path [gtu arrow] (mem) edge[bend right] (cpu);
    \path [gtu arrow] (cpu) -- (comm);
    \path [gtu arrow] (comm) -- (cpu);
    \path [gtu arrow] (power) -- (cpu);
    \path [gtu arrow] (clock) -- (cpu);
\end{tikzpicture}
\end{answerdiagram}

\textbf{b) Microcontroller Selection Criteria:}

\begin{answertable}{Microcontroller Selection Criteria}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Criteria} & \textbf{Considerations} \\ \hline
\keyword{Processing Speed} & Clock frequency, instruction execution time \\ \hline
\keyword{Memory Requirements} & Flash, RAM, EEPROM capacity \\ \hline
\keyword{I/O Capabilities} & Number of pins, special functions \\ \hline
\keyword{Power Consumption} & Battery life, sleep modes \\ \hline
\keyword{Cost} & Budget constraints, volume pricing \\ \hline
\keyword{Development Tools} & Compiler, debugger availability \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Key Factors:}
\begin{itemize}
    \item \keyword{Performance requirements}: Processing speed and real-time constraints
    \item \keyword{Interface needs}: ADC, PWM, communication protocols
    \item \keyword{Environmental conditions}: Operating temperature, humidity
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PMPICD Selection: Performance, Memory, Power, Interface, Cost, Development tools}
\end{mnemonicbox}

\orquestionmarks{1(c)}{7}{Explain the pin configuration of the ATmega32.}

\begin{solutionbox}
ATmega32 is a 40-pin microcontroller with four 8-bit I/O ports and various special function pins.

\keyword{Port Configuration:}
\begin{answertable}{Port Configuration}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Port} & \textbf{Pins} & \textbf{Functions} \\ \hline
\keyword{Port A} & PA0-PA7 & ADC channels, general I/O \\ \hline
\keyword{Port B} & PB0-PB7 & SPI, PWM, external interrupts \\ \hline
\keyword{Port C} & PC0-PC7 & TWI, general I/O \\ \hline
\keyword{Port D} & PD0-PD7 & USART, external interrupts, PWM \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Special Pins:}
\begin{itemize}
    \item \keyword{VCC/GND}: Power supply pins
    \item \keyword{AVCC/AGND}: Analog power supply for ADC
    \item \keyword{XTAL1/XTAL2}: Crystal oscillator connections
    \item \keyword{RESET}: Active low reset input
    \item \keyword{AREF}: ADC reference voltage
\end{itemize}

\keyword{Pin Functions:}
\begin{itemize}
    \item \keyword{Dual-purpose pins}: Most pins have alternate functions
    \item \keyword{Input/Output capability}: All port pins are bidirectional
    \item \keyword{Internal pull-up}: Software configurable for input pins
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ABCD Ports: ADC, Bus interfaces, Communication, Data transfer}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{Explain the data memory architecture of ATMEGA32.}

\begin{solutionbox}
ATmega32 data memory consists of three sections organized in a unified address space.

\keyword{Memory Organization:}
\begin{answertable}{Memory Organization}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Section} & \textbf{Address Range} & \textbf{Size} & \textbf{Purpose} \\ \hline
\keyword{General Registers} & 0x00-0x1F & 32 bytes & Working registers R0-R31 \\ \hline
\keyword{I/O Registers} & 0x20-0x5F & 64 bytes & Control and status registers \\ \hline
\keyword{Internal SRAM} & 0x60-0x45F & 2048 bytes & Data storage and stack \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Key Features:}
\begin{itemize}
    \item \keyword{Unified addressing}: All memory accessible through single address space
    \item \keyword{Register file}: R0-R31 for arithmetic and logic operations
    \item \keyword{Stack pointer}: Points to top of stack in SRAM
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{GIS Memory: General registers, IO registers, SRAM}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{Explain the Program Status Word.}

\begin{solutionbox}
\keyword{SREG (Status Register)} contains flags that reflect the result of arithmetic and logic operations.

\keyword{SREG Bit Configuration:}
\begin{answertable}{SREG Bit Configuration}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Bit} & \textbf{Flag} & \textbf{Description} \\ \hline
\keyword{Bit 7} & I & Global Interrupt Enable \\ \hline
\keyword{Bit 6} & T & Bit Copy Storage \\ \hline
\keyword{Bit 5} & H & Half Carry Flag \\ \hline
\keyword{Bit 4} & S & Sign Flag \\ \hline
\keyword{Bit 3} & V & Overflow Flag \\ \hline
\keyword{Bit 2} & N & Negative Flag \\ \hline
\keyword{Bit 1} & Z & Zero Flag \\ \hline
\keyword{Bit 0} & C & Carry Flag \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Flag Functions:}
\begin{itemize}
    \item \keyword{Arithmetic operations}: C, Z, N, V, H flags updated automatically
    \item \keyword{Conditional branching}: Flags used for decision making
    \item \keyword{Interrupt control}: I flag enables/disables global interrupts
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{I THSVNZC: Interrupt, Transfer, Half-carry, Sign, oVerflow, Negative, Zero, Carry}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{Draw and explain the architecture of ATMEGA32.}

\begin{solutionbox}
\textbf{ATmega32 Architecture:}

\begin{answerdiagram}{ATmega32 Architecture}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block, minimum width=3cm] (alu) {ALU};
    \node [gtu block, above=of alu] (decoder) {Instruction Decoder};
    \node [gtu block, fit=(alu) (decoder), draw, dashed, label=above:CPU Core] (cpu) {};
    
    \node [gtu block, above=of cpu] (progmem) {Program Memory\\32KB Flash};
    \node [gtu block, below=of cpu] (regs) {Register File\\R0-R31};
    \node [gtu block, below=of regs] (io) {I/O Registers};
    \node [gtu block, below=of io] (sram) {Data Memory\\2KB SRAM};
    
    \node [gtu block, left=2cm of io] (eeprom) {EEPROM\\1KB};
    \node [gtu block, right=2cm of io] (periph) {Peripherals\\(Timers, ADC, USART, SPI, TWI)};
    \node [gtu block, right=2cm of decoder] (interrupt) {Interrupt Unit};
    
    \path [gtu arrow] (progmem) -- (decoder);
    \path [gtu arrow] (decoder) -- (alu);
    \path [gtu arrow] (alu) -- (regs);
    \path [gtu arrow] (regs) -- (io);
    \path [gtu arrow] (io) -- (sram);
    \path [gtu arrow] (sram) -- (io);
    \path [gtu arrow] (eeprom) -- (io);
    \path [gtu arrow] (io) -- (eeprom);
    \path [gtu arrow] (periph) -- (io);
    \path [gtu arrow] (io) -- (periph);
    \path [gtu arrow] (interrupt) -- (decoder);
\end{tikzpicture}
\end{answerdiagram}

\keyword{Architecture Components:}
\begin{answertable}{Architecture Components}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Component} & \textbf{Description} \\ \hline
\keyword{Harvard Architecture} & Separate program and data memory buses \\ \hline
\keyword{RISC Core} & 131 instructions, mostly single-cycle execution \\ \hline
\keyword{ALU} & 8-bit arithmetic and logic operations \\ \hline
\keyword{Register File} & 32 $\times$ 8-bit working registers \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Memory System:}
\begin{itemize}
    \item \keyword{Program memory}: 32KB Flash for storing instructions
    \item \keyword{Data memory}: 2KB SRAM for variables and stack
    \item \keyword{EEPROM}: 1KB non-volatile data storage
\end{itemize}

\keyword{Peripheral Features:}
\begin{itemize}
    \item \keyword{Three timer/counters}: 8-bit and 16-bit timers
    \item \keyword{8-channel ADC}: 10-bit resolution
    \item \keyword{Communication interfaces}: USART, SPI, TWI
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{HRAM Micro: Harvard architecture, RISC core, ALU, Memory system}
\end{mnemonicbox}

\orquestionmarks{2(a)}{3}{Explain Program Counter of ATMEGA32.}

\begin{solutionbox}
\keyword{Program Counter (PC)} is a 16-bit register that holds the address of the next instruction to be executed.

\keyword{PC Characteristics:}
\begin{answertable}{PC Characteristics}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Feature} & \textbf{Description} \\ \hline
\keyword{Size} & 16-bit (can address 64KB program memory) \\ \hline
\keyword{Reset Value} & 0x0000 (starts execution from beginning) \\ \hline
\keyword{Increment} & Automatically incremented after instruction fetch \\ \hline
\keyword{Jump/Branch} & Modified by jump, branch, and call instructions \\ \hline
\end{tabulary}
\end{answertable}

\keyword{PC Operations:}
\begin{itemize}
    \item \keyword{Sequential execution}: PC increments by 1 for most instructions
    \item \keyword{Branch instructions}: PC loaded with target address
    \item \keyword{Interrupt handling}: PC saved on stack, loaded with interrupt vector
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SRIB PC: Sequential, Reset, Increment, Branch}
\end{mnemonicbox}

\orquestionmarks{2(b)}{4}{Explain the role of clock and reset circuits in an AVR microcontroller.}

\begin{solutionbox}
\keyword{Clock System:}
\begin{answertable}{Clock Sources}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Clock Source} & \textbf{Description} \\ \hline
\keyword{External Crystal} & High accuracy, 1-16 MHz typical \\ \hline
\keyword{Internal RC} & Built-in 8 MHz oscillator \\ \hline
\keyword{External Clock} & External clock signal input \\ \hline
\keyword{Low-frequency Crystal} & 32.768 kHz for RTC applications \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Reset Circuit Functions:}
\begin{itemize}
    \item \keyword{Power-on Reset}: Automatic reset when power is applied
    \item \keyword{Brown-out Reset}: Reset when supply voltage drops
    \item \keyword{External Reset}: Manual reset through RESET pin
    \item \keyword{Watchdog Reset}: Reset from watchdog timer timeout
\end{itemize}

\keyword{Key Features:}
\begin{itemize}
    \item \keyword{Clock distribution}: System clock drives CPU and peripherals
    \item \keyword{Reset sequence}: Initializes all registers to default values
    \item \keyword{Fuse bits}: Configure clock source and reset options
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEIL Clock: Crystal, External, Internal, Low-frequency}
\end{mnemonicbox}

\orquestionmarks{2(c)}{7}{Explain TCCRn and TIFR Timer Register}

\begin{solutionbox}
\keyword{TCCRn (Timer/Counter Control Register):}

\begin{answertable}{TCCRn Registers}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Register} & \textbf{Function} \\ \hline
\keyword{TCCR0} & Controls Timer0 operation mode \\ \hline
\keyword{TCCR1A/B} & Controls Timer1 (16-bit) operation \\ \hline
\keyword{TCCR2} & Controls Timer2 operation mode \\ \hline
\end{tabulary}
\end{answertable}

\keyword{TCCR Bit Functions:}
\begin{itemize}
    \item \keyword{Clock Select (CS)}: Selects clock source and prescaler
    \item \keyword{Waveform Generation (WGM)}: Sets timer mode (Normal, CTC, PWM)
    \item \keyword{Compare Output Mode (COM)}: Controls output pin behavior
\end{itemize}

\keyword{TIFR (Timer Interrupt Flag Register):}
\begin{answertable}{TIFR Flags}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Bit} & \textbf{Flag} & \textbf{Description} \\ \hline
\keyword{TOV} & Timer Overflow & Set when timer overflows \\ \hline
\keyword{OCF} & Output Compare & Set when compare match occurs \\ \hline
\keyword{ICF} & Input Capture & Set when input capture event occurs \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Timer Operations:}
\begin{itemize}
    \item \keyword{Mode selection}: Normal, CTC, Fast PWM, Phase Correct PWM
    \item \keyword{Interrupt generation}: Flags trigger interrupts when enabled
    \item \keyword{Output generation}: PWM signals for motor control, LED dimming
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TCCR WGM: Timer Control, Clock, Register, Waveform Generation Mode}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{Distinguish different data types for programming AVR in C.}

\begin{solutionbox}
\keyword{AVR C Data Types:}

\begin{answertable}{AVR C Data Types}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{Data Type} & \textbf{Size} & \textbf{Range} & \textbf{Usage} \\ \hline
\keyword{char} & 8-bit & -128 to 127 & Characters, small integers \\ \hline
\keyword{unsigned char} & 8-bit & 0 to 255 & Port values, flags \\ \hline
\keyword{int} & 16-bit & -32768 to 32767 & General integers \\ \hline
\keyword{unsigned int} & 16-bit & 0 to 65535 & Counters, addresses \\ \hline
\keyword{long} & 32-bit & -2\textsuperscript{31} to 2\textsuperscript{31}-1 & Large calculations \\ \hline
\keyword{float} & 32-bit & $\pm3.4\times10^{38}$ & Decimal calculations \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Special Considerations:}
\begin{itemize}
    \item \keyword{Memory efficient}: Use smallest suitable data type
    \item \keyword{Port operations}: unsigned char for 8-bit ports
    \item \keyword{Timing calculations}: unsigned int for timer values
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CUIL Float: Char, Unsigned, Int, Long, Float}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{Write a C program to toggle all the bits of Port C 200 times.}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRC = 0xFF;        // Set Port C as output
    unsigned int count = 0;
    
    while(count < 200) {
        PORTC = 0xFF;   // Set all bits high
        _delay_ms(100); // Delay
        PORTC = 0x00;   // Set all bits low  
        _delay_ms(100); // Delay
        count++;        // Increment counter
    }
    return 0;
}
\end{lstlisting}

\keyword{Program Explanation:}
\begin{itemize}
    \item \keyword{DDRC = 0xFF}: Configures all Port C pins as outputs
    \item \keyword{Toggle operation}: Alternates between 0xFF and 0x00
    \item \keyword{Counter}: Tracks number of toggle cycles
    \item \keyword{Delay}: Provides visible timing for toggle operation
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DTC Loop: DDR setup, Toggle bits, Count iterations, Loop control}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{a) LED are connected to Pins of PORTB. Write an AVR programs to show the count from 0 to FFh on the LED\\b) Write an AVR C program to get a byte of data from Port C. If it is less than 100 send it to Port B; otherwise, send it to Port D.}

\begin{solutionbox}
\textbf{a) Binary Counter Display:}

\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRB = 0xFF;           // Port B as output
    unsigned char count = 0;
    
    while(1) {
        PORTB = count;     // Display count on LEDs
        _delay_ms(500);    // Delay for visibility
        count++;           // Increment counter
        if(count > 0xFF)   // Reset after 255
            count = 0;
    }
    return 0;
}
\end{lstlisting}

\textbf{b) Conditional Data Transfer:}

\begin{lstlisting}[language=C]
#include <avr/io.h>

int main() {
    DDRC = 0x00;    // Port C as input
    DDRB = 0xFF;    // Port B as output  
    DDRD = 0xFF;    // Port D as output
    
    while(1) {
        unsigned char data = PINC;  // Read from Port C
        
        if(data < 100) {
            PORTB = data;           // Send to Port B
            PORTD = 0x00;          // Clear Port D
        } else {
            PORTD = data;           // Send to Port D
            PORTB = 0x00;          // Clear Port B
        }
    }
    return 0;
}
\end{lstlisting}

\keyword{Key Programming Concepts:}
\begin{itemize}
    \item \keyword{Port direction}: DDR registers configure input/output
    \item \keyword{Data reading}: PIN registers read input values
    \item \keyword{Conditional logic}: if-else statements for decision making
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RCC Data: Read input, Compare value, Conditional output}
\end{mnemonicbox}

\orquestionmarks{3(a)}{3}{Write AVR C program to send values of -3 to +3 Port B}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRB = 0xFF;              // Port B as output
    signed char values[] = {-3, -2, -1, 0, 1, 2, 3};
    unsigned char i = 0;
    
    while(1) {
        PORTB = values[i];    // Send value to Port B
        _delay_ms(1000);      // 1 second delay
        i++;                  // Next value
        if(i > 6) i = 0;      // Reset index
    }
    return 0;
}
\end{lstlisting}

\keyword{Program Features:}
\begin{itemize}
    \item \keyword{Signed data}: Uses signed char for negative values
    \item \keyword{Array storage}: Values stored in array for easy access
    \item \keyword{Cyclic operation}: Continuously cycles through all values
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SAC Values: Signed char, Array storage, Cyclic operation}
\end{mnemonicbox}

\orquestionmarks{3(b)}{4}{Write AVR C program to send hex values for ASCII characters 0,1,2,3,4,5,A,B,C and D to port B.}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRB = 0xFF;    // Port B as output
    
    // ASCII hex values array
    unsigned char ascii_values[] = {
        0x30,  // '0'
        0x31,  // '1' 
        0x32,  // '2'
        0x33,  // '3'
        0x34,  // '4'
        0x35,  // '5'
        0x41,  // 'A'
        0x42,  // 'B'
        0x43,  // 'C'
        0x44   // 'D'
    };
    
    unsigned char i = 0;
    
    while(1) {
        PORTB = ascii_values[i];  // Send ASCII value
        _delay_ms(500);           // Delay
        i++;                      // Next character
        if(i > 9) i = 0;          // Reset index
    }
    return 0;
}
\end{lstlisting}

\keyword{ASCII Values Table:}
\begin{answertable}{ASCII Values}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Character} & \textbf{Hex Value} & \textbf{Binary} \\ \hline
'0' & 0x30 & 00110000 \\ \hline
'1' & 0x31 & 00110001 \\ \hline
'A' & 0x41 & 01000001 \\ \hline
'B' & 0x42 & 01000010 \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{HAC ASCII: Hex values, Array storage, Cyclic transmission}
\end{mnemonicbox}

\orquestionmarks{3(c)}{7}{A door sensor is connected to bit 1 of Port B, and an LED is connected to bit 7 of Port C. Write an AVR C program to monitor the door sensor and, when it opens (PIN is HIGH), turn on the LED. Also draw Flow chart.}

\begin{solutionbox}
\textbf{C Program:}

\begin{lstlisting}[language=C]
#include <avr/io.h>

int main() {
    DDRB = 0xFD;    // Port B bit 1 as input (0), others output (1)
    DDRC = 0xFF;    // Port C as output
    PORTB = 0x02;   // Enable pull-up for bit 1
    
    while(1) {
        if(PINB & 0x02) {      // Check if door sensor is HIGH
            PORTC |= 0x80;     // Turn ON LED (bit 7)
        } else {
            PORTC &= 0x7F;     // Turn OFF LED (bit 7)
        }
    }
    return 0;
}
\end{lstlisting}

\textbf{Flow Chart:}

\begin{answerdiagram}{Door Sensor Logic Flowchart}
\begin{tikzpicture}[gtu flow]
    \node [gtu start] (start) {Start};
    \node [gtu process, below=of start] (init) {Initialize Ports\\B1=Input, C7=Output};
    \node [gtu decision, below=of init] (check) {Door Open?\\(PINB.1==1)};
    \node [gtu process, below left=of check] (on) {Turn LED ON\\(PORTC.7=1)};
    \node [gtu process, below right=of check] (off) {Turn LED OFF\\(PORTC.7=0)};
    \node [gtu state, below=3cm of check] (combine) {Loop};

    \path [gtu arrow] (start) -- (init);
    \path [gtu arrow] (init) -- (check);
    \path [gtu arrow] (check) -| node[above, near start] {Yes} (on);
    \path [gtu arrow] (check) -| node[above, near start] {No} (off);
    \path [gtu arrow] (on) |- (combine);
    \path [gtu arrow] (off) |- (combine);
    \path [gtu arrow] (combine) -- (check);
\end{tikzpicture}
\end{answerdiagram}

\keyword{Bit Operations:}
\begin{itemize}
    \item \keyword{Input reading}: \code{PINB \& 0x02} checks bit 1
    \item \keyword{LED control}: \code{PORTC |= 0x80} sets bit 7
    \item \keyword{LED off}: \code{PORTC \&= 0x7F} clears bit 7
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BIC Door: Bit manipulation, Input monitoring, Conditional LED control}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{Explain ADMUX ADC Register}

\begin{solutionbox}
\keyword{ADMUX (ADC Multiplexer Selection Register):}

\begin{answertable}{ADMUX Bits}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Bit} & \textbf{Name} & \textbf{Description} \\ \hline
\keyword{Bit 7-6} & REFS1:0 & Reference Selection \\ \hline
\keyword{Bit 5} & ADLAR & ADC Left Adjust Result \\ \hline
\keyword{Bit 4-0} & MUX4:0 & Analog Channel Selection \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Reference Selection (REFS1:0):}
\begin{itemize}
    \item \keyword{00}: AREF, Internal Vref turned off
    \item \keyword{01}: AVCC with external capacitor at AREF pin  
    \item \keyword{10}: Reserved
    \item \keyword{11}: Internal 2.56V reference
\end{itemize}

\keyword{Channel Selection (MUX4:0):}
\begin{itemize}
    \item \keyword{00000-00111}: ADC0-ADC7 (single-ended inputs)
    \item \keyword{Other combinations}: Differential inputs with gain
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RAM ADMUX: Reference, Alignment, Multiplexer}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{Explain Different LCD Pins.}

\begin{solutionbox}
\keyword{16x2 LCD Pin Configuration:}

\begin{answertable}{LCD Pins}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Pin} & \textbf{Symbol} & \textbf{Function} \\ \hline
\textbf{1} & VSS & Ground (0V) \\ \hline
\textbf{2} & VDD & Power supply (+5V) \\ \hline
\textbf{3} & V0 & Contrast adjustment \\ \hline
\textbf{4} & RS & Register Select (Data/Command) \\ \hline
\textbf{5} & R/W & Read/Write select \\ \hline
\textbf{6} & E & Enable signal \\ \hline
\textbf{7-14} & D0-D7 & Data bus (8-bit) \\ \hline
\textbf{15} & A & Backlight anode (+) \\ \hline
\textbf{16} & K & Backlight cathode (-) \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Control Pin Functions:}
\begin{itemize}
    \item \keyword{RS = 0}: Command register selected
    \item \keyword{RS = 1}: Data register selected  
    \item \keyword{R/W = 0}: Write operation
    \item \keyword{R/W = 1}: Read operation
    \item \keyword{E}: Enable pulse triggers operation
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{VCR EDB LCD: Vpower, Contrast, Register select, Enable, Data Bus}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{Write a Program to toggle all the bits of PORTB continually with 20$\mu$s delay. Use Timer0, normal mode and no Prescaler to generate delay}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>

void delay_20us() {
    TCNT0 = 0;          // Clear timer counter
    TCCR0 = 0x01;       // No prescaler, normal mode
    while(TCNT0 < 160); // Wait for 20us (8MHz/1 * 20us = 160)
    TCCR0 = 0;          // Stop timer
}

int main() {
    DDRB = 0xFF;        // Port B as output
    
    while(1) {
        PORTB = 0xFF;   // Set all bits high
        delay_20us();   // 20us delay
        PORTB = 0x00;   // Set all bits low
        delay_20us();   // 20us delay
    }
    return 0;
}
\end{lstlisting}

\keyword{Timer Calculation:}
\begin{itemize}
    \item \keyword{Clock frequency}: 8 MHz (assumption)
    \item \keyword{Timer resolution}: 1/8MHz = 0.125$\mu$s per count
    \item \keyword{Required counts}: 20$\mu$s / 0.125$\mu$s = 160 counts
\end{itemize}

\keyword{Timer0 Configuration:}
\begin{answertable}{Timer0 Settings}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Setting} & \textbf{Value} & \textbf{Description} \\ \hline
\keyword{Mode} & Normal & Counts from 0 to 255 \\ \hline
\keyword{Prescaler} & 1 & No prescaling \\ \hline
\keyword{Clock source} & System clock & 8 MHz \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TNP Timer: Timer0, Normal mode, Prescaler none}
\end{mnemonicbox}

\orquestionmarks{4(a)}{3}{Short note Two wire Interface (TWI)}

\begin{solutionbox}
\keyword{TWI (Two Wire Interface) - I2C Protocol:}

\keyword{Key Features:}
\begin{answertable}{TWI Features}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Feature} & \textbf{Description} \\ \hline
\keyword{Two wires} & SDA (data) and SCL (clock) \\ \hline
\keyword{Multi-master} & Multiple masters can control bus \\ \hline
\keyword{Multi-slave} & Up to 127 slave devices \\ \hline
\keyword{Address-based} & 7-bit or 10-bit device addressing \\ \hline
\keyword{Bidirectional} & Data flows in both directions \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Bus Characteristics:}
\begin{itemize}
    \item \keyword{Open-drain}: Requires pull-up resistors (4.7k$\Omega$ typical)
    \item \keyword{Synchronous}: Clock provided by master
    \item \keyword{Start/Stop conditions}: Special sequences for communication
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SDA SCL TWI: Serial Data, Serial CLock, Two Wire Interface}
\end{mnemonicbox}

\orquestionmarks{4(b)}{4}{Explain ADCSRA ADC Register}

\begin{solutionbox}
\keyword{ADCSRA (ADC Control and Status Register A):}

\begin{answertable}{ADCSRA Register}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Bit} & \textbf{Name} & \textbf{Function} \\ \hline
\keyword{Bit 7} & ADEN & ADC Enable \\ \hline
\keyword{Bit 6} & ADSC & ADC Start Conversion \\ \hline
\keyword{Bit 5} & ADATE & ADC Auto Trigger Enable \\ \hline
\keyword{Bit 4} & ADIF & ADC Interrupt Flag \\ \hline
\keyword{Bit 3} & ADIE & ADC Interrupt Enable \\ \hline
\keyword{Bit 2-0} & ADPS2:0 & ADC Prescaler Select \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Prescaler Settings (ADPS2:0):}
\begin{answertable}{Prescaler Settings}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Binary} & \textbf{Division Factor} & \textbf{ADC Clock (8MHz)} \\ \hline
000 & 2 & 4 MHz \\ \hline
001 & 2 & 4 MHz \\ \hline
010 & 4 & 2 MHz \\ \hline
011 & 8 & 1 MHz \\ \hline
100 & 16 & 500 kHz \\ \hline
101 & 32 & 250 kHz \\ \hline
110 & 64 & 125 kHz \\ \hline
111 & 128 & 62.5 kHz \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Control Functions:}
\begin{itemize}
    \item \keyword{ADEN}: Must be set to enable ADC operation
    \item \keyword{ADSC}: Set to start conversion, cleared when complete
    \item \keyword{Prescaler}: ADC clock should be 50-200 kHz for optimal accuracy
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EASCID ADC: Enable, Auto-trigger, Start, Conversion, Interrupt, Divider}
\end{mnemonicbox}

\orquestionmarks{4(c)}{7}{Write a Program to generate a square wave of 16 Khz frequency on pin PORTC.3. Assume Crystal Frequency 8 Mhz}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <avr/interrupt.h>

int main() {
    // Configure PC3 as output
    DDRC |= (1 << PC3);
    
    // Timer1 CTC mode configuration
    TCCR1A = 0x00;                    // Normal port operation
    TCCR1B = (1 << WGM12) | (1 << CS10); // CTC mode, no prescaler
    
    // Calculate OCR1A value for 16 kHz
    // Period = 1/16000 = 62.5us
    // Half period = 31.25us  
    // OCR1A = (8MHz * 31.25us) - 1 = 249
    OCR1A = 249;
    
    // Enable Timer1 Compare A interrupt
    TIMSK |= (1 << OCIE1A);
    
    // Enable global interrupts
    sei();
    
    while(1) {
        // Main loop - square wave generated by interrupt
    }
    return 0;
}

// Timer1 Compare A interrupt service routine
ISR(TIMER1_COMPA_vect) {
    PORTC ^= (1 << PC3);    // Toggle PC3
}
\end{lstlisting}

\keyword{Frequency Calculation:}
\begin{answertable}{Frequency Calculation}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Parameter} & \textbf{Value} & \textbf{Formula} \\ \hline
\keyword{Target frequency} & 16 kHz & Given \\ \hline
\keyword{Period} & 62.5 $\mu$s & 1/16000 \\ \hline
\keyword{Half period} & 31.25 $\mu$s & Period/2 \\ \hline
\keyword{Timer counts} & 250 & 8MHz $\times$ 31.25$\mu$s \\ \hline
\keyword{OCR1A value} & 249 & Counts - 1 \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Timer Configuration:}
\begin{itemize}
    \item \keyword{Mode}: CTC (Clear Timer on Compare)
    \item \keyword{Prescaler}: 1 (no prescaling)
    \item \keyword{Interrupt}: Compare match toggles output pin
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CTC Square: CTC mode, Timer interrupt, Compare match}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{Difference between Polling and Interrupt}

\begin{solutionbox}
\keyword{Polling vs Interrupt Comparison:}

\begin{answertable}{Polling vs Interrupt}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Aspect} & \textbf{Polling} & \textbf{Interrupt} \\ \hline
\keyword{CPU Usage} & Continuously checks status & CPU free until event occurs \\ \hline
\keyword{Response Time} & Variable, depends on polling frequency & Fast, immediate response \\ \hline
\keyword{Power Consumption} & Higher due to continuous checking & Lower, CPU can sleep \\ \hline
\keyword{Programming} & Simple, sequential code & Complex, requires ISR \\ \hline
\keyword{Real-time} & Not suitable for critical timing & Excellent for real-time systems \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PIE Method: Polling inefficient, Interrupt efficient, Event-driven}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{Explain LM35 Interface with AVR ATmega32.}

\begin{solutionbox}
\textbf{LM35 Temperature Sensor Interface:}

\begin{answerdiagram}{LM35 Interface}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block, minimum height=2cm, minimum width=3cm] (mcu) {ATmega32\\(ADC Channel)};
    \node [gtu block, left=of mcu] (lm35) {LM35\\Sensor};
    \node [above=0.5cm of lm35] (vcc) {+5V};
    \node [below=0.5cm of lm35] (gnd) {GND};
    
    \draw [gtu arrow] (lm35) -- node [midway, above] {Vout} (mcu);
    \draw [gtu arrow] (vcc) -- (lm35);
    \draw [gtu arrow] (lm35) -- (gnd);
\end{tikzpicture}
\end{answerdiagram}

\keyword{LM35 Characteristics:}
\begin{answertable}{LM35 Characteristics}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{Parameter} & \textbf{Value} & \textbf{Description} \\ \hline
\keyword{Output} & 10mV/$^\circ$C & Linear temperature coefficient \\ \hline
\keyword{Range} & 0$^\circ$C to 100$^\circ$C & Operating temperature range \\ \hline
\keyword{Supply} & 4V to 30V & Power supply range \\ \hline
\keyword{Accuracy} & $\pm0.5^\circ$C & Temperature accuracy \\ \hline
\end{tabulary}
\end{answertable}

\keyword{Interface Code:}
\begin{lstlisting}[language=C]
#include <avr/io.h>

void ADC_init() {
    ADMUX = 0x40;   // AVCC reference, ADC0 channel
    ADCSRA = 0x87;  // Enable ADC, prescaler 128
}

unsigned int read_temperature() {
    ADCSRA |= (1 << ADSC);      // Start conversion
    while(ADCSRA & (1 << ADSC)); // Wait for completion
    
    // Convert ADC value to temperature
    // Temperature = (ADC * 5000) / (1024 * 10)
    unsigned int temp = (ADC * 5000) / 10240;
    return temp;
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LAC Temperature: LM35 sensor, ADC conversion, Calculation formula}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{Write a program to interface DC Motor with AVR ATmega32.}

\begin{solutionbox}
\textbf{DC Motor Interface Circuit:}

\begin{answerdiagram}{DC Motor Interface with L293D}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block, minimum height=3cm] (mcu) {ATmega32};
    \node [gtu block, right=of mcu, minimum height=3cm] (driver) {L293D\\Driver};
    \node [gtu block, right=of driver] (motor) {DC Motor};
    
    \draw [gtu arrow] (mcu.20) -- node[above] {PD5(IN1)} (driver.160);
    \draw [gtu arrow] (mcu.0) -- node[above] {PD6(IN2)} (driver.180);
    \draw [gtu arrow] (mcu.-20) -- node[above] {PD4(EN)} (driver.200);
    
    \draw [gtu arrow] (driver.20) -- node[above] {OUT1} (motor.160);
    \draw [gtu arrow] (driver.0) -- node[above] {OUT2} (motor.180);
    
    \node [above=0.5cm of driver] (vcc) {+12V (Motors) / +5V (Logic)};
    \draw [gtu arrow] (vcc) -- (driver);
\end{tikzpicture}
\end{answerdiagram}

\keyword{Motor Control Program:}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

void motor_init() {
    DDRD |= (1 << PD4) | (1 << PD5) | (1 << PD6); // Set as output
}

void motor_forward() {
    PORTD |= (1 << PD4);   // Enable motor
    PORTD |= (1 << PD5);   // IN1 = 1
    PORTD &= ~(1 << PD6);  // IN2 = 0
}

void motor_reverse() {
    PORTD |= (1 << PD4);   // Enable motor
    PORTD &= ~(1 << PD5);  // IN1 = 0
    PORTD |= (1 << PD6);   // IN2 = 1
}

void motor_stop() {
    PORTD &= ~(1 << PD4);  // Disable motor
}

int main() {
    motor_init();
    
    while(1) {
        motor_forward();    // Forward for 2 seconds
        _delay_ms(2000);
        
        motor_stop();       // Stop for 1 second
        _delay_ms(1000);
        
        motor_reverse();    // Reverse for 2 seconds
        _delay_ms(2000);
        
        motor_stop();       // Stop for 1 second
        _delay_ms(1000);
    }
    return 0;
}
\end{lstlisting}

\keyword{L293D Truth Table:}
\begin{answertable}{L293D Truth Table}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{EN} & \textbf{IN1} & \textbf{IN2} & \textbf{Motor Action} \\ \hline
0 & X & X & Stop \\ \hline
1 & 0 & 0 & Stop \\ \hline
1 & 0 & 1 & Reverse \\ \hline
1 & 1 & 0 & Forward \\ \hline
1 & 1 & 1 & Stop \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LED Motor: L293D driver, Enable control, Direction pins}
\end{mnemonicbox}

\orquestionmarks{5(a)}{3}{Explain basic block diagram of GSM based security system.}

\begin{solutionbox}
\textbf{GSM Security System Block Diagram:}

\begin{answerdiagram}{GSM Security System}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block] (mcu) {ATmega32\\Microcontroller};
    
    \node [gtu input, left=of mcu] (sensors) {Sensors\\(PIR, Door)};
    \node [gtu block, right=of mcu] (gsm) {GSM\\Module};
    \node [gtu block, right=of gsm] (network) {Mobile\\Network};
    \node [gtu block, right=of network] (phone) {User\\Phone};
    \node [gtu block, above=of mcu] (lcd) {LCD\\Display};
    \node [gtu block, below=of mcu] (alarm) {Alarm/\\Buzzer};
    \node [gtu block, below left=1.5cm of mcu] (power) {Power Support};
    
    \path [gtu arrow] (sensors) -- (mcu);
    \path [gtu arrow] (mcu) -- (gsm);
    \path [gtu arrow] (gsm) -- (network);
    \path [gtu arrow] (network) -- (phone);
    \path [gtu arrow] (mcu) -- (lcd);
    \path [gtu arrow] (mcu) -- (alarm);
    \path [gtu arrow] (power) -- (mcu);
    \path [gtu arrow] (power) -- (gsm);
\end{tikzpicture}
\end{answerdiagram}

\keyword{System Components:}
\begin{answertable}{System Components}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{Component} & \textbf{Function} \\ \hline
\keyword{Sensors} & PIR, door/window sensors, smoke detector \\ \hline
\keyword{Microcontroller} & Process sensor data, control system \\ \hline
\keyword{GSM Module} & Send SMS alerts, make calls \\ \hline
\keyword{Display} & Show system status \\ \hline
\keyword{Alarm} & Local audio/visual alert \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SGMA Security: Sensors, GSM module, Microcontroller, Alerts}
\end{mnemonicbox}

\orquestionmarks{5(b)}{4}{Explain Relay Interface with AVR ATmega32.}

\begin{solutionboxnobreak}
\textbf{Relay Interface Circuit:}

\begin{center}
\captionof{figure}{Relay Interface with ULN2803}
\begin{tikzpicture}[auto, node distance=1.2cm]
    \node [gtu block, minimum height=2cm] (mcu) {ATmega32};
    \node [gtu block, right=1cm of mcu, minimum height=2cm] (driver) {ULN2803\\Driver};
    \node [draw, rectangle, right=1cm of driver, minimum height=1.5cm, align=center] (relay) {Relay};
    \node [draw, circle, right=1cm of relay, align=center] (load) {AC\\Load};
    
    \draw [gtu arrow] (mcu.20) -- node[above, font=\tiny] {PB0} (driver.160);
    \draw [gtu arrow] (mcu.-20) -- node[above, font=\tiny] {PB1} (driver.200);
    
    \draw [gtu arrow] (driver.0) -- node[above, font=\tiny] {Drive} (relay.180);
    \draw [gtu arrow] (relay) -- (load);
    
    \node [above=0.3cm of relay] (v12) {+12V};
    \draw [gtu arrow] (v12) -- (relay);
\end{tikzpicture}
\end{center}

\keyword{Relay Interface Code:}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

void relay_init() {
    DDRB |= (1 << PB0) | (1 << PB1); // Set as output pins
}

void relay1_on() {
    PORTB |= (1 << PB0);  // Activate relay 1
}

void relay1_off() {
    PORTB &= ~(1 << PB0); // Deactivate relay 1
}

int main() {
    relay_init();
    
    while(1) {
        relay1_on();        // Turn on relay 1
        _delay_ms(2000);
        relay1_off();       // Turn off relay 1
        _delay_ms(1000);
    }
    return 0;
}
\end{lstlisting}

\keyword{ULN2803 Features:}
\begin{itemize}
    \item \keyword{8 Channels}: Eight Darlington pair drivers
    \item \keyword{High Current}: Up to 500mA per channel
    \item \keyword{Protection}: Built-in flyback diodes
\end{itemize}
\end{solutionboxnobreak}

\begin{mnemonicbox}
\mnemonic{ULN Relay: ULN2803 driver, Load control, Non-contact switching}
\end{mnemonicbox}

\orquestionmarks{5(c)}{7}{Draw and Explain Automatic Juice vending machine}

\begin{solutionbox}
\textbf{Automatic Juice Vending Machine Block Diagram:}

\begin{center}
\captionof{figure}{Juice Vending Machine}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block] (mcu) {ATmega32\\Controller};
    
    \node [gtu block, left=of mcu, yshift=1.5cm] (coin) {Coin Sensor};
    \node [gtu block, left=of mcu, yshift=-1.5cm] (keypad) {Keypad};
    \node [gtu block, right=of mcu, yshift=1.5cm] (dispense) {Pump/Valve};
    \node [gtu block, right=of mcu, yshift=-1.5cm] (return) {Coin Return};
    \node [gtu block, above=of mcu] (lcd) {LCD Display};
    \node [gtu block, below=of mcu] (level) {Level Sensors};
    
    \path [gtu arrow] (coin) -- (mcu);
    \path [gtu arrow] (keypad) -- (mcu);
    \path [gtu arrow] (mcu) -- (dispense);
    \path [gtu arrow] (mcu) -- (return);
    \path [gtu arrow] (mcu) -- (lcd);
    \path [gtu arrow] (level) -- (mcu);
\end{tikzpicture}
\end{center}

\keyword{System Operation:}
\begin{itemize}
    \item \keyword{Initialization}: Display welcome message and juice menu
    \item \keyword{Coin Input}: User inserts coins, system validates amount
    \item \keyword{Selection}: User presses keypad to select juice type
    \item \keyword{Validation}: Check if enough money and juice available
    \item \keyword{Dispensing}: Activate pump and valve for selected juice
    \item \keyword{Completion}: Return change if any, display thank you message
\end{itemize}

\keyword{Control Logic:}
\begin{lstlisting}[language=C]
// Pseudo code for vending machine operation
void vending_machine() {
    display_menu();
    
    while(1) {
        if(coin_inserted()) {
            total_amount += validate_coin();
            update_display();
        }
        
        if(selection_made()) {
            juice_type = get_selection();
            if(total_amount >= juice_price[juice_type]) {
                if(juice_available[juice_type]) {
                    dispense_juice(juice_type);
                    return_change();
                    reset_system();
                } else {
                    display_error("Out of Stock");
                }
            } else {
                display_error("Insufficient Amount");
            }
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CLPDV Juice: Coin sensor, LCD display, Pump motors, Dispensing unit, Valve control}
\end{mnemonicbox}

\end{document}
