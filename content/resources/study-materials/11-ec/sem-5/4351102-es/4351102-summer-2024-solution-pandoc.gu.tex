\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/gujarati-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name (Gujarati)}\\[5pt]
{\LARGE 4351102 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{પ્રશ્ન 1(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa85-3-uxa97uxaa3}

\textbf{એમ્બેડેડ સિસ્ટમની વ્યાખ્યા શું છે? એમ્બેડેડ સિસ્ટમનું ઉદાહરણ આપો.}

\begin{solutionbox}
\textbf{એમ્બેડેડ સિસ્ટમ} એ એક વિશેષ કમ્પ્યુટર સિસ્ટમ છે જે ચોક્કસ
કાર્યો કરવા માટે સમર્પિત કાર્યો સાથે ડિઝાઇન કરવામાં આવે છે. તે હાર્ડવેર અને સોફ્ટવેર
ઘટકોને જોડે છે જે વિશાળ સિસ્ટમમાં એકીકૃત થાય છે.

\textbf{મુખ્ય લક્ષણો:}

\begin{itemize}
\tightlist
\item
  \textbf{રીઅલ-ટાઇમ ઓપરેશન}: નિર્દિષ્ટ સમય મર્યાદામાં ઇનપુટ્સનો પ્રતિસાદ આપે છે
\item
  \textbf{સમર્પિત કાર્ય}: ચોક્કસ એપ્લિકેશન માટે ડિઝાઇન કરેલું
\item
  \textbf{રિસોર્સ મર્યાદાઓ}: મર્યાદિત મેમરી, પાવર અને પ્રોસેસિંગ ક્ષમતાઓ
\end{itemize}

\textbf{ઉદાહરણ}: વોશિંગ મશીન કન્ટ્રોલર જે વોશ સાઇકલ્સ, પાણીનું તાપમાન અને
ટાઇમિંગને આપમેળે મેનેજ કરે છે.

\end{solutionbox}
\begin{mnemonicbox}
``SMART Embedded'' - \textbf{S}pecialized,
\textbf{M}icroprocessor-based, \textbf{A}pplication-specific,
\textbf{R}eal-time, \textbf{T}ask-oriented

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxaac-4-uxa97uxaa3}

\textbf{રીઅલ-ટાઇમ ઓપરેટિંગ સિસ્ટમ (RTOS) ને વ્યાખ્યાયિત કરો અને RTOS ની ત્રણ
લાક્ષણિકતાઓની યાદી બનાવો.}

\begin{solutionbox}
\textbf{RTOS} એ એક ઓપરેટિંગ સિસ્ટમ છે જે રીઅલ-ટાઇમ એપ્લિકેશન્સને
હેન્ડલ કરવા માટે ડિઝાઇન કરવામાં આવ્યું છે જ્યાં સિસ્ટમ ઓપરેશન માટે ટાઇમિંગ અવરોધો
નિર્ણાયક છે.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
લાક્ષણિકતા
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
વર્ણન
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{નિર્ધારિત પ્રતિસાદ} & નિર્ણાયક કાર્યો માટે ગેરંટીડ રિસ્પોન્સ ટાઇમ \\
\textbf{પ્રાથમિકતા-આધારિત શેડ્યુલિંગ} & ઉચ્ચ પ્રાથમિકતાના કાર્યો નીચા
પ્રાથમિકતાના કાર્યો પહેલાં ચાલે છે \\
\textbf{મલ્ટિટાસ્કિંગ સપોર્ટ} & બહુવિધ કાર્યો એકસાથે ચાલી શકે છે \\
\end{longtable}
}

\textbf{વધારાની વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{કાર્ય વ્યવસ્થાપન}: બહુવિધ સમાંતર પ્રક્રિયાઓને અસરકારક રીતે હેન્ડલ કરે છે
\item
  \textbf{ઇન્ટરપ્ટ હેન્ડલિંગ}: બાહ્ય ઘટનાઓને ઝડપી પ્રતિસાદ
\item
  \textbf{મેમરી વ્યવસ્થાપન}: એમ્બેડેડ એપ્લિકેશન્સ માટે ઓપ્ટિમાઇઝ્ડ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DPM RTOS'' - \textbf{D}eterministic,
\textbf{P}riority-based, \textbf{M}ultitasking

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-7-uxa97uxaa3}

\textbf{અ) એમ્બેડેડ સિસ્ટમનો જનરલ બ્લોક ડાયાગ્રામ દોરો} \textbf{બ) એમ્બેડેડ સિસ્ટમ
માટે માઇક્રોકન્ટ્રોલર પસંદ કરવાના માપદંડો સમજાવો.}

\begin{solutionbox}

\textbf{અ) જનરલ બ્લોક ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Input Devices] {-{-}{} B[Microcontroller/Processor]}
    B {-{-}{} C[Output Devices]}
    B {-{-}{} D[Memory System]}
    D {-{-}{} B}
    B {-{-}{} E[Communication Interface]}
    F[Power Supply] {-{-}{} B}
    G[Clock/Timer] {-{-}{} B}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{બ) માઇક્રોકન્ટ્રોલર પસંદગીના માપદંડો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
માપદંડ & વિચારણાઓ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{પ્રોસેસિંગ સ્પીડ} & ક્લોક ફ્રીક્વન્સી, ઇન્સ્ટ્રક્શન એક્ઝિક્યુશન ટાઇમ \\
\textbf{મેમરી જરૂરિયાતો} & Flash, RAM, EEPROM ક્ષમતા \\
\textbf{I/O ક્ષમતાઓ} & પિન્સની સંખ્યા, વિશેષ કાર્યો \\
\textbf{પાવર વપરાશ} & બેટરી લાઇફ, સ્લીપ મોડ્સ \\
\textbf{કિંમત} & બજેટ અવરોધો, વોલ્યુમ પ્રાઇસિંગ \\
\textbf{ડેવલપમેન્ટ ટૂલ્સ} & કમ્પાઇલર, ડિબગર ઉપલબ્ધતા \\
\end{longtable}
}

\textbf{મુખ્ય પરિબળો:}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રદર્શન આવશ્યકતાઓ}: પ્રોસેસિંગ સ્પીડ અને રીઅલ-ટાઇમ અવરોધો
\item
  \textbf{ઇન્ટરફેસ જરૂરિયાતો}: ADC, PWM, કમ્યુનિકેશન પ્રોટોકોલ્સ
\item
  \textbf{પર્યાવરણીય પરિસ્થિતિઓ}: ઓપરેટિંગ તાપમાન, ભેજ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PMPICD Selection'' - \textbf{P}erformance,
\textbf{M}emory, \textbf{P}ower, \textbf{I}nterface, \textbf{C}ost,
\textbf{D}evelopment tools

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 1(ક) અથવા [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-1uxa95-uxa85uxaa5uxab5-7-uxa97uxaa3}

\textbf{ATmega32 ની પિન ગોઠવણી સમજાવો.}

\begin{solutionbox}
ATmega32 એ 40-પિન માઇક્રોકન્ટ્રોલર છે જેમાં ચાર 8-બિટ I/O પોર્ટ્સ
અને વિવિધ વિશેષ કાર્યાત્મક પિન્સ છે.

\textbf{પોર્ટ ગોઠવણી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પોર્ટ & પિન્સ & કાર્યો \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Port A} & PA0-PA7 & ADC ચેનલ્સ, જનરલ I/O \\
\textbf{Port B} & PB0-PB7 & SPI, PWM, બાહ્ય ઇન્ટરપ્ટ્સ \\
\textbf{Port C} & PC0-PC7 & TWI, જનરલ I/O \\
\textbf{Port D} & PD0-PD7 & USART, બાહ્ય ઇન્ટરપ્ટ્સ, PWM \\
\end{longtable}
}

\textbf{વિશેષ પિન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{VCC/GND}: પાવર સપ્લાઇ પિન્સ
\item
  \textbf{AVCC/AGND}: ADC માટે એનાલોગ પાવર સપ્લાઇ
\item
  \textbf{XTAL1/XTAL2}: ક્રિસ્ટલ ઓસિલેટર કનેક્શન્સ
\item
  \textbf{RESET}: એક્ટિવ લો રીસેટ ઇનપુટ
\item
  \textbf{AREF}: ADC રેફરન્સ વોલ્ટેજ
\end{itemize}

\textbf{પિન કાર્યો:}

\begin{itemize}
\tightlist
\item
  \textbf{ડ્યૂઅલ-પર્પઝ પિન્સ}: મોટાભાગની પિન્સમાં વૈકલ્પિક કાર્યો છે
\item
  \textbf{ઇનપુટ/આઉટપુટ ક્ષમતા}: બધી પોર્ટ પિન્સ દ્વિદિશીય છે
\item
  \textbf{આંતરિક પુલ-અપ}: ઇનપુટ પિન્સ માટે સોફ્ટવેર રૂપરેખાંકિત
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ABCD Ports'' - \textbf{A}DC, \textbf{B}us
interfaces, \textbf{C}ommunication, \textbf{D}ata transfer

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa85-3-uxa97uxaa3}

\textbf{ATMEGA32 નું ડેટા મેમરી આર્કિટેક્ચર સમજાવો.}

\begin{solutionbox}
ATmega32 ડેટા મેમરી ત્રણ વિભાગોનો સમાવેશ કરે છે જે એકીકૃત સરનામા
સ્થળમાં આયોજિત છે.

\textbf{મેમરી સંગઠન:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
વિભાગ & સરનામા શ્રેણી & કદ & હેતુ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{જનરલ રજિસ્ટર્સ} & 0x00-0x1F & 32 બાઇટ્સ & વર્કિંગ રજિસ્ટર્સ R0-R31 \\
\textbf{I/O રજિસ્ટર્સ} & 0x20-0x5F & 64 બાઇટ્સ & કન્ટ્રોલ અને સ્ટેટસ રજિસ્ટર્સ \\
\textbf{આંતરિક SRAM} & 0x60-0x45F & 2048 બાઇટ્સ & ડેટા સ્ટોરેજ અને સ્ટેક \\
\end{longtable}
}

\textbf{મુખ્ય વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{એકીકૃત એડ્રેસિંગ}: બધી મેમરી એક સરનામા સ્થળ દ્વારા સુલભ
\item
  \textbf{રજિસ્ટર ફાઇલ}: અંકગણિત અને તર્ક ઓપરેશન્સ માટે R0-R31
\item
  \textbf{સ્ટેક પોઇન્ટર}: SRAM માં સ્ટેકની ટોપ તરફ નિર્દેશ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``GIS Memory'' - \textbf{G}eneral registers,
\textbf{I}O registers, \textbf{S}RAM

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxaac-4-uxa97uxaa3}

\textbf{પ્રોગ્રામ સ્ટેટસ વર્ડ સમજાવો.}

\begin{solutionbox}
\textbf{SREG (સ્ટેટસ રજિસ્ટર)} માં ફ્લેગ્સ છે જે અંકગણિત અને તર્ક
ઓપરેશન્સના પરિણામને પ્રતિબિંબિત કરે છે.

\textbf{SREG બિટ રૂપરેખાંકન:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
બિટ & ફ્લેગ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બિટ 7} & I & ગ્લોબલ ઇન્ટરપ્ટ એનેબલ \\
\textbf{બિટ 6} & T & બિટ કોપી સ્ટોરેજ \\
\textbf{બિટ 5} & H & હાફ કેરી ફ્લેગ \\
\textbf{બિટ 4} & S & સાઇન ફ્લેગ \\
\textbf{બિટ 3} & V & ઓવરફ્લો ફ્લેગ \\
\textbf{બિટ 2} & N & નેગેટિવ ફ્લેગ \\
\textbf{બિટ 1} & Z & ઝીરો ફ્લેગ \\
\textbf{બિટ 0} & C & કેરી ફ્લેગ \\
\end{longtable}
}

\textbf{ફ્લેગ કાર્યો:}

\begin{itemize}
\tightlist
\item
  \textbf{અંકગણિત ઓપરેશન્સ}: C, Z, N, V, H ફ્લેગ્સ આપમેળે અપડેટ થાય છે
\item
  \textbf{શરતી બ્રાન્ચિંગ}: નિર્ણય લેવા માટે ફ્લેગ્સનો ઉપયોગ
\item
  \textbf{ઇન્ટરપ્ટ નિયંત્રણ}: I ફ્લેગ ગ્લોબલ ઇન્ટરપ્ટ્સને સક્ષમ/અક્ષમ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``I THSVNZC'' - \textbf{I}nterrupt,
\textbf{T}ransfer, \textbf{H}alf-carry, \textbf{S}ign,
o\textbf{V}erflow, \textbf{N}egative, \textbf{Z}ero, \textbf{C}arry

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2uxa95-7-uxa97uxaa3}

\textbf{ATMEGA32 ના આર્કિટેક્ચર દોરો અને સમજાવો.}

\begin{solutionbox}

\textbf{ATmega32 આર્કિટેક્ચર:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[Program Memory 32KB] {-{-}{} B[Instruction Decoder]}
    B {-{-}{} C[ALU]}
    C {-{-}{} D[Register File R0{-}R31]}
    D {-{-}{} E[I/O Registers]}
    E {-{-}{} F[Data Memory 2KB SRAM]}
    G[EEPROM 1KB] {-{-}{} E}
    H[Timers/Counters] {-{-}{} E}
    I[ADC] {-{-}{} E}
    J[USART] {-{-}{} E}
    K[SPI] {-{-}{} E}
    L[TWI] {-{-}{} E}
    M[Interrupt Unit] {-{-}{} B}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{આર્કિટેક્ચર ઘટકો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઘટક & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{હાર્વર્ડ આર્કિટેક્ચર} & અલગ પ્રોગ્રામ અને ડેટા મેમરી બસ \\
\textbf{RISC કોર} & 131 સૂચનાઓ, મોટાભાગે સિંગલ-સાઇકલ એક્ઝિક્યુશન \\
\textbf{ALU} & 8-બિટ અંકગણિત અને તર્ક ઓપરેશન્સ \\
\textbf{રજિસ્ટર ફાઇલ} & 32 \times 8-બિટ વર્કિંગ રજિસ્ટર્સ \\
\end{longtable}
}

\textbf{મેમરી સિસ્ટમ:}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રોગ્રામ મેમરી}: સૂચનાઓ સંગ્રહ કરવા માટે 32KB Flash
\item
  \textbf{ડેટા મેમરી}: ચલો અને સ્ટેક માટે 2KB SRAM
\item
  \textbf{EEPROM}: 1KB નોન-વોલેટાઇલ ડેટા સ્ટોરેજ
\end{itemize}

\textbf{પેરિફેરલ વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ત્રણ ટાઇમર/કાઉન્ટર્સ}: 8-બિટ અને 16-બિટ ટાઇમર્સ
\item
  \textbf{8-ચેનલ ADC}: 10-બિટ રીઝોલ્યુશન
\item
  \textbf{કમ્યુનિકેશન ઇન્ટરફેસ}: USART, SPI, TWI
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``HRAM Micro'' - \textbf{H}arvard architecture,
\textbf{R}ISC core, \textbf{A}LU, \textbf{M}emory system

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2 અથવા(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2-uxa85uxaa5uxab5uxa85-3-uxa97uxaa3}

\textbf{ATMEGA32 ના પ્રોગ્રામ કાઉન્ટર સમજાવો.}

\begin{solutionbox}
\textbf{પ્રોગ્રામ કાઉન્ટર (PC)} એ 16-બિટ રજિસ્ટર છે જે એક્ઝિક્યુટ
થવાની આગલી સૂચનાનું સરનામું ધરાવે છે.

\textbf{PC લાક્ષણિકતાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{કદ} & 16-બિટ (64KB પ્રોગ્રામ મેમરીને સરનામું આપી શકે છે) \\
\textbf{રીસેટ વેલ્યુ} & 0x0000 (શરૂઆતથી એક્ઝિક્યુશન શરૂ કરે છે) \\
\textbf{વૃદ્ધિ} & સૂચના મેળવ્યા પછી આપમેળે વધે છે \\
\textbf{જમ્પ/બ્રાન્ચ} & જમ્પ, બ્રાન્ચ અને કોલ સૂચનાઓ દ્વારા સુધારેલું \\
\end{longtable}
}

\textbf{PC ઓપરેશન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{અનુક્રમિક એક્ઝિક્યુશન}: મોટાભાગની સૂચનાઓ માટે PC 1 વધે છે
\item
  \textbf{બ્રાન્ચ સૂચનાઓ}: PC ને ટાર્ગેટ એડ્રેસ સાથે લોડ કરવામાં આવે છે
\item
  \textbf{ઇન્ટરપ્ટ હેન્ડલિંગ}: PC સ્ટેકમાં સાચવાય છે, ઇન્ટરપ્ટ વેક્ટર સાથે લોડ કરાય છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SRIB PC'' - \textbf{S}equential, \textbf{R}eset,
\textbf{I}ncrement, \textbf{B}ranch

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2 અથવા(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2-uxa85uxaa5uxab5uxaac-4-uxa97uxaa3}

\textbf{AVR માઇક્રોકન્ટ્રોલરમાં ક્લોક અને રીસેટ સર્કિટની ભૂમિકા સમજાવો.}

\begin{solutionbox}

\textbf{ક્લોક સિસ્ટમ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ક્લોક સ્રોત & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બાહ્ય ક્રિસ્ટલ} & ઉચ્ચ ચોકસાઇ, 1-16 MHz સામાન્ય \\
\textbf{આંતરિક RC} & બિલ્ટ-ઇન 8 MHz ઓસિલેટર \\
\textbf{બાહ્ય ક્લોક} & બાહ્ય ક્લોક સિગ્નલ ઇનપુટ \\
\textbf{લો-ફ્રીક્વન્સી ક્રિસ્ટલ} & RTC એપ્લિકેશન્સ માટે 32.768 kHz \\
\end{longtable}
}

\textbf{રીસેટ સર્કિટ કાર્યો:}

\begin{itemize}
\tightlist
\item
  \textbf{પાવર-ઓન રીસેટ}: પાવર લાગુ થયા પછી આપમેળે રીસેટ
\item
  \textbf{બ્રાઉન-આઉટ રીસેટ}: સપ્લાઇ વોલ્ટેજ ઘટે છે ત્યારે રીસેટ
\item
  \textbf{બાહ્ય રીસેટ}: RESET પિન દ્વારા મેન્યુઅલ રીસેટ
\item
  \textbf{વોચડોગ રીસેટ}: વોચડોગ ટાઇમર ટાઇમઆઉટથી રીસેટ
\end{itemize}

\textbf{મુખ્ય વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ક્લોક વિતરણ}: સિસ્ટમ ક્લોક CPU અને પેરિફેરલ્સ ચલાવે છે
\item
  \textbf{રીસેટ ક્રમ}: બધા રજિસ્ટર્સને ડિફોલ્ટ વેલ્યુમાં પ્રારંભ કરે છે
\item
  \textbf{ફ્યુઝ બિટ્સ}: ક્લોક સ્રોત અને રીસેટ વિકલ્પો રૂપરેખાંકિત કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CEIL Clock'' - \textbf{C}rystal,
\textbf{E}xternal, \textbf{I}nternal, \textbf{L}ow-frequency

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 2 અથવા(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-2-uxa85uxaa5uxab5uxa95-7-uxa97uxaa3}

\textbf{TCCRn અને TIFR ટાઇમર રજિસ્ટર સમજાવો}

\begin{solutionbox}

\textbf{TCCRn (ટાઇમર/કાઉન્ટર કન્ટ્રોલ રજિસ્ટર):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
રજિસ્ટર & કાર્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{TCCR0} & Timer0 ઓપરેશન મોડ નિયંત્રિત કરે છે \\
\textbf{TCCR1A/B} & Timer1 (16-બિટ) ઓપરેશન નિયંત્રિત કરે છે \\
\textbf{TCCR2} & Timer2 ઓપરેશન મોડ નિયંત્રિત કરે છે \\
\end{longtable}
}

\textbf{TCCR બિટ કાર્યો:}

\begin{itemize}
\tightlist
\item
  \textbf{ક્લોક સિલેક્ટ (CS)}: ક્લોક સ્રોત અને પ્રીસ્કેલર પસંદ કરે છે
\item
  \textbf{વેવફોર્મ જનરેશન (WGM)}: ટાઇમર મોડ સેટ કરે છે (Normal, CTC, PWM)
\item
  \textbf{કમ્પેર આઉટપુટ મોડ (COM)}: આઉટપુટ પિન વર્તન નિયંત્રિત કરે છે
\end{itemize}

\textbf{TIFR (ટાઇમર ઇન્ટરપ્ટ ફ્લેગ રજિસ્ટર):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
બિટ & ફ્લેગ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{TOV} & ટાઇમર ઓવરફ્લો & ટાઇમર ઓવરફ્લો થાય છે ત્યારે સેટ થાય છે \\
\textbf{OCF} & આઉટપુટ કમ્પેર & કમ્પેર મેચ થાય છે ત્યારે સેટ થાય છે \\
\textbf{ICF} & ઇનપુટ કેપ્ચર & ઇનપુટ કેપ્ચર ઇવેન્ટ થાય છે ત્યારે સેટ થાય છે \\
\end{longtable}
}

\textbf{ટાઇમર ઓપરેશન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ પસંદગી}: Normal, CTC, Fast PWM, Phase Correct PWM
\item
  \textbf{ઇન્ટરપ્ટ જનરેશન}: સક્ષમ હોય ત્યારે ફ્લેગ્સ ઇન્ટરપ્ટ ટ્રિગર કરે છે
\item
  \textbf{આઉટપુટ જનરેશન}: મોટર કન્ટ્રોલ, LED ડિમિંગ માટે PWM સિગ્નલ્સ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TCCR WGM'' - \textbf{T}imer \textbf{C}ontrol,
\textbf{C}lock, \textbf{R}egister, \textbf{W}aveform \textbf{G}eneration
\textbf{M}ode

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa85-3-uxa97uxaa3}

\textbf{C માં પ્રોગ્રામિંગ AVR માટે વિવિધ ડેટા ટાઇપ અલગ પાડો}

\begin{solutionbox}

\textbf{AVR C ડેટા ટાઇપ્સ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
ડેટા ટાઇપ & કદ & શ્રેણી & ઉપયોગ \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{char} & 8-બિટ & -128 to 127 & અક્ષરો, નાના પૂર્ણાંકો \\
\textbf{unsigned char} & 8-બિટ & 0 to 255 & પોર્ટ મૂલ્યો, ફ્લેગ્સ \\
\textbf{int} & 16-બિટ & -32768 to 32767 & સામાન્ય પૂર્ણાંકો \\
\textbf{unsigned int} & 16-બિટ & 0 to 65535 & કાઉન્ટર્સ, સરનામાઓ \\
\textbf{long} & 32-બિટ & -2^{3}^{1} to 2^{3}^{1}-1 & મોટી ગણતરીઓ \\
\textbf{float} & 32-બિટ & \pm3.4\times10^{3}^{8} & દશાંશ ગણતરીઓ \\
\end{longtable}
}

\textbf{વિશેષ વિચારણાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{મેમરી કાર્યક્ષમ}: સૌથી નાની યોગ્ય ડેટા ટાઇપનો ઉપયોગ કરો
\item
  \textbf{પોર્ટ ઓપરેશન્સ}: 8-બિટ પોર્ટ્સ માટે unsigned char
\item
  \textbf{ટાઇમિંગ ગણતરીઓ}: ટાઇમર મૂલ્યો માટે unsigned int
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CUIL Float'' - \textbf{C}har, \textbf{U}nsigned,
\textbf{I}nt, \textbf{L}ong, \textbf{Float}

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxaac-4-uxa97uxaa3}

\textbf{પોર્ટ C ના તમામ બિટ્સને 200 વખત ટૉગલ કરવા માટે C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRC = 0xFF;        // પોર્ટ C ને આઉટપુટ તરીકે સેટ કરો
    unsigned int count = 0;
    
    while(count {} 200) \{
        PORTC = 0xFF;   // બધા બિટ્સ high સેટ કરો
        \_delay\_ms(100); // વિલંબ
        PORTC = 0x00;   // બધા બિટ્સ low સેટ કરો
        \_delay\_ms(100); // વિલંબ
        count++;        // કાઉન્ટર વધારો
    \}
    return 0;
\}
\end{verbatim}

\textbf{પ્રોગ્રામ સમજૂતી:}

\begin{itemize}
\tightlist
\item
  \textbf{DDRC = 0xFF}: પોર્ટ C ના બધા પિન્સને આઉટપુટ તરીકે રૂપરેખાંકિત કરે છે
\item
  \textbf{ટૉગલ ઓપરેશન}: 0xFF અને 0x00 વચ્ચે ફેરબદલી કરે છે
\item
  \textbf{કાઉન્ટર}: ટૉગલ સાઇકલ્સની સંખ્યા ટ્રેક કરે છે
\item
  \textbf{વિલંબ}: ટૉગલ ઓપરેશન માટે દૃશ્યમાન ટાઇમિંગ પ્રદાન કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DTC Loop'' - \textbf{D}DR setup, \textbf{T}oggle
bits, \textbf{C}ount iterations, \textbf{L}oop control

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3uxa95-7-uxa97uxaa3}

\textbf{અ) LED PORTB ના પિન સાથે જોડાયેલ છે. LED પર 0 થી FFh સુધીની ગણતરી
બતાવવા માટે AVR પ્રોગ્રામ્સ લખો} \textbf{બ) પોર્ટ C માંથી ડેટાનો બાઇટ મેળવવા માટે
AVR C પ્રોગ્રામ લખો. જો તે 100 કરતા ઓછો હોય તો તેને પોર્ટ B પર મોકલો; નહીંતર,
તેને પોર્ટ D પર મોકલો.}

\begin{solutionbox}

\textbf{અ) બાઇનરી કાઉન્ટર ડિસ્પ્લે:}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRB = 0xFF;           // પોર્ટ B ને આઉટપુટ તરીકે
    unsigned char count = 0;
    
    while(1) \{
        PORTB = count;     // LED પર કાઉન્ટ દર્શાવો
        \_delay\_ms(500);    // દૃશ્યતા માટે વિલંબ
        count++;           // કાઉન્ટર વધારો
        if(count {} 0xFF)   // 255 પછી રીસેટ કરો
            count = 0;
    \}
    return 0;
\}
\end{verbatim}

\textbf{બ) શરતી ડેટા ટ્રાન્સફર:}

\begin{verbatim}
\#include {avr/io.h}

int main() \{
    DDRC = 0x00;    // પોર્ટ C ને ઇનપુટ તરીકે
    DDRB = 0xFF;    // પોર્ટ B ને આઉટપુટ તરીકે
    DDRD = 0xFF;    // પોર્ટ D ને આઉટપુટ તરીકે
    
    while(1) \{
        unsigned char data = PINC;  // પોર્ટ C માંથી વાંચો
        
        if(data {} 100) \{
            PORTB = data;           // પોર્ટ B પર મોકલો
            PORTD = 0x00;          // પોર્ટ D સાફ કરો
        \} else \{
            PORTD = data;           // પોર્ટ D પર મોકલો
            PORTB = 0x00;          // પોર્ટ B સાફ કરો
        \}
    \}
    return 0;
\}
\end{verbatim}

\textbf{મુખ્ય પ્રોગ્રામિંગ વિભાવનાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{પોર્ટ દિશા}: DDR રજિસ્ટર્સ ઇનપુટ/આઉટપુટ રૂપરેખાંકિત કરે છે
\item
  \textbf{ડેટા વાંચવું}: PIN રજિસ્ટર્સ ઇનપુટ મૂલ્યો વાંચે છે
\item
  \textbf{શરતી તર્ક}: નિર્ણય લેવા માટે if-else નિવેદનો
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``RCC Data'' - \textbf{R}ead input, \textbf{C}ompare
value, \textbf{C}onditional output

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3 અથવા(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3-uxa85uxaa5uxab5uxa85-3-uxa97uxaa3}

\textbf{-3 થી +3 પોર્ટ B ની કિંમતો મોકલવા માટે AVR C પ્રોગ્રામ લખો}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRB = 0xFF;              // પોર્ટ B ને આઉટપુટ તરીકે
    signed char values[] = \{{-}3, {-}2, {-}1, 0, 1, 2, 3\;}
    unsigned char i = 0;
    
    while(1) \{
        PORTB = values[i];    // પોર્ટ B પર મૂલ્ય મોકલો
        \_delay\_ms(1000);      // 1 સેકન્ડ વિલંબ
        i++;                  // આગલું મૂલ્ય
        if(i {} 6) i = 0;      // ઇન્ડેક્સ રીસેટ કરો
    \}
    return 0;
\}
\end{verbatim}

\textbf{પ્રોગ્રામ વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{સાઇન ડેટા}: નકારાત્મક મૂલ્યો માટે signed char નો ઉપયોગ
\item
  \textbf{અરે સ્ટોરેજ}: સરળ પહોંચ માટે અરેમાં મૂલ્યો સંગ્રહ
\item
  \textbf{ચક્રીય ઓપરેશન}: તમામ મૂલ્યો દ્વારા સતત ચક્ર
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SAC Values'' - \textbf{S}igned char,
\textbf{A}rray storage, \textbf{C}yclic operation

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3 અથવા(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3-uxa85uxaa5uxab5uxaac-4-uxa97uxaa3}

\textbf{ASCII અક્ષરો 0,1,2,3,4,5,A,B,C અને D માટે હેક્સ મૂલ્યો પોર્ટ B પર મોકલવા
માટે AVR C પ્રોગ્રામ લખો.}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRB = 0xFF;    // પોર્ટ B ને આઉટપુટ તરીકે
    
    // ASCII હેક્સ મૂલ્યો અરે
    unsigned char ascii\_values[] = \{
        0x30,  // {0}
        0x31,  // {1 }
        0x32,  // {2}
        0x33,  // {3}
        0x34,  // {4}
        0x35,  // {5}
        0x41,  // {A}
        0x42,  // {B}
        0x43,  // {C}
        0x44   // {D}
    \;}
    
    unsigned char i = 0;
    
    while(1) \{
        PORTB = ascii\_values[i];  // ASCII મૂલ્ય મોકલો
        \_delay\_ms(500);           // વિલંબ
        i++;                      // આગલો અક્ષર
        if(i {} 9) i = 0;          // ઇન્ડેક્સ રીસેટ કરો
    \}
    return 0;
\}
\end{verbatim}

\textbf{ASCII મૂલ્યો ટેબલ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
અક્ષર & હેક્સ મૂલ્ય & બાઇનરી \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
`0' & 0x30 & 00110000 \\
`1' & 0x31 & 00110001 \\
`A' & 0x41 & 01000001 \\
`B' & 0x42 & 01000010 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``HAC ASCII'' - \textbf{H}ex values, \textbf{A}rray
storage, \textbf{C}yclic transmission

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 3 અથવા(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-3-uxa85uxaa5uxab5uxa95-7-uxa97uxaa3}

\textbf{ડોર સેન્સર પોર્ટ B ના બિટ 1 સાથે જોડાયેલ છે, અને LED પોર્ટ C ના બિટ 7
સાથે જોડાયેલ છે. ડોર સેન્સર પર દેખરેખ રાખવા માટે AVR C પ્રોગ્રામ લખો અને જ્યારે તે ખુલે
છે (PIN HIGH છે), LED ચાલુ કરો. ફ્લો ચાર્ટ પણ દોરો.}

\begin{solutionbox}

\textbf{C પ્રોગ્રામ:}

\begin{verbatim}
\#include {avr/io.h}

int main() \{
    DDRB = 0xFD;    // પોર્ટ B બિટ 1 ઇનપુટ તરીકે (0), અન્ય આઉટપુટ (1)
    DDRC = 0xFF;    // પોર્ટ C આઉટપુટ તરીકે
    PORTB = 0x02;   // બિટ 1 માટે પુલ{-અપ સક્ષમ કરો}
    
    while(1) \{
        if(PINB \& 0x02) \{      // તપાસો કે ડોર સેન્સર HIGH છે કે
            PORTC |= 0x80;     // LED ચાલુ કરો (બિટ 7)
        \} else \{
            PORTC \&= 0x7F;     // LED બંધ કરો (બિટ 7)
        \}
    \}
    return 0;
\}
\end{verbatim}

\textbf{ફ્લો ચાર્ટ:}

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Initialize Ports]}
    B {-{-} C[Configure Port B bit 1 as input]}
    C {-{-} D[Configure Port C bit 7 as output]}
    D {-{-} E\{Read Door Sensor\}}
    E {-{-}|HIGH| F[Turn ON LED]}
    E {-{-}|LOW| G[Turn OFF LED]}
    F {-{-} H[Continue Monitoring]}
    G {-{-} H}
    H {-{-} E}
\end{verbatim}

\textbf{બિટ ઓપરેશન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{ઇનપુટ વાંચવું}: \texttt{PINB\ \&\ 0x02} બિટ 1 તપાસે છે
\item
  \textbf{LED નિયંત્રણ}: \texttt{PORTC\ \textbar{}=\ 0x80} બિટ 7 સેટ કરે છે
\item
  \textbf{LED બંધ}: \texttt{PORTC\ \&=\ 0x7F} બિટ 7 સાફ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BIC Door'' - \textbf{B}it manipulation,
\textbf{I}nput monitoring, \textbf{C}onditional LED control

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa85-3-uxa97uxaa3}

\textbf{ADC માટેનું ADMUX રજિસ્ટર સમજાવો}

\begin{solutionbox}

\textbf{ADMUX (ADC મલ્ટિપ્લેક્સર સિલેક્શન રજિસ્ટર):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
બિટ & નામ & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બિટ 7-6} & REFS1:0 & રેફરન્સ સિલેક્શન \\
\textbf{બિટ 5} & ADLAR & ADC લેફ્ટ એડજસ્ટ રિઝલ્ટ \\
\textbf{બિટ 4-0} & MUX4:0 & એનાલોગ ચેનલ સિલેક્શન \\
\end{longtable}
}

\textbf{રેફરન્સ સિલેક્શન (REFS1:0):}

\begin{itemize}
\tightlist
\item
  \textbf{00}: AREF, આંતરિક Vref બંધ
\item
  \textbf{01}: AREF પિન પર બાહ્ય કેપેસિટર સાથે AVCC
\item
  \textbf{10}: આરક્ષિત
\item
  \textbf{11}: આંતરિક 2.56V રેફરન્સ
\end{itemize}

\textbf{ચેનલ સિલેક્શન (MUX4:0):}

\begin{itemize}
\tightlist
\item
  \textbf{00000-00111}: ADC0-ADC7 (સિંગલ-એન્ડેડ ઇનપુટ્સ)
\item
  \textbf{અન્ય કમ્બિનેશન્સ}: ગેઇન સાથે ડિફરન્શિયલ ઇનપુટ્સ
\end{itemize}

\textbf{મુખ્ય કાર્યો:}

\begin{itemize}
\tightlist
\item
  \textbf{વોલ્ટેજ રેફરન્સ}: ADC માપ શ્રેણી નક્કી કરે છે
\item
  \textbf{ચેનલ મલ્ટિપ્લેક્સિંગ}: કયા એનાલોગ ઇનપુટને કન્વર્ટ કરવું તે પસંદ કરે છે
\item
  \textbf{રિઝલ્ટ એલાઇનમેન્ટ}: ડાબું અથવા જમણું જસ્ટિફાઇડ ADC પરિણામ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``RAM ADMUX'' - \textbf{R}eference,
\textbf{A}lignment, \textbf{M}ultiplexer

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxaac-4-uxa97uxaa3}

\textbf{વિવિધ એલસીડી પિન સમજાવો.}

\begin{solutionbox}

\textbf{16x2 LCD પિન રૂપરેખાંકન:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પિન & સિમ્બોલ & કાર્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & VSS & ગ્રાઉન્ડ (0V) \\
\textbf{2} & VDD & પાવર સપ્લાઇ (+5V) \\
\textbf{3} & V0 & કોન્ટ્રાસ્ટ એડજસ્ટમેન્ટ \\
\textbf{4} & RS & રજિસ્ટર સિલેક્ટ (ડેટા/કમાન્ડ) \\
\textbf{5} & R/W & રીડ/રાઇટ સિલેક્ટ \\
\textbf{6} & E & એનેબલ સિગ્નલ \\
\textbf{7-14} & D0-D7 & ડેટા બસ (8-બિટ) \\
\textbf{15} & A & બેકલાઇટ એનોડ (+) \\
\textbf{16} & K & બેકલાઇટ કેથોડ (-) \\
\end{longtable}
}

\textbf{કન્ટ્રોલ પિન કાર્યો:}

\begin{itemize}
\tightlist
\item
  \textbf{RS = 0}: કમાન્ડ રજિસ્ટર પસંદ
\item
  \textbf{RS = 1}: ડેટા રજિસ્ટર પસંદ
\item
  \textbf{R/W = 0}: રાઇટ ઓપરેશન
\item
  \textbf{R/W = 1}: રીડ ઓપરેશન
\item
  \textbf{E}: એનેબલ પલ્સ ઓપરેશન ટ્રિગર કરે છે
\end{itemize}

\textbf{કનેક્શન મોડ્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{8-બિટ મોડ}: બધા ડેટા પિન્સ D0-D7 જોડાયેલા
\item
  \textbf{4-બિટ મોડ}: માત્ર D4-D7 ઉપયોગ (માઇક્રોકન્ટ્રોલર પિન્સ બચાવે છે)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``VCR EDB LCD'' - \textbf{V}power,
\textbf{C}ontrast, \textbf{R}egister select, \textbf{E}nable,
\textbf{D}ata \textbf{B}us

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4uxa95-7-uxa97uxaa3}

\textbf{20µs વિલંબ સાથે PORTB ના તમામ બિટ્સને સતત ટૉગલ કરવા માટે પ્રોગ્રામ લખો.
વિલંબ જનરેટ કરવા માટે Timer0, નોર્મલ મોડ અને કોઈ Prescaler નો ઉપયોગ કરો}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}

void delay\_20us() \{
    TCNT0 = 0;          // ટાઇમર કાઉન્ટર સાફ કરો
    TCCR0 = 0x01;       // કોઈ prescaler નહીં, નોર્મલ મોડ
    while(TCNT0 {} 160); // 20µs માટે રાહ જુઓ (8MHz/1 * 20µs = 160)
    TCCR0 = 0;          // ટાઇમર બંધ કરો
\}

int main() \{
    DDRB = 0xFF;        // પોર્ટ B આઉટપુટ તરીકે
    
    while(1) \{
        PORTB = 0xFF;   // બધા બિટ્સ high સેટ કરો
        delay\_20us();   // 20µs વિલંબ
        PORTB = 0x00;   // બધા બિટ્સ low સેટ કરો
        delay\_20us();   // 20µs વિલંબ
    \}
    return 0;
\}
\end{verbatim}

\textbf{ટાઇમર ગણતરી:}

\begin{itemize}
\tightlist
\item
  \textbf{ક્લોક ફ્રીક્વન્સી}: 8 MHz (ધારણા)
\item
  \textbf{ટાઇમર રીઝોલ્યુશન}: 1/8MHz = 0.125µs પ્રતિ કાઉન્ટ
\item
  \textbf{જરૂરી કાઉન્ટ્સ}: 20µs / 0.125µs = 160 કાઉન્ટ્સ
\end{itemize}

\textbf{Timer0 રૂપરેખાંકન:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
સેટિંગ & મૂલ્ય & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{મોડ} & નોર્મલ & 0 થી 255 સુધી ગણે છે \\
\textbf{Prescaler} & 1 & કોઈ પ્રીસ્કેલિંગ નહીં \\
\textbf{ક્લોક સ્રોત} & સિસ્ટમ ક્લોક & 8 MHz \\
\end{longtable}
}

\textbf{પ્રોગ્રામ ફ્લો:}

\begin{itemize}
\tightlist
\item
  \textbf{પ્રારંભ કરો}: પોર્ટ B ને આઉટપુટ તરીકે સેટ કરો
\item
  \textbf{ટૉગલ high}: PORTB = 0xFF, 20µs રાહ જુઓ
\item
  \textbf{ટૉગલ low}: PORTB = 0x00, 20µs રાહ જુઓ
\item
  \textbf{પુનરાવર્તન}: સતત ઓપરેશન
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TNP Timer'' - \textbf{T}imer0, \textbf{N}ormal
mode, \textbf{P}rescaler none

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4 અથવા(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4-uxa85uxaa5uxab5uxa85-3-uxa97uxaa3}

\textbf{ટૂંકી નોંધ બે વાયર ઇન્ટરફેસ (TWI)}

\begin{solutionbox}

\textbf{TWI (બે વાયર ઇન્ટરફેસ) - I2C પ્રોટોકોલ:}

\textbf{મુખ્ય વિશેષતાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બે વાયર} & SDA (ડેટા) અને SCL (ક્લોક) \\
\textbf{મલ્ટી-માસ્ટર} & બહુવિધ માસ્ટર્સ બસ નિયંત્રિત કરી શકે છે \\
\textbf{મલ્ટી-સ્લેવ} & 127 સુધી સ્લેવ ડિવાઇસ \\
\textbf{સરનામું-આધારિત} & 7-બિટ અથવા 10-બિટ ડિવાઇસ સરનામું \\
\textbf{દ્વિદિશીય} & બંને દિશામાં ડેટા વહે છે \\
\end{longtable}
}

\textbf{બસ લાક્ષણિકતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ઓપન-ડ્રેઇન}: પુલ-અપ રેઝિસ્ટર્સ આવશ્યક (4.7kΩ સામાન્ય)
\item
  \textbf{સિન્ક્રોનસ}: માસ્ટર દ્વારા ક્લોક પ્રદાન કરાય છે
\item
  \textbf{સ્ટાર્ટ/સ્ટોપ કન્ડિશન્સ}: કમ્યુનિકેશન માટે વિશેષ ક્રમ
\end{itemize}

\textbf{સામાન્ય એપ્લિકેશન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{EEPROMs}: નોન-વોલેટાઇલ મેમરી સ્ટોરેજ
\item
  \textbf{RTC મોડ્યુલ્સ}: રીઅલ-ટાઇમ ક્લોક ડિવાઇસ
\item
  \textbf{સેન્સર્સ}: તાપમાન, દબાણ, એક્સેલેરોમીટર
\item
  \textbf{ડિસ્પ્લે કન્ટ્રોલર્સ}: OLED, LCD કન્ટ્રોલર્સ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SDA SCL TWI'' - \textbf{S}erial \textbf{D}ata,
\textbf{S}erial \textbf{CL}ock, \textbf{T}wo \textbf{W}ire
\textbf{I}nterface

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4 અથવા(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4-uxa85uxaa5uxab5uxaac-4-uxa97uxaa3}

\textbf{ADC માટેનું ADCSRA રજિસ્ટર સમજાવો}

\begin{solutionbox}

\textbf{ADCSRA (ADC કન્ટ્રોલ અને સ્ટેટસ રજિસ્ટર A):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
બિટ & નામ & કાર્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{બિટ 7} & ADEN & ADC એનેબલ \\
\textbf{બિટ 6} & ADSC & ADC સ્ટાર્ટ કન્વર્ઝન \\
\textbf{બિટ 5} & ADATE & ADC ઓટો ટ્રિગર એનેબલ \\
\textbf{બિટ 4} & ADIF & ADC ઇન્ટરપ્ટ ફ્લેગ \\
\textbf{બિટ 3} & ADIE & ADC ઇન્ટરપ્ટ એનેબલ \\
\textbf{બિટ 2-0} & ADPS2:0 & ADC પ્રીસ્કેલર સિલેક્ટ \\
\end{longtable}
}

\textbf{પ્રીસ્કેલર સેટિંગ્સ (ADPS2:0):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
બાઇનરી & વિભાજન પરિબળ & ADC ક્લોક (8MHz) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
000 & 2 & 4 MHz \\
001 & 2 & 4 MHz \\
010 & 4 & 2 MHz \\
011 & 8 & 1 MHz \\
100 & 16 & 500 kHz \\
101 & 32 & 250 kHz \\
110 & 64 & 125 kHz \\
111 & 128 & 62.5 kHz \\
\end{longtable}
}

\textbf{કન્ટ્રોલ કાર્યો:}

\begin{itemize}
\tightlist
\item
  \textbf{ADEN}: ADC ઓપરેશન સક્ષમ કરવા માટે સેટ કરવું આવશ્યક
\item
  \textbf{ADSC}: કન્વર્ઝન શરૂ કરવા માટે સેટ કરો, પૂર્ણ થાય ત્યારે સાફ થાય છે
\item
  \textbf{ADIF}: કન્વર્ઝન પૂર્ણ થાય ત્યારે સેટ થાય છે
\item
  \textbf{Prescaler}: શ્રેષ્ઠ ચોકસાઇ માટે ADC ક્લોક 50-200 kHz હોવી જોઈએ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``EASCID ADC'' - \textbf{E}nable,
\textbf{A}uto-trigger, \textbf{S}tart, \textbf{C}onversion,
\textbf{I}nterrupt, \textbf{D}ivider

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 4 અથવા(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-4-uxa85uxaa5uxab5uxa95-7-uxa97uxaa3}

\textbf{PORTC.3 પિન પર 16 Khz ફ્રીક્વન્સીની સ્ક્વેર વેવ જનરેટ કરવા માટે પ્રોગ્રામ
લખો. ક્રિસ્ટલ ફ્રીક્વન્સી 8 Mhz ધારો}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {avr/interrupt.h}

int main() \{
    // PC3 ને આઉટપુટ તરીકે રૂપરેખાંકિત કરો
    DDRC |= (1 {} PC3);
    
    // Timer1 CTC મોડ રૂપરેખાંકન
    TCCR1A = 0x00;                    // નોર્મલ પોર્ટ ઓપરેશન
    TCCR1B = (1 {} WGM12) | (1 {} CS10); // CTC મોડ, કોઈ prescaler નહીં
    
    // 16 kHz માટે OCR1A મૂલ્ય ગણતરી કરો
    // Period = 1/16000 = 62.5µs
    // Half period = 31.25µs  
    // OCR1A = (8MHz * 31.25µs) {- 1 = 249}
    OCR1A = 249;
    
    // Timer1 Compare A ઇન્ટરપ્ટ સક્ષમ કરો
    TIMSK |= (1 {} OCIE1A);
    
    // ગ્લોબલ ઇન્ટરપ્ટ્સ સક્ષમ કરો
    sei();
    
    while(1) \{
        // મુખ્ય લુપ {- ઇન્ટરપ્ટ દ્વારા સ્ક્વેર વેવ જનરેટ}
    \}
    return 0;
\}

// Timer1 Compare A ઇન્ટરપ્ટ સર્વિસ રૂટિન
ISR(TIMER1\_COMPA\_vect) \{
    PORTC \^{=} (1 {} PC3);    // PC3 ટૉગલ કરો
\}
\end{verbatim}

\textbf{ફ્રીક્વન્સી ગણતરી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પેરામીટર & મૂલ્ય & ફોર્મ્યુલા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{ટાર્ગેટ ફ્રીક્વન્સી} & 16 kHz & આપેલ \\
\textbf{Period} & 62.5 µs & 1/16000 \\
\textbf{Half period} & 31.25 µs & Period/2 \\
\textbf{ટાઇમર કાઉન્ટ્સ} & 250 & 8MHz \times 31.25µs \\
\textbf{OCR1A મૂલ્ય} & 249 & કાઉન્ટ્સ - 1 \\
\end{longtable}
}

\textbf{ટાઇમર રૂપરેખાંકન:}

\begin{itemize}
\tightlist
\item
  \textbf{મોડ}: CTC (Clear Timer on Compare)
\item
  \textbf{Prescaler}: 1 (કોઈ પ્રીસ્કેલિંગ નહીં)
\item
  \textbf{ઇન્ટરપ્ટ}: કમ્પેર મેચ આઉટપુટ પિન ટૉગલ કરે છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CTC Square'' - \textbf{C}TC mode, \textbf{T}imer
interrupt, \textbf{C}ompare match

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa85-3-uxa97uxaa3}

\textbf{Polling અને Interrupt વચ્ચેનો તફાવત}

\begin{solutionbox}

\textbf{Polling વિ Interrupt સરખામણી:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
પાસું
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Polling
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Interrupt
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{CPU ઉપયોગ} & સતત સ્ટેટસ તપાસે છે & ઇવેન્ટ થાય ત્યાં સુધી CPU મુક્ત \\
\textbf{પ્રતિસાદ સમય} & વેરિએબલ, પોલિંગ ફ્રીક્વન્સી પર આધાર રાખે છે & ઝડપી,
તાત્કાલિક પ્રતિસાદ \\
\textbf{પાવર વપરાશ} & સતત તપાસવાને કારણે વધારે & ઓછું, CPU સ્લીપ કરી શકે છે \\
\textbf{પ્રોગ્રામિંગ} & સરળ, અનુક્રમિક કોડ & જટિલ, ISR આવશ્યક \\
\textbf{રીઅલ-ટાઇમ} & નિર્ણાયક ટાઇમિંગ માટે યોગ્ય નથી & રીઅલ-ટાઇમ સિસ્ટમ્સ માટે
ઉત્તમ \\
\end{longtable}
}

\textbf{મુખ્ય તફાવતો:}

\begin{itemize}
\tightlist
\item
  \textbf{કાર્યક્ષમતા}: ઇન્ટરપ્ટ્સ વધુ CPU કાર્યક્ષમ છે
\item
  \textbf{ટાઇમિંગ}: ઇન્ટરપ્ટ્સ નિર્ધારિત પ્રતિસાદ પ્રદાન કરે છે
\item
  \textbf{જટિલતા}: પોલિંગ અમલીકરણ અને ડિબગ કરવામાં સરળ છે
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PIE Method'' - \textbf{P}olling inefficient,
\textbf{I}nterrupt efficient, \textbf{E}vent-driven

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxaac-4-uxa97uxaa3}

\textbf{AVR ATmega32 સાથે LM35 ઇન્ટરફેસ સમજાવો.}

\begin{solutionbox}

\textbf{LM35 તાપમાન સેન્સર ઇન્ટરફેસ:}

\begin{verbatim}
    +5V {-{-}{-}{-}+}
            |
        +{-{-}{-}+{-}{-}{-}+}
        |  LM35 |
        |       |
        +{-{-}{-}+{-}{-}{-}+}
            |
            +{-{-}{-}{-} To ADC Pin (PA0)}
\end{verbatim}

\textbf{LM35 લાક્ષણિકતાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
પેરામીટર & મૂલ્ય & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{આઉટપુટ} & 10mV/^\circC & લિનિયર તાપમાન ગુણાંક \\
\textbf{શ્રેણી} & 0^\circC to 100^\circC & ઓપરેટિંગ તાપમાન શ્રેણી \\
\textbf{સપ્લાઇ} & 4V to 30V & પાવર સપ્લાઇ શ્રેણી \\
\textbf{ચોકસાઇ} & \pm0.5^\circC & તાપમાન ચોકસાઇ \\
\end{longtable}
}

\textbf{ઇન્ટરફેસ કોડ:}

\begin{verbatim}
\#include {avr/io.h}

void ADC\_init() \{
    ADMUX = 0x40;   // AVCC રેફરન્સ, ADC0 ચેનલ
    ADCSRA = 0x87;  // ADC સક્ષમ કરો, prescaler 128
\}

unsigned int read\_temperature() \{
    ADCSRA |= (1 {} ADSC);      // કન્વર્ઝન શરૂ કરો
    while(ADCSRA \& (1 {} ADSC)); // પૂર્ણતા માટે રાહ જુઓ
    
    // ADC મૂલ્યને તાપમાનમાં કન્વર્ટ કરો
    // Temperature = (ADC * 5000) / (1024 * 10)
    unsigned int temp = (ADC * 5000) / 10240;
    return temp;
\}
\end{verbatim}

\textbf{ગણતરી:}

\begin{itemize}
\tightlist
\item
  \textbf{ADC રીઝોલ્યુશન}: 10-બિટ (0-1023)
\item
  \textbf{રેફરન્સ વોલ્ટેજ}: 5V
\item
  \textbf{LM35 સ્કેલ}: 10mV/^\circC
\item
  \textbf{ફોર્મ્યુલા}: Temperature = (ADC\_Value \times 5000mV) / (1024 \times
  10mV/^\circC)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``LAC Temperature'' - \textbf{L}M35 sensor,
\textbf{A}DC conversion, \textbf{C}alculation formula

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5uxa95-7-uxa97uxaa3}

\textbf{AVR ATmega32 સાથે DC મોટરને ઇન્ટરફેસ કરવા માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}

\textbf{DC મોટર ઇન્ટરફેસ સર્કિટ:}

\begin{verbatim}
    ATmega32                L293D Motor Driver              DC Motor
    +{-{-}{-}{-}{-}{-}{-}{-}+            +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+              +{-}{-}{-}{-}{-}{-}{-}+}
    |  PD5   |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN1         O1 |{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}|   +   |}
    |  PD6   |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN2         O2 |{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}|   {-}   |}
    |  PD4   |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}| EN1            |              +{-}{-}{-}{-}{-}{-}{-}+}
    +{-{-}{-}{-}{-}{-}{-}{-}+            +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
                          |                |
                         +5V              GND
\end{verbatim}

\textbf{મોટર કન્ટ્રોલ પ્રોગ્રામ:}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

void motor\_init() \{
    DDRD |= (1 {} PD4) | (1 {} PD5) | (1 {} PD6); // આઉટપુટ તરીકે સેટ કરો
\}

void motor\_forward() \{
    PORTD |= (1 {} PD4);   // મોટર સક્ષમ કરો
    PORTD |= (1 {} PD5);   // IN1 = 1
    PORTD \&= {(}1 {} PD6);  // IN2 = 0
\}

void motor\_reverse() \{
    PORTD |= (1 {} PD4);   // મોટર સક્ષમ કરો
    PORTD \&= {(}1 {} PD5);  // IN1 = 0
    PORTD |= (1 {} PD6);   // IN2 = 1
\}

void motor\_stop() \{
    PORTD \&= {(}1 {} PD4);  // મોટર અક્ષમ કરો
\}

int main() \{
    motor\_init();
    
    while(1) \{
        motor\_forward();    // 2 સેકન્ડ માટે આગળ
        \_delay\_ms(2000);
        
        motor\_stop();       // 1 સેકન્ડ માટે બંધ
        \_delay\_ms(1000);
        
        motor\_reverse();    // 2 સેકન્ડ માટે પાછળ
        \_delay\_ms(2000);
        
        motor\_stop();       // 1 સેકન્ડ માટે બંધ
        \_delay\_ms(1000);
    \}
    return 0;
\}
\end{verbatim}

\textbf{L293D Truth Table:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
EN & IN1 & IN2 & મોટર ક્રિયા \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & X & X & બંધ \\
1 & 0 & 0 & બંધ \\
1 & 0 & 1 & રિવર્સ \\
1 & 1 & 0 & ફોરવર્ડ \\
1 & 1 & 1 & બંધ \\
\end{longtable}
}

\textbf{મુખ્ય ઘટકો:}

\begin{itemize}
\tightlist
\item
  \textbf{L293D}: ડ્યુઅલ H-બ્રિજ મોટર ડ્રાઇવર IC
\item
  \textbf{એનેબલ પિન}: મોટર પાવર નિયંત્રિત કરે છે
\item
  \textbf{દિશા પિન્સ}: IN1, IN2 રોટેશન દિશા નિયંત્રિત કરે છે
\item
  \textbf{પ્રોટેક્શન}: બેક EMF પ્રોટેક્શન માટે બિલ્ટ-ઇન ડાયોડ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``LED Motor'' - \textbf{L}293D driver,
\textbf{E}nable control, \textbf{D}irection pins

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5 અથવા(અ) [3
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5-uxa85uxaa5uxab5uxa85-3-uxa97uxaa3}

\textbf{GSM આધારિત સિક્યુરિટી સિસ્ટમના બેઝિક બ્લોક ડાયાગ્રામ સમજાવો.}

\begin{solutionbox}

\textbf{GSM સિક્યુરિટી સિસ્ટમ બ્લોક ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Sensors] {-{-}{} B[ATmega32 Microcontroller]}
    B {-{-}{} C[GSM Module]}
    C {-{-}{} D[Mobile Network]}
    D {-{-}{} E[User Mobile Phone]}
    B {-{-}{} F[Alarm/Buzzer]}
    B {-{-}{} G[LCD Display]}
    H[Power Supply] {-{-}{} B}
    H {-{-}{} C}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{સિસ્ટમ ઘટકો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઘટક & કાર્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{સેન્સર્સ} & PIR, દરવાજા/બારી સેન્સર્સ, ધુમાડો ડિટેક્ટર \\
\textbf{માઇક્રોકન્ટ્રોલર} & સેન્સર ડેટા પ્રોસેસ કરે છે, સિસ્ટમ નિયંત્રિત કરે છે \\
\textbf{GSM મોડ્યુલ} & SMS અલર્ટ મોકલે છે, કોલ કરે છે \\
\textbf{ડિસ્પ્લે} & સિસ્ટમ સ્ટેટસ બતાવે છે \\
\textbf{અલાર્મ} & સ્થાનિક ઓડિયો/વિઝ્યુઅલ અલર્ટ \\
\end{longtable}
}

\textbf{કાર્યકારી સિદ્ધાંત:}

\begin{itemize}
\tightlist
\item
  \textbf{સેન્સર મોનિટરિંગ}: સુરક્ષા ઝોનની સતત દેખરેખ
\item
  \textbf{ઇવેન્ટ ડિટેક્શન}: અનધિકૃત પ્રવેશ શોધાયા પર ટ્રિગર
\item
  \textbf{અલર્ટ જનરેશન}: પૂર્વનિર્ધારિત નંબરો પર SMS મોકલવામાં આવે છે
\item
  \textbf{સ્થાનિક અલાર્મ}: તાત્કાલિક ઓડિયો/વિઝ્યુઅલ ચેતવણી
\end{itemize}

\textbf{મુખ્ય વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{રિમોટ મોનિટરિંગ}: SMS દ્વારા રીઅલ-ટાઇમ અલર્ટ
\item
  \textbf{બહુવિધ સેન્સર્સ}: વિવિધ ઘૂસણખોરી શોધ પદ્ધતિઓ
\item
  \textbf{બેકઅપ પાવર}: પાવર નિષ્ફળતા માટે બેટરી બેકઅપ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SGMA Security'' - \textbf{S}ensors, \textbf{G}SM
module, \textbf{M}icrocontroller, \textbf{A}lerts

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5 અથવા(બ) [4
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5-uxa85uxaa5uxab5uxaac-4-uxa97uxaa3}

\textbf{AVR ATmega32 સાથે રિલે ઇન્ટરફેસ સમજાવો.}

\begin{solutionbox}

\textbf{રિલે ઇન્ટરફેસ સર્કિટ:}

\begin{verbatim}
    ATmega32              ULN2803           Relay        Load
    +{-{-}{-}{-}{-}{-}{-}{-}+           +{-}{-}{-}{-}{-}{-}{-}{-}+        +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}+}
    |   PB0  |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN1 O1 |{-}{-}{-}{-}{-}{-}{-}| COM |{-}{-}{-}{-}| AC   |}
    |   PB1  |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN2 O2 |{-}{-}{-}{-}{-}{-}{-}| NO  |     | Load |}
    +{-{-}{-}{-}{-}{-}{-}{-}+           +{-}{-}{-}{-}{-}{-}{-}{-}+        +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}+}
                         |        |
                        GND      +12V
\end{verbatim}

\textbf{રિલે ઇન્ટરફેસ કોડ:}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

void relay\_init() \{
    DDRB |= (1 {} PB0) | (1 {} PB1); // આઉટપુટ પિન્સ તરીકે સેટ કરો
\}

void relay1\_on() \{
    PORTB |= (1 {} PB0);  // રિલે 1 સક્રિય કરો
\}

void relay1\_off() \{
    PORTB \&= {(}1 {} PB0); // રિલે 1 નિષ્ક્રિય કરો
\}

void relay2\_on() \{
    PORTB |= (1 {} PB1);  // રિલે 2 સક્રિય કરો
\}

void relay2\_off() \{
    PORTB \&= {(}1 {} PB1); // રિલે 2 નિષ્ક્રિય કરો
\}

int main() \{
    relay\_init();
    
    while(1) \{
        relay1\_on();        // રિલે 1 ચાલુ કરો
        \_delay\_ms(2000);
        relay1\_off();       // રિલે 1 બંધ કરો
        
        relay2\_on();        // રિલે 2 ચાલુ કરો
        \_delay\_ms(2000);
        relay2\_off();       // રિલે 2 બંધ કરો
        
        \_delay\_ms(1000);
    \}
    return 0;
\}
\end{verbatim}

\textbf{ULN2803 વિશેષતાઓ:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
વિશેષતા & વર્ણન \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{8 ચેનલ્સ} & આઠ ડાર્લિંગ્ટન પેર ડ્રાઇવર્સ \\
\textbf{હાઇ કરન્ટ} & ચેનલ દીઠ 500mA સુધી \\
\textbf{પ્રોટેક્શન} & બિલ્ટ-ઇન ફ્લાયબેક ડાયોડ \\
\textbf{ઇનપુટ વોલ્ટેજ} & 5V TTL સુસંગત \\
\textbf{આઉટપુટ વોલ્ટેજ} & 50V સુધી \\
\end{longtable}
}

\textbf{એપ્લિકેશન્સ:}

\begin{itemize}
\tightlist
\item
  \textbf{હોમ ઓટોમેશન}: લાઇટ, ફેન કન્ટ્રોલ
\item
  \textbf{ઇન્ડસ્ટ્રિયલ કન્ટ્રોલ}: મોટર, વાલ્વ ઓપરેશન
\item
  \textbf{સિક્યુરિટી સિસ્ટમ્સ}: દરવાજા લોક, અલાર્મ
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ULN Relay'' - \textbf{U}LN2803 driver,
\textbf{L}oad control, \textbf{N}on-contact switching

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{પ્રશ્ન 5 અથવા(ક) [7
ગુણ]}\label{uxaaauxab0uxab6uxaa8-5-uxa85uxaa5uxab5uxa95-7-uxa97uxaa3}

\textbf{ઓટોમેટિક જ્યુસ વેન્ડિંગ મશીન દોરો અને સમજાવો}

\begin{solutionbox}

\textbf{ઓટોમેટિક જ્યુસ વેન્ડિંગ મશીન બ્લોક ડાયાગ્રામ:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[Coin Sensor] {-{-}{} B[ATmega32 Controller]}
    C[Keypad] {-{-}{} B}
    D[LCD Display] {-{-}{} B}
    B {-{-}{} E[Pump Motors]}
    B {-{-}{} F[Solenoid Valves]}
    B {-{-}{} G[Coin Return Mechanism]}
    H[Level Sensors] {-{-}{} B}
    I[Power Supply] {-{-}{} B}
    J[Juice Containers] {-{-}{} E}
    E {-{-}{} K[Dispensing Unit]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{સિસ્ટમ ઘટકો:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
ઘટક & કાર્ય \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{કોઇન સેન્સર} & દાખલ કરેલા સિક્કાઓ શોધે છે અને માન્ય કરે છે \\
\textbf{કીપેડ} & યુઝર સિલેક્શન ઇન્ટરફેસ (4x4 મેટ્રિક્સ) \\
\textbf{LCD ડિસ્પ્લે} & મેનુ, કિંમત, સ્ટેટસ મેસેજ બતાવે છે \\
\textbf{પંપ મોટર્સ} & પસંદ કરેલ જ્યુસ વિતરિત કરે છે \\
\textbf{સોલેનોઇડ વાલ્વ} & જ્યુસ ફ્લો કન્ટ્રોલ કરે છે \\
\textbf{લેવલ સેન્સર્સ} & જ્યુસ કન્ટેનર લેવલ મોનિટર કરે છે \\
\textbf{કોઇન રિટર્ન} & વધારાના પૈસા પરત કરે છે \\
\end{longtable}
}

\textbf{સિસ્ટમ ઓપરેશન:}

\begin{enumerate}
\tightlist
\item
  \textbf{ઇનિશિયલાઇઝેશન}: સ્વાગત સંદેશ અને જ્યુસ મેનુ દર્શાવો
\item
  \textbf{કોઇન ઇનપુટ}: યુઝર સિક્કાઓ દાખલ કરે છે, સિસ્ટમ રકમ માન્ય કરે છે
\item
  \textbf{સિલેક્શન}: યુઝર જ્યુસ પ્રકાર પસંદ કરવા માટે કીપેડ દબાવે છે
\item
  \textbf{વેલિડેશન}: પૂરતા પૈસા અને જ્યુસ ઉપલબ્ધ છે કે કેમ તપાસો
\item
  \textbf{ડિસ્પેન્સિંગ}: પસંદ કરેલ જ્યુસ માટે પંપ અને વાલ્વ સક્રિય કરો
\item
  \textbf{પૂર્ણતા}: જો કોઈ બાકી રકમ હોય તો પરત કરો, આભાર સંદેશ દર્શાવો
\end{enumerate}

\textbf{કન્ટ્રોલ લોજિક:}

\begin{verbatim}
// વેન્ડિંગ મશીન ઓપરેશન માટે સ્યુડો કોડ
void vending\_machine() \{
    display\_menu();
    
    while(1) \{
        if(coin\_inserted()) \{
            total\_amount += validate\_coin();
            update\_display();
        \}
        
        if(selection\_made()) \{
            juice\_type = get\_selection();
            if(total\_amount {=} juice\_price[juice\_type]) \{
                if(juice\_available[juice\_type]) \{
                    dispense\_juice(juice\_type);
                    return\_change();
                    reset\_system();
                \} else \{
                    display\_error("Stock Nathi");
                \}
            \} else \{
                display\_error("Nakafi Rakam");
            \}
        \}
    \}
\}
\end{verbatim}

\textbf{મુખ્ય વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{બહુવિધ જ્યુસ પ્રકારો}: 4-6 વિવિધ ફ્લેવર્સ
\item
  \textbf{ઓટોમેટિક ડિસ્પેન્સિંગ}: ચોક્કસ વોલ્યુમ કન્ટ્રોલ
\item
  \textbf{ચેન્જ રિટર્ન}: ચોક્કસ બાકી રકમ ગણે છે અને પરત કરે છે
\item
  \textbf{ઇન્વેન્ટરી ટ્રેકિંગ}: જ્યુસ લેવલ મોનિટર કરે છે
\item
  \textbf{એરર હેન્ડલિંગ}: વિવિધ ફોલ્ટ કન્ડિશન્સ હેન્ડલ કરે છે
\end{itemize}

\textbf{સેફ્ટી વિશેષતાઓ:}

\begin{itemize}
\tightlist
\item
  \textbf{ઓવર-ડિસ્પેન્સિંગ પ્રોટેક્શન}: ટાઇમર-આધારિત પંપ કન્ટ્રોલ
\item
  \textbf{કોઇન વેલિડેશન}: નકલી સિક્કા સ્વીકારવાનું અટકાવે છે
\item
  \textbf{લેવલ મોનિટરિંગ}: પંપના ડ્રાય રનિંગને અટકાવે છે
\item
  \textbf{ઇમર્જન્સી સ્ટોપ}: મેન્યુઅલ ઓવરરાઇડ ક્ષમતા
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CLPDV Juice'' - \textbf{C}oin sensor, \textbf{L}CD
display, \textbf{P}ump motors, \textbf{D}ispensing unit, \textbf{V}alve
control

\end{mnemonicbox}

\end{document}
