\documentclass[10pt,a4paper]{article}
\input{../../../../../../latex-templates/gtu-solutions/preamble.tex}
\input{../../../../../../latex-templates/gtu-solutions/english-boxes.tex}

\begin{document}

\begin{center}
{\Huge\bfseries\color{headcolor} Subject Name Solutions}\\[5pt]
{\LARGE 4351102 -- Summer 2024}\\[3pt]
{\large Semester 1 Study Material}\\[3pt]
{\normalsize\textit{Detailed Solutions and Explanations}}
\end{center}

\vspace{10pt}

\subsection*{Question 1(a) [3 marks]}\label{q1a}

\textbf{What is the definition of an embedded system? Provide an example
of an embedded system.}

\begin{solutionbox}
An \textbf{embedded system} is a specialized computer
system designed to perform specific tasks with dedicated functions. It
combines hardware and software components that are integrated into a
larger system.

\textbf{Key Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Real-time operation}: Responds to inputs within specified time
  limits
\item
  \textbf{Dedicated function}: Designed for specific applications
\item
  \textbf{Resource constraints}: Limited memory, power, and processing
  capabilities
\end{itemize}

\textbf{Example}: Washing machine controller that manages wash cycles,
water temperature, and timing automatically.

\end{solutionbox}
\begin{mnemonicbox}
``SMART Embedded'' - \textbf{S}pecialized,
\textbf{M}icroprocessor-based, \textbf{A}pplication-specific,
\textbf{R}eal-time, \textbf{T}ask-oriented

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(b) [4 marks]}\label{q1b}

\textbf{Define a Real-Time Operating System (RTOS) and list three
characteristics of RTOS.}

\begin{solutionbox}
\textbf{RTOS} is an operating system designed to handle
real-time applications where timing constraints are critical for system
operation.

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Characteristic
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Deterministic Response} & Guaranteed response time for critical
tasks \\
\textbf{Priority-based Scheduling} & High-priority tasks execute before
low-priority tasks \\
\textbf{Multitasking Support} & Multiple tasks can run concurrently \\
\end{longtable}
}

\textbf{Additional Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Task management}: Efficiently handles multiple concurrent
  processes
\item
  \textbf{Interrupt handling}: Quick response to external events
\item
  \textbf{Memory management}: Optimized for embedded applications
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DPM RTOS'' - \textbf{D}eterministic,
\textbf{P}riority-based, \textbf{M}ultitasking

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c) [7 marks]}\label{q1c}

\textbf{a) Draw the general block diagram of Embedded System} \textbf{b)
Explain the criteria for choosing a microcontroller for an embedded
system.}

\begin{solutionbox}

\textbf{a) General Block Diagram:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Input Devices] {-{-}{} B[Microcontroller/Processor]}
    B {-{-}{} C[Output Devices]}
    B {-{-}{} D[Memory System]}
    D {-{-}{} B}
    B {-{-}{} E[Communication Interface]}
    F[Power Supply] {-{-}{} B}
    G[Clock/Timer] {-{-}{} B}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{b) Microcontroller Selection Criteria:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Criteria & Considerations \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Processing Speed} & Clock frequency, instruction execution
time \\
\textbf{Memory Requirements} & Flash, RAM, EEPROM capacity \\
\textbf{I/O Capabilities} & Number of pins, special functions \\
\textbf{Power Consumption} & Battery life, sleep modes \\
\textbf{Cost} & Budget constraints, volume pricing \\
\textbf{Development Tools} & Compiler, debugger availability \\
\end{longtable}
}

\textbf{Key Factors:}

\begin{itemize}
\tightlist
\item
  \textbf{Performance requirements}: Processing speed and real-time
  constraints
\item
  \textbf{Interface needs}: ADC, PWM, communication protocols
\item
  \textbf{Environmental conditions}: Operating temperature, humidity
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PMPICD Selection'' - \textbf{P}erformance,
\textbf{M}emory, \textbf{P}ower, \textbf{I}nterface, \textbf{C}ost,
\textbf{D}evelopment tools

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 1(c) OR [7
marks]}\label{q1c}

\textbf{Explain the pin configuration of the ATmega32.}

\begin{solutionbox}
ATmega32 is a 40-pin microcontroller with four 8-bit
I/O ports and various special function pins.

\textbf{Port Configuration:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Port & Pins & Functions \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Port A} & PA0-PA7 & ADC channels, general I/O \\
\textbf{Port B} & PB0-PB7 & SPI, PWM, external interrupts \\
\textbf{Port C} & PC0-PC7 & TWI, general I/O \\
\textbf{Port D} & PD0-PD7 & USART, external interrupts, PWM \\
\end{longtable}
}

\textbf{Special Pins:}

\begin{itemize}
\tightlist
\item
  \textbf{VCC/GND}: Power supply pins
\item
  \textbf{AVCC/AGND}: Analog power supply for ADC
\item
  \textbf{XTAL1/XTAL2}: Crystal oscillator connections
\item
  \textbf{RESET}: Active low reset input
\item
  \textbf{AREF}: ADC reference voltage
\end{itemize}

\textbf{Pin Functions:}

\begin{itemize}
\tightlist
\item
  \textbf{Dual-purpose pins}: Most pins have alternate functions
\item
  \textbf{Input/Output capability}: All port pins are bidirectional
\item
  \textbf{Internal pull-up}: Software configurable for input pins
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ABCD Ports'' - \textbf{A}DC, \textbf{B}us
interfaces, \textbf{C}ommunication, \textbf{D}ata transfer

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(a) [3 marks]}\label{q2a}

\textbf{Explain the data memory architecture of ATMEGA32.}

\begin{solutionbox}
ATmega32 data memory consists of three sections
organized in a unified address space.

\textbf{Memory Organization:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Section
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Address Range
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Size
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{General Registers} & 0x00-0x1F & 32 bytes & Working registers
R0-R31 \\
\textbf{I/O Registers} & 0x20-0x5F & 64 bytes & Control and status
registers \\
\textbf{Internal SRAM} & 0x60-0x45F & 2048 bytes & Data storage and
stack \\
\end{longtable}
}

\textbf{Key Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Unified addressing}: All memory accessible through single
  address space
\item
  \textbf{Register file}: R0-R31 for arithmetic and logic operations
\item
  \textbf{Stack pointer}: Points to top of stack in SRAM
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``GIS Memory'' - \textbf{G}eneral registers,
\textbf{I}O registers, \textbf{S}RAM

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(b) [4 marks]}\label{q2b}

\textbf{Explain the Program Status Word.}

\begin{solutionbox}
\textbf{SREG (Status Register)} contains flags that
reflect the result of arithmetic and logic operations.

\textbf{SREG Bit Configuration:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Bit & Flag & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Bit 7} & I & Global Interrupt Enable \\
\textbf{Bit 6} & T & Bit Copy Storage \\
\textbf{Bit 5} & H & Half Carry Flag \\
\textbf{Bit 4} & S & Sign Flag \\
\textbf{Bit 3} & V & Overflow Flag \\
\textbf{Bit 2} & N & Negative Flag \\
\textbf{Bit 1} & Z & Zero Flag \\
\textbf{Bit 0} & C & Carry Flag \\
\end{longtable}
}

\textbf{Flag Functions:}

\begin{itemize}
\tightlist
\item
  \textbf{Arithmetic operations}: C, Z, N, V, H flags updated
  automatically
\item
  \textbf{Conditional branching}: Flags used for decision making
\item
  \textbf{Interrupt control}: I flag enables/disables global interrupts
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``I THSVNZC'' - \textbf{I}nterrupt,
\textbf{T}ransfer, \textbf{H}alf-carry, \textbf{S}ign,
o\textbf{V}erflow, \textbf{N}egative, \textbf{Z}ero, \textbf{C}arry

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2(c) [7 marks]}\label{q2c}

\textbf{Draw and explain the architecture of ATMEGA32.}

\begin{solutionbox}

\textbf{ATmega32 Architecture:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[Program Memory 32KB] {-{-}{} B[Instruction Decoder]}
    B {-{-}{} C[ALU]}
    C {-{-}{} D[Register File R0{-}R31]}
    D {-{-}{} E[I/O Registers]}
    E {-{-}{} F[Data Memory 2KB SRAM]}
    G[EEPROM 1KB] {-{-}{} E}
    H[Timers/Counters] {-{-}{} E}
    I[ADC] {-{-}{} E}
    J[USART] {-{-}{} E}
    K[SPI] {-{-}{} E}
    L[TWI] {-{-}{} E}
    M[Interrupt Unit] {-{-}{} B}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{Architecture Components:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Component & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Harvard Architecture} & Separate program and data memory
buses \\
\textbf{RISC Core} & 131 instructions, mostly single-cycle execution \\
\textbf{ALU} & 8-bit arithmetic and logic operations \\
\textbf{Register File} & 32 \times 8-bit working registers \\
\end{longtable}
}

\textbf{Memory System:}

\begin{itemize}
\tightlist
\item
  \textbf{Program memory}: 32KB Flash for storing instructions
\item
  \textbf{Data memory}: 2KB SRAM for variables and stack
\item
  \textbf{EEPROM}: 1KB non-volatile data storage
\end{itemize}

\textbf{Peripheral Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Three timer/counters}: 8-bit and 16-bit timers
\item
  \textbf{8-channel ADC}: 10-bit resolution
\item
  \textbf{Communication interfaces}: USART, SPI, TWI
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``HRAM Micro'' - \textbf{H}arvard architecture,
\textbf{R}ISC core, \textbf{A}LU, \textbf{M}emory system

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2 OR(a) [3
marks]}\label{question-2-ora-3-marks}

\textbf{Explain Program Counter of ATMEGA32.}

\begin{solutionbox}
\textbf{Program Counter (PC)} is a 16-bit register that
holds the address of the next instruction to be executed.

\textbf{PC Characteristics:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Size} & 16-bit (can address 64KB program memory) \\
\textbf{Reset Value} & 0x0000 (starts execution from beginning) \\
\textbf{Increment} & Automatically incremented after instruction
fetch \\
\textbf{Jump/Branch} & Modified by jump, branch, and call
instructions \\
\end{longtable}
}

\textbf{PC Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{Sequential execution}: PC increments by 1 for most
  instructions
\item
  \textbf{Branch instructions}: PC loaded with target address
\item
  \textbf{Interrupt handling}: PC saved on stack, loaded with interrupt
  vector
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SRIB PC'' - \textbf{S}equential, \textbf{R}eset,
\textbf{I}ncrement, \textbf{B}ranch

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2 OR(b) [4
marks]}\label{question-2-orb-4-marks}

\textbf{Explain the role of clock and reset circuits in an AVR
microcontroller.}

\begin{solutionbox}

\textbf{Clock System:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Clock Source & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{External Crystal} & High accuracy, 1-16 MHz typical \\
\textbf{Internal RC} & Built-in 8 MHz oscillator \\
\textbf{External Clock} & External clock signal input \\
\textbf{Low-frequency Crystal} & 32.768 kHz for RTC applications \\
\end{longtable}
}

\textbf{Reset Circuit Functions:}

\begin{itemize}
\tightlist
\item
  \textbf{Power-on Reset}: Automatic reset when power is applied
\item
  \textbf{Brown-out Reset}: Reset when supply voltage drops
\item
  \textbf{External Reset}: Manual reset through RESET pin
\item
  \textbf{Watchdog Reset}: Reset from watchdog timer timeout
\end{itemize}

\textbf{Key Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Clock distribution}: System clock drives CPU and peripherals
\item
  \textbf{Reset sequence}: Initializes all registers to default values
\item
  \textbf{Fuse bits}: Configure clock source and reset options
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CEIL Clock'' - \textbf{C}rystal, \textbf{E}xternal,
\textbf{I}nternal, \textbf{L}ow-frequency

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 2 OR(c) [7
marks]}\label{question-2-orc-7-marks}

\textbf{Explain TCCRn and TIFR Timer Register}

\begin{solutionbox}

\textbf{TCCRn (Timer/Counter Control Register):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Register & Function \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{TCCR0} & Controls Timer0 operation mode \\
\textbf{TCCR1A/B} & Controls Timer1 (16-bit) operation \\
\textbf{TCCR2} & Controls Timer2 operation mode \\
\end{longtable}
}

\textbf{TCCR Bit Functions:}

\begin{itemize}
\tightlist
\item
  \textbf{Clock Select (CS)}: Selects clock source and prescaler
\item
  \textbf{Waveform Generation (WGM)}: Sets timer mode (Normal, CTC, PWM)
\item
  \textbf{Compare Output Mode (COM)}: Controls output pin behavior
\end{itemize}

\textbf{TIFR (Timer Interrupt Flag Register):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Bit & Flag & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{TOV} & Timer Overflow & Set when timer overflows \\
\textbf{OCF} & Output Compare & Set when compare match occurs \\
\textbf{ICF} & Input Capture & Set when input capture event occurs \\
\end{longtable}
}

\textbf{Timer Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{Mode selection}: Normal, CTC, Fast PWM, Phase Correct PWM
\item
  \textbf{Interrupt generation}: Flags trigger interrupts when enabled
\item
  \textbf{Output generation}: PWM signals for motor control, LED dimming
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TCCR WGM'' - \textbf{T}imer \textbf{C}ontrol,
\textbf{C}lock, \textbf{R}egister, \textbf{W}aveform \textbf{G}eneration
\textbf{M}ode

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(a) [3 marks]}\label{q3a}

\textbf{Distinguish different data types for programming AVR in C.}

\begin{solutionbox}

\textbf{AVR C Data Types:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Data Type & Size & Range & Usage \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{char} & 8-bit & -128 to 127 & Characters, small integers \\
\textbf{unsigned char} & 8-bit & 0 to 255 & Port values, flags \\
\textbf{int} & 16-bit & -32768 to 32767 & General integers \\
\textbf{unsigned int} & 16-bit & 0 to 65535 & Counters, addresses \\
\textbf{long} & 32-bit & -2^{3}^{1} to 2^{3}^{1}-1 & Large calculations \\
\textbf{float} & 32-bit & \pm3.4\times10^{3}^{8} & Decimal calculations \\
\end{longtable}
}

\textbf{Special Considerations:}

\begin{itemize}
\tightlist
\item
  \textbf{Memory efficient}: Use smallest suitable data type
\item
  \textbf{Port operations}: unsigned char for 8-bit ports
\item
  \textbf{Timing calculations}: unsigned int for timer values
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CUIL Float'' - \textbf{C}har, \textbf{U}nsigned,
\textbf{I}nt, \textbf{L}ong, \textbf{Float}

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(b) [4 marks]}\label{q3b}

\textbf{Write a C program to toggle all the bits of Port C 200 times.}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRC = 0xFF;        // Set Port C as output
    unsigned int count = 0;
    
    while(count {} 200) \{
        PORTC = 0xFF;   // Set all bits high
        \_delay\_ms(100); // Delay
        PORTC = 0x00;   // Set all bits low  
        \_delay\_ms(100); // Delay
        count++;        // Increment counter
    \}
    return 0;
\}
\end{verbatim}

\textbf{Program Explanation:}

\begin{itemize}
\tightlist
\item
  \textbf{DDRC = 0xFF}: Configures all Port C pins as outputs
\item
  \textbf{Toggle operation}: Alternates between 0xFF and 0x00
\item
  \textbf{Counter}: Tracks number of toggle cycles
\item
  \textbf{Delay}: Provides visible timing for toggle operation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``DTC Loop'' - \textbf{D}DR setup, \textbf{T}oggle
bits, \textbf{C}ount iterations, \textbf{L}oop control

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3(c) [7 marks]}\label{q3c}

\textbf{a) LED are connected to Pins of PORTB. Write an AVR programs to
show the count from 0 to FFh on the LED} \textbf{b) Write an AVR C
program to get a byte of data from Port C. If it is less than 100 send
it to Port B; otherwise, send it to Port D.}

\begin{solutionbox}

\textbf{a) Binary Counter Display:}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRB = 0xFF;           // Port B as output
    unsigned char count = 0;
    
    while(1) \{
        PORTB = count;     // Display count on LEDs
        \_delay\_ms(500);    // Delay for visibility
        count++;           // Increment counter
        if(count {} 0xFF)   // Reset after 255
            count = 0;
    \}
    return 0;
\}
\end{verbatim}

\textbf{b) Conditional Data Transfer:}

\begin{verbatim}
\#include {avr/io.h}

int main() \{
    DDRC = 0x00;    // Port C as input
    DDRB = 0xFF;    // Port B as output  
    DDRD = 0xFF;    // Port D as output
    
    while(1) \{
        unsigned char data = PINC;  // Read from Port C
        
        if(data {} 100) \{
            PORTB = data;           // Send to Port B
            PORTD = 0x00;          // Clear Port D
        \} else \{
            PORTD = data;           // Send to Port D
            PORTB = 0x00;          // Clear Port B
        \}
    \}
    return 0;
\}
\end{verbatim}

\textbf{Key Programming Concepts:}

\begin{itemize}
\tightlist
\item
  \textbf{Port direction}: DDR registers configure input/output
\item
  \textbf{Data reading}: PIN registers read input values
\item
  \textbf{Conditional logic}: if-else statements for decision making
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``RCC Data'' - \textbf{R}ead input, \textbf{C}ompare
value, \textbf{C}onditional output

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3 OR(a) [3
marks]}\label{question-3-ora-3-marks}

\textbf{Write AVR C program to send values of -3 to +3 Port B}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRB = 0xFF;              // Port B as output
    signed char values[] = \{{-}3, {-}2, {-}1, 0, 1, 2, 3\;}
    unsigned char i = 0;
    
    while(1) \{
        PORTB = values[i];    // Send value to Port B
        \_delay\_ms(1000);      // 1 second delay
        i++;                  // Next value
        if(i {} 6) i = 0;      // Reset index
    \}
    return 0;
\}
\end{verbatim}

\textbf{Program Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Signed data}: Uses signed char for negative values
\item
  \textbf{Array storage}: Values stored in array for easy access
\item
  \textbf{Cyclic operation}: Continuously cycles through all values
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SAC Values'' - \textbf{S}igned char, \textbf{A}rray
storage, \textbf{C}yclic operation

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3 OR(b) [4
marks]}\label{question-3-orb-4-marks}

\textbf{Write AVR C program to send hex values for ASCII characters
0,1,2,3,4,5,A,B,C and D to port B.}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

int main() \{
    DDRB = 0xFF;    // Port B as output
    
    // ASCII hex values array
    unsigned char ascii\_values[] = \{
        0x30,  // {0}
        0x31,  // {1 }
        0x32,  // {2}
        0x33,  // {3}
        0x34,  // {4}
        0x35,  // {5}
        0x41,  // {A}
        0x42,  // {B}
        0x43,  // {C}
        0x44   // {D}
    \;}
    
    unsigned char i = 0;
    
    while(1) \{
        PORTB = ascii\_values[i];  // Send ASCII value
        \_delay\_ms(500);           // Delay
        i++;                      // Next character
        if(i {} 9) i = 0;          // Reset index
    \}
    return 0;
\}
\end{verbatim}

\textbf{ASCII Values Table:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Character & Hex Value & Binary \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
`0' & 0x30 & 00110000 \\
`1' & 0x31 & 00110001 \\
`A' & 0x41 & 01000001 \\
`B' & 0x42 & 01000010 \\
\end{longtable}
}

\end{solutionbox}
\begin{mnemonicbox}
``HAC ASCII'' - \textbf{H}ex values, \textbf{A}rray
storage, \textbf{C}yclic transmission

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 3 OR(c) [7
marks]}\label{question-3-orc-7-marks}

\textbf{A door sensor is connected to bit 1 of Port B, and an LED is
connected to bit 7 of Port C. Write an AVR C program to monitor the door
sensor and, when it opens (PIN is HIGH), turn on the LED. Also draw Flow
chart.}

\begin{solutionbox}

\textbf{C Program:}

\begin{verbatim}
\#include {avr/io.h}

int main() \{
    DDRB = 0xFD;    // Port B bit 1 as input (0), others output (1)
    DDRC = 0xFF;    // Port C as output
    PORTB = 0x02;   // Enable pull{-up for bit 1}
    
    while(1) \{
        if(PINB \& 0x02) \{      // Check if door sensor is HIGH
            PORTC |= 0x80;     // Turn ON LED (bit 7)
        \} else \{
            PORTC \&= 0x7F;     // Turn OFF LED (bit 7)
        \}
    \}
    return 0;
\}
\end{verbatim}

\textbf{Flow Chart:}

\begin{verbatim}
flowchart LR
    A[Start] {-{-} B[Initialize Ports]}
    B {-{-} C[Configure Port B bit 1 as input]}
    C {-{-} D[Configure Port C bit 7 as output]}
    D {-{-} E\{Read Door Sensor\}}
    E {-{-}|HIGH| F[Turn ON LED]}
    E {-{-}|LOW| G[Turn OFF LED]}
    F {-{-} H[Continue Monitoring]}
    G {-{-} H}
    H {-{-} E}
\end{verbatim}

\textbf{Bit Operations:}

\begin{itemize}
\tightlist
\item
  \textbf{Input reading}: \texttt{PINB\ \&\ 0x02} checks bit 1
\item
  \textbf{LED control}: \texttt{PORTC\ \textbar{}=\ 0x80} sets bit 7
\item
  \textbf{LED off}: \texttt{PORTC\ \&=\ 0x7F} clears bit 7
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``BIC Door'' - \textbf{B}it manipulation,
\textbf{I}nput monitoring, \textbf{C}onditional LED control

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(a) [3 marks]}\label{q4a}

\textbf{Explain ADMUX ADC Register}

\begin{solutionbox}

\textbf{ADMUX (ADC Multiplexer Selection Register):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Bit & Name & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Bit 7-6} & REFS1:0 & Reference Selection \\
\textbf{Bit 5} & ADLAR & ADC Left Adjust Result \\
\textbf{Bit 4-0} & MUX4:0 & Analog Channel Selection \\
\end{longtable}
}

\textbf{Reference Selection (REFS1:0):}

\begin{itemize}
\tightlist
\item
  \textbf{00}: AREF, Internal Vref turned off
\item
  \textbf{01}: AVCC with external capacitor at AREF pin\\
\item
  \textbf{10}: Reserved
\item
  \textbf{11}: Internal 2.56V reference
\end{itemize}

\textbf{Channel Selection (MUX4:0):}

\begin{itemize}
\tightlist
\item
  \textbf{00000-00111}: ADC0-ADC7 (single-ended inputs)
\item
  \textbf{Other combinations}: Differential inputs with gain
\end{itemize}

\textbf{Key Functions:}

\begin{itemize}
\tightlist
\item
  \textbf{Voltage reference}: Determines ADC measurement range
\item
  \textbf{Channel multiplexing}: Selects which analog input to convert
\item
  \textbf{Result alignment}: Left or right justified ADC result
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``RAM ADMUX'' - \textbf{R}eference,
\textbf{A}lignment, \textbf{M}ultiplexer

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(b) [4 marks]}\label{q4b}

\textbf{Explain Different LCD Pins.}

\begin{solutionbox}

\textbf{16x2 LCD Pin Configuration:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Pin & Symbol & Function \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{1} & VSS & Ground (0V) \\
\textbf{2} & VDD & Power supply (+5V) \\
\textbf{3} & V0 & Contrast adjustment \\
\textbf{4} & RS & Register Select (Data/Command) \\
\textbf{5} & R/W & Read/Write select \\
\textbf{6} & E & Enable signal \\
\textbf{7-14} & D0-D7 & Data bus (8-bit) \\
\textbf{15} & A & Backlight anode (+) \\
\textbf{16} & K & Backlight cathode (-) \\
\end{longtable}
}

\textbf{Control Pin Functions:}

\begin{itemize}
\tightlist
\item
  \textbf{RS = 0}: Command register selected
\item
  \textbf{RS = 1}: Data register selected\\
\item
  \textbf{R/W = 0}: Write operation
\item
  \textbf{R/W = 1}: Read operation
\item
  \textbf{E}: Enable pulse triggers operation
\end{itemize}

\textbf{Connection Modes:}

\begin{itemize}
\tightlist
\item
  \textbf{8-bit mode}: All data pins D0-D7 connected
\item
  \textbf{4-bit mode}: Only D4-D7 used (saves microcontroller pins)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``VCR EDB LCD'' - \textbf{V}power, \textbf{C}ontrast,
\textbf{R}egister select, \textbf{E}nable, \textbf{D}ata \textbf{B}us

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4(c) [7 marks]}\label{q4c}

\textbf{Write a Program to toggle all the bits of PORTB continually with
20µs delay. Use Timer0, normal mode and no Prescaler to generate delay}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}

void delay\_20us() \{
    TCNT0 = 0;          // Clear timer counter
    TCCR0 = 0x01;       // No prescaler, normal mode
    while(TCNT0 {} 160); // Wait for 20µs (8MHz/1 * 20µs = 160)
    TCCR0 = 0;          // Stop timer
\}

int main() \{
    DDRB = 0xFF;        // Port B as output
    
    while(1) \{
        PORTB = 0xFF;   // Set all bits high
        delay\_20us();   // 20µs delay
        PORTB = 0x00;   // Set all bits low
        delay\_20us();   // 20µs delay
    \}
    return 0;
\}
\end{verbatim}

\textbf{Timer Calculation:}

\begin{itemize}
\tightlist
\item
  \textbf{Clock frequency}: 8 MHz (assumption)
\item
  \textbf{Timer resolution}: 1/8MHz = 0.125µs per count
\item
  \textbf{Required counts}: 20µs / 0.125µs = 160 counts
\end{itemize}

\textbf{Timer0 Configuration:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Setting & Value & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Mode} & Normal & Counts from 0 to 255 \\
\textbf{Prescaler} & 1 & No prescaling \\
\textbf{Clock source} & System clock & 8 MHz \\
\end{longtable}
}

\textbf{Program Flow:}

\begin{itemize}
\tightlist
\item
  \textbf{Initialize}: Set Port B as output
\item
  \textbf{Toggle high}: PORTB = 0xFF, wait 20µs
\item
  \textbf{Toggle low}: PORTB = 0x00, wait 20µs
\item
  \textbf{Repeat}: Continuous operation
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``TNP Timer'' - \textbf{T}imer0, \textbf{N}ormal
mode, \textbf{P}rescaler none

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4 OR(a) [3
marks]}\label{question-4-ora-3-marks}

\textbf{Short note Two wire Interface (TWI)}

\begin{solutionbox}

\textbf{TWI (Two Wire Interface) - I2C Protocol:}

\textbf{Key Features:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Two wires} & SDA (data) and SCL (clock) \\
\textbf{Multi-master} & Multiple masters can control bus \\
\textbf{Multi-slave} & Up to 127 slave devices \\
\textbf{Address-based} & 7-bit or 10-bit device addressing \\
\textbf{Bidirectional} & Data flows in both directions \\
\end{longtable}
}

\textbf{Bus Characteristics:}

\begin{itemize}
\tightlist
\item
  \textbf{Open-drain}: Requires pull-up resistors (4.7kΩ typical)
\item
  \textbf{Synchronous}: Clock provided by master
\item
  \textbf{Start/Stop conditions}: Special sequences for communication
\end{itemize}

\textbf{Common Applications:}

\begin{itemize}
\tightlist
\item
  \textbf{EEPROMs}: Non-volatile memory storage
\item
  \textbf{RTC modules}: Real-time clock devices\\
\item
  \textbf{Sensors}: Temperature, pressure, accelerometer
\item
  \textbf{Display controllers}: OLED, LCD controllers
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SDA SCL TWI'' - \textbf{S}erial \textbf{D}ata,
\textbf{S}erial \textbf{CL}ock, \textbf{T}wo \textbf{W}ire
\textbf{I}nterface

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4 OR(b) [4
marks]}\label{question-4-orb-4-marks}

\textbf{Explain ADCSRA ADC Register}

\begin{solutionbox}

\textbf{ADCSRA (ADC Control and Status Register A):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Bit & Name & Function \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Bit 7} & ADEN & ADC Enable \\
\textbf{Bit 6} & ADSC & ADC Start Conversion \\
\textbf{Bit 5} & ADATE & ADC Auto Trigger Enable \\
\textbf{Bit 4} & ADIF & ADC Interrupt Flag \\
\textbf{Bit 3} & ADIE & ADC Interrupt Enable \\
\textbf{Bit 2-0} & ADPS2:0 & ADC Prescaler Select \\
\end{longtable}
}

\textbf{Prescaler Settings (ADPS2:0):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Binary & Division Factor & ADC Clock (8MHz) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
000 & 2 & 4 MHz \\
001 & 2 & 4 MHz \\
010 & 4 & 2 MHz \\
011 & 8 & 1 MHz \\
100 & 16 & 500 kHz \\
101 & 32 & 250 kHz \\
110 & 64 & 125 kHz \\
111 & 128 & 62.5 kHz \\
\end{longtable}
}

\textbf{Control Functions:}

\begin{itemize}
\tightlist
\item
  \textbf{ADEN}: Must be set to enable ADC operation
\item
  \textbf{ADSC}: Set to start conversion, cleared when complete
\item
  \textbf{ADIF}: Set when conversion completes
\item
  \textbf{Prescaler}: ADC clock should be 50-200 kHz for optimal
  accuracy
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``EASCID ADC'' - \textbf{E}nable,
\textbf{A}uto-trigger, \textbf{S}tart, \textbf{C}onversion,
\textbf{I}nterrupt, \textbf{D}ivider

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 4 OR(c) [7
marks]}\label{question-4-orc-7-marks}

\textbf{Write a Program to generate a square wave of 16 Khz frequency on
pin PORTC.3. Assume Crystal Frequency 8 Mhz}

\begin{solutionbox}

\begin{verbatim}
\#include {avr/io.h}
\#include {avr/interrupt.h}

int main() \{
    // Configure PC3 as output
    DDRC |= (1 {} PC3);
    
    // Timer1 CTC mode configuration
    TCCR1A = 0x00;                    // Normal port operation
    TCCR1B = (1 {} WGM12) | (1 {} CS10); // CTC mode, no prescaler
    
    // Calculate OCR1A value for 16 kHz
    // Period = 1/16000 = 62.5µs
    // Half period = 31.25µs  
    // OCR1A = (8MHz * 31.25µs) {- 1 = 249}
    OCR1A = 249;
    
    // Enable Timer1 Compare A interrupt
    TIMSK |= (1 {} OCIE1A);
    
    // Enable global interrupts
    sei();
    
    while(1) \{
        // Main loop {- square wave generated by interrupt}
    \}
    return 0;
\}

// Timer1 Compare A interrupt service routine
ISR(TIMER1\_COMPA\_vect) \{
    PORTC \^{=} (1 {} PC3);    // Toggle PC3
\}
\end{verbatim}

\textbf{Frequency Calculation:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Parameter & Value & Formula \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Target frequency} & 16 kHz & Given \\
\textbf{Period} & 62.5 µs & 1/16000 \\
\textbf{Half period} & 31.25 µs & Period/2 \\
\textbf{Timer counts} & 250 & 8MHz \times 31.25µs \\
\textbf{OCR1A value} & 249 & Counts - 1 \\
\end{longtable}
}

\textbf{Timer Configuration:}

\begin{itemize}
\tightlist
\item
  \textbf{Mode}: CTC (Clear Timer on Compare)
\item
  \textbf{Prescaler}: 1 (no prescaling)
\item
  \textbf{Interrupt}: Compare match toggles output pin
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CTC Square'' - \textbf{C}TC mode, \textbf{T}imer
interrupt, \textbf{C}ompare match

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(a) [3 marks]}\label{q5a}

\textbf{Difference between Polling and Interrupt}

\begin{solutionbox}

\textbf{Polling vs Interrupt Comparison:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Aspect
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Polling
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Interrupt
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{CPU Usage} & Continuously checks status & CPU free until event
occurs \\
\textbf{Response Time} & Variable, depends on polling frequency & Fast,
immediate response \\
\textbf{Power Consumption} & Higher due to continuous checking & Lower,
CPU can sleep \\
\textbf{Programming} & Simple, sequential code & Complex, requires
ISR \\
\textbf{Real-time} & Not suitable for critical timing & Excellent for
real-time systems \\
\end{longtable}
}

\textbf{Key Differences:}

\begin{itemize}
\tightlist
\item
  \textbf{Efficiency}: Interrupts are more CPU efficient
\item
  \textbf{Timing}: Interrupts provide deterministic response
\item
  \textbf{Complexity}: Polling is easier to implement and debug
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``PIE Method'' - \textbf{P}olling inefficient,
\textbf{I}nterrupt efficient, \textbf{E}vent-driven

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(b) [4 marks]}\label{q5b}

\textbf{Explain LM35 Interface with AVR ATmega32.}

\begin{solutionbox}

\textbf{LM35 Temperature Sensor Interface:}

\begin{verbatim}
    +5V {-{-}{-}{-}+}
            |
        +{-{-}{-}+{-}{-}{-}+}
        |  LM35 |
        |       |
        +{-{-}{-}+{-}{-}{-}+}
            |
            +{-{-}{-}{-} To ADC Pin (PA0)}
\end{verbatim}

\textbf{LM35 Characteristics:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Parameter & Value & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Output} & 10mV/^\circC & Linear temperature coefficient \\
\textbf{Range} & 0^\circC to 100^\circC & Operating temperature range \\
\textbf{Supply} & 4V to 30V & Power supply range \\
\textbf{Accuracy} & \pm0.5^\circC & Temperature accuracy \\
\end{longtable}
}

\textbf{Interface Code:}

\begin{verbatim}
\#include {avr/io.h}

void ADC\_init() \{
    ADMUX = 0x40;   // AVCC reference, ADC0 channel
    ADCSRA = 0x87;  // Enable ADC, prescaler 128
\}

unsigned int read\_temperature() \{
    ADCSRA |= (1 {} ADSC);      // Start conversion
    while(ADCSRA \& (1 {} ADSC)); // Wait for completion
    
    // Convert ADC value to temperature
    // Temperature = (ADC * 5000) / (1024 * 10)
    unsigned int temp = (ADC * 5000) / 10240;
    return temp;
\}
\end{verbatim}

\textbf{Calculation:}

\begin{itemize}
\tightlist
\item
  \textbf{ADC Resolution}: 10-bit (0-1023)
\item
  \textbf{Reference Voltage}: 5V
\item
  \textbf{LM35 Scale}: 10mV/^\circC
\item
  \textbf{Formula}: Temperature = (ADC\_Value \times 5000mV) / (1024 \times
  10mV/^\circC)
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``LAC Temperature'' - \textbf{L}M35 sensor,
\textbf{A}DC conversion, \textbf{C}alculation formula

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5(c) [7 marks]}\label{q5c}

\textbf{Write a program to interface DC Motor with AVR ATmega32.}

\begin{solutionbox}

\textbf{DC Motor Interface Circuit:}

\begin{verbatim}
    ATmega32                L293D Motor Driver              DC Motor
    +{-{-}{-}{-}{-}{-}{-}{-}+            +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+              +{-}{-}{-}{-}{-}{-}{-}+}
    |  PD5   |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN1         O1 |{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}|   +   |}
    |  PD6   |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN2         O2 |{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}|   {-}   |}
    |  PD4   |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}| EN1            |              +{-}{-}{-}{-}{-}{-}{-}+}
    +{-{-}{-}{-}{-}{-}{-}{-}+            +{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}+}
                          |                |
                         +5V              GND
\end{verbatim}

\textbf{Motor Control Program:}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

void motor\_init() \{
    DDRD |= (1 {} PD4) | (1 {} PD5) | (1 {} PD6); // Set as output
\}

void motor\_forward() \{
    PORTD |= (1 {} PD4);   // Enable motor
    PORTD |= (1 {} PD5);   // IN1 = 1
    PORTD \&= {(}1 {} PD6);  // IN2 = 0
\}

void motor\_reverse() \{
    PORTD |= (1 {} PD4);   // Enable motor
    PORTD \&= {(}1 {} PD5);  // IN1 = 0
    PORTD |= (1 {} PD6);   // IN2 = 1
\}

void motor\_stop() \{
    PORTD \&= {(}1 {} PD4);  // Disable motor
\}

int main() \{
    motor\_init();
    
    while(1) \{
        motor\_forward();    // Forward for 2 seconds
        \_delay\_ms(2000);
        
        motor\_stop();       // Stop for 1 second
        \_delay\_ms(1000);
        
        motor\_reverse();    // Reverse for 2 seconds
        \_delay\_ms(2000);
        
        motor\_stop();       // Stop for 1 second
        \_delay\_ms(1000);
    \}
    return 0;
\}
\end{verbatim}

\textbf{L293D Truth Table:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
EN & IN1 & IN2 & Motor Action \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
0 & X & X & Stop \\
1 & 0 & 0 & Stop \\
1 & 0 & 1 & Reverse \\
1 & 1 & 0 & Forward \\
1 & 1 & 1 & Stop \\
\end{longtable}
}

\textbf{Key Components:}

\begin{itemize}
\tightlist
\item
  \textbf{L293D}: Dual H-bridge motor driver IC
\item
  \textbf{Enable pin}: Controls motor power
\item
  \textbf{Direction pins}: IN1, IN2 control rotation direction
\item
  \textbf{Protection}: Built-in diodes for back EMF protection
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``LED Motor'' - \textbf{L}293D driver,
\textbf{E}nable control, \textbf{D}irection pins

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5 OR(a) [3
marks]}\label{question-5-ora-3-marks}

\textbf{Explain basic block diagram of GSM based security system.}

\begin{solutionbox}

\textbf{GSM Security System Block Diagram:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph LR
    A[Sensors] {-{-}{} B[ATmega32 Microcontroller]}
    B {-{-}{} C[GSM Module]}
    C {-{-}{} D[Mobile Network]}
    D {-{-}{} E[User Mobile Phone]}
    B {-{-}{} F[Alarm/Buzzer]}
    B {-{-}{} G[LCD Display]}
    H[Power Supply] {-{-}{} B}
    H {-{-}{} C}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{System Components:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Component & Function \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Sensors} & PIR, door/window sensors, smoke detector \\
\textbf{Microcontroller} & Process sensor data, control system \\
\textbf{GSM Module} & Send SMS alerts, make calls \\
\textbf{Display} & Show system status \\
\textbf{Alarm} & Local audio/visual alert \\
\end{longtable}
}

\textbf{Working Principle:}

\begin{itemize}
\tightlist
\item
  \textbf{Sensor monitoring}: Continuous surveillance of security zones
\item
  \textbf{Event detection}: Triggered when unauthorized access detected
\item
  \textbf{Alert generation}: SMS sent to predefined numbers
\item
  \textbf{Local alarm}: Immediate audio/visual warning
\end{itemize}

\textbf{Key Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Remote monitoring}: Real-time alerts via SMS
\item
  \textbf{Multiple sensors}: Various intrusion detection methods
\item
  \textbf{Backup power}: Battery backup for power failures
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``SGMA Security'' - \textbf{S}ensors, \textbf{G}SM
module, \textbf{M}icrocontroller, \textbf{A}lerts

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5 OR(b) [4
marks]}\label{question-5-orb-4-marks}

\textbf{Explain Relay Interface with AVR ATmega32.}

\begin{solutionbox}

\textbf{Relay Interface Circuit:}

\begin{verbatim}
    ATmega32              ULN2803           Relay        Load
    +{-{-}{-}{-}{-}{-}{-}{-}+           +{-}{-}{-}{-}{-}{-}{-}{-}+        +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}+}
    |   PB0  |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN1 O1 |{-}{-}{-}{-}{-}{-}{-}| COM |{-}{-}{-}{-}| AC   |}
    |   PB1  |{-{-}{-}{-}{-}{-}{-}{-}{-}{-}| IN2 O2 |{-}{-}{-}{-}{-}{-}{-}| NO  |     | Load |}
    +{-{-}{-}{-}{-}{-}{-}{-}+           +{-}{-}{-}{-}{-}{-}{-}{-}+        +{-}{-}{-}{-}{-}+     +{-}{-}{-}{-}{-}{-}+}
                         |        |
                        GND      +12V
\end{verbatim}

\textbf{Relay Interface Code:}

\begin{verbatim}
\#include {avr/io.h}
\#include {util/delay.h}

void relay\_init() \{
    DDRB |= (1 {} PB0) | (1 {} PB1); // Set as output pins
\}

void relay1\_on() \{
    PORTB |= (1 {} PB0);  // Activate relay 1
\}

void relay1\_off() \{
    PORTB \&= {(}1 {} PB0); // Deactivate relay 1
\}

void relay2\_on() \{
    PORTB |= (1 {} PB1);  // Activate relay 2
\}

void relay2\_off() \{
    PORTB \&= {(}1 {} PB1); // Deactivate relay 2
\}

int main() \{
    relay\_init();
    
    while(1) \{
        relay1\_on();        // Turn on relay 1
        \_delay\_ms(2000);
        relay1\_off();       // Turn off relay 1
        
        relay2\_on();        // Turn on relay 2
        \_delay\_ms(2000);
        relay2\_off();       // Turn off relay 2
        
        \_delay\_ms(1000);
    \}
    return 0;
\}
\end{verbatim}

\textbf{ULN2803 Features:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Feature & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{8 Channels} & Eight Darlington pair drivers \\
\textbf{High Current} & Up to 500mA per channel \\
\textbf{Protection} & Built-in flyback diodes \\
\textbf{Input Voltage} & 5V TTL compatible \\
\textbf{Output Voltage} & Up to 50V \\
\end{longtable}
}

\textbf{Applications:}

\begin{itemize}
\tightlist
\item
  \textbf{Home automation}: Light, fan control
\item
  \textbf{Industrial control}: Motor, valve operation
\item
  \textbf{Security systems}: Door locks, alarms
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``ULN Relay'' - \textbf{U}LN2803 driver,
\textbf{L}oad control, \textbf{N}on-contact switching

\end{mnemonicbox}
\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Question 5 OR(c) [7
marks]}\label{question-5-orc-7-marks}

\textbf{Draw and Explain Automatic Juice vending machine}

\begin{solutionbox}

\textbf{Automatic Juice Vending Machine Block Diagram:}

\begin{center}
\textbf{Mermaid Diagram (Code)}
\begin{verbatim}
{Shaded}
{Highlighting}[]
graph TD
    A[Coin Sensor] {-{-}{} B[ATmega32 Controller]}
    C[Keypad] {-{-}{} B}
    D[LCD Display] {-{-}{} B}
    B {-{-}{} E[Pump Motors]}
    B {-{-}{} F[Solenoid Valves]}
    B {-{-}{} G[Coin Return Mechanism]}
    H[Level Sensors] {-{-}{} B}
    I[Power Supply] {-{-}{} B}
    J[Juice Containers] {-{-}{} E}
    E {-{-}{} K[Dispensing Unit]}
{Highlighting}
{Shaded}
\end{verbatim}
\end{center}

\textbf{System Components:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Component & Function & \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Coin Sensor} & Detects and validates inserted coins & \\
\textbf{Keypad} & User selection interface (4x4 matrix) & \\
\textbf{LCD Display} & Shows menu, price, status messages & \\
\textbf{Pump Motors} & Dispense selected juice & \\
\textbf{Solenoid Valves} & Control juice flow & \\
\textbf{Level Sensors} & Monitor juice container levels & \\
\textbf{Coin Return} & Returns excess money & \\
\end{longtable}
}

\textbf{System Operation:}

\begin{enumerate}
\tightlist
\item
  \textbf{Initialization}: Display welcome message and juice menu
\item
  \textbf{Coin Input}: User inserts coins, system validates amount
\item
  \textbf{Selection}: User presses keypad to select juice type
\item
  \textbf{Validation}: Check if enough money and juice available
\item
  \textbf{Dispensing}: Activate pump and valve for selected juice
\item
  \textbf{Completion}: Return change if any, display thank you message
\end{enumerate}

\textbf{Control Logic:}

\begin{verbatim}
// Pseudo code for vending machine operation
void vending\_machine() \{
    display\_menu();
    
    while(1) \{
        if(coin\_inserted()) \{
            total\_amount += validate\_coin();
            update\_display();
        \}
        
        if(selection\_made()) \{
            juice\_type = get\_selection();
            if(total\_amount {=} juice\_price[juice\_type]) \{
                if(juice\_available[juice\_type]) \{
                    dispense\_juice(juice\_type);
                    return\_change();
                    reset\_system();
                \} else \{
                    display\_error("Out of Stock");
                \}
            \} else \{
                display\_error("Insufficient Amount");
            \}
        \}
    \}
\}
\end{verbatim}

\textbf{Key Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Multiple juice types}: 4-6 different flavors
\item
  \textbf{Automatic dispensing}: Precise volume control
\item
  \textbf{Change return}: Calculates and returns exact change
\item
  \textbf{Inventory tracking}: Monitors juice levels
\item
  \textbf{Error handling}: Handles various fault conditions
\end{itemize}

\textbf{Safety Features:}

\begin{itemize}
\tightlist
\item
  \textbf{Over-dispensing protection}: Timer-based pump control
\item
  \textbf{Coin validation}: Prevents fake coin acceptance
\item
  \textbf{Level monitoring}: Prevents dry running of pumps
\item
  \textbf{Emergency stop}: Manual override capability
\end{itemize}

\end{solutionbox}
\begin{mnemonicbox}
``CLPDV Juice'' - \textbf{C}oin sensor, \textbf{L}CD
display, \textbf{P}ump motors, \textbf{D}ispensing unit, \textbf{V}alve
control

\end{mnemonicbox}

\end{document}
