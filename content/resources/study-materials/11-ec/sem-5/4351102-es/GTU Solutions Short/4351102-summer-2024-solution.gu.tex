\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{Embedded System \& Microcontroller Application (4351102) - Summer 2024 Solution Gujarati}
\date{May 16, 2024}

\begin{document}
\maketitle

\questionmarks{1(અ)}{3}{એમ્બેડેડ સિસ્ટમની વ્યાખ્યા શું છે? એમ્બેડેડ સિસ્ટમનું ઉદાહરણ આપો.}

\begin{solutionbox}
\textbf{એમ્બેડેડ સિસ્ટમ} એ એક વિશેષ કમ્પ્યુટર સિસ્ટમ છે જે ચોક્કસ કાર્યો કરવા માટે સમર્પિત કાર્યો સાથે ડિઝાઇન કરવામાં આવે છે. તે હાર્ડવેર અને સોફ્ટવેર ઘટકોને જોડે છે જે વિશાળ સિસ્ટમમાં એકીકૃત થાય છે.

\keyword{મુખ્ય લક્ષણો:}
\begin{itemize}
    \item \keyword{રીઅલ-ટાઇમ ઓપરેશન}: નિર્દિષ્ટ સમય મર્યાદામાં ઇનપુટ્સનો પ્રતિસાદ આપે છે
    \item \keyword{સમર્પિત કાર્ય}: ચોક્કસ એપ્લિકેશન માટે ડિઝાઇન કરેલું
    \item \keyword{રિસોર્સ મર્યાદાઓ}: મર્યાદિત મેમરી, પાવર અને પ્રોસેસિંગ ક્ષમતાઓ
\end{itemize}

\keyword{ઉદાહરણ}: વોશિંગ મશીન કન્ટ્રોલર જે વોશ સાઇકલ્સ, પાણીનું તાપમાન અને ટાઇમિંગને આપમેળે મેનેજ કરે છે.
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SMART Embedded: Specialized, Microprocessor-based, Application-specific, Real-time, Task-oriented}
\end{mnemonicbox}

\questionmarks{1(બ)}{4}{રીઅલ-ટાઇમ ઓપરેટિંગ સિસ્ટમ (RTOS) ને વ્યાખ્યાયિત કરો અને RTOS ની ત્રણ લાક્ષણિકતાઓની યાદી બનાવો.}

\begin{solutionbox}
\keyword{RTOS} એ એક ઓપરેટિંગ સિસ્ટમ છે જે રીઅલ-ટાઇમ એપ્લિકેશન્સને હેન્ડલ કરવા માટે ડિઝાઇન કરવામાં આવ્યું છે જ્યાં સિસ્ટમ ઓપરેશન માટે ટાઇમિંગ અવરોધો નિર્ણાયક છે.

\begin{answertable}{RTOS લાક્ષણિકતાઓ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{લાક્ષણિકતા} & \textbf{વર્ણન} \\ \hline
\keyword{નિર્ધારિત પ્રતિસાદ} & નિર્ણાયક કાર્યો માટે ગેરંટીડ રિસ્પોન્સ ટાઇમ \\ \hline
\keyword{પ્રાથમિકતા-આધારિત શેડ્યુલિંગ} & ઉચ્ચ પ્રાથમિકતાના કાર્યો નીચા પ્રાથમિકતાના કાર્યો પહેલાં ચાલે છે \\ \hline
\keyword{મલ્ટિટાસ્કિંગ સપોર્ટ} & બહુવિધ કાર્યો એકસાથે ચાલી શકે છે \\ \hline
\end{tabulary}
\end{answertable}

\keyword{વધારાની વિશેષતાઓ:}
\begin{itemize}
    \item \keyword{કાર્ય વ્યવસ્થાપન}: બહુવિધ સમાંતર પ્રક્રિયાઓને અસરકારક રીતે હેન્ડલ કરે છે
    \item \keyword{ઇન્ટરપ્ટ હેન્ડલિંગ}: બાહ્ય ઘટનાઓને ઝડપી પ્રતિસાદ
    \item \keyword{મેમરી વ્યવસ્થાપન}: એમ્બેડેડ એપ્લિકેશન્સ માટે ઓપ્ટિમાઇઝ્ડ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DPM RTOS: Deterministic, Priority-based, Multitasking}
\end{mnemonicbox}

\questionmarks{1(ક)}{7}{અ) એમ્બેડેડ સિસ્ટમનો જનરલ બ્લોક ડાયાગ્રામ દોરો\\બ) એમ્બેડેડ સિસ્ટમ માટે માઇક્રોકન્ટ્રોલર પસંદ કરવાના માપદંડો સમજાવો.}

\begin{solutionbox}
\textbf{અ) જનરલ બ્લોક ડાયાગ્રામ:}

\begin{answerdiagram}{જનરલ બ્લોક ડાયાગ્રામ}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block] (cpu) {Microcontroller/\\Processor};
    \node [gtu block, left=of cpu] (input) {Input Devices};
    \node [gtu block, right=of cpu] (output) {Output Devices};
    \node [gtu block, above=of cpu] (mem) {Memory System};
    \node [gtu block, below=of cpu] (comm) {Communication\\Interface};
    \node [gtu block, below left=1.5cm of cpu] (power) {Power Supply};
    \node [gtu block, below right=1.5cm of cpu] (clock) {Clock/Timer};

    \path [gtu arrow] (input) -- (cpu);
    \path [gtu arrow] (cpu) -- (output);
    \path [gtu arrow] (cpu) edge[bend right] (mem);
    \path [gtu arrow] (mem) edge[bend right] (cpu);
    \path [gtu arrow] (cpu) -- (comm);
    \path [gtu arrow] (comm) -- (cpu);
    \path [gtu arrow] (power) -- (cpu);
    \path [gtu arrow] (clock) -- (cpu);
\end{tikzpicture}
\end{answerdiagram}

\textbf{બ) માઇક્રોકન્ટ્રોલર પસંદગીના માપદંડો:}

\begin{answertable}{પસંદગીના માપદંડો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{માપદંડ} & \textbf{વિચારણાઓ} \\ \hline
\keyword{પ્રોસેસિંગ સ્પીડ} & ક્લોક ફ્રીક્વન્સી, ઇન્સ્ટ્રક્શન એક્ઝિક્યુશન ટાઇમ \\ \hline
\keyword{મેમરી જરૂરિયાતો} & Flash, RAM, EEPROM ક્ષમતા \\ \hline
\keyword{I/O ક્ષમતાઓ} & પિન્સની સંખ્યા, વિશેષ કાર્યો \\ \hline
\keyword{પાવર વપરાશ} & બેટરી લાઇફ, સ્લીપ મોડ્સ \\ \hline
\keyword{કિંમત} & બજેટ અવરોધો, વોલ્યુમ પ્રાઇસિંગ \\ \hline
\keyword{ડેવલપમેન્ટ ટૂલ્સ} & કમ્પાઇલર, ડિબગર ઉપલબ્ધતા \\ \hline
\end{tabulary}
\end{answertable}

\keyword{મુખ્ય પરિબળો:}
\begin{itemize}
    \item \keyword{પ્રદર્શન આવશ્યકતાઓ}: પ્રોસેસિંગ સ્પીડ અને રીઅલ-ટાઇમ અવરોધો
    \item \keyword{ઇન્ટરફેસ જરૂરિયાતો}: ADC, PWM, કમ્યુનિકેશન પ્રોટોકોલ્સ
    \item \keyword{પર્યાવરણીય પરિસ્થિતિઓ}: ઓપરેટિંગ તાપમાન, ભેજ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PMPICD Selection: Performance, Memory, Power, Interface, Cost, Development tools}
\end{mnemonicbox}

\orquestionmarks{1(ક)}{7}{ATmega32 ની પિન ગોઠવણી સમજાવો.}

\begin{solutionbox}
ATmega32 એ 40-પિન માઇક્રોકન્ટ્રોલર છે જેમાં ચાર 8-બિટ I/O પોર્ટ્સ અને વિવિધ વિશેષ કાર્યાત્મક પિન્સ છે.

\keyword{પોર્ટ ગોઠવણી:}
\begin{answertable}{પોર્ટ ગોઠવણી}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પોર્ટ} & \textbf{પિન્સ} & \textbf{કાર્યો} \\ \hline
\keyword{Port A} & PA0-PA7 & ADC ચેનલ્સ, જનરલ I/O \\ \hline
\keyword{Port B} & PB0-PB7 & SPI, PWM, બાહ્ય ઇન્ટરપ્ટ્સ \\ \hline
\keyword{Port C} & PC0-PC7 & TWI, જનરલ I/O \\ \hline
\keyword{Port D} & PD0-PD7 & USART, બાહ્ય ઇન્ટરપ્ટ્સ, PWM \\ \hline
\end{tabulary}
\end{answertable}

\keyword{વિશેષ પિન્સ:}
\begin{itemize}
    \item \keyword{VCC/GND}: પાવર સપ્લાઇ પિન્સ
    \item \keyword{AVCC/AGND}: ADC માટે એનાલોગ પાવર સપ્લાઇ
    \item \keyword{XTAL1/XTAL2}: ક્રિસ્ટલ ઓસિલેટર કનેક્શન્સ
    \item \keyword{RESET}: એક્ટિવ લો રીસેટ ઇનપુટ
    \item \keyword{AREF}: ADC રેફરન્સ વોલ્ટેજ
\end{itemize}

\keyword{પિન કાર્યો:}
\begin{itemize}
    \item \keyword{ડ્યૂઅલ-પર્પઝ પિન્સ}: મોટાભાગની પિન્સમાં વૈકલ્પિક કાર્યો છે
    \item \keyword{ઇનપુટ/આઉટપુટ ક્ષમતા}: બધી પોર્ટ પિન્સ દ્વિદિશીય છે
    \item \keyword{આંતરિક પુલ-અપ}: ઇનપુટ પિન્સ માટે સોફ્ટવેર રૂપરેખાંકિત
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ABCD Ports: ADC, Bus interfaces, Communication, Data transfer}
\end{mnemonicbox}

\questionmarks{2(અ)}{3}{ATMEGA32 નું ડેટા મેમરી આર્કિટેક્ચર સમજાવો.}

\begin{solutionbox}
ATmega32 ડેટા મેમરી ત્રણ વિભાગોનો સમાવેશ કરે છે જે એકીકૃત સરનામા સ્થળમાં આયોજિત છે.

\keyword{મેમરી સંગઠન:}
\begin{answertable}{મેમરી સંગઠન}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ત્રણ વિભાગો} & \textbf{સરનામા શ્રેણી} & \textbf{કદ} & \textbf{હેતુ} \\ \hline
\keyword{જનરલ રજિસ્ટર્સ} & 0x00-0x1F & 32 બાઇટ્સ & વર્કિંગ રજિસ્ટર્સ R0-R31 \\ \hline
\keyword{I/O રજિસ્ટર્સ} & 0x20-0x5F & 64 બાઇટ્સ & કન્ટ્રોલ અને સ્ટેટસ રજિસ્ટર્સ \\ \hline
\keyword{આંતરિક SRAM} & 0x60-0x45F & 2048 બાઇટ્સ & ડેટા સ્ટોરેજ અને સ્ટેક \\ \hline
\end{tabulary}
\end{answertable}

\keyword{મુખ્ય વિશેષતાઓ:}
\begin{itemize}
    \item \keyword{એકીકૃત એડ્રેસિંગ}: બધી મેમરી એક સરનામા સ્થળ દ્વારા સુલભ
    \item \keyword{રજિસ્ટર ફાઇલ}: અંકગણિત અને તર્ક ઓપરેશન્સ માટે R0-R31
    \item \keyword{સ્ટેક પોઇન્ટર}: SRAM માં સ્ટેકની ટોપ તરફ નિર્દેશ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{GIS Memory: General registers, IO registers, SRAM}
\end{mnemonicbox}

\questionmarks{2(બ)}{4}{પ્રોગ્રામ સ્ટેટસ વર્ડ સમજાવો.}

\begin{solutionbox}
\keyword{SREG (સ્ટેટસ રજિસ્ટર)} માં ફ્લેગ્સ છે જે અંકગણિત અને તર્ક ઓપરેશન્સના પરિણામને પ્રતિબિંબિત કરે છે.

\keyword{SREG બિટ રૂપરેખાંકન:}
\begin{answertable}{SREG બિટ રૂપરેખાંકન}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{બિટ} & \textbf{ફ્લેગ} & \textbf{વર્ણન} \\ \hline
\keyword{બિટ 7} & I & ગ્લોબલ ઇન્ટરપ્ટ એનેબલ \\ \hline
\keyword{બિટ 6} & T & બિટ કોપી સ્ટોરેજ \\ \hline
\keyword{બિટ 5} & H & હાફ કેરી ફ્લેગ \\ \hline
\keyword{બિટ 4} & S & સાઇન ફ્લેગ \\ \hline
\keyword{બિટ 3} & V & ઓવરફ્લો ફ્લેગ \\ \hline
\keyword{બિટ 2} & N & નેગેટિવ ફ્લેગ \\ \hline
\keyword{બિટ 1} & Z & ઝીરો ફ્લેગ \\ \hline
\keyword{બિટ 0} & C & કેરી ફ્લેગ \\ \hline
\end{tabulary}
\end{answertable}

\keyword{ફ્લેગ કાર્યો:}
\begin{itemize}
    \item \keyword{અંકગણિત ઓપરેશન્સ}: C, Z, N, V, H ફ્લેગ્સ આપમેળે અપડેટ થાય છે
    \item \keyword{શરતી બ્રાન્ચિંગ}: નિર્ણય લેવા માટે ફ્લેગ્સનો ઉપયોગ
    \item \keyword{ઇન્ટરપ્ટ નિયંત્રણ}: I ફ્લેગ ગ્લોબલ ઇન્ટરપ્ટ્સને સક્ષમ/અક્ષમ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{I THSVNZC: Interrupt, Transfer, Half-carry, Sign, oVerflow, Negative, Zero, Carry}
\end{mnemonicbox}

\questionmarks{2(ક)}{7}{ATMEGA32 ના આર્કિટેક્ચર દોરો અને સમજાવો.}

\begin{solutionbox}
\textbf{ATmega32 આર્કિટેક્ચર:}

\begin{answerdiagram}{ATmega32 આર્કિટેક્ચર}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block, minimum width=3cm] (alu) {ALU};
    \node [gtu block, above=of alu] (decoder) {Instruction Decoder};
    \node [gtu block, fit=(alu) (decoder), draw, dashed, label=above:CPU Core] (cpu) {};
    
    \node [gtu block, above=of cpu] (progmem) {Program Memory\\32KB Flash};
    \node [gtu block, below=of cpu] (regs) {Register File\\R0-R31};
    \node [gtu block, below=of regs] (io) {I/O Registers};
    \node [gtu block, below=of io] (sram) {Data Memory\\2KB SRAM};
    
    \node [gtu block, left=2cm of io] (eeprom) {EEPROM\\1KB};
    \node [gtu block, right=2cm of io] (periph) {Peripherals\\(Timers, ADC, USART, SPI, TWI)};
    \node [gtu block, right=2cm of decoder] (interrupt) {Interrupt Unit};
    
    \path [gtu arrow] (progmem) -- (decoder);
    \path [gtu arrow] (decoder) -- (alu);
    \path [gtu arrow] (alu) -- (regs);
    \path [gtu arrow] (regs) -- (io);
    \path [gtu arrow] (io) -- (sram);
    \path [gtu arrow] (sram) -- (io);
    \path [gtu arrow] (eeprom) -- (io);
    \path [gtu arrow] (io) -- (eeprom);
    \path [gtu arrow] (periph) -- (io);
    \path [gtu arrow] (io) -- (periph);
    \path [gtu arrow] (interrupt) -- (decoder);
\end{tikzpicture}
\end{answerdiagram}

\keyword{આર્કિટેક્ચર ઘટકો:}
\begin{answertable}{આર્કિટેક્ચર ઘટકો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઘટક} & \textbf{વર્ણન} \\ \hline
\keyword{હાર્વર્ડ આર્કિટેક્ચર} & અલગ પ્રોગ્રામ અને ડેટા મેમરી બસ \\ \hline
\keyword{RISC કોર} & 131 સૂચનાઓ, મોટાભાગે સિંગલ-સાઇકલ એક્ઝિક્યુશન \\ \hline
\keyword{ALU} & 8-બિટ અંકગણિત અને તર્ક ઓપરેશન્સ \\ \hline
\keyword{રજિસ્ટર ફાઇલ} & 32 $\times$ 8-બિટ વર્કિંગ રજિસ્ટર્સ \\ \hline
\end{tabulary}
\end{answertable}

\keyword{મેમરી સિસ્ટમ:}
\begin{itemize}
    \item \keyword{પ્રોગ્રામ મેમરી}: સૂચનાઓ સંગ્રહ કરવા માટે 32KB Flash
    \item \keyword{ડેટા મેમરી}: ચલો અને સ્ટેક માટે 2KB SRAM
    \item \keyword{EEPROM}: 1KB નોન-વોલેટાઇલ ડેટા સ્ટોરેજ
\end{itemize}

\keyword{પેરિફેરલ વિશેષતાઓ:}
\begin{itemize}
    \item \keyword{ત્રણ ટાઇમર/કાઉન્ટર્સ}: 8-બિટ અને 16-બિટ ટાઇમર્સ
    \item \keyword{8-ચેનલ ADC}: 10-બિટ રીઝોલ્યુશન
    \item \keyword{કમ્યુનિકેશન ઇન્ટરફેસ}: USART, SPI, TWI
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{HRAM Micro: Harvard architecture, RISC core, ALU, Memory system}
\end{mnemonicbox}

\orquestionmarks{2(અ)}{3}{ATMEGA32 ના પ્રોગ્રામ કાઉન્ટર સમજાવો.}

\begin{solutionbox}
\keyword{પ્રોગ્રામ કાઉન્ટર (PC)} એ 16-બિટ રજિસ્ટર છે જે એક્ઝિક્યુટ થવાની આગલી સૂચનાનું સરનામું ધરાવે છે.

\keyword{PC લાક્ષણિકતાઓ:}
\begin{answertable}{PC લાક્ષણિકતાઓ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{વિશેષતા} & \textbf{વર્ણન} \\ \hline
\keyword{કદ} & 16-બિટ (64KB પ્રોગ્રામ મેમરીને સરનામું આપી શકે છે) \\ \hline
\keyword{રીસેટ વેલ્યુ} & 0x0000 (શરૂઆતથી એક્ઝિક્યુશન શરૂ કરે છે) \\ \hline
\keyword{વૃદ્ધિ} & સૂચના મેળવ્યા પછી આપમેળે વધે છે \\ \hline
\keyword{જમ્પ/બ્રાન્ચ} & જમ્પ, બ્રાન્ચ અને કોલ સૂચનાઓ દ્વારા સુધારેલું \\ \hline
\end{tabulary}
\end{answertable}

\keyword{PC ઓપરેશન્સ:}
\begin{itemize}
    \item \keyword{અનુક્રમિક એક્ઝિક્યુશન}: મોટાભાગની સૂચનાઓ માટે PC 1 વધે છે
    \item \keyword{બ્રાન્ચ સૂચનાઓ}: PC ને ટાર્ગેટ એડ્રેસ સાથે લોડ કરવામાં આવે છે
    \item \keyword{ઇન્ટરપ્ટ હેન્ડલિંગ}: PC સ્ટેકમાં સાચવાય છે, ઇન્ટરપ્ટ વેક્ટર સાથે લોડ કરાય છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SRIB PC: Sequential, Reset, Increment, Branch}
\end{mnemonicbox}

\orquestionmarks{2(બ)}{4}{AVR માઇક્રોકન્ટ્રોલરમાં ક્લોક અને રીસેટ સર્કિટની ભૂમિકા સમજાવો.}

\begin{solutionbox}
\keyword{ક્લોક સિસ્ટમ:}
\begin{answertable}{ક્લોક સ્રોત}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ક્લોક સ્રોત} & \textbf{વર્ણન} \\ \hline
\keyword{બાહ્ય ક્રિસ્ટલ} & ઉચ્ચ ચોકસાઇ, 1-16 MHz સામાન્ય \\ \hline
\keyword{આંતરિક RC} & બિલ્ટ-ઇન 8 MHz ઓસિલેટર \\ \hline
\keyword{બાહ્ય ક્લોક} & બાહ્ય ક્લોક સિગ્નલ ઇનપુટ \\ \hline
\keyword{લો-ફ્રીક્વન્સી ક્રિસ્ટલ} & RTC એપ્લિકેશન્સ માટે 32.768 kHz \\ \hline
\end{tabulary}
\end{answertable}

\keyword{રીસેટ સર્કિટ કાર્યો:}
\begin{itemize}
    \item \keyword{પાવર-ઓન રીસેટ}: પાવર લાગુ થયા પછી આપમેળે રીસેટ
    \item \keyword{બ્રાઉન-આઉટ રીસેટ}: સપ્લાઇ વોલ્ટેજ ઘટે છે ત્યારે રીસેટ
    \item \keyword{બાહ્ય રીસેટ}: RESET પિન દ્વારા મેન્યુઅલ રીસેટ
    \item \keyword{વોચડોગ રીસેટ}: વોચડોગ ટાઇમર ટાઇમઆઉટથી રીસેટ
\end{itemize}

\keyword{મુખ્ય વિશેષતાઓ:}
\begin{itemize}
    \item \keyword{ક્લોક વિતરણ}: સિસ્ટમ ક્લોક CPU અને પેરિફેરલ્સ ચલાવે છે
    \item \keyword{રીસેટ ક્રમ}: બધા રજિસ્ટર્સને ડિફોલ્ટ વેલ્યુમાં પ્રારંભ કરે છે
    \item \keyword{ફ્યુઝ બિટ્સ}: ક્લોક સ્રોત અને રીસેટ વિકલ્પો રૂપરેખાંકિત કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CEIL Clock: Crystal, External, Internal, Low-frequency}
\end{mnemonicbox}

\orquestionmarks{2(ક)}{7}{TCCRn અને TIFR ટાઇમર રજિસ્ટર સમજાવો}

\begin{solutionbox}
\keyword{TCCRn (ટાઇમર/કાઉન્ટર કન્ટ્રોલ રજિસ્ટર):}

\begin{answertable}{TCCRn રજિસ્ટર્સ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{રજિસ્ટર} & \textbf{કાર્ય} \\ \hline
\keyword{TCCR0} & Timer0 ઓપરેશન મોડ નિયંત્રિત કરે છે \\ \hline
\keyword{TCCR1A/B} & Timer1 (16-બિટ) ઓપરેશન નિયંત્રિત કરે છે \\ \hline
\keyword{TCCR2} & Timer2 ઓપરેશન મોડ નિયંત્રિત કરે છે \\ \hline
\end{tabulary}
\end{answertable}

\keyword{TCCR બિટ કાર્યો:}
\begin{itemize}
    \item \keyword{ક્લોક સિલેક્ટ (CS)}: ક્લોક સ્રોત અને પ્રીસ્કેલર પસંદ કરે છે
    \item \keyword{વેવફોર્મ જનરેશન (WGM)}: ટાઇમર મોડ સેટ કરે છે (Normal, CTC, PWM)
    \item \keyword{કમ્પેર આઉટપુટ મોડ (COM)}: આઉટપુટ પિન વર્તન નિયંત્રિત કરે છે
\end{itemize}

\keyword{TIFR (ટાઇમર ઇન્ટરપ્ટ ફ્લેગ રજિસ્ટર):}
\begin{answertable}{TIFR ફ્લેગ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{બિટ} & \textbf{ફ્લેગ} & \textbf{વર્ણન} \\ \hline
\keyword{TOV} & ટાઇમર ઓવરફ્લો & ટાઇમર ઓવરફ્લો થાય છે ત્યારે સેટ થાય છે \\ \hline
\keyword{OCF} & આઉટપુટ કમ્પેર & કમ્પેર મેચ થાય છે ત્યારે સેટ થાય છે \\ \hline
\keyword{ICF} & ઇનપુટ કેપ્ચર & ઇનપુટ કેપ્ચર ઇવેન્ટ થાય છે ત્યારે સેટ થાય છે \\ \hline
\end{tabulary}
\end{answertable}

\keyword{ટાઇમર ઓપરેશન્સ:}
\begin{itemize}
    \item \keyword{મોડ પસંદગી}: Normal, CTC, Fast PWM, Phase Correct PWM
    \item \keyword{ઇન્ટરપ્ટ જનરેશન}: સક્ષમ હોય ત્યારે ફ્લેગ્સ ઇન્ટરપ્ટ ટ્રિગર કરે છે
    \item \keyword{આઉટપુટ જનરેશન}: મોટર કન્ટ્રોલ, LED ડિમિંગ માટે PWM સિગ્નલ્સ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TCCR WGM: Timer Control, Clock, Register, Waveform Generation Mode}
\end{mnemonicbox}

\questionmarks{3(અ)}{3}{C માં પ્રોગ્રામિંગ AVR માટે વિવિધ ડેટા ટાઇપ અલગ પાડો}

\begin{solutionbox}
\keyword{AVR C ડેટા ટાઇપ્સ:}

\begin{answertable}{AVR C ડેટા ટાઇપ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{ડેટા ટાઇપ} & \textbf{કદ} & \textbf{શ્રેણી} & \textbf{ઉપયોગ} \\ \hline
\keyword{char} & 8-બિટ & -128 to 127 & અક્ષરો, નાના પૂર્ણાંકો \\ \hline
\keyword{unsigned char} & 8-બિટ & 0 to 255 & પોર્ટ મૂલ્યો, ફ્લેગ્સ \\ \hline
\keyword{int} & 16-બિટ & -32768 to 32767 & સામાન્ય પૂર્ણાંકો \\ \hline
\keyword{unsigned int} & 16-બિટ & 0 to 65535 & કાઉન્ટર્સ, સરનામાઓ \\ \hline
\keyword{long} & 32-બિટ & -2\textsuperscript{31} to 2\textsuperscript{31}-1 & મોટી ગણતરીઓ \\ \hline
\keyword{float} & 32-બિટ & $\pm3.4\times10^{38}$ & દશાંશ ગણતરીઓ \\ \hline
\end{tabulary}
\end{answertable}

\keyword{વિશેષ વિચારણાઓ:}
\begin{itemize}
    \item \keyword{મેમરી કાર્યક્ષમ}: સૌથી નાની યોગ્ય ડેટા ટાઇપનો ઉપયોગ કરો
    \item \keyword{પોર્ટ ઓપરેશન્સ}: 8-બિટ પોર્ટ્સ માટે unsigned char
    \item \keyword{ટાઇમિંગ ગણતરીઓ}: ટાઇમર મૂલ્યો માટે unsigned int
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CUIL Float: Char, Unsigned, Int, Long, Float}
\end{mnemonicbox}

\questionmarks{3(બ)}{4}{પોર્ટ C ના તમામ બિટ્સને 200 વખત ટૉગલ કરવા માટે C પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRC = 0xFF;        // Set Port C as output
    unsigned int count = 0;
    
    while(count < 200) {
        PORTC = 0xFF;   // Set all bits high
        _delay_ms(100); // Delay
        PORTC = 0x00;   // Set all bits low  
        _delay_ms(100); // Delay
        count++;        // Increment counter
    }
    return 0;
}
\end{lstlisting}

\keyword{પ્રોગ્રામ સમજૂતી:}
\begin{itemize}
    \item \keyword{DDRC = 0xFF}: પોર્ટ C ના બધા પિન્સને આઉટપુટ તરીકે રૂપરેખાંકિત કરે છે
    \item \keyword{ટૉગલ ઓપરેશન}: 0xFF અને 0x00 વચ્ચે ફેરબદલી કરે છે
    \item \keyword{કાઉન્ટર}: ટૉગલ સાઇકલ્સની સંખ્યા ટ્રેક કરે છે
    \item \keyword{વિલંબ}: ટૉગલ ઓપરેશન માટે દૃશ્યમાન ટાઇમિંગ પ્રદાન કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DTC Loop: DDR setup, Toggle bits, Count iterations, Loop control}
\end{mnemonicbox}

\questionmarks{3(ક)}{7}{અ) LED PORTB ના પિન સાથે જોડાયેલ છે. LED પર 0 થી FFh સુધીની ગણતરી બતાવવા માટે AVR પ્રોગ્રામ્સ લખો\\બ) પોર્ટ C માંથી ડેટાનો બાઇટ મેળવવા માટે AVR C પ્રોગ્રામ લખો. જો તે 100 કરતા ઓછો હોય તો તેને પોર્ટ B પર મોકલો; નહીંતર, તેને પોર્ટ D પર મોકલો.}

\begin{solutionbox}
\textbf{અ) બાઇનરી કાઉન્ટર ડિસ્પ્લે:}

\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRB = 0xFF;           // Port B as output
    unsigned char count = 0;
    
    while(1) {
        PORTB = count;     // Display count on LEDs
        _delay_ms(500);    // Delay for visibility
        count++;           // Increment counter
        if(count > 0xFF)   // Reset after 255
            count = 0;
    }
    return 0;
}
\end{lstlisting}

\textbf{બ) શરતી ડેટા ટ્રાન્સફર:}

\begin{lstlisting}[language=C]
#include <avr/io.h>

int main() {
    DDRC = 0x00;    // Port C as input
    DDRB = 0xFF;    // Port B as output  
    DDRD = 0xFF;    // Port D as output
    
    while(1) {
        unsigned char data = PINC;  // Read from Port C
        
        if(data < 100) {
            PORTB = data;           // Send to Port B
            PORTD = 0x00;          // Clear Port D
        } else {
            PORTD = data;           // Send to Port D
            PORTB = 0x00;          // Clear Port B
        }
    }
    return 0;
}
\end{lstlisting}

\keyword{મુખ્ય પ્રોગ્રામિંગ વિભાવનાઓ:}
\begin{itemize}
    \item \keyword{પોર્ટ દિશા}: DDR રજિસ્ટર્સ ઇનપુટ/આઉટપુટ રૂપરેખાંકિત કરે છે
    \item \keyword{ડેટા વાંચવું}: PIN રજિસ્ટર્સ ઇનપુટ મૂલ્યો વાંચે છે
    \item \keyword{શરતી તર્ક}: નિર્ણય લેવા માટે if-else નિવેદનો
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RCC Data: Read input, Compare value, Conditional output}
\end{mnemonicbox}

\orquestionmarks{3(અ)}{3}{-3 થી +3 પોર્ટ B ની કિંમતો મોકલવા માટે AVR C પ્રોગ્રામ લખો}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRB = 0xFF;              // Port B as output
    signed char values[] = {-3, -2, -1, 0, 1, 2, 3};
    unsigned char i = 0;
    
    while(1) {
        PORTB = values[i];    // Send value to Port B
        _delay_ms(1000);      // 1 second delay
        i++;                  // Next value
        if(i > 6) i = 0;      // Reset index
    }
    return 0;
}
\end{lstlisting}

\keyword{પ્રોગ્રામ વિશેષતાઓ:}
\begin{itemize}
    \item \keyword{સાઇન ડેટા}: નકારાત્મક મૂલ્યો માટે signed char નો ઉપયોગ
    \item \keyword{અરે સ્ટોરેજ}: સરળ પહોંચ માટે અરેમાં મૂલ્યો સંગ્રહ
    \item \keyword{ચક્રીય ઓપરેશન}: તમામ મૂલ્યો દ્વારા સતત ચક્ર
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SAC Values: Signed char, Array storage, Cyclic operation}
\end{mnemonicbox}

\orquestionmarks{3(બ)}{4}{ASCII અક્ષરો 0,1,2,3,4,5,A,B,C અને D માટે હેક્સ મૂલ્યો પોર્ટ B પર મોકલવા માટે AVR C પ્રોગ્રામ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

int main() {
    DDRB = 0xFF;    // Port B as output
    
    // ASCII hex values array
    unsigned char ascii_values[] = {
        0x30,  // '0'
        0x31,  // '1' 
        0x32,  // '2'
        0x33,  // '3'
        0x34,  // '4'
        0x35,  // '5'
        0x41,  // 'A'
        0x42,  // 'B'
        0x43,  // 'C'
        0x44   // 'D'
    };
    
    unsigned char i = 0;
    
    while(1) {
        PORTB = ascii_values[i];  // Send ASCII value
        _delay_ms(500);           // Delay
        i++;                      // Next character
        if(i > 9) i = 0;          // Reset index
    }
    return 0;
}
\end{lstlisting}

\keyword{ASCII મૂલ્યો ટેબલ:}
\begin{answertable}{ASCII મૂલ્યો}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{અક્ષર} & \textbf{હેક્સ મૂલ્ય} & \textbf{બાઇનરી} \\ \hline
'0' & 0x30 & 00110000 \\ \hline
'1' & 0x31 & 00110001 \\ \hline
'A' & 0x41 & 01000001 \\ \hline
'B' & 0x42 & 01000010 \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{HAC ASCII: Hex values, Array storage, Cyclic transmission}
\end{mnemonicbox}

\orquestionmarks{3(ક)}{7}{ડોર સેન્સર પોર્ટ B ના બિટ 1 સાથે જોડાયેલ છે, અને LED પોર્ટ C ના બિટ 7 સાથે જોડાયેલ છે. ડોર સેન્સર પર દેખરેખ રાખવા માટે AVR C પ્રોગ્રામ લખો અને જ્યારે તે ખુલે છે (PIN HIGH છે), LED ચાલુ કરો. ફ્લો ચાર્ટ પણ દોરો.}

\begin{solutionbox}
\textbf{C પ્રોગ્રામ:}

\begin{lstlisting}[language=C]
#include <avr/io.h>

int main() {
    DDRB = 0xFD;    // Port B bit 1 as input (0), others output (1)
    DDRC = 0xFF;    // Port C as output
    PORTB = 0x02;   // Enable pull-up for bit 1
    
    while(1) {
        if(PINB & 0x02) {      // Check if door sensor is HIGH
            PORTC |= 0x80;     // Turn ON LED (bit 7)
        } else {
            PORTC &= 0x7F;     // Turn OFF LED (bit 7)
        }
    }
    return 0;
}
\end{lstlisting}

\textbf{ફ્લો ચાર્ટ:}

\begin{answerdiagram}{ડોર સેન્સર ફ્લો ચાર્ટ}
\begin{tikzpicture}[gtu flow]
    \node [gtu start] (start) {Start};
    \node [gtu process, below=of start] (init) {Initialize Ports\\B1=Input, C7=Output};
    \node [gtu decision, below=of init] (check) {Door Open?\\(PINB.1==1)};
    \node [gtu process, below left=of check] (on) {Turn LED ON\\(PORTC.7=1)};
    \node [gtu process, below right=of check] (off) {Turn LED OFF\\(PORTC.7=0)};
    \node [gtu state, below=3cm of check] (combine) {Loop};

    \path [gtu arrow] (start) -- (init);
    \path [gtu arrow] (init) -- (check);
    \path [gtu arrow] (check) -| node[above, near start] {Yes} (on);
    \path [gtu arrow] (check) -| node[above, near start] {No} (off);
    \path [gtu arrow] (on) |- (combine);
    \path [gtu arrow] (off) |- (combine);
    \path [gtu arrow] (combine) -- (check);
\end{tikzpicture}
\end{answerdiagram}

\keyword{બિટ ઓપરેશન્સ:}
\begin{itemize}
    \item \keyword{ઇનપુટ વાંચવું}: \code{PINB \& 0x02} બિટ 1 તપાસે છે
    \item \keyword{LED નિયંત્રણ}: \code{PORTC |= 0x80} બિટ 7 સેટ કરે છે
    \item \keyword{LED બંધ}: \code{PORTC \&= 0x7F} બિટ 7 સાફ કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BIC Door: Bit manipulation, Input monitoring, Conditional LED control}
\end{mnemonicbox}

\questionmarks{4(અ)}{3}{ADC માટેનું ADMUX રજિસ્ટર સમજાવો}

\begin{solutionbox}
\keyword{ADMUX (ADC મલ્ટિપ્લેક્સર સિલેક્શન રજિસ્ટર):}

\begin{answertable}{ADMUX બિટ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{બિટ} & \textbf{નામ} & \textbf{વર્ણન} \\ \hline
\keyword{બિટ 7-6} & REFS1:0 & રેફરન્સ સિલેક્શન \\ \hline
\keyword{બિટ 5} & ADLAR & ADC લેફ્ટ એડજસ્ટ રિઝલ્ટ \\ \hline
\keyword{બિટ 4-0} & MUX4:0 & એનાલોગ ચેનલ સિલેક્શન \\ \hline
\end{tabulary}
\end{answertable}

\keyword{રેફરન્સ સિલેક્શન (REFS1:0):}
\begin{itemize}
    \item \keyword{00}: AREF, આંતરિક Vref બંધ
    \item \keyword{01}: AREF પિન પર બાહ્ય કેપેસિટર સાથે AVCC
    \item \keyword{10}: આરક્ષિત
    \item \keyword{11}: આંતરિક 2.56V રેફરન્સ
\end{itemize}

\keyword{ચેનલ સિલેક્શન (MUX4:0):}
\begin{itemize}
    \item \keyword{00000-00111}: ADC0-ADC7 (સિંગલ-એન્ડેડ ઇનપુટ્સ)
    \item \keyword{અન્ય કમ્બિનેશન્સ}: ગેઇન સાથે ડિફરન્શિયલ ઇનપુટ્સ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RAM ADMUX: Reference, Alignment, Multiplexer}
\end{mnemonicbox}

\questionmarks{4(બ)}{4}{વિવિધ એલસીડી પિન સમજાવો.}

\begin{solutionbox}
\keyword{16x2 LCD પિન રૂપરેખાંકન:}

\begin{answertable}{LCD પિન}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પિન} & \textbf{સિમ્બોલ} & \textbf{કાર્ય} \\ \hline
\textbf{1} & VSS & ગ્રાઉન્ડ (0V) \\ \hline
\textbf{2} & VDD & પાવર સપ્લાઇ (+5V) \\ \hline
\textbf{3} & V0 & કોન્ટ્રાસ્ટ એડજસ્ટમેન્ટ \\ \hline
\textbf{4} & RS & રજિસ્ટર સિલેક્ટ (ડેટા/કમાન્ડ) \\ \hline
\textbf{5} & R/W & રીડ/રાઇટ સિલેક્ટ \\ \hline
\textbf{6} & E & એનેબલ સિગ્નલ \\ \hline
\textbf{7-14} & D0-D7 & ડેટા બસ (8-બિટ) \\ \hline
\textbf{15} & A & બેકલાઇટ એનોડ (+) \\ \hline
\textbf{16} & K & બેકલાઇટ કેથોડ (-) \\ \hline
\end{tabulary}
\end{answertable}

\keyword{કન્ટ્રોલ પિન કાર્યો:}
\begin{itemize}
    \item \keyword{RS = 0}: કમાન્ડ રજિસ્ટર પસંદ
    \item \keyword{RS = 1}: ડેટા રજિસ્ટર પસંદ
    \item \keyword{R/W = 0}: રાઇટ ઓપરેશન
    \item \keyword{R/W = 1}: રીડ ઓપરેશન
    \item \keyword{E}: એનેબલ પલ્સ ઓપરેશન ટ્રિગર કરે છે
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{VCR EDB LCD: Vpower, Contrast, Register select, Enable, Data Bus}
\end{mnemonicbox}

\questionmarks{4(ક)}{7}{20$\mu$s વિલંબ સાથે PORTB ના તમામ બિટ્સને સતત ટૉગલ કરવા માટે પ્રોગ્રામ લખો. વિલંબ જનરેટ કરવા માટે Timer0, નોર્મલ મોડ અને કોઈ Prescaler નો ઉપયોગ કરો}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>

void delay_20us() {
    TCNT0 = 0;          // Clear timer counter
    TCCR0 = 0x01;       // No prescaler, normal mode
    while(TCNT0 < 160); // Wait for 20us (8MHz/1 * 20us = 160)
    TCCR0 = 0;          // Stop timer
}

int main() {
    DDRB = 0xFF;        // Port B as output
    
    while(1) {
        PORTB = 0xFF;   // Set all bits high
        delay_20us();   // 20us delay
        PORTB = 0x00;   // Set all bits low
        delay_20us();   // 20us delay
    }
    return 0;
}
\end{lstlisting}

\keyword{ટાઇમર ગણતરી:}
\begin{itemize}
    \item \keyword{ક્લોક ફ્રીક્વન્સી}: 8 MHz (ધારણા)
    \item \keyword{ટાઇમર રીઝોલ્યુશન}: 1/8MHz = 0.125$\mu$s પ્રતિ કાઉન્ટ
    \item \keyword{જરૂરી કાઉન્ટ્સ}: 20$\mu$s / 0.125$\mu$s = 160 કાઉન્ટ્સ
\end{itemize}

\keyword{Timer0 રૂપરેખાંકન:}
\begin{answertable}{Timer0 સેટિંગ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{સેટિંગ} & \textbf{મૂલ્ય} & \textbf{વર્ણન} \\ \hline
\keyword{મોડ} & નોર્મલ & 0 થી 255 સુધી ગણે છે \\ \hline
\keyword{Prescaler} & 1 & કોઈ પ્રીસ્કેલિંગ નહીં \\ \hline
\keyword{ક્લોક સ્રોત} & સિસ્ટમ ક્લોક & 8 MHz \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{TNP Timer: Timer0, Normal mode, Prescaler none}
\end{mnemonicbox}

\orquestionmarks{4(અ)}{3}{ટૂંકી નોંધ બે વાયર ઇન્ટરફેસ (TWI)}

\begin{solutionbox}
\keyword{TWI (બે વાયર ઇન્ટરફેસ) - I2C પ્રોટોકોલ:}

\keyword{મુખ્ય વિશેષતાઓ:}
\begin{answertable}{TWI વિશેષતાઓ}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{વિશેષતા} & \textbf{વર્ણન} \\ \hline
\keyword{બે વાયર} & SDA (ડેટા) અને SCL (ક્લોક) \\ \hline
\keyword{મલ્ટી-માસ્ટર} & બહુવિધ માસ્ટર્સ બસ નિયંત્રિત કરી શકે છે \\ \hline
\keyword{મલ્ટી-સ્લેવ} & 127 સુધી સ્લેવ ડિવાઇસ \\ \hline
\keyword{સરનામું-આધારિત} & 7-બિટ અથવા 10-બિટ ડિવાઇસ સરનામું \\ \hline
\keyword{દ્વિદિશીય} & બંને દિશામાં ડેટા વહે છે \\ \hline
\end{tabulary}
\end{answertable}

\keyword{બસ લાક્ષણિકતાઓ:}
\begin{itemize}
    \item \keyword{ઓપન-ડ્રેઇન}: પુલ-અપ રેઝિસ્ટર્સ આવશ્યક (4.7k$\Omega$ મુળ)
    \item \keyword{સિન્ક્રોનસ}: માસ્ટર દ્વારા ક્લોક પ્રદાન કરાય છે
    \item \keyword{સ્ટાર્ટ/સ્ટોપ કન્ડિશન્સ}: કમ્યુનિકેશન માટે વિશેષ ક્રમ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SDA SCL TWI: Serial Data, Serial CLock, Two Wire Interface}
\end{mnemonicbox}

\orquestionmarks{4(બ)}{4}{ADC માટેનું ADCSRA રજિસ્ટર સમજાવો}

\begin{solutionbox}
\keyword{ADCSRA (ADC કન્ટ્રોલ અને સ્ટેટસ રજિસ્ટર A):}

\begin{answertable}{ADCSRA રજિસ્ટર}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{બિટ} & \textbf{નામ} & \textbf{કાર્ય} \\ \hline
\keyword{બિટ 7} & ADEN & ADC એનેબલ \\ \hline
\keyword{બિટ 6} & ADSC & ADC સ્ટાર્ટ કન્વર્ઝન \\ \hline
\keyword{બિટ 5} & ADATE & ADC ઓટો ટ્રિગર એનેબલ \\ \hline
\keyword{બિટ 4} & ADIF & ADC ઇન્ટરપ્ટ ફ્લેગ \\ \hline
\keyword{બિટ 3} & ADIE & ADC ઇન્ટરપ્ટ એનેબલ \\ \hline
\keyword{બિટ 2-0} & ADPS2:0 & ADC પ્રીસ્કેલર સિલેક્ટ \\ \hline
\end{tabulary}
\end{answertable}

\keyword{પ્રીસ્કેલર સેટિંગ્સ (ADPS2:0):}
\begin{answertable}{પ્રીસ્કેલર સેટિંગ્સ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{બાઇનરી} & \textbf{વિભાજન પરિબળ} & \textbf{ADC ક્લોક (8MHz)} \\ \hline
000 & 2 & 4 MHz \\ \hline
001 & 2 & 4 MHz \\ \hline
010 & 4 & 2 MHz \\ \hline
011 & 8 & 1 MHz \\ \hline
100 & 16 & 500 kHz \\ \hline
101 & 32 & 250 kHz \\ \hline
110 & 64 & 125 kHz \\ \hline
111 & 128 & 62.5 kHz \\ \hline
\end{tabulary}
\end{answertable}

\keyword{કન્ટ્રોલ કાર્યો:}
\begin{itemize}
    \item \keyword{ADEN}: ADC ઓપરેશન સક્ષમ કરવા માટે સેટ કરવું આવશ્યક
    \item \keyword{ADSC}: કન્વર્ઝન શરૂ કરવા માટે સેટ કરો, પૂર્ણ થાય ત્યારે સાફ થાય છે
    \item \keyword{Prescaler}: શ્રેષ્ઠ ચોકસાઇ માટે ADC ક્લોક 50-200 kHz હોવી જોઈએ
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EASCID ADC: Enable, Auto-trigger, Start, Conversion, Interrupt, Divider}
\end{mnemonicbox}

\orquestionmarks{4(ક)}{7}{PORTC.3 પિન પર 16 Khz ફ્રીક્વન્સીની સ્ક્વેર વેવ જનરેટ કરવા માટે પ્રોગ્રામ લખો. ક્રિસ્ટલ ફ્રીક્વન્સી 8 Mhz ધારો}

\begin{solutionbox}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <avr/interrupt.h>

int main() {
    // Configure PC3 as output
    DDRC |= (1 << PC3);
    
    // Timer1 CTC mode configuration
    TCCR1A = 0x00;                    // Normal port operation
    TCCR1B = (1 << WGM12) | (1 << CS10); // CTC mode, no prescaler
    
    // Calculate OCR1A value for 16 kHz
    // Period = 1/16000 = 62.5us
    // Half period = 31.25us  
    // OCR1A = (8MHz * 31.25us) - 1 = 249
    OCR1A = 249;
    
    // Enable Timer1 Compare A interrupt
    TIMSK |= (1 << OCIE1A);
    
    // Enable global interrupts
    sei();
    
    while(1) {
        // Main loop - square wave generated by interrupt
    }
    return 0;
}

// Timer1 Compare A interrupt service routine
ISR(TIMER1_COMPA_vect) {
    PORTC ^= (1 << PC3);    // Toggle PC3
}
\end{lstlisting}

\keyword{ફ્રીક્વન્સી ગણતરી:}
\begin{answertable}{ફ્રીક્વન્સી ગણતરી}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પેરામીટર} & \textbf{મૂલ્ય} & \textbf{ફોર્મ્યુલા} \\ \hline
\keyword{Target frequency} & 16 kHz & Given \\ \hline
\keyword{Period} & 62.5 $\mu$s & 1/16000 \\ \hline
\keyword{Half period} & 31.25 $\mu$s & Period/2 \\ \hline
\keyword{Timer counts} & 250 & 8MHz $\times$ 31.25$\mu$s \\ \hline
\keyword{OCR1A value} & 249 & Counts - 1 \\ \hline
\end{tabulary}
\end{answertable}

\keyword{ટાઇમર રૂપરેખાંકન:}
\begin{itemize}
    \item \keyword{Mode}: CTC (Clear Timer on Compare)
    \item \keyword{Prescaler}: 1 (no prescaling)
    \item \keyword{Interrupt}: Compare match toggles output pin
\end{itemize}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CTC Square: CTC mode, Timer interrupt, Compare match}
\end{mnemonicbox}

\questionmarks{5(અ)}{3}{Polling અને Interrupt વચ્ચેનો તફાવત}

\begin{solutionbox}
\keyword{Polling vs Interrupt:}

\begin{answertable}{તફાવત}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પાસું} & \textbf{Polling} & \textbf{Interrupt} \\ \hline
\keyword{CPU ઉપયોગ} & સતત સ્ટેટસ તપાસે છે & ઇવેન્ટ થાય ત્યાં સુધી CPU મુક્ત \\ \hline
\keyword{પ્રતિસાદ સમય} & વેરિએબલ, પોલિંગ ફ્રીક્વન્સી પર આધારિત & ઝડપી, તાત્કાલિક પ્રતિસાદ \\ \hline
\keyword{પાવર વપરાશ} & સતત તપાસને કારણે વધારે & ઓછો, CPU સ્લીપ થઈ શકે છે \\ \hline
\keyword{પ્રોગ્રામિંગ} & સરળ, અનુક્રમિક કોડ & જટિલ, ISR ની જરૂર છે \\ \hline
\keyword{રીઅલ-ટાઇમ} & નિર્ણાયક ટાઇમિંગ માટે યોગ્ય નથી & રીઅલ-ટાઇમ સિસ્ટમો માટે ઉત્તમ \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PIE Method: Polling inefficient, Interrupt efficient, Event-driven}
\end{mnemonicbox}

\questionmarks{5(બ)}{4}{LM35 ઇન્ટરફેસ સમજાવો.}

\begin{solutionbox}
\textbf{LM35 તાપમાન સેન્સર ઇન્ટરફેસ:}

\begin{answerdiagram}{LM35 ઇન્ટરફેસ}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block, minimum height=2cm, minimum width=3cm] (mcu) {ATmega32\\(ADC Channel)};
    \node [gtu block, left=of mcu] (lm35) {LM35\\Sensor};
    \node [above=0.5cm of lm35] (vcc) {+5V};
    \node [below=0.5cm of lm35] (gnd) {GND};
    
    \draw [gtu arrow] (lm35) -- node [midway, above] {Vout} (mcu);
    \draw [gtu arrow] (vcc) -- (lm35);
    \draw [gtu arrow] (lm35) -- (gnd);
\end{tikzpicture}
\end{answerdiagram}

\keyword{LM35 લાક્ષણિકતાઓ:}
\begin{answertable}{LM35 લાક્ષણિકતાઓ}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{પેરામીટર} & \textbf{મૂલ્ય} & \textbf{વર્ણન} \\ \hline
\keyword{આઉટપુટ} & 10mV/$^\circ$C & લીનિયર તાપમાન ગુણાંક \\ \hline
\keyword{શ્રેણી} & 0$^\circ$C to 100$^\circ$C & ઓપરેટિંગ તાપમાન શ્રેણી \\ \hline
\keyword{સપ્લાઇ} & 4V to 30V & પાવર સપ્લાઇ શ્રેણી \\ \hline
\keyword{ચોકસાઇ} & $\pm0.5^\circ$C & તાપમાન ચોકસાઇ \\ \hline
\end{tabulary}
\end{answertable}

\keyword{ઇન્ટરફેસ કોડ:}
\begin{lstlisting}[language=C]
#include <avr/io.h>

void ADC_init() {
    ADMUX = 0x40;   // AVCC reference, ADC0 channel
    ADCSRA = 0x87;  // Enable ADC, prescaler 128
}

unsigned int read_temperature() {
    ADCSRA |= (1 << ADSC);      // Start conversion
    while(ADCSRA & (1 << ADSC)); // Wait for completion
    
    // Convert ADC value to temperature
    // Temperature = (ADC * 5000) / (1024 * 10)
    unsigned int temp = (ADC * 5000) / 10240;
    return temp;
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LAC Temperature: LM35 sensor, ADC conversion, Calculation formula}
\end{mnemonicbox}

\questionmarks{5(ક)}{7}{DC મોટરને ઇન્ટરફેસ કરવા માટે પ્રોગ્રામ લખો.}

\begin{solutionbox}
\textbf{DC મોટર ઇન્ટરફેસ સર્કિટ:}

\begin{answerdiagram}{DC મોટર ઇન્ટરફેસ}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block, minimum height=3cm] (mcu) {ATmega32};
    \node [gtu block, right=of mcu, minimum height=3cm] (driver) {L293D\\Driver};
    \node [gtu block, right=of driver] (motor) {DC Motor};
    
    \node [above=0.5cm of driver] (vcc) {+12V (Motors) / +5V (Logic)};
    \draw [gtu arrow] (vcc) -- (driver);

    \draw [gtu arrow] (mcu.20) -- node[above] {PD5(IN1)} (driver.160);
    \draw [gtu arrow] (mcu.0) -- node[above] {PD6(IN2)} (driver.180);
    \draw [gtu arrow] (mcu.-20) -- node[above] {PD4(EN)} (driver.200);
    
    \draw [gtu arrow] (driver.20) -- node[above] {OUT1} (motor.160);
    \draw [gtu arrow] (driver.0) -- node[above] {OUT2} (motor.180);
\end{tikzpicture}
\end{answerdiagram}

\keyword{મોટર કન્ટ્રોલ પ્રોગ્રામ:}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

void motor_init() {
    DDRD |= (1 << PD4) | (1 << PD5) | (1 << PD6); // Set as output
}

void motor_forward() {
    PORTD |= (1 << PD4);   // Enable motor
    PORTD |= (1 << PD5);   // IN1 = 1
    PORTD &= ~(1 << PD6);  // IN2 = 0
}

void motor_reverse() {
    PORTD |= (1 << PD4);   // Enable motor
    PORTD &= ~(1 << PD5);  // IN1 = 0
    PORTD |= (1 << PD6);   // IN2 = 1
}

void motor_stop() {
    PORTD &= ~(1 << PD4);  // Disable motor
}

int main() {
    motor_init();
    
    while(1) {
        motor_forward();    // Forward for 2 seconds
        _delay_ms(2000);
        
        motor_stop();       // Stop for 1 second
        _delay_ms(1000);
        
        motor_reverse();    // Reverse for 2 seconds
        _delay_ms(2000);
        
        motor_stop();       // Stop for 1 second
        _delay_ms(1000);
    }
    return 0;
}
\end{lstlisting}

\keyword{L293D ટ્રુથ ટેબલ:}
\begin{answertable}{L293D ટ્રુથ ટેબલ}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textbf{EN} & \textbf{IN1} & \textbf{IN2} & \textbf{Motor Action} \\ \hline
0 & X & X & Stop \\ \hline
1 & 0 & 0 & Stop \\ \hline
1 & 0 & 1 & Reverse \\ \hline
1 & 1 & 0 & Forward \\ \hline
1 & 1 & 1 & Stop \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{LED Motor: L293D driver, Enable control, Direction pins}
\end{mnemonicbox}

\orquestionmarks{5(અ)}{3}{GSM આધારિત સુરક્ષા સિસ્ટમનો બ્લોક ડાયાગ્રામ સમજાવો.}

\begin{solutionbox}
\textbf{GSM સુરક્ષા સિસ્ટમ બ્લોક ડાયાગ્રામ:}

\begin{answerdiagram}{GSM સુરક્ષા સિસ્ટમ}
\begin{tikzpicture}[auto, node distance=2cm]
    \node [gtu block] (mcu) {ATmega32\\Microcontroller};
    
    \node [gtu input, left=of mcu] (sensors) {Sensors\\(PIR, Door)};
    \node [gtu block, right=of mcu] (gsm) {GSM\\Module};
    \node [gtu block, right=of gsm] (network) {Mobile\\Network};
    \node [gtu block, right=of network] (phone) {User\\Phone};
    \node [gtu block, above=of mcu] (lcd) {LCD\\Display};
    \node [gtu block, below=of mcu] (alarm) {Alarm/\\Buzzer};
    \node [gtu block, below left=1.5cm of mcu] (power) {Power Support};
    
    \path [gtu arrow] (sensors) -- (mcu);
    \path [gtu arrow] (mcu) -- (gsm);
    \path [gtu arrow] (gsm) -- (network);
    \path [gtu arrow] (network) -- (phone);
    \path [gtu arrow] (mcu) -- (lcd);
    \path [gtu arrow] (mcu) -- (alarm);
    \path [gtu arrow] (power) -- (mcu);
    \path [gtu arrow] (power) -- (gsm);
\end{tikzpicture}
\end{answerdiagram}

\keyword{સિસ્ટમ ઘટકો:}
\begin{answertable}{સિસ્ટમ ઘટકો}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{ઘટક} & \textbf{કાર્ય} \\ \hline
\keyword{સેન્સર્સ} & PIR, ડોર/વિન્ડો સેન્સર્સ, સ્મોક ડિટેક્ટર \\ \hline
\keyword{માઇક્રોકન્ટ્રોલર} & સેન્સર ડેટા પ્રોસેસ કરે છે, સિસ્ટમ કન્ટ્રોલ \\ \hline
\keyword{GSM મોડ્યુલ} & SMS ચેતવણીઓ મોકલે છે, કોલ કરે છે \\ \hline
\keyword{ડિસ્પ્લે} & સિસ્ટમ સ્ટેટસ બતાવે છે \\ \hline
\keyword{એલાર્મ} & સ્થાનિક ઓડિયો/વિઝ્યુઅલ ચેતવણી \\ \hline
\end{tabulary}
\end{answertable}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SGMA Security: Sensors, GSM module, Microcontroller, Alerts}
\end{mnemonicbox}

\orquestionmarks{5(બ)}{4}{રીલે ઇન્ટરફેસ સમજાવો.}

\begin{solutionboxnobreak}
\textbf{રીલે ઇન્ટરફેસ સર્કિટ:}

\begin{center}
\captionof{figure}{રીલે ઇન્ટરફેસ}
\begin{tikzpicture}[auto, node distance=1.2cm]
    \node [gtu block, minimum height=2cm] (mcu) {ATmega32};
    \node [gtu block, right=1cm of mcu, minimum height=2cm] (driver) {ULN2803\\Driver};
    \node [draw, rectangle, right=1cm of driver, minimum height=1.5cm, align=center] (relay) {Relay};
    \node [draw, circle, right=1cm of relay, align=center] (load) {AC\\Load};
    
    \draw [gtu arrow] (mcu.20) -- node[above, font=\tiny] {PB0} (driver.160);
    \draw [gtu arrow] (mcu.-20) -- node[above, font=\tiny] {PB1} (driver.200);
    
    \draw [gtu arrow] (driver.0) -- node[above, font=\tiny] {Drive} (relay.180);
    \draw [gtu arrow] (relay) -- (load);
    
    \node [above=0.3cm of relay] (v12) {+12V};
    \draw [gtu arrow] (v12) -- (relay);
\end{tikzpicture}
\end{center}

\keyword{રીલે ઇન્ટરફેસ કોડ:}
\begin{lstlisting}[language=C]
#include <avr/io.h>
#include <util/delay.h>

void relay_init() {
    DDRB |= (1 << PB0) | (1 << PB1); // Set as output pins
}

void relay1_on() {
    PORTB |= (1 << PB0);  // Activate relay 1
}

void relay1_off() {
    PORTB &= ~(1 << PB0); // Deactivate relay 1
}

int main() {
    relay_init();
    
    while(1) {
        relay1_on();        // Turn on relay 1
        _delay_ms(2000);
        relay1_off();       // Turn off relay 1
        _delay_ms(1000);
    }
    return 0;
}
\end{lstlisting}

\keyword{ULN2803 વિશેષતાઓ:}
\begin{itemize}
    \item \keyword{8 ચેનલો}: આઠ ડાર્લિંગટન જોડી ડ્રાઇવરો
    \item \keyword{ઉચ્ચ કરંટ}: 500mA પ્રતિ ચેનલ સુધી
    \item \keyword{સુરક્ષા}: બિલ્ટ-ઇન ફ્લાયબેક ડાયોડ્સ
\end{itemize}
\end{solutionboxnobreak}

\begin{mnemonicbox}
\mnemonic{ULN Relay: ULN2803 driver, Load control, Non-contact switching}
\end{mnemonicbox}

\orquestionmarks{5(ક)}{7}{ઓટોમેટિક જ્યુસ વેન્ડિંગ મશીન દોરો અને સમજાવો}

\begin{solutionbox}
\textbf{ઓટોમેટિક જ્યુસ વેન્ડિંગ મશીન બ્લોક ડાયાગ્રામ:}

\begin{center}
\captionof{figure}{જ્યુસ વેન્ડિંગ મશીન}
\begin{tikzpicture}[auto, node distance=1.5cm]
    \node [gtu block] (mcu) {ATmega32\\Controller};
    
    \node [gtu block, left=of mcu, yshift=1.5cm] (coin) {Coin Sensor};
    \node [gtu block, left=of mcu, yshift=-1.5cm] (keypad) {Keypad};
    \node [gtu block, right=of mcu, yshift=1.5cm] (dispense) {Pump/Valve};
    \node [gtu block, right=of mcu, yshift=-1.5cm] (return) {Coin Return};
    \node [gtu block, above=of mcu] (lcd) {LCD Display};
    \node [gtu block, below=of mcu] (level) {Level Sensors};
    
    \path [gtu arrow] (coin) -- (mcu);
    \path [gtu arrow] (keypad) -- (mcu);
    \path [gtu arrow] (mcu) -- (dispense);
    \path [gtu arrow] (mcu) -- (return);
    \path [gtu arrow] (mcu) -- (lcd);
    \path [gtu arrow] (level) -- (mcu);
\end{tikzpicture}
\end{center}

\keyword{સિસ્ટમ ઓપરેશન:}
\begin{itemize}
    \item \keyword{પ્રારંભિકીકરણ}: વેલકમ મેસેજ અને જ્યુસ મેનુ દર્શાવો
    \item \keyword{કોઇન ઇનપુટ}: વપરાશકર્તા સિક્કા દાખલ કરે છે, સિસ્ટમ રકમ માન્ય કરે છે
    \item \keyword{પસંદગી}: વપરાશકર્તા જ્યુસ પ્રકાર પસંદ કરવા માટે કીપેડ દબાવે છે
    \item \keyword{માન્યતા}: તપાસો કે પૂરતા પૈસા અને જ્યુસ ઉપલબ્ધ છે કે કેમ
    \item \keyword{ડિસ્પેન્સિંગ}: પસંદ કરેલ જ્યુસ માટે પંપ અને વાલ્વ સક્રિય કરો
    \item \keyword{પૂર્ણતા}: જો કોઈ ફેરફાર હોય તો પરત કરો, આભાર સંદેશ દર્શાવો
\end{itemize}

\keyword{કન્ટ્રોલ લોજિક:}
\begin{lstlisting}[language=C]
// Pseudo code for vending machine operation
void vending_machine() {
    display_menu();
    
    while(1) {
        if(coin_inserted()) {
            total_amount += validate_coin();
            update_display();
        }
        
        if(selection_made()) {
            juice_type = get_selection();
            if(total_amount >= juice_price[juice_type]) {
                if(juice_available[juice_type]) {
                    dispense_juice(juice_type);
                    return_change();
                    reset_system();
                } else {
                    display_error("Out of Stock");
                }
            } else {
                display_error("Insufficient Amount");
            }
        }
    }
}
\end{lstlisting}
\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CLPDV Juice: Coin sensor, LCD display, Pump motors, Dispensing unit, Valve control}
\end{mnemonicbox}

\end{document}
