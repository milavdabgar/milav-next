\documentclass{article}
\input{../../../../../../../latex-templates/gtu-solutions-short/preamble.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/gujarati-boxes.tex}
\input{../../../../../../../latex-templates/gtu-solutions-short/commands.tex}

\title{VLSI Technology (4361102) - Summer 2024 Solution}
\date{May 16, 2024}

\begin{document}
\maketitle

\questionmarks{1(a)}{3}{FinFET ની રચના દોરો અને તેના ફાયદા લખો.}

\begin{solutionbox}
\begin{figure}[H]
\centering
\begin{tikzpicture}
    % Substrate
    \draw[fill=gray!10] (-1,-1) rectangle (6,0);
    \node at (2.5, -0.5) {Silicon Substrate};

    % Fin
    \draw[fill=blue!10] (0,0) -- (5,0) -- (5.5,1) -- (0.5,1) -- cycle; % Top
    \draw[fill=blue!20] (0,0) rectangle (5,1.5); % Front face
    
    % Fin body
    \draw[fill=gray!30] (0,0) -- (4,0) -- (4,1) -- (0,1) -- cycle; % Front
    \draw[fill=gray!20] (0,1) -- (4,1) -- (5,2) -- (1,2) -- cycle; % Top
    \draw[fill=gray!40] (4,0) -- (5,1) -- (5,2) -- (4,1) -- cycle; % Side

    % Gate wrapping around
    \draw[fill=red!40, opacity=0.9] (1.5,-0.2) rectangle (2.5, 1.2); % Front part
    \draw[fill=red!30, opacity=0.9] (1.5,1.2) -- (2.5,1.2) -- (3.5,2.2) -- (2.5,2.2) -- cycle; % Top part
    \draw[fill=red!50, opacity=0.9] (2.5,-0.2) -- (3.5,0.8) -- (3.5,2.2) -- (2.5,1.2) -- cycle; % Side part

    % Labels
    \node at (0.7, 0.5) {\textbf{Source}};
    \node at (3.3, 0.5) {\textbf{Drain}};
    \node at (2, 0.5) {\textbf{Gate}};
    \node[right] at (5,2) {Fin Structure};
\end{tikzpicture}
\caption{FinFET Structure}
\end{figure}

\textbf{ફાયદા:}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L}
\toprule
\textbf{ફાયદો} & \textbf{વર્ણન} \\
\midrule
\textbf{બેહતર નિયંત્રણ} & ગુણાકાર gates બહેતર channel control આપે છે \\
\textbf{ઘટાડેલ લીકેજ} & 3D રચનાના કારણે ઓછું off-state current \\
\textbf{સુધારેલ કામગીરી} & વધુ drive current અને ઝડપી switching \\
\bottomrule
\end{tabulary}
\caption{FinFET Advantages}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BCR - Better Control Reduces leakage}
\end{mnemonicbox}

\questionmarks{1(b)}{4}{એક્સટર્નલ બાયઝ હેઠળ MOS રચનાનું ડેપ્લીશન અને ઇનવર્શન સમજાવો}

\begin{solutionbox}
\textbf{કોષ્ટક: MOS બાયઝ પરિસ્થિતિઓ}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L L}
\toprule
\textbf{બાયઝ પ્રકાર} & \textbf{ગેટ વોલ્ટેજ} & \textbf{ચેનલ સ્થિતિ} & \textbf{ચાર્જ કેરિયર્સ} \\
\midrule
\textbf{ડેપ્લીશન} & થોડું પોઝિટિવ & Depleted & Holes દૂર ધકેલાય છે \\
\textbf{ઇનવર્શન} & વધુ પોઝિટિવ & Inverted & Electrons આકર્ષાય છે \\
\bottomrule
\end{tabulary}
\caption{MOS Bias Conditions}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.9]
    % Depletion Mode
    \begin{scope}
        \node at (1.5, 3.5) {\textbf{Depletion ($V_G > 0$)}};
        \draw[fill=gray!10] (0,0) rectangle (3,2); % Substrate
        \draw[fill=white] (0,2) rectangle (3,2.2); % Oxide
        \draw[fill=gray!50] (0,2.2) rectangle (3,2.5); % Gate
        
        \node at (1.5, 2.7) {Gate (+)};
        \node at (1.5, 1) {p-substrate};
        
        \draw[dashed] (0,1.5) -- (3,1.5);
        \node at (1.5, 1.8) {\small Depletion Region};
        \node[font=\tiny] at (0.5, 1.7) {-}; \node[font=\tiny] at (1.0, 1.7) {-};
        \node[font=\tiny] at (1.5, 1.7) {-}; \node[font=\tiny] at (2.0, 1.7) {-};
        \node[font=\tiny] at (2.5, 1.7) {-};
    \end{scope}

    % Inversion Mode
    \begin{scope}[xshift=5cm]
        \node at (1.5, 3.5) {\textbf{Inversion ($V_G \gg 0$)}};
        \draw[fill=gray!10] (0,0) rectangle (3,2); % Substrate
        \draw[fill=white] (0,2) rectangle (3,2.2); % Oxide
        \draw[fill=gray!50] (0,2.2) rectangle (3,2.5); % Gate
        
        \node at (1.5, 2.7) {Gate (++)};
        \node at (1.5, 1) {p-substrate};
        
        \draw[fill=blue!20] (0,1.8) rectangle (3,2);
        \node at (1.5, 1.9) {\small Electron Channel};
        \node[font=\tiny] at (0.5, 1.9) {e-}; \node[font=\tiny] at (1.5, 1.9) {e-}; \node[font=\tiny] at (2.5, 1.9) {e-};
    \end{scope}
\end{tikzpicture}
\caption{MOS Depletion and Inversion Layers}
\end{figure}

\begin{itemize}
    \item \textbf{ડેપ્લીશન}: પોઝિટિવ ગેટ વોલ્ટેજ electric field બનાવે છે જે holes ને દૂર ધકેલે છે.
    \item \textbf{ઇનવર્શન}: વધુ વોલ્ટેજ electrons ને આકર્ષે છે અને conducting channel બનાવે છે.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DI - Depletion Inverts to conducting channel}
\end{mnemonicbox}

\questionmarks{1(c)}{7}{n-ચેનલ MOSFET ને તેની કરંટ-વોલ્ટેજ લાક્ષણિકતાઓની મદદથી સમજાવો.}

\begin{solutionbox}
\textbf{કોષ્ટક: MOSFET ઓપરેટિંગ વિભાગો}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L L}
\toprule
\textbf{વિભાગ} & \textbf{શરત} & \textbf{ડ્રેઇન કરંટ} & \textbf{લાક્ષણિકતાઓ} \\
\midrule
\textbf{કટ-ઓફ} & $V_{GS} < V_{TH}$ & $I_D \approx 0$ & કોઈ conduction નથી \\
\textbf{લિનિયર} & $V_{DS} < V_{GS}-V_{TH}$ & $I_D \propto V_{DS}$ & Resistive વર્તન \\
\textbf{સેચ્યુરેશન} & $V_{DS} \geq V_{GS}-V_{TH}$ & $I_D \propto (V_{GS}-V_{TH})^2$ & કરંટ $V_{DS}$ પર આધારિત નથી \\
\bottomrule
\end{tabulary}
\caption{MOSFET Operating Regions}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}
    \begin{axis}[
        width=8cm, height=6cm,
        xlabel={$V_{DS}$ (V)},
        ylabel={$I_D$ (mA)},
        xmin=0, xmax=5,
        ymin=0, ymax=5,
        axis lines=left,
        grid=major
    ]
    \addplot[domain=0:5, samples=100, thick, blue] { (x < 1) ? (2*1*x - x^2) : (1^2) }; 
    \addlegendentry{$V_{GS} = 2V$}
    
    \addplot[domain=0:5, samples=100, thick, red] { (x < 2) ? (2*2*x - x^2) : (2^2) };
    \addlegendentry{$V_{GS} = 3V$}
    
    \addplot[domain=0:5, samples=100, thick, green!60!black] { (x < 3) ? (2*3*x - x^2) : (3^2) };
    \addlegendentry{$V_{GS} = 4V$}
    
    \node at (axis cs: 0.5, 0.2) {Linear};
    \node at (axis cs: 3.5, 3.5) {Saturation};
    \draw[dashed] (axis cs: 1,1) -- (axis cs: 1,0); 
    \draw[dashed, black!50] (axis cs: 0,0) parabola (axis cs:3,9); % Saturation locus
    \end{axis}
\end{tikzpicture}
\caption{MOSFET IV Characteristics}
\end{figure}

\textbf{મુખ્ય સમીકરણો:}
\begin{itemize}
    \item \textbf{Linear}: $I_D = \mu_n C_{ox} \frac{W}{L} [(V_{GS}-V_{TH})V_{DS} - \frac{V_{DS}^2}{2}]$
    \item \textbf{Saturation}: $I_D = \frac{1}{2} \mu_n C_{ox} \frac{W}{L} (V_{GS}-V_{TH})^2$
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CLS - Cut-off, Linear, Saturation regions}
\end{mnemonicbox}

\questionmarks{1(c OR)}{7}{સ્કેલિંગ વ્યાખ્યાયિત કરો. full voltage સ્કેલિંગ સાથે constant voltage સ્કેલિંગની તુલના કરો. સ્કેલિંગના ગેરફાયદા લખો.}

\begin{solutionbox}
\textbf{વ્યાખ્યા:} સ્કેલિંગ એ ડેન્સિટી અને performance વધારવા માટે device dimensions ઘટાડવાની પ્રક્રિયા છે.

\textbf{કોષ્ટક: સ્કેલિંગ તુલના}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L}
\toprule
\textbf{પેરામીટર} & \textbf{Full Voltage Scaling} & \textbf{Constant Voltage Scaling} \\
\midrule
\textbf{વોલ્ટેજ} & $\alpha$ દ્વારા ઘટાડાય છે & સ્થિર રહે છે \\
\textbf{પાવર ડેન્સિટી} & સ્થિર & $\alpha$ દ્વારા વધે છે \\
\textbf{ઇલેક્ટ્રિક ફિલ્ડ} & સ્થિર & $\alpha$ દ્વારા વધે છે \\
\textbf{પરફોર્મન્સ} & બેહતર & મધ્યમ સુધારો \\
\bottomrule
\end{tabulary}
\caption{Scaling Comparison}
\end{table}

\textbf{ગેરફાયદા:}
\begin{itemize}
    \item \textbf{શોર્ટ ચેનલ ઇફેક્ટ્સ}: ચેનલ લેન્થ modulation વધે છે.
    \item \textbf{હોટ કેરિયર ઇફેક્ટ્સ}: વધુ electric fields devices ને નુકસાન કરે છે.
    \item \textbf{ક્વોન્ટમ ઇફેક્ટ્સ}: ટનલિંગ currents નોંધપાત્ર રીતે વધે છે.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SHQ - Short channel, Hot carriers, Quantum effects}
\end{mnemonicbox}

\questionmarks{2(a)}{3}{CMOS ની મદદથી બે ઇનપુટ NAND ગેટ દોરો.}

\begin{solutionbox}
CMOS NAND gate બે parallel pMOS ટ્રાન્ઝિસ્ટર અને બે series nMOS ટ્રાન્ઝિસ્ટરનો ઉપયોગ કરે છે.

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=1.2]
    \draw (0,4) node[vdd] (VDD) {$V_{DD}$};
    \draw (0,4) -- (0,3.5);
    \draw (-1.5,3.5) -- (1.5,3.5); % Top rail
    
    % PMOS Parallel
    \draw (-1.5,3.5) node[pmos, anchor=S] (P1) {};
    \draw (1.5,3.5) node[pmos, anchor=S] (P2) {};
    
    \draw (P1.D) -- (-1.5,1.5) -- (0,1.5);
    \draw (P2.D) -- (1.5,1.5) -- (0,1.5);
    
    % NMOS Series
    \draw (0,1.5) -- (0,1) node[nmos, anchor=D] (N1) {};
    \draw (N1.S) -- (0,-0.5) node[nmos, anchor=D] (N2) {};
    \draw (N2.S) node[ground] {};
    
    % Inputs
    \draw (P1.G) -- ++(-0.5,0) node[left] {A};
    \draw (N1.G) -- ++(-0.5,0) node[left] {A}; 
    
    \draw (P2.G) -- ++(-0.5,0) node[left] {B};
    \draw (N2.G) -- ++(-0.5,0) node[left] {B}; 
    
    % Output
    \draw (0,1.5) to[short, -o] (2.5,1.5) node[right] {Y = $\overline{A \cdot B}$};
    
    \draw[dashed] (P1.G) -- (N1.G);
    \draw[dashed] (P2.G) -- (N2.G);
\end{circuitikz}
\caption{2-Input CMOS NAND Gate}
\end{figure}

\textbf{કોષ્ટક: NAND સત્ય કોષ્ટક}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C C C}
\toprule
A & B & Y \\
\midrule
0 & 0 & 1 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
\bottomrule
\end{tabulary}
\caption{NAND Truth Table}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PP-SS: Parallel PMOS, Series NMOS}
\end{mnemonicbox}

\questionmarks{2(b)}{4}{nMOS ઇન્વર્ટર માટે નોઇઝ ઇમ્યુનિટી અને નોઇઝ માર્જિન સમજાવો.}

\begin{solutionbox}
\textbf{કોષ્ટક: નોઇઝ પેરામીટર્સ}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L}
\toprule
\textbf{પેરામીટર} & \textbf{વ્યાખ્યા} & \textbf{ફોર્મ્યુલા} \\
\midrule
\textbf{NMH} & હાઇ નોઇઝ માર્જિન & $V_{OH} - V_{IH}$ \\
\textbf{NML} & લો નોઇઝ માર્જિન & $V_{IL} - V_{OL}$ \\
\textbf{નોઇઝ ઇમ્યુનિટી} & નોઇઝ રિજેક્ટ કરવાની ક્ષમતા & Min(NMH, NML) \\
\bottomrule
\end{tabulary}
\caption{Noise Parameters}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}
    \draw[->] (0,0) -- (0,5);
    \draw (-0.2, 4.5) node[left] {$V_{OH}$} -- (0.2, 4.5);
    \draw (-0.2, 3.5) node[left] {$V_{IH}$} -- (0.2, 3.5);
    \draw (-0.2, 1.5) node[left] {$V_{IL}$} -- (0.2, 1.5);
    \draw (-0.2, 0.5) node[left] {$V_{OL}$} -- (0.2, 0.5);
    
    \draw[fill=green!20] (0.5, 3.5) rectangle (2, 4.5) node[pos=0.5] {Logic 1 (NMH)};
    \draw[fill=red!20] (0.5, 1.5) rectangle (2, 3.5) node[pos=0.5] {Undefined};
    \draw[fill=green!20] (0.5, 0.5) rectangle (2, 1.5) node[pos=0.5] {Logic 0 (NML)};

    \draw[<->] (2.2, 3.5) -- (2.2, 4.5) node[midway, right] {NMH};
    \draw[<->] (2.2, 0.5) -- (2.2, 1.5) node[midway, right] {NML};
\end{tikzpicture}
\caption{Noise Margins}
\end{figure}

\begin{itemize}
    \item \textbf{$V_{IL}$}: મહત્તમ લો ઇનપુટ વોલ્ટેજ.
    \item \textbf{$V_{IH}$}: લઘુત્તમ હાઇ ઇનપુટ વોલ્ટેજ.
    \item \textbf{સારી નોઇઝ ઇમ્યુનિટી}: મોટા નોઇઝ માર્જિન ખોટી switching ને રોકે છે.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{HILOL - High/Low Input/Output Levels}
\end{mnemonicbox}

\questionmarks{2(c)}{7}{CMOS ઇન્વર્ટરની વોલ્ટેજ ટ્રાન્સફર લાક્ષણિકતાઓ (VTC) સમજાવો.}

\begin{solutionbox}
\textbf{કોષ્ટક: VTC વિભાગો}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C L L L}
\toprule
\textbf{વિભાગ} & \textbf{ઇનપુટ રેન્જ} & \textbf{આઉટપુટ} & \textbf{ટ્રાન્ઝિસ્ટર સ્થિતિઓ} \\
\midrule
\textbf{A} & $0$ to $V_{TN}$ & $V_{DD}$ & pMOS ON, nMOS OFF \\
\textbf{B} & $V_{TN}$ to $V_{DD}/2$ & ટ્રાન્ઝિશન & બંને આંશિક રીતે ON \\
\textbf{C} & $V_{DD}/2$ & ટ્રાન્ઝિશન & બંને Saturation \\
\textbf{D} & $V_{DD}/2$ to $V_{DD}-|V_{TP}|$ & ટ્રાન્ઝિશન & બંને આંશિક રીતે ON \\
\textbf{E} & $V_{DD}-|V_{TP}|$ to $V_{DD}$ & $0V$ & pMOS OFF, nMOS ON \\
\bottomrule
\end{tabulary}
\caption{VTC Regions}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}
    \begin{axis}[
        width=8cm, height=8cm,
        xlabel={$V_{in}$},
        ylabel={$V_{out}$},
        xmin=0, xmax=5,
        ymin=0, ymax=5,
        grid=major,
        xtick={0,1,2.5,4,5},
        xticklabels={0, $V_{TN}$, $V_{th}$, $V_{DD}-V_{TP}$, $V_{DD}$},
        ytick={0,2.5,5},
        yticklabels={0, $V_{DD}/2$, $V_{DD}$}
    ]
    % Idealized CMOS VTC
    \addplot[thick, blue] coordinates {
        (0,5) (1,5) (2.3, 4.5) (2.5, 2.5) (2.7, 0.5) (4,0) (5,0)
    };
    
    \node at (axis cs: 0.5, 4.5) {A};
    \node at (axis cs: 1.8, 4.8) {B};
    \node at (axis cs: 2.5, 3) {C};
    \node at (axis cs: 3.2, 0.5) {D};
    \node at (axis cs: 4.5, 0.5) {E};
    \end{axis}
\end{tikzpicture}
\caption{CMOS Inverter VTC}
\end{figure}

\textbf{મુખ્ય લક્ષણો:}
\begin{itemize}
    \item \textbf{તીક્ષ્ણ ટ્રાન્ઝિશન}: આદર્શ switching વર્તન.
    \item \textbf{હાઇ ગેઇન}: ટ્રાન્ઝિશન વિભાગમાં મોટો slope.
    \item \textbf{રેઇલ-ટુ-રેઇલ}: આઉટપુટ સંપૂર્ણ સપ્લાય રેન્જમાં swing કરે છે ($0$ to $V_{DD}$).
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{ASH - A-region, Sharp transition, High gain}
\end{mnemonicbox}

\questionmarks{2(a OR)}{3}{ડિપ્લીશન લોડ nMOS નો ઉપયોગ કરીને NOR2 ગેટનો અમલ કરો.}

\begin{solutionbox}
Depletion load NOR2 એ depletion nMOS ને લોડ તરીકે અને બે parallel nMOS ને drivers તરીકે વાપરે છે.

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=1.2]
    \draw (0,4) node[vdd] (VDD) {$V_{DD}$};
    \draw (0,4) -- (0,3);
    
    \draw (0,3) node[nmos, anchor=D] (DL) {}; 
    \draw (DL.S) -- (0,1.5);
    \draw (DL.G) -- ++(-0.5,0) -- (DL.S); 
    
    % Parallel nMOS Drivers
    \draw (-1,1.5) -- (0,1.5) -- (1,1.5);
    
    \draw (-1,1.5) -- (-1,1) node[nmos, anchor=D] (N1) {};
    \draw (1,1.5) -- (1,1) node[nmos, anchor=D] (N2) {};
    
    \draw (N1.S) -- (-1,0) -- (0,0);
    \draw (N2.S) -- (1,0) -- (0,0);
    \draw (0,0) node[ground] {};
    
    % Inputs
    \draw (N1.G) -- ++(-0.5,0) node[left] {A};
    \draw (N2.G) -- ++(-0.5,0) node[left] {B};
    
    % Output
    \draw (0,1.5) to[short, -o] (2,1.5) node[right] {Y = $\overline{A+B}$};
    
    \node[right] at (DL.D) {Depletion Load};
\end{circuitikz}
\caption{Depletion Load NOR2}
\end{figure}

\textbf{કોષ્ટક: NOR2 સત્ય કોષ્ટક}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C C C}
\toprule
A & B & Y \\
\midrule
0 & 0 & 1 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
1 & 1 & 0 \\
\bottomrule
\end{tabulary}
\caption{NOR2 Truth Table}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DPN - Depletion load, Parallel NMOS}
\end{mnemonicbox}

\questionmarks{2(b OR)}{4}{એન્હાન્સમેન્ટ લોડ ઇન્વર્ટર અને ડિપ્લીશન લોડ ઇન્વર્ટર વચ્ચે તફાવત શોધો.}

\begin{solutionbox}
\textbf{કોષ્ટક: લોડ ઇન્વર્ટર તુલના}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L}
\toprule
\textbf{પેરામીટર} & \textbf{એન્હાન્સમેન્ટ લોડ} & \textbf{ડિપ્લીશન લોડ} \\
\midrule
\textbf{થ્રેશોલ્ડ વોલ્ટેજ} & $V_T > 0$ & $V_T < 0$ \\
\textbf{ગેટ કનેક્શન} & $V_{GS} = V_{DS}$ & $V_{GS} = 0$ \\
\textbf{લોજિક હાઇ ($V_{OH}$)} & $V_{DD} - V_T$ & $V_{DD}$ \\
\textbf{પાવર કન્ઝમ્પશન} & વધુ & ઓછું \\
\textbf{સ્વિચિંગ સ્પીડ} & ધીમું & ઝડપી \\
\bottomrule
\end{tabulary}
\caption{Inverter Load Types Comparison}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{EPDLH - Enhancement Positive, Depletion Lower power, Higher speed}
\end{mnemonicbox}

\questionmarks{2(c OR)}{7}{ડિપ્લીશન લોડ nMOS ઇન્વર્ટરને તેના VTC સાથે સમજાવો.}

\begin{solutionbox}
\textbf{સર્કિટ ઓપરેશન:}
\begin{itemize}
    \item \textbf{લોડ ટ્રાન્ઝિસ્ટર}: હંમેશા conducting ($V_{GS} = 0, V_T < 0$).
    \item \textbf{ડ્રાઇવર ટ્રાન્ઝિસ્ટર}: ઇનપુટ વોલ્ટેજ દ્વારા નિયંત્રિત.
    \item \textbf{આઉટપુટ}: વોલ્ટેજ ડિવાઇડર એક્શન દ્વારા નક્કી થાય છે.
\end{itemize}

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=1]
    \draw (0,4) node[vdd] (VDD) {$V_{DD}$};
    \draw (0,4) -- (0,3) node[nmos, anchor=D] (L) {}; % Depletion load
    \draw (L.S) -- (0,1.5);
    \draw (L.G) -- ++(-0.5,0) -- (L.S);
    
    \draw (0,1.5) -- (0,1) node[nmos, anchor=D] (D) {}; % Enh Driver
    \draw (D.S) node[ground] {};
    
    \draw (D.G) -- ++(-0.5,0) node[left] {$V_{in}$};
    \draw (0,1.5) to[short, -o] (1.5,1.5) node[right] {$V_{out}$};
    
    \node[right] at (L.D) {Depletion Load};
    \node[right] at (D.D) {Driver};
\end{circuitikz}
\caption{Depletion Load Inverter}
\end{figure}

\textbf{કોષ્ટક: ઓપરેટિંગ પોઇન્ટ્સ}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L L}
\toprule
\textbf{ઇનપુટ સ્થિતિ} & \textbf{ડ્રાઇવર} & \textbf{લોડ} & \textbf{આઉટપુટ} \\
\midrule
$\mathbf{V_{in} = 0}$ & OFF & ON (Linear) & $V_{DD}$ \\
$\mathbf{V_{in} = V_{DD}}$ & ON (Linear) & ON (Sat) & $\approx 0V$ \\
\bottomrule
\end{tabulary}
\caption{Inverter Operating Points}
\end{table}

\textbf{VTC લાક્ષણિકતાઓ:}
\begin{itemize}
    \item \textbf{$V_{OH}$}: $V_{DD}$ (એન્હાન્સમેન્ટ લોડ કરતાં બેહતર).
    \item \textbf{$V_{OL}$}: ડિપ્લીશન લોડ લાક્ષણિકતાઓના કારણે ઓછું.
    \item \textbf{ટ્રાન્ઝિશન}: સ્થિતિઓ વચ્ચે તીક્ષ્ણ switching.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DLB - Depletion Load gives Better high output}
\end{mnemonicbox}

\questionmarks{3(a)}{3}{ડિપ્લીશન લોડ nMOS નો ઉપયોગ કરીને EX-OR નો અમલ કરો.}

\begin{solutionbox}
XOR ($Y = A \oplus B$) અમલ કરવા માટે, આપણે XNOR નું pull-down network બનાવીએ છીએ.

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=1]
    \draw (0,5) node[vdd] (VDD) {$V_{DD}$};
    \draw (0,5) -- (0,4) node[nmos, anchor=D] (L) {}; % Depletion Load
    \draw (L.S) -- (0,3);
    \draw (L.G) -- ++(-0.5,0) -- (L.S);
    
    \draw (0,3) -- (0,2.5);
    
    % Block 1: A || B'
    \draw (0,2.5) -- (-1.5,2.5) -- (-1.5,1.5) node[nmos, anchor=D] (NA) {};
    \draw (0,2.5) -- (1.5,2.5) -- (1.5,1.5) node[nmos, anchor=D] (NBp) {};
    
    \draw (NA.S) -- (-1.5,0.5);
    \draw (NBp.S) -- (1.5,0.5);
    
    % Connect Block 1 to Block 2
    \draw (-1.5,0.5) -- (0,0.5) -- (1.5,0.5);
    
    % Block 2: A' || B
    \draw (0,0.5) -- (-1.5,0.5) -- (-1.5,-0.5) node[nmos, anchor=D] (NAp) {};
    \draw (0,0.5) -- (1.5,0.5) -- (1.5,-0.5) node[nmos, anchor=D] (NB) {};
    
    \draw (NAp.S) -- (-1.5,-1.5) -- (0,-1.5);
    \draw (NB.S) -- (1.5,-1.5) -- (0,-1.5);
    \draw (0,-1.5) node[ground] {};
    
    % Inputs
    \draw (NA.G) -- ++(-0.2,0) node[left] {A};
    \draw (NBp.G) -- ++(-0.2,0) node[left] {$B'$};
    \draw (NAp.G) -- ++(-0.2,0) node[left] {$A'$};
    \draw (NB.G) -- ++(-0.2,0) node[left] {B};
    
    % Output
    \draw (0,3) to[short, -o] (2.5,3) node[right] {$Y = A \oplus B$};
    
    \node[right] at (L.D) {Depletion Load};
\end{circuitikz}
\caption{Depletion Load NMOS EX-OR Gate}
\end{figure}

\textbf{કોષ્ટક: XOR સત્ય કોષ્ટક}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C C C}
\toprule
A & B & Y \\
\midrule
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
\bottomrule
\end{tabulary}
\caption{XOR Truth Table}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{XOR - eXclusive OR, different inputs give 1}
\end{mnemonicbox}

\questionmarks{3(b)}{4}{ડિઝાઇન હાઇરાર્કીને ઉદાહરણ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{કોષ્ટક: હાઇરાર્કી લેવલ્સ}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L}
\toprule
\textbf{લેવલ} & \textbf{કમ્પોનન્ટ} & \textbf{ઉદાહરણ} \\
\midrule
\textbf{સિસ્ટમ} & સંપૂર્ણ ચિપ & માઇક્રોપ્રોસેસર \\
\textbf{મોડ્યુલ} & ફંક્શનલ બ્લોક્સ & ALU, મેમરી \\
\textbf{ગેટ} & લોજિક ગેટ્સ & NAND, NOR \\
\textbf{ટ્રાન્ઝિસ્ટર} & વ્યક્તિગત ડિવાઇસેસ & MOSFET \\
\bottomrule
\end{tabulary}
\caption{Design Hierarchy Levels}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}[gtu tree]
    \node [gtu root] {System Level (CPU)}
        child { node [gtu child] {Module Level (ALU)}
            child { node [gtu block] {Gate Level (Adder)}
                child { node [gtu block, fill=orange!10] {Transistor Level (MOSFET)} }
            }
        }
        child { node [gtu child] {Module Level (Registers)} };
\end{tikzpicture}
\caption{Design Hierarchy Tree}
\end{figure}

\textbf{ફાયદા:}
\begin{itemize}
    \item \textbf{મોડ્યુલારિટી}: સ્વતંત્ર ડિઝાઇન અને ટેસ્ટિંગ.
    \item \textbf{પુનઃઉપયોગ}: સામાન્ય બ્લોક્સ (જેમ કે adders) ઘણી વખત વપરાય છે.
    \item \textbf{જાળવણીયોગ્યતા}: સરળ debugging અને modification.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SMG-T: System, Module, Gate, Transistor levels}
\end{mnemonicbox}

\questionmarks{3(c)}{7}{Y ચાર્ટ ડિઝાઇન ફ્લો દોરો અને સમજાવો.}

\begin{solutionbox}
Y-ચાર્ટ VLSI ડિઝાઇનના ત્રણ ડોમેન્સ દર્શાવે છે: Behavioral, Structural, અને Physical.

\begin{figure}[H]
\centering
\begin{tikzpicture}
    % Axes
    \draw[thick, ->] (0,0) -- (90:4) node[above] {\textbf{Behavioral}};
    \draw[thick, ->] (0,0) -- (210:4) node[below left] {\textbf{Structural}};
    \draw[thick, ->] (0,0) -- (330:4) node[below right] {\textbf{Physical}};
    
    % Concentric circles for levels
    \foreach \r in {1,2,3} {
        \draw[dashed, gray] (0,0) circle (\r);
    }
    
    % Items
    \node[font=\footnotesize, fill=white] at (90:3) {Algorithms};
    \node[font=\footnotesize, fill=white] at (90:2) {RTL};
    \node[font=\footnotesize, fill=white] at (90:1) {Logic Eq.};
    
    \node[font=\footnotesize, fill=white] at (210:3) {Processor};
    \node[font=\footnotesize, fill=white] at (210:2) {Registers/ALU};
    \node[font=\footnotesize, fill=white] at (210:1) {Gates};
    
    \node[font=\footnotesize, fill=white] at (330:3) {Chip Floorplan};
    \node[font=\footnotesize, fill=white] at (330:2) {Module Layout};
    \node[font=\footnotesize, fill=white] at (330:1) {Transistor Layout};
    
    % Spiral flow
    \draw[->, blue, thick] (90:3.2) arc (90:30:3.2) -- (330:3.2);
\end{tikzpicture}
\caption{Gajski-Kuhn Y-Chart}
\end{figure}

\textbf{કોષ્ટક: Y-ચાર્ટ ડોમેન્સ}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L}
\toprule
\textbf{ડોમેન} & \textbf{વર્ણન} & \textbf{ઉદાહરણો} \\
\midrule
\textbf{બિહેવિયરલ} & સિસ્ટમ શું કરે છે & Algorithms, RTL \\
\textbf{સ્ટ્રક્ચરલ} & તે કેવી રીતે ગોઠવાયેલું છે & Architecture, Gates \\
\textbf{ફિઝિકલ} & કમ્પોનન્ટ્સ ક્યાં મૂકાયેલા છે & Floorplan, Layout \\
\bottomrule
\end{tabulary}
\caption{Y-Chart Domains}
\end{table}

\textbf{ડિઝાઇન ફ્લો:}
\begin{itemize}
    \item \textbf{ટોપ-ડાઉન}: Behavioral $\to$ Structural $\to$ Physical.
    \item \textbf{બોટમ-અપ}: Physical constraints ઉપરના લેવલ્સને પ્રભાવિત કરે છે.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BSP - Behavioral, Structural, Physical domains}
\end{mnemonicbox}

\questionmarks{3(a OR)}{3}{CMOS નો ઉપયોગ કરીને NAND2 - SR લેચનો અમલ કરો}

\begin{solutionbox}
NAND SR Latch બે cross-coupled NAND gates નો ઉપયોગ કરે છે.

\begin{figure}[H]
\centering
\begin{circuitikz}
    \draw (0,0) node[nand port] (N1) {};
    \draw (0,-2) node[nand port] (N2) {};
    
    % Inputs
    \draw (N1.in 1) -- ++(-1,0) node[left] {$\bar{S}$};
    \draw (N2.in 2) -- ++(-1,0) node[left] {$\bar{R}$};
    
    % Outputs
    \draw (N1.out) -- ++(1,0) node[right] {$Q$};
    \draw (N2.out) -- ++(1,0) node[right] {$\bar{Q}$};
    
    % Cross coupling
    \draw (N1.in 2) -- ++(-0.5,0) -- ++(0,-0.5) -- ++(2.5,-1.2) -- (N2.out);
    \draw (N2.in 1) -- ++(-0.5,0) -- ++(0,0.5) -- ++(2.5,1.2) -- (N1.out);
\end{circuitikz}
\caption{CMOS NAND SR Latch}
\end{figure}

\textbf{કોષ્ટક: SR લેચ ઓપરેશન}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C C C C L}
\toprule
S & R & Q & Q' & સ્થિતિ \\
\midrule
0 & 0 & 1 & 1 & અમાન્ય (Invalid) \\
0 & 1 & 1 & 0 & સેટ (Set) \\
1 & 0 & 0 & 1 & રીસેટ (Reset) \\
1 & 1 & Q & Q' & હોલ્ડ (Hold) \\
\bottomrule
\end{tabulary}
\caption{NAND SR Latch Truth Table (Active Low Inputs)}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SR-HRI: Set, Reset, Hold, Invalid states}
\end{mnemonicbox}

\questionmarks{3(b OR)}{4}{સિલિકોન વેફર પર પેટર્ન અથવા માસ્ક ટ્રાન્સફર કરવા માટે કઈ પદ્ધતિનો ઉપયોગ થાય છે? તેને સ્વચ્છ આકૃતિઓ સાથે સમજાવો.}

\begin{solutionbox}
\textbf{પદ્ધતિ}: \textbf{લિથોગ્રાફી (Photolithography)} એ માસ્ક પરની ભૌમિતિક રચનાઓને સિલિકોન વેફરની સપાટી પર ટ્રાન્સફર કરવા માટે વપરાય છે.

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=1.5cm]
    \node [gtu process] (coat) {1. Coating\\(Apply Photoresist)};
    \node [gtu process, right=of coat] (expose) {2. Exposure\\(UV Light via Mask)};
    \node [gtu process, right=of expose] (develop) {3. Development\\(Remove Exposed)};
    
    \draw [gtu arrow] (coat) -- (expose);
    \draw [gtu arrow] (expose) -- (develop);
    
    % Simplified diagrams below nodes
    \draw[fill=gray!20] (-1,-1) rectangle (1,-1.5); % Wafer
    \draw[fill=red!20] (-1,-1) rectangle (1,-0.8); % Resist
    \node[below=2cm of coat] {PR Coated Wafer};
    
    \draw[fill=gray!20] (3.5,-1) rectangle (5.5,-1.5);
    \draw[fill=red!20] (3.5,-1) rectangle (5.5,-0.8);
    \draw[thick] (4,-0.3) -- (5,-0.3); % Mask
    \draw[->, yellow!80!black] (4.5, 0.2) -- (4.5, -0.3); % UV
    \node[below=2cm of expose] {UV Exposure};
    
    \draw[fill=gray!20] (8,-1) rectangle (10,-1.5);
    \draw[fill=red!20] (8,-1) rectangle (8.5,-0.8); 
    \draw[fill=red!20] (9.5,-1) rectangle (10,-0.8); % Patterned
    \node[below=2cm of develop] {Pattern Defined};
\end{tikzpicture}
\caption{Photolithography Process}
\end{figure}

\textbf{પ્રક્રિયાના પગલાં:}
\begin{itemize}
    \item \textbf{Coating}: ફોટોરેસિસ્ટનું પાતળું સ્તર લગાવવું.
    \item \textbf{Exposure}: માસ્ક દ્વારા UV light થી રેસિસ્ટને expose કરવું.
    \item \textbf{Development}: Exposed (positive) અથવા unexposed (negative) રેસિસ્ટને દૂર કરવું.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{CED - Coating, Exposure, Development}
\end{mnemonicbox}

\questionmarks{3(c OR)}{7}{MOSFET ફેબ્રિકેશનમાં મેટલ deposit કરવા માટે કઈ પદ્ધતિઓનો ઉપયોગ થાય છે? યોગ્ય ડાયાગ્રામ સાથે ડિપોઝિશનને વિગતવાર સમજાવો.}

\begin{solutionbox}
\textbf{કોષ્ટક: મેટલ ડિપોઝિશન પદ્ધતિઓ}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L}
\toprule
\textbf{પદ્ધતિ} & \textbf{ટેકનિક} & \textbf{ઉપયોગ} \\
\midrule
\textbf{PVD} & Sputtering, Evaporation & એલ્યુમિનિયમ, કોપર \\
\textbf{CVD} & CVD, PECVD & ટંગસ્ટન, ટાઇટેનિયમ \\
\textbf{Electroplating} & Electrochemical & કોપર interconnects \\
\bottomrule
\end{tabulary}
\caption{Metal Deposition Methods}
\end{table}

\textbf{Sputtering Process:}
Sputtering માં, પ્લાઝ્માંથી આયનો ટાર્ગેટ મટેરિયલ તરફ પ્રવેગિત થાય છે, જેનાથી એટમ્સ બહાર નીકળે છે અને વેફર પર જમા થાય છે.

\begin{figure}[H]
\centering
\begin{tikzpicture}
    % Chamber
    \draw[thick] (0,0) rectangle (6,4);
    \node[above] at (3,4) {Vacuum Chamber};
    
    % Target
    \draw[fill=gray!50] (1,3.5) rectangle (5,3.8);
    \node at (3,3.65) {Target (Cathode -)};
    
    % Wafer
    \draw[fill=blue!20] (1,0.2) rectangle (5,0.5);
    \node at (3,0.35) {Wafer (Anode +)};
    
    % Ions
    \foreach \x in {1.5, 2.5, 3.5, 4.5} {
        \draw[->, red, thick] (\x, 2) -- (\x, 3.4); % Ions hitting target
        \node[red, font=\tiny] at (\x, 1.8) {$Ar^+$};
        
        \draw[->, black, dashed] (\x, 3.4) -- (\x-0.2, 0.6); % Atoms falling
        \draw[->, black, dashed] (\x, 3.4) -- (\x+0.2, 0.6);
    }
    \node at (5.5, 2) {Plasma};
\end{tikzpicture}
\caption{Sputtering System}
\end{figure}

\textbf{ફાયદા:}
\begin{itemize}
    \item \textbf{સમાન જાડાઈ}: ઉત્તમ step coverage.
    \item \textbf{ઓછું તાપમાન}: ડિવાઇસ integrity જાળવે છે.
    \item \textbf{વિવિધતા}: Alloys અને compounds નું ડિપોઝિશન શક્ય.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{IBE-DC: Ion Bombardment Ejects atoms for Deposition Control}
\end{mnemonicbox}

\questionmarks{4(a)}{3}{ડિપ્લીશન nMOS લોડ સાથે Z= ((A+B+C)·(D+E+F). G)' અમલમાં મૂકો.}

\begin{solutionbox}
લોજિક ફંક્શન $Z = \overline{(A+B+C) \cdot (D+E+F) \cdot G}$ ને depletion load અને pull-down network દ્વારા અમલમાં મુકાય છે.
1. Parallel inputs A, B, C (OR)
2. Parallel inputs D, E, F (OR)
3. Single input G
આ બધા સીરિઝમાં જોડાયેલા છે (AND operation).

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=1]
    \draw (0,6) node[vdd] (VDD) {$V_{DD}$};
    \draw (0,6) -- (0,5) node[nmos, anchor=D] (L) {}; % Depletion Load
    \draw (L.S) -- (0,4.5);
    \draw (L.G) -- ++(-0.5,0) -- (L.S);
    
    % Output Z
    \draw (0,4.5) to[short, -o] (3,4.5) node[right] {$Z$};
    
    % Pull Down Network
    
    % Block 1: Parallel A, B, C
    \draw (0,4.5) -- (0,4);
    \draw (0,4) -- (-2,4) -- (-2,3) node[nmos, anchor=D] (NA) {};
    \draw (0,4) -- (0,3) node[nmos, anchor=D] (NB) {};
    \draw (0,4) -- (2,4) -- (2,3) node[nmos, anchor=D] (NC) {};
    
    \draw (NA.S) -- (-2,2);
    \draw (NB.S) -- (0,2);
    \draw (NC.S) -- (2,2);
    \draw (-2,2) -- (2,2); % Combine sources
    
    % Block 2: Parallel D, E, F
    \draw (0,2) -- (0,1.5);
    \draw (0,1.5) -- (-2,1.5) -- (-2,0.5) node[nmos, anchor=D] (ND) {};
    \draw (0,1.5) -- (0,0.5) node[nmos, anchor=D] (NE) {};
    \draw (0,1.5) -- (2,1.5) -- (2,0.5) node[nmos, anchor=D] (NF) {};
    
    \draw (ND.S) -- (-2,-0.5);
    \draw (NE.S) -- (0,-0.5);
    \draw (NF.S) -- (2,-0.5);
    \draw (-2,-0.5) -- (2,-0.5); % Combine sources
    
    % Block 3: Series G (Single)
    \draw (0,-0.5) -- (0,-1) node[nmos, anchor=D] (NG) {};
    \draw (NG.S) node[ground] {};
    
    % Inputs
    \draw (NA.G) -- ++(-0.2,0) node[left] {A};
    \draw (NB.G) -- ++(-0.2,0) node[left] {B};
    \draw (NC.G) -- ++(-0.2,0) node[left] {C};
    
    \draw (ND.G) -- ++(-0.2,0) node[left] {D};
    \draw (NE.G) -- ++(-0.2,0) node[left] {E};
    \draw (NF.G) -- ++(-0.2,0) node[left] {F};
    
    \draw (NG.G) -- ++(-0.2,0) node[left] {G};
    
    \node[right] at (L.D) {Depletion Load};
\end{circuitikz}
\caption{Logic Implementation of Z}
\end{figure}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{POI - Parallel OR, Inversion at output}
\end{mnemonicbox}

\questionmarks{4(b)}{4}{VERILOG માં વપરાતી ડિઝાઇન શૈલીઓની સૂચિ બનાવો અને સમજાવો.}

\begin{solutionbox}
\textbf{કોષ્ટક: વેરિલોગ ડિઝાઇન શૈલીઓ}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L L}
\toprule
\textbf{શૈલી} & \textbf{વર્ણન} & \textbf{ઉપયોગનો કેસ} & \textbf{ઉદાહરણ} \\
\midrule
\textbf{બિહેવિયરલ} & એલ્ગોરિધમ વર્ણન & ઉચ્ચ-સ્તરીય મોડેલિંગ & \code{always} blocks \\
\textbf{ડેટાફ્લો} & બૂલિયન expressions & કમ્બિનેશનલ લોજિક & \code{assign} statements \\
\textbf{સ્ટ્રક્ચરલ} & કમ્પોનન્ટ instantiation & હાઇરાર્કિકલ ડિઝાઇન & module connections \\
\textbf{ગેટ-લેવલ} & પ્રિમિટિવ ગેટ્સ & લો-લેવલ ડિઝાઇન & \code{and}, \code{or} gates \\
\bottomrule
\end{tabulary}
\caption{Verilog Design Styles}
\end{table}

\textbf{લાક્ષણિકતાઓ:}
\begin{itemize}
    \item \textbf{બિહેવિયરલ}: સર્કિટ શું કરે છે (functionality) તેનું વર્ણન.
    \item \textbf{સ્ટ્રક્ચરલ}: કમ્પોનન્ટ્સ કેવી રીતે જોડાય છે (netlist) તે બતાવે છે.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BDSG - Behavioral, Dataflow, Structural, Gate-level}
\end{mnemonicbox}

\questionmarks{4(c)}{7}{CMOS નો ઉપયોગ કરીને NAND2 SR લેચનો અમલ કરો અને CMOS નો ઉપયોગ કરીને NOR2 SR લેચનો પણ અમલ કરો.}

\begin{solutionbox}
\textbf{NAND2 SR Latch (Verilog):}
\begin{lstlisting}[language=Verilog]
module nand_sr_latch(
    input S, R,
    output Q, Q_bar
);
    nand(Q, S, Q_bar);
    nand(Q_bar, R, Q);
endmodule
\end{lstlisting}

\textbf{NOR2 SR Latch (Verilog):}
\begin{lstlisting}[language=Verilog]
module nor_sr_latch(
    input S, R,
    output Q, Q_bar
);
    nor(Q_bar, R, Q);
    nor(Q, S, Q_bar);
endmodule
\end{lstlisting}

\textbf{તફાવત:}
\begin{itemize}
    \item \textbf{NAND}: Low Inputs સાથે Set/Reset (Active Low).
    \item \textbf{NOR}: High Inputs સાથે Set/Reset (Active High).
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{NAND-Low, NOR-High active}
\end{mnemonicbox}

\questionmarks{4(a OR)}{3}{Y= (ABC + DE + F)' ને ડિપ્લીશન nMOS લોડ સાથે અમલમાં મૂકો.}

\begin{solutionbox}
લોજિક ફંક્શન $Y = \overline{(ABC) + (DE) + F}$ એ Sum of Products (ORing of AND terms) દર્શાવે છે.
Pull-down network માં ત્રણ parallel branches હશે:
1. A, B, C series માં (AND)
2. D, E series માં (AND)
3. F single

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=1]
    \draw (0,5) node[vdd] (VDD) {$V_{DD}$};
    \draw (0,5) -- (0,4) node[nmos, anchor=D] (L) {}; % Depletion Load
    \draw (L.S) -- (0,3.5);
    \draw (L.G) -- ++(-0.5,0) -- (L.S);
    
    % Output Y
    \draw (0,3.5) to[short, -o] (3,3.5) node[right] {$Y$};
    
    % Pull Down Network
    
    \draw (0,3.5) -- (0,3);
    
    % Branch 1: ABC Series (-2 x)
    \draw (0,3) -- (-2,3) -- (-2,2.5) node[nmos, anchor=D] (NA) {};
    \draw (NA.S) -- (-2,1.5) node[nmos, anchor=D] (NB) {};
    \draw (NB.S) -- (-2,0.5) node[nmos, anchor=D] (NC) {};
    \draw (NC.S) -- (-2,-0.5) node[ground] {};
    
    % Branch 2: DE Series (0 x)
    \draw (0,3) -- (0,2) node[nmos, anchor=D] (ND) {};
    \draw (ND.S) -- (0,1) node[nmos, anchor=D] (NE) {};
    \draw (NE.S) -- (0,-0.5) node[ground] {};
    
    % Branch 3: F Single (2 x)
    \draw (0,3) -- (2,3) -- (2,1.5) node[nmos, anchor=D] (NF) {};
    \draw (NF.S) -- (2,-0.5) node[ground] {};
    
    % Inputs
    \draw (NA.G) -- ++(-0.2,0) node[left] {A};
    \draw (NB.G) -- ++(-0.2,0) node[left] {B};
    \draw (NC.G) -- ++(-0.2,0) node[left] {C};
    
    \draw (ND.G) -- ++(-0.2,0) node[left] {D};
    \draw (NE.G) -- ++(-0.2,0) node[left] {E};
    
    \draw (NF.G) -- ++(-0.2,0) node[left] {F};
    
\end{circuitikz}
\caption{Logic Implementation of Y}
\end{figure}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SSS-I: Series-Series-Single with Inversion}
\end{mnemonicbox}

\questionmarks{4(b OR)}{4}{ફુલ એડરને અમલમાં મૂકવા માટે વેરિલોગ કોડ લખો.}

\begin{solutionbox}
\begin{lstlisting}[language=Verilog]
module full_adder(
    input a, b, cin,
    output sum, cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (cin & (a ^ b));
endmodule
\end{lstlisting}

\textbf{લોજિક ફંક્શન્સ:}
\begin{itemize}
    \item \textbf{Sum}: Triple XOR operation ($A \oplus B \oplus C_{in}$)
    \item \textbf{Carry}: Majority function of inputs.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{XOR-Sum, Majority-Carry}
\end{mnemonicbox}

\questionmarks{4(c OR)}{7}{ડિપ્લીશન લોડનો ઉપયોગ કરીને Y = (S1'S0'I0 + S1'S0 I1 + S1 S0' I2 + S1 S2 I3) લાગૂ કરો}

\begin{solutionbox}
\textbf{4:1 Multiplexer Verilog Code} (Assuming S2 corresponds to S0):

\begin{lstlisting}[language=Verilog]
// 4:1 Multiplexer implementation
module mux_4to1(
    input [1:0] sel,  // S1, S0
    input [3:0] data, // I3, I2, I1, I0
    output Y
);
    assign Y = (sel == 2'b00) ? data[0] :
               (sel == 2'b01) ? data[1] :
               (sel == 2'b10) ? data[2] :
                                data[3];
endmodule
\end{lstlisting}

\textbf{કોષ્ટક: મલ્ટિપ્લેક્સર સિલેક્શન}

\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C C C L}
\toprule
S1 & S0 & પસંદ કરેલ ઇનપુટ & આઉટપુટ \\
\midrule
0 & 0 & I0 & $Y = I0$ \\
0 & 1 & I1 & $Y = I1$ \\
1 & 0 & I2 & $Y = I2$ \\
1 & 1 & I3 & $Y = I3$ \\
\bottomrule
\end{tabulary}
\caption{Multiplexer Selection}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{DAO - Decoder, AND gates, OR combination}
\end{mnemonicbox}

\questionmarks{5(a)}{3}{CMOS નો ઉપયોગ કરીને લોજિક ફંક્શન G = (PQR +U(S+T))' નો અમલ કરો}

\begin{solutionbox}
ફંક્શન $G = \overline{(PQR) + U(S+T)}$ માટે CMOS અમલીકરણ:
\textbf{Pull-Down Network (PDN)}: $(PQR) + U(S+T)$ નું અમલીકરણ (nMOS).
\begin{itemize}
    \item $P, Q, R$ Series માં (AND).
    \item $S, T$ Parallel માં (OR).
    \item $U$ એ $(S || T)$ સાથે Series માં.
    \item બ્લોક $(P-Q-R)$ એ $(U-(S||T))$ સાથે Parallel માં.
\end{itemize}

\textbf{Pull-Up Network (PUN)}: Dual નું અમલીકરણ (pMOS). W
\begin{itemize}
    \item $P, Q, R$ Parallel માં.
    \item $S, T$ Series માં.
    \item $U$ એ $(S-T)$ સાથે Parallel માં.
    \item બ્લોક $(P||Q||R)$ એ $(U || (S-T))$ સાથે Series માં.
\end{itemize}

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=0.9]
    \draw (0,8) node[vdd] (VDD) {$V_{DD}$};
    
    % PUN
    % Top Block: P || Q || R
    \draw (0,8) -- (0,7.5);
    \draw (0,7.5) -- (-2,7.5) -- (-2,6.5) node[pmos, anchor=S] (P) {};
    \draw (0,7.5) -- (0,6.5) node[pmos, anchor=S] (Q) {};
    \draw (0,7.5) -- (2,7.5) -- (2,6.5) node[pmos, anchor=S] (R) {};
    
    \draw (P.D) -- (-2,5.5);
    \draw (Q.D) -- (0,5.5);
    \draw (R.D) -- (2,5.5);
    \draw (-2,5.5) -- (2,5.5); % Merge points
    
    % Connect Top to Bottom PUN
    \draw (0,5.5) -- (0,5);
    
    % Bottom Block: U || (S-T)
    \draw (0,5) -- (-2,5) -- (-2,4) node[pmos, anchor=S] (U) {};
    \draw (0,5) -- (2,5) -- (2,4) node[pmos, anchor=S] (S) {};
    
    \draw (S.D) -- (2,3.5) node[pmos, anchor=S] (T) {};
    
    \draw (U.D) -- (-2,2.5);
    \draw (T.D) -- (2,2.5);
    \draw (-2,2.5) -- (2,2.5); % Output node Y
    
    \draw (0,2.5) to[short, -o] (4,2.5) node[right] {$G$};
    
    % PDN
    % Parallel Branches
    \draw (0,2.5) -- (0,2);
    
    % Branch 1: P-Q-R Series
    \draw (0,2) -- (-3,2) -- (-3,1.5) node[nmos, anchor=D] (nP) {};
    \draw (nP.S) -- (-3,0.5) node[nmos, anchor=D] (nQ) {};
    \draw (nQ.S) -- (-3,-0.5) node[nmos, anchor=D] (nR) {};
    \draw (nR.S) -- (-3,-1.5);
    
    % Branch 2: U Series (S || T)
    \draw (0,2) -- (3,2) -- (3,1.5) node[nmos, anchor=D] (nU) {};
    \draw (nU.S) -- (3,0.5);
    
    \draw (3,0.5) -- (1.5,0.5) -- (1.5,-0.5) node[nmos, anchor=D] (nS) {};
    \draw (3,0.5) -- (4.5,0.5) -- (4.5,-0.5) node[nmos, anchor=D] (nT) {};
    
    \draw (nS.S) -- (1.5,-1.5) -- (3,-1.5);
    \draw (nT.S) -- (4.5,-1.5) -- (3,-1.5);
    
    \draw (3,-1.5) -- (-3,-1.5); % Common Ground
    \draw (0,-1.5) node[ground] {};
    
    % Labels
    \draw (P.G) node[left] {P}; \draw (nP.G) node[left] {P};
    \draw (Q.G) node[left] {Q}; \draw (nQ.G) node[left] {Q};
    \draw (R.G) node[left] {R}; \draw (nR.G) node[left] {R};
    \draw (U.G) node[left] {U}; \draw (nU.G) node[left] {U};
    \draw (S.G) node[left] {S}; \draw (nS.G) node[left] {S};
    \draw (T.G) node[left] {T}; \draw (nT.G) node[left] {T};
    
\end{circuitikz}
\caption{CMOS Implementation of Logic G}
\end{figure}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PSSP - Parallel Series Series Parallel}
\end{mnemonicbox}

\questionmarks{5(b)}{4}{વેરિલોગનો ઉપયોગ કરીને 8×1 મલ્ટિપ્લેક્સર અમલમાં મૂકો.}

\begin{solutionbox}
\begin{lstlisting}[language=Verilog]
module mux_8to1(
    input [2:0] sel,     // 3-bit select
    input [7:0] data,    // 8 data inputs
    output reg Y         // Output
);
    always @(*) begin
        case(sel)
            3'b000: Y = data[0];
            3'b001: Y = data[1];
            3'b010: Y = data[2];
            3'b011: Y = data[3];
            3'b100: Y = data[4];
            3'b101: Y = data[5];
            3'b110: Y = data[6];
            3'b111: Y = data[7];
        endcase
    end
endmodule
\end{lstlisting}

\textbf{કોષ્ટક: 8:1 MUX સિલેક્શન}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C C C L}
\toprule
S2 & S1 & S0 & Output \\
\midrule
0 & 0 & 0 & data[0] \\
0 & 0 & 1 & data[1] \\
1 & 0 & 0 & data[4] \\
1 & 1 & 1 & data[7] \\
\bottomrule
\end{tabulary}
\caption{8:1 MUX Truth Table (Partial)}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{Case-Always: Use case statement in always block}
\end{mnemonicbox}

\questionmarks{5(c)}{7}{વેરિલોગમાં સ્ટ્રક્ચરલ મોડેલિંગ શૈલીનો ઉપયોગ કરીને 4 બીટ ફુલ એડરને લાગૂ કરો.}

\begin{solutionbox}
\textbf{Verilog Code (Structural):}

\begin{lstlisting}[language=Verilog]
module full_adder(
    input a, b, cin,
    output sum, cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (cin & (a ^ b));
endmodule

module full_adder_4bit(
    input [3:0] a, b,
    input cin,
    output [3:0] sum,
    output cout
);
    wire c1, c2, c3;
    
    // Instantiating 4 Full Adders
    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), 
                   .sum(sum[0]), .cout(c1));
    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), 
                   .sum(sum[1]), .cout(c2));
    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2), 
                   .sum(sum[2]), .cout(c3));
    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3), 
                   .sum(sum[3]), .cout(cout));
endmodule
\end{lstlisting}

\textbf{કોષ્ટક: રિપલ કેરી એડિશન}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{L L L L L}
\toprule
\textbf{સ્ટેજ} & \textbf{ઇનપુટ્સ} & \textbf{કેરી ઇન} & \textbf{સમ} & \textbf{કેરી આઉટ} \\
\midrule
\textbf{FA0} & A[0], B[0] & Cin & S[0] & C1 \\
\textbf{FA1} & A[1], B[1] & C1 & S[1] & C2 \\
\textbf{FA2} & A[2], B[2] & C2 & S[2] & C3 \\
\textbf{FA3} & A[3], B[3] & C3 & S[3] & Cout \\
\bottomrule
\end{tabulary}
\caption{Ripple Carry Structure}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{RCC - Ripple Carry Chain connection}
\end{mnemonicbox}

\questionmarks{5(a OR)}{3}{CMOS નો ઉપયોગ કરીને લોજિક ફંક્શન Y = ((AF(D + E) )+ (B+ C))' ને અમલમાં મૂકો.}

\begin{solutionbox}
ફંક્શન: $Y = \overline{(A \cdot F \cdot (D+E)) + (B+C)}$.
\textbf{PDN (Implementation of Function):}
\begin{itemize}
    \item Block 1: $B, C$ Parallel માં (OR).
    \item Block 2: $D, E$ Parallel માં (OR) $\to$ Series માં $A, F$ સાથે (AND).
    \item Top level: Block 1 || Block 2.
\end{itemize}

\textbf{PUN (Implementation of Dual):}
\begin{itemize}
    \item Block 1: $B, C$ Series માં.
    \item Block 2: $D, E$ Series માં $\to$ Parallel માં $A, F$ સાથે.
    \item Top level: Block 1 - Block 2 (Series).
\end{itemize}

\begin{figure}[H]
\centering
\begin{circuitikz}[scale=0.8]
    \draw (0,7) node[vdd] (VDD) {$V_{DD}$};
    
    % PUN
    % Series of two blocks
    
    % Block 1: B-C Series
    \draw (0,7) -- (0,6.5) node[pmos, anchor=S] (P_B) {};
    \draw (P_B.D) -- (0,5.5) node[pmos, anchor=S] (P_C) {};
    \draw (P_C.D) -- (0,4.5);
    
    % Block 2: A || F || (D-E)
    \draw (0,4.5) -- (-2,4.5) -- (-2,3.5) node[pmos, anchor=S] (P_A) {};
    \draw (0,4.5) -- (0,3.5) node[pmos, anchor=S] (P_F) {};
    \draw (0,4.5) -- (2,4.5) -- (2,3.5) node[pmos, anchor=S] (P_D) {};
    
    \draw (P_D.D) -- (2,2.5) node[pmos, anchor=S] (P_E) {};
    
    \draw (P_A.D) -- (-2,1.5);
    \draw (P_F.D) -- (0,1.5);
    \draw (P_E.D) -- (2,1.5);
    \draw (-2,1.5) -- (2,1.5); % Output Node
    
    \draw (0,1.5) to[short, -o] (4,1.5) node[right] {$Y$};
    
    % PDN
    % Parallel Blocks
    \draw (0,1.5) -- (0,1);
    
    % Block 1: B || C
    \draw (0,1) -- (-3,1) -- (-3,0.5) node[nmos, anchor=D] (nB) {};
    \draw (0,1) -- (-1.5,1) -- (-1.5,0.5) node[nmos, anchor=D] (nC) {};
    \draw (nB.S) -- (-3,-0.5);
    \draw (nC.S) -- (-1.5,-0.5);
    
    % Block 2: A-F-(D || E) Series
    \draw (0,1) -- (2,1) -- (2,0.5) node[nmos, anchor=D] (nA) {};
    \draw (nA.S) -- (2,-0.5) node[nmos, anchor=D] (nF) {};
    \draw (nF.S) -- (2,-1.5);
    
    \draw (2,-1.5) -- (0.5,-1.5) -- (0.5,-2) node[nmos, anchor=D] (nD) {};
    \draw (2,-1.5) -- (3.5,-1.5) -- (3.5,-2) node[nmos, anchor=D] (nE) {};
    \draw (nD.S) -- (0.5,-3);
    \draw (nE.S) -- (3.5,-3);
    
    % Ground
    \draw (-3,-0.5) -- (-1.5,-0.5) -- (-2.25,-0.5) -- (-2.25,-3); % Connect B/C to ground
    \draw (0.5,-3) -- (3.5,-3); % Connect D/E sources
    \draw (-2.25,-3) -- (2,-3); % Connect all to ground
    \draw (0,-3) node[ground] {};
    
    \draw (P_B.G) node[left] {B}; \draw (nB.G) node[left] {B};
    \draw (P_C.G) node[left] {C}; \draw (nC.G) node[left] {C};
    \draw (P_A.G) node[left] {A}; \draw (nA.G) node[left] {A};
    \draw (P_F.G) node[left] {F}; \draw (nF.G) node[left] {F};
    \draw (P_D.G) node[left] {D}; \draw (nD.G) node[left] {D};
    \draw (P_E.G) node[left] {E}; \draw (nE.G) node[left] {E};
    
\end{circuitikz}
\caption{CMOS Implementation of Y}
\end{figure}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{PNAI - PMOS Network Applies Inversion}
\end{mnemonicbox}

\questionmarks{5(b OR)}{4}{વેરિલોગનો ઉપયોગ કરીને 4 બીટ અપ કાઉન્ટર અમલમાં મૂકવું}

\begin{solutionbox}
\begin{lstlisting}[language=Verilog]
module counter_4bit_up(
    input clk, reset,
    output reg [3:0] count
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            count <= 4'b0000;
        else
            count <= count + 1;
    end
endmodule
\end{lstlisting}

\textbf{કોષ્ટક: કાઉન્ટર સિક્વન્સ}
\begin{table}[H]
\centering
\begin{tabulary}{\textwidth}{C C C L}
\toprule
Clock & Reset & Count & Next Count \\
\midrule
$\uparrow$ & 1 & X & 0000 \\
$\uparrow$ & 0 & 0000 & 0001 \\
$\uparrow$ & 0 & 1111 & 0000 \\
\bottomrule
\end{tabulary}
\caption{Counter Sequence}
\end{table}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{SRA - Synchronous Reset with Auto rollover}
\end{mnemonicbox}

\questionmarks{5(c OR)}{7}{વેરિલોગમાં બિહેવિયરલ મોડેલિંગ સ્ટાઈલનો ઉપયોગ કરીને 3:8 ડીકોડરનો અમલ કરો}

\begin{solutionbox}
\begin{lstlisting}[language=Verilog]
module decoder_3to8(
    input [2:0] select,
    input enable,
    output reg [7:0] out
);
    always @(*) begin
        if (enable) begin
            case(select)
                3'b000: out = 8'b00000001;
                3'b001: out = 8'b00000010;
                3'b010: out = 8'b00000100;
                3'b011: out = 8'b00001000;
                3'b100: out = 8'b00010000;
                3'b101: out = 8'b00100000;
                3'b110: out = 8'b01000000;
                3'b111: out = 8'b10000000;
                default: out = 8'b00000000;
            endcase
        end else begin
            out = 8'b00000000;
        end
    end
endmodule
\end{lstlisting}

\textbf{ઉપયોગો:}
\begin{itemize}
    \item \textbf{મેમરી એડ્રેસિંગ}: Chip select generation.
    \item \textbf{ડેટા રાઉટિંગ}: Channel selection.
\end{itemize}

\end{solutionbox}

\begin{mnemonicbox}
\mnemonic{BEOH - Behavioral Enable One-Hot decoder}
\end{mnemonicbox}

\end{document}

